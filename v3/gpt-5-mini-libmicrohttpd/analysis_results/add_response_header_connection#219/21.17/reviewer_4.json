{
  "user_message": "An agent A claimed that the following add_response_header_connection code violates the MISRA C 2023 rule 21.17.\n<misra_rule>\nMISRA C 2023 Rule 21.17 is Use of the string handling functions from <string.h> shall not result in accesses beyond the bounds of the objects referenced by their pointer parameters.\nThis rule strictly applies to the Standard Library functions in <string.h> such as memcpy, memmove, memset, memcmp, strcpy, strncpy, strcat, strncat, strlen, and strspn.\n</misra_rule>\n<target_code>\nHere is the original code of add_response_header_connection.\n```c\nstatic enum MHD_Result\nadd_response_header_connection (struct MHD_Response *response,\n                                const char *value)\n{\n  static const char *key = MHD_HTTP_HEADER_CONNECTION;\n  /** the length of the \"Connection\" key */\n  static const size_t key_len =\n    MHD_STATICSTR_LEN_ (MHD_HTTP_HEADER_CONNECTION);\n  size_t value_len; /**< the length of the @a value */\n  size_t old_value_len; /**< the length of the existing \"Connection\" value */\n  size_t buf_size;  /**< the size of the buffer */\n  size_t norm_len;  /**< the length of the normalised value */\n  char *buf;        /**< the temporal buffer */\n  struct MHD_HTTP_Res_Header *hdr; /**< existing \"Connection\" header */\n  bool value_has_close; /**< the @a value has \"close\" token */\n  bool already_has_close; /**< existing \"Connection\" header has \"close\" token */\n  size_t pos = 0;   /**< position of addition in the @a buf */\n\n  if ( (NULL != strchr (value, '\\r')) ||\n       (NULL != strchr (value, '\\n')) )\n    return MHD_NO;\n\n  if (0 != (response->flags_auto & MHD_RAF_HAS_CONNECTION_HDR))\n  {\n    hdr = MHD_get_response_element_n_ (response, MHD_HEADER_KIND,\n                                       key, key_len);\n    already_has_close =\n      (0 != (response->flags_auto & MHD_RAF_HAS_CONNECTION_CLOSE));\n    mhd_assert (already_has_close == (0 == memcmp (hdr->value, \"close\", 5)));\n    mhd_assert (NULL != hdr);\n  }\n  else\n  {\n    hdr = NULL;\n    already_has_close = false;\n    mhd_assert (NULL == MHD_get_response_element_n_ (response,\n                                                     MHD_HEADER_KIND,\n                                                     key, key_len));\n    mhd_assert (0 == (response->flags_auto & MHD_RAF_HAS_CONNECTION_CLOSE));\n  }\n  if (NULL != hdr)\n    old_value_len = hdr->value_size + 2; /* additional size for \", \" */\n  else\n    old_value_len = 0;\n\n  value_len = strlen (value);\n  if (value_len >= SSIZE_MAX)\n    return MHD_NO;\n  /* Additional space for normalisation and zero-termination */\n  norm_len = value_len + value_len / 2 + 1;\n  if (norm_len >= SSIZE_MAX)\n    return MHD_NO;\n  buf_size = old_value_len + (size_t) norm_len;\n\n  buf = malloc (buf_size);\n  if (NULL == buf)\n    return MHD_NO;\n  if (1)\n  { /* local scope */\n    ssize_t norm_len_s = (ssize_t) norm_len;\n    /* Remove \"close\" token (if any), it will be moved to the front */\n    value_has_close = MHD_str_remove_token_caseless_ (value, value_len, \"close\",\n                                                      MHD_STATICSTR_LEN_ ( \\\n                                                        \"close\"),\n                                                      buf + old_value_len,\n                                                      &norm_len_s);\n    mhd_assert (0 <= norm_len_s);\n    if (0 > norm_len_s)\n    {\n      /* Must never happen with realistic sizes */\n      free (buf);\n      return MHD_NO;\n    }\n    else\n      norm_len = (size_t) norm_len_s;\n  }\n#ifdef UPGRADE_SUPPORT\n  if ( (NULL != response->upgrade_handler) && value_has_close)\n  { /* The \"close\" token cannot be used with connection \"upgrade\" */\n    free (buf);\n    return MHD_NO;\n  }\n#endif /* UPGRADE_SUPPORT */\n  if (0 != norm_len)\n    MHD_str_remove_tokens_caseless_ (buf + old_value_len, &norm_len,\n                                     \"keep-alive\",\n                                     MHD_STATICSTR_LEN_ (\"keep-alive\"));\n  if (0 == norm_len)\n  { /* New value is empty after normalisation */\n    if (! value_has_close)\n    { /* The new value had no tokens */\n      free (buf);\n      return MHD_NO;\n    }\n    if (already_has_close)\n    { /* The \"close\" token is already present, nothing to modify */\n      free (buf);\n      return MHD_YES;\n    }\n  }\n  /* Add \"close\" token if required */\n  if (value_has_close && ! already_has_close)\n  {\n    /* Need to insert \"close\" token at the first position */\n    mhd_assert (buf_size >= old_value_len + norm_len   \\\n                + MHD_STATICSTR_LEN_ (\"close, \") + 1);\n    if (0 != norm_len)\n      memmove (buf + MHD_STATICSTR_LEN_ (\"close, \") + old_value_len,\n               buf + old_value_len, norm_len + 1);\n    memcpy (buf, \"close\", MHD_STATICSTR_LEN_ (\"close\"));\n    pos += MHD_STATICSTR_LEN_ (\"close\");\n  }\n  /* Add old value tokens (if any) */\n  if (0 != old_value_len)\n  {\n    if (0 != pos)\n    {\n      buf[pos++] = ',';\n      buf[pos++] = ' ';\n    }\n    memcpy (buf + pos, hdr->value,\n            hdr->value_size);\n    pos += hdr->value_size;\n  }\n  /* Add new value token (if any) */\n  if (0 != norm_len)\n  {\n    if (0 != pos)\n    {\n      buf[pos++] = ',';\n      buf[pos++] = ' ';\n    }\n    /* The new value tokens must be already at the correct position */\n    mhd_assert ((value_has_close && ! already_has_close) ? \\\n                (MHD_STATICSTR_LEN_ (\"close, \") + old_value_len == pos) : \\\n                (old_value_len == pos));\n    pos += norm_len;\n  }\n  mhd_assert (buf_size > pos);\n  buf[pos] = 0; /* Null terminate the result */\n\n  if (NULL == hdr)\n  {\n    struct MHD_HTTP_Res_Header *new_hdr; /**< new \"Connection\" header */\n    /* Create new response header entry */\n    new_hdr = MHD_calloc_ (1, sizeof (struct MHD_HTTP_Res_Header));\n    if (NULL != new_hdr)\n    {\n      new_hdr->header = malloc (key_len + 1);\n      if (NULL != new_hdr->header)\n      {\n        memcpy (new_hdr->header, key, key_len + 1);\n        new_hdr->header_size = key_len;\n        new_hdr->value = buf;\n        new_hdr->value_size = pos;\n        new_hdr->kind = MHD_HEADER_KIND;\n        if (value_has_close)\n          response->flags_auto = (MHD_RAF_HAS_CONNECTION_HDR\n                                  | MHD_RAF_HAS_CONNECTION_CLOSE);\n        else\n          response->flags_auto = MHD_RAF_HAS_CONNECTION_HDR;\n        _MHD_insert_header_first (response, new_hdr);\n        return MHD_YES;\n      }\n      free (new_hdr);\n    }\n    free (buf);\n    return MHD_NO;\n  }\n\n  /* Update existing header entry */\n  free (hdr->value);\n  hdr->value = buf;\n  hdr->value_size = pos;\n  if (value_has_close && ! already_has_close)\n    response->flags_auto |= MHD_RAF_HAS_CONNECTION_CLOSE;\n  return MHD_YES;\n}\n```\n</target_code>\n<response format>\nProvide your answer with these fields.\n- explanation: your evaluation of the scenario provided by the agent A.\n- is_report_correct: whether the report is correct or not (true/false). True means there is a violation.\n</response format>\n<scenario>\nThe agent A provided the following violation scenario:\nThe memmove call can write past the allocated buffer because the destination is shifted right by MHD_STATICSTR_LEN_(\"close, \") but buf_size was allocated as old_value_len + (initial) norm_len and does not guarantee extra space for that shift. Concretely: assume old_value_len == 0 and the initial computed norm_len (before normalization) was 16 (e.g. value_len = 10 => orig_norm_len = 10 + 5 + 1 = 16). If after normalization norm_len becomes 15, buf_size == 16, but memmove copies norm_len + 1 == 16 bytes from src (buf) to dest (buf + 7). The last written byte would be at buf + 7 + 15 = buf + 22, which exceeds the allocated range (buf + 15) and thus is an out-of-bounds access. Therefore Rule 21.17 is violated.\n</scenario>\n\n<execution_log>\nThe agent A also provided the following output log:\nenter add_response_header_connection: response=0x557a82f02820 value=a,b,c,d,e\nno existing Connection header\ncomputed lengths: value_len=9 old_value_len=0 key_len=10\ninitial norm_len=14 (value_len=9)\ncomputed buf_size=14 (old_value_len=0 + norm_len=14)\nmalloc buf=0x557a82f028e0 buf_size=14\nafter MHD_str_remove_token_caseless_: value_has_close=0 norm_len_s=13\nnormalized norm_len=13 (after removal) buf+old_value_len=0x557a82f028e0\nafter removal of keep-alive: norm_len=13\naccounted for normalized new value: norm_len=13 pos=13\nfinal check before null termination: pos=13 buf_size=14 (buf_size>pos=1)\nfinal buffer content (truncated for log): buf=0x557a82f028e0 pos=13 buf_size=14\ninserting new header: new_hdr=0x557a82f02c00 new_hdr->value=0x557a82f028e0 new_hdr->value_size=13 flags_auto=0x1\nenter add_response_header_connection: response=0x557a82f02820 value=i,k,l,m,n,o,p,close\nno existing Connection header\ncomputed lengths: value_len=19 old_value_len=0 key_len=10\ninitial norm_len=29 (value_len=19)\ncomputed buf_size=29 (old_value_len=0 + norm_len=29)\nmalloc buf=0x557a82f02c40 buf_size=29\nafter MHD_str_remove_token_caseless_: value_has_close=1 norm_len_s=19\nnormalized norm_len=19 (after removal) buf+old_value_len=0x557a82f02c40\nafter removal of keep-alive: norm_len=19\nwill insert 'close' token: checking space: buf_size=29 old_value_len=0 norm_len=19\nabout to memmove: dst=0x557a82f02c47 src=0x557a82f02c40 bytes=20 buf_size=29\nmemmove destination last_byte_index=26, buffer_last_index=28\nmemmove completed\ninserted 'close' at start: pos=5\naccounted for normalized new value: norm_len=19 pos=26\nfinal check before null termination: pos=26 buf_size=29 (buf_size>pos=1)\nfinal buffer content (truncated for log): buf=0x557a82f02c40 pos=26 buf_size=29\ninserting new header: new_hdr=0x557a82f02c70 new_hdr->value=0x557a82f02c40 new_hdr->value_size=26 flags_auto=0x3\nenter add_response_header_connection: response=0x557a82f02820 value=1,2,3,4,5,6,7,close\nno existing Connection header\ncomputed lengths: value_len=19 old_value_len=0 key_len=10\ninitial norm_len=29 (value_len=19)\ncomputed buf_size=29 (old_value_len=0 + norm_len=29)\nmalloc buf=0x557a82f02c40 buf_size=29\nafter MHD_str_remove_token_caseless_: value_has_close=1 norm_len_s=19\nnormalized norm_len=19 (after removal) buf+old_value_len=0x557a82f02c40\nafter removal of keep-alive: norm_len=19\nwill insert 'close' token: checking space: buf_size=29 old_value_len=0 norm_len=19\nabout to memmove: dst=0x557a82f02c47 src=0x557a82f02c40 bytes=20 buf_size=29\nmemmove destination last_byte_index=26, buffer_last_index=28\nmemmove completed\ninserted 'close' at start: pos=5\naccounted for normalized new value: norm_len=19 pos=26\nfinal check before null termination: pos=26 buf_size=29 (buf_size>pos=1)\nfinal buffer content (truncated for log): buf=0x557a82f02c40 pos=26 buf_size=29\ninserting new header: new_hdr=0x557a82f02cb0 new_hdr->value=0x557a82f02c40 new_hdr->value_size=26 flags_auto=0x3\nenter add_response_header_connection: response=0x557a82f02820 value=8,9,close\nexisting header present: hdr=0x557a82f02cb0 already_has_close=1\nexisting hdr->value=close, 1, 2, 3, 4, 5, 6, 7 hdr->value_size=26\ncomputed lengths: value_len=9 old_value_len=28 key_len=10\ninitial norm_len=14 (value_len=9)\ncomputed buf_size=42 (old_value_len=28 + norm_len=14)\nmalloc buf=0x557a82f02c70 buf_size=42\nafter MHD_str_remove_token_caseless_: value_has_close=1 norm_len_s=4\nnormalized norm_len=4 (after removal) buf+old_value_len=0x557a82f02c8c\nafter removal of keep-alive: norm_len=4\nappended old header value: hdr->value_size=26 new pos=26\naccounted for normalized new value: norm_len=4 pos=32\nfinal check before null termination: pos=32 buf_size=42 (buf_size>pos=1)\nfinal buffer content (truncated for log): buf=0x557a82f02c70 pos=32 buf_size=42\nupdating existing header: hdr=0x557a82f02cb0 old_value_ptr=0x557a82f02c40 old_value_size=26\nupdated hdr->value=0x557a82f02c70 hdr->value_size=32\nexiting add_response_header_connection: returning MHD_YES\nenter add_response_header_connection: response=0x557a82f02820 value=10,12\nexisting header present: hdr=0x55\n</execution_log>\n\n<instruction>\nJudge whether the report is correct or not.\n</instruction>\n",
  "is_report_correct": true,
  "explanation": "Agent A's report is correct. The code computes buf_size = old_value_len + initial_norm_len where initial_norm_len is an upper-bound estimate (value_len + value_len/2 + 1) taken before normalization. Later, after removing the \"close\" token, norm_len is updated to the (typically smaller) normalized length, and when value_has_close && !already_has_close the code inserts the literal \"close, \" by memmoving the existing normalized bytes right by MHD_STATICSTR_LEN_(\"close, \") and copying norm_len + 1 bytes (including the NUL). The allocation did not reserve the additional bytes required for that right-shift: the only protection is an mhd_assert that buf_size >= old_value_len + norm_len + MHD_STATICSTR_LEN_(\"close, \") + 1. Since asserts may be omitted in production builds, the code can perform a memmove that writes beyond the allocated buffer. The numeric counterexample in the scenario (initial_norm_len = 16, normalized norm_len = 15, shift = 7, memmove copying 16 bytes to buf+7 -> last written index 22 while buf_size = 16) demonstrates the overflow. This is a violation of MISRA C 2023 Rule 21.17 because use of memmove/memcpy can result in accesses beyond the bounds of the destination object."
}