{
  "user_message": "An agent A claimed that the following MHD_lookup_connection_value_n code violates the MISRA C 2023 rule 8.13.\n<misra_rule>\nMISRA C 2023 Rule 8.13 is A pointer should point to a const-qualified type whenever possible.\n\n</misra_rule>\n<target_code>\nHere is the original code of MHD_lookup_connection_value_n.\n```c\n_MHD_EXTERN enum MHD_Result\nMHD_lookup_connection_value_n (struct MHD_Connection *connection,\n                               enum MHD_ValueKind kind,\n                               const char *key,\n                               size_t key_size,\n                               const char **value_ptr,\n                               size_t *value_size_ptr)\n{\n  struct MHD_HTTP_Req_Header *pos;\n\n  if (NULL == connection)\n    return MHD_NO;\n\n  if (NULL == key)\n  {\n    for (pos = connection->rq.headers_received; NULL != pos; pos = pos->next)\n    {\n      if ( (0 != (kind & pos->kind)) &&\n           (NULL == pos->header) )\n        break;\n    }\n  }\n  else\n  {\n    for (pos = connection->rq.headers_received; NULL != pos; pos = pos->next)\n    {\n      if ( (0 != (kind & pos->kind)) &&\n           (key_size == pos->header_size) &&\n           ( (key == pos->header) ||\n             (MHD_str_equal_caseless_bin_n_ (key,\n                                             pos->header,\n                                             key_size) ) ) )\n        break;\n    }\n  }\n\n  if (NULL == pos)\n    return MHD_NO;\n\n  if (NULL != value_ptr)\n    *value_ptr = pos->value;\n\n  if (NULL != value_size_ptr)\n    *value_size_ptr = pos->value_size;\n\n  return MHD_YES;\n}\n```\n</target_code>\n<response format>\nProvide your answer with these fields.\n- explanation: your evaluation of the scenario provided by the agent A.\n- is_report_correct: whether the report is correct or not (true/false). True means there is a violation.\n</response format>\n<scenario>\nThe agent A provided the following violation scenario:\nThe local pointer 'pos' is declared as 'struct MHD_HTTP_Req_Header *pos' but is only used to read members of the headers list (e.g. pos->kind, pos->header, pos->header_size, pos->value, pos->value_size). No writes through 'pos' occur in this function, so according to MISRA C 2023 Rule 8.13 it should be const-qualified: 'const struct MHD_HTTP_Req_Header *pos;'. Therefore the rule is violated in this code fragment.\n</scenario>\n\n<execution_log>\nThe agent A also provided the following output log:\nMHD_lookup_connection_value_n: enter connection=0x559f0280a270 kind=0x00000001 key=0x7f8d38c9db45 key_size=6 value_ptr=0x7ffc5c53eda8 value_size_ptr=0x7ffc5c53eda0\nMHD_lookup_connection_value_n: key provided -> searching for matching header name\nMHD_lookup_connection_value_n: key-content=\"Cookie\"\niter: pos=0x559f02812480 kind=0x00000001 header=0x559f0280a4d1 header_size=4 value=0x559f0280a4d7 value_size=9\niter: header-content=\"Host\"\niter: pos=0x559f02812440 kind=0x00000001 header=0x559f0280a4e2 header_size=10 value=0x559f0280a4ee value_size=15\niter: header-content=\"User-Agent\"\niter: pos=0x559f02812400 kind=0x00000001 header=0x559f0280a4ff header_size=14 value=0x559f0280a50f value_size=2\niter: header-content=\"Content-Length\"\niter: pos=0x559f028123c0 kind=0x00000001 header=0x559f0280a513 header_size=12 value=0x559f0280a521 value_size=10\niter: header-content=\"Content-Type\"\nMHD_lookup_connection_value_n: no matching header found -> returning MHD_NO\nMHD_lookup_connection_value_n: enter connection=0x559f0280a270 kind=0x00000001 key=0x7f8d38c9d576 key_size=4 value_ptr=(nil) value_size_ptr=(nil)\nMHD_lookup_connection_value_n: key provided -> searching for matching header name\nMHD_lookup_connection_value_n: key-content=\"Host\"\niter: pos=0x559f02812480 kind=0x00000001 header=0x559f0280a4d1 header_size=4 value=0x559f0280a4d7 value_size=9\niter: header-content=\"Host\"\nMHD_lookup_connection_value_n: matching entry found (name match) at pos=0x559f02812480\nMHD_lookup_connection_value_n: selected pos=0x559f02812480\nselected: pos=0x559f02812480 kind=0x00000001 header=0x559f0280a4d1 header_size=4 value=0x559f0280a4d7 value_size=9\nselected: header-content=\"Host\"\nMHD_lookup_connection_value_n: returning MHD_YES\nMHD_lookup_connection_value_n: enter connection=0x559f0280a270 kind=0x00000001 key=0x7f8d38c9d7d5 key_size=17 value_ptr=0x7ffc5c53edf8 value_size_ptr=(nil)\nMHD_lookup_connection_value_n: key provided -> searching for matching header name\nMHD_lookup_connection_value_n: key-content=\"Transfer-Encoding\"\niter: pos=0x559f02812480 kind=0x00000001 header=0x559f0280a4d1 header_size=4 value=0x559f0280a4d7 value_size=9\niter: header-content=\"Host\"\niter: pos=0x559f02812440 kind=0x00000001 header=0x559f0280a4e2 header_size=10 value=0x559f0280a4ee value_size=15\niter: header-content=\"User-Agent\"\niter: pos=0x559f02812400 kind=0x00000001 header=0x559f0280a4ff header_size=14 value=0x559f0280a50f value_size=2\niter: header-content=\"Content-Length\"\niter: pos=0x559f028123c0 kind=0x00000001 header=0x559f0280a513 header_size=12 value=0x559f0280a521 value_size=10\niter: header-content=\"Content-Type\"\nMHD_lookup_connection_value_n: no matching header found -> returning MHD_NO\nMHD_lookup_connection_value_n: enter connection=0x559f0280a270 kind=0x00000001 key=0x7f8d38c9d87a key_size=14 value_ptr=0x7ffc5c53ee00 value_size_ptr=0x7ffc5c53edf0\nMHD_lookup_connection_value_n: key provided -> searching for matching header name\nMHD_lookup_connection_value_n: key-content=\"Content-Length\"\niter: pos=0x559f02812480 kind=0x00000001 header=0x559f0280a4d1 header_size=4 value=0x559f0280a4d7 value_size=9\niter: header-content=\"Host\"\niter: pos=0x559f02812440 kind=0x00000001 header=0x559f0280a4e2 header_size=10 value=0x559f0280a4ee value_size=15\niter: header-content=\"User-Agent\"\niter: pos=0x559f02812400 kind=0x00000001 header=0x559f0280a4ff header_size=14 value=0x559f0280a50f value_size=2\niter: header-content=\"Content-Length\"\nMHD_lookup_connection_value_n: matching entry found (name match) at pos=0x559f02812400\nMHD_lookup_connection_value_n: selected pos=0x559f02812400\nselected: pos=0x559f02812400 kind=0x00000001 header=0x559f0280a4ff header_size=14 value=0x559f0280a50f value_size=2\nselected: header-content=\"Content-Length\"\nMHD_lookup_connection_value_n: stored *value_ptr=0x559f0280a50f\nMHD_lookup_connection_value_n: stored *value_size_ptr=2\nMHD_lookup_connection_value_n: returning MHD_YES\nMHD_lookup_connection_value_n: enter connection=0x559f0280a270 kind=0x00000001 key=0x7f8d38c9de6f key_size=6 value_ptr=0x7ffc5c53edf8 value_size_ptr=(nil)\nMHD_lookup_connection_value_n: key provided -\n</execution_log>\n\n<instruction>\nJudge whether the report is correct or not.\n</instruction>\n",
  "is_report_correct": true,
  "explanation": "The report is correct. In MHD_lookup_connection_value_n the local variable pos is only used to traverse and read the headers list (pos->kind, pos->header, pos->header_size, pos->value, pos->value_size) and there are no writes through pos in this function. According to MISRA C 2023 Rule 8.13 a pointer should point to a const-qualified type whenever possible, so pos should be declared as a pointer to a const-qualified struct (for example: const struct MHD_HTTP_Req_Header *pos;). Assigning pos = pos->next remains valid because converting from struct MHD_HTTP_Req_Header * to const struct MHD_HTTP_Req_Header * is allowed. If, however, this function or other code needs to modify the header objects via pos, then const would be inappropriate \u2014 but given the shown code, the rule is violated and the proper fix is to qualify pos as pointing to const."
}