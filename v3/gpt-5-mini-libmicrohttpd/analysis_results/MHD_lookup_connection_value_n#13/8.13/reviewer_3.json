{
  "user_message": "An agent A claimed that the following MHD_lookup_connection_value_n code violates the MISRA C 2023 rule 8.13.\n<misra_rule>\nMISRA C 2023 Rule 8.13 is A pointer should point to a const-qualified type whenever possible.\n\n</misra_rule>\n<target_code>\nHere is the original code of MHD_lookup_connection_value_n.\n```c\n_MHD_EXTERN enum MHD_Result\nMHD_lookup_connection_value_n (struct MHD_Connection *connection,\n                               enum MHD_ValueKind kind,\n                               const char *key,\n                               size_t key_size,\n                               const char **value_ptr,\n                               size_t *value_size_ptr)\n{\n  struct MHD_HTTP_Req_Header *pos;\n\n  if (NULL == connection)\n    return MHD_NO;\n\n  if (NULL == key)\n  {\n    for (pos = connection->rq.headers_received; NULL != pos; pos = pos->next)\n    {\n      if ( (0 != (kind & pos->kind)) &&\n           (NULL == pos->header) )\n        break;\n    }\n  }\n  else\n  {\n    for (pos = connection->rq.headers_received; NULL != pos; pos = pos->next)\n    {\n      if ( (0 != (kind & pos->kind)) &&\n           (key_size == pos->header_size) &&\n           ( (key == pos->header) ||\n             (MHD_str_equal_caseless_bin_n_ (key,\n                                             pos->header,\n                                             key_size) ) ) )\n        break;\n    }\n  }\n\n  if (NULL == pos)\n    return MHD_NO;\n\n  if (NULL != value_ptr)\n    *value_ptr = pos->value;\n\n  if (NULL != value_size_ptr)\n    *value_size_ptr = pos->value_size;\n\n  return MHD_YES;\n}\n```\n</target_code>\n<response format>\nProvide your answer with these fields.\n- explanation: your evaluation of the scenario provided by the agent A.\n- is_report_correct: whether the report is correct or not (true/false). True means there is a violation.\n</response format>\n<scenario>\nThe agent A provided the following violation scenario:\nThe loop only reads the header pointer (compares it to NULL and later compares its contents to a const key) and does not modify it. If the struct member is declared as a non-const pointer (e.g. char *header) or pos is a non-const pointer to the header structure, that is a violation: the pointer should be const-qualified (either pos should be declared as const struct MHD_HTTP_Req_Header *pos or the member as const char *header) because the data is only accessed read-only.\n</scenario>\n\n<execution_log>\nThe agent A also provided the following output log:\nENTER MHD_lookup_connection_value_n: connection=0x5586d9dc6270, kind=1, key=0x7f2238dfaaf3, key_size=6, value_ptr=0x7ffd5c13a668, value_size_ptr=0x7ffd5c13a660\nSearching for specific key (key ptr=0x7f2238dfaaf3, key_size=6). Starting at headers_received=0x5586d9dce480\niter=0: pos=0x5586d9dce480, pos->kind=0x00000001, pos->header=0x5586d9dc64d1, pos->header_size=4, cond_kind=1, cond_size=0, cond_eq=0\niter=1: pos=0x5586d9dce440, pos->kind=0x00000001, pos->header=0x5586d9dc64e2, pos->header_size=10, cond_kind=1, cond_size=0, cond_eq=0\niter=2: pos=0x5586d9dce400, pos->kind=0x00000001, pos->header=0x5586d9dc64ff, pos->header_size=14, cond_kind=1, cond_size=0, cond_eq=0\niter=3: pos=0x5586d9dce3c0, pos->kind=0x00000001, pos->header=0x5586d9dc6513, pos->header_size=12, cond_kind=1, cond_size=0, cond_eq=0\nEXIT not found: pos == NULL\nENTER MHD_lookup_connection_value_n: connection=0x5586d9dc6270, kind=1, key=0x7f2238dfa524, key_size=4, value_ptr=(nil), value_size_ptr=(nil)\nSearching for specific key (key ptr=0x7f2238dfa524, key_size=4). Starting at headers_received=0x5586d9dce480\niter=0: pos=0x5586d9dce480, pos->kind=0x00000001, pos->header=0x5586d9dc64d1, pos->header_size=4, cond_kind=1, cond_size=1, cond_eq=1\nMATCH at iter=0: cond_kind=1, cond_size=1, cond_eq=1 -> breaking. pos=0x5586d9dce480\nFOUND: pos=0x5586d9dce480, pos->header=0x5586d9dc64d1, pos->header_size=4, pos->value=0x5586d9dc64d7, pos->value_size=9\nEXIT return MHD_YES\nENTER MHD_lookup_connection_value_n: connection=0x5586d9dc6270, kind=1, key=0x7f2238dfa783, key_size=17, value_ptr=0x7ffd5c13a6b8, value_size_ptr=(nil)\nSearching for specific key (key ptr=0x7f2238dfa783, key_size=17). Starting at headers_received=0x5586d9dce480\niter=0: pos=0x5586d9dce480, pos->kind=0x00000001, pos->header=0x5586d9dc64d1, pos->header_size=4, cond_kind=1, cond_size=0, cond_eq=0\niter=1: pos=0x5586d9dce440, pos->kind=0x00000001, pos->header=0x5586d9dc64e2, pos->header_size=10, cond_kind=1, cond_size=0, cond_eq=0\niter=2: pos=0x5586d9dce400, pos->kind=0x00000001, pos->header=0x5586d9dc64ff, pos->header_size=14, cond_kind=1, cond_size=0, cond_eq=0\niter=3: pos=0x5586d9dce3c0, pos->kind=0x00000001, pos->header=0x5586d9dc6513, pos->header_size=12, cond_kind=1, cond_size=0, cond_eq=0\nEXIT not found: pos == NULL\nENTER MHD_lookup_connection_value_n: connection=0x5586d9dc6270, kind=1, key=0x7f2238dfa828, key_size=14, value_ptr=0x7ffd5c13a6c0, value_size_ptr=0x7ffd5c13a6b0\nSearching for specific key (key ptr=0x7f2238dfa828, key_size=14). Starting at headers_received=0x5586d9dce480\niter=0: pos=0x5586d9dce480, pos->kind=0x00000001, pos->header=0x5586d9dc64d1, pos->header_size=4, cond_kind=1, cond_size=0, cond_eq=0\niter=1: pos=0x5586d9dce440, pos->kind=0x00000001, pos->header=0x5586d9dc64e2, pos->header_size=10, cond_kind=1, cond_size=0, cond_eq=0\niter=2: pos=0x5586d9dce400, pos->kind=0x00000001, pos->header=0x5586d9dc64ff, pos->header_size=14, cond_kind=1, cond_size=1, cond_eq=1\nMATCH at iter=2: cond_kind=1, cond_size=1, cond_eq=1 -> breaking. pos=0x5586d9dce400\nFOUND: pos=0x5586d9dce400, pos->header=0x5586d9dc64ff, pos->header_size=14, pos->value=0x5586d9dc650f, pos->value_size=2\nAssigned value_ptr -> 0x5586d9dc650f (pos->value)\nAssigned value_size_ptr -> 2 (pos->value_size)\nEXIT return MHD_YES\nENTER MHD_lookup_connection_value_n: connection=0x5586d9dc6270, kind=1, key=0x7f2238dfae1d, key_size=6, value_ptr=0x7ffd5c13a6b8, value_size_ptr=(nil)\nSearching for specific key (key ptr=0x7f2238dfae1d, key_size=6). Starting at headers_received=0x5586d9dce480\niter=0: pos=0x5586d9dce480, pos->kind=0x00000001, pos->header=0x5586d9dc64d1, pos->header_size=4, cond_kind=1, cond_size=0, cond_eq=0\niter=1: pos=0x5586d9dce440, pos->kind=0x00000001, pos->header=0x5586d9dc64e2, pos->header_size=10, cond_kind=1, cond_size=0, cond_eq=0\niter=2: pos=0x5586d9dce400, pos->kind=0x00000001, pos->header=0x5586d9dc64ff, pos->header_size=14, cond_kind=1, cond_size=0, cond_eq=0\niter=3: pos=0x5586d9dce3c0, pos->kind=0x00000001, pos->header=0x5586d9dc6513, pos->header_size=12, cond_kind=1, cond_size=0, cond_eq=0\nEXIT not found: pos == N\n</execution_log>\n\n<instruction>\nJudge whether the report is correct or not.\n</instruction>\n",
  "is_report_correct": false,
  "explanation": "Not enough information to conclude a definite MISRA 8.13 violation from the snippet alone. Rule 8.13 concerns pointer declarations: a pointer should point to a const-qualified type when the callee does not modify the pointed-to object. In the shown function pos is only used to read header/value members, so a const qualification would be appropriate here. However the rule applies to the actual declarations (e.g. the type of connection->rq.headers_received and the members of struct MHD_HTTP_Req_Header). If those are already declared as const-qualified (for example, header and value are already const char * or headers_received is declared const), there is no violation. Conversely, if the struct/member declarations are non-const but could sensibly be const (and no other code requires them to be mutable), then the agent A\u2019s complaint is correct and the declarations should be changed (for example: const struct MHD_HTTP_Req_Header *pos; and/or const char *header/value in the struct). Given only the function body, the claim cannot be proven; therefore the report as stated is not definitively correct."
}