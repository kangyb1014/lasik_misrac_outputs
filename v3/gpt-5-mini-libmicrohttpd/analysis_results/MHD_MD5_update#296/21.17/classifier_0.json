{
  "user_message": "<misra_rule>\nMISRA C 2023 Rule 21.17 is: Use of the string handling functions from <string.h> shall not result in accesses beyond the bounds of the objects referenced by their pointer parameters.\nThis rule strictly applies to the Standard Library functions in <string.h> such as memcpy, memmove, memset, memcmp, strcpy, strncpy, strcat, strncat, strlen, and strspn.\n</misra_rule>\n<response format>\nProvide your answer with these fields.\n- is_rule_violated: whether the rule is violated or not (true/false),\n- scenario: a specific violation scenario.\n</response format>\n<target_code>\nHere is the code of MHD_MD5_update:\n```c\nvoid\nMHD_MD5_update (struct Md5Ctx *ctx,\n                const uint8_t *data,\n                size_t length)\n{\n  unsigned int bytes_have; /**< Number of bytes in the context buffer */\n\n  mhd_assert ((data != NULL) || (length == 0));\n\n#ifndef MHD_FAVOR_SMALL_CODE\n  if (0 == length)\n    return; /* Shortcut, do nothing */\n#endif /* MHD_FAVOR_SMALL_CODE */\n\n  /* Note: (count & (MD5_BLOCK_SIZE-1))\n           equals (count % MD5_BLOCK_SIZE) for this block size. */\n  bytes_have = (unsigned int) (ctx->count & (MD5_BLOCK_SIZE - 1));\n  ctx->count += length;\n\n  if (0 != bytes_have)\n  {\n    unsigned int bytes_left = MD5_BLOCK_SIZE - bytes_have;\n    if (length >= bytes_left)\n    {     /* Combine new data with data in the buffer and\n             process the full block. */\n      memcpy (((uint8_t *) ctx->buffer) + bytes_have,\n              data,\n              bytes_left);\n      data += bytes_left;\n      length -= bytes_left;\n      md5_transform (ctx->H, ctx->buffer);\n      bytes_have = 0;\n    }\n  }\n\n  while (MD5_BLOCK_SIZE <= length)\n  {   /* Process any full blocks of new data directly,\n         without copying to the buffer. */\n    md5_transform (ctx->H, data);\n    data += MD5_BLOCK_SIZE;\n    length -= MD5_BLOCK_SIZE;\n  }\n\n  if (0 != length)\n  {   /* Copy incomplete block of new data (if any)\n         to the buffer. */\n    memcpy (((uint8_t *) ctx->buffer) + bytes_have, data, length);\n  }\n}\n```\n</target_code>\n<target_code>\nHere is the code fragment that you need to analyze:\n```c\nmemcpy (((uint8_t *) ctx->buffer) + bytes_have, data, length);\n```\nFocus on the above code fragment and judge whether it violates the rule 21.17 or not.\n</target_code>\n",
  "is_rule_violated": false,
  "scenario": "No violation in normal use: the surrounding code ensures that bytes_have + length never exceeds MD5_BLOCK_SIZE. bytes_have is the number of bytes already in the MD5 block buffer (0 <= bytes_have < MD5_BLOCK_SIZE). If length was large enough to overflow the buffer the earlier branch copies exactly bytes_left to complete the block and processes it, and the subsequent loop consumes any full blocks, so the final length < MD5_BLOCK_SIZE and bytes_have + length <= MD5_BLOCK_SIZE. Therefore the memcpy call will not access beyond the destination buffer bounds. \n\nPotential violation scenarios (preconditions not met): 1) If ctx->buffer is not actually at least MD5_BLOCK_SIZE bytes in size (incorrect context definition), the memcpy can overflow the destination\u2014this would violate Rule 21.17. 2) If data == NULL while length > 0 (the code only asserts data != NULL or length == 0 via mhd_assert, which may be disabled), the source pointer is invalid and memcpy will access out of bounds. 3) If ctx->count/bytes_have computation is corrupted (e.g. integer overflow or wrong mask) such that bytes_have + length > MD5_BLOCK_SIZE, the copy could exceed the buffer."
}