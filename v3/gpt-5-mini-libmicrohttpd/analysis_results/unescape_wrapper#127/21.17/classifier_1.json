{
  "user_message": "<misra_rule>\nMISRA C 2023 Rule 21.17 is: Use of the string handling functions from <string.h> shall not result in accesses beyond the bounds of the objects referenced by their pointer parameters.\nThis rule strictly applies to the Standard Library functions in <string.h> such as memcpy, memmove, memset, memcmp, strcpy, strncpy, strcat, strncat, strlen, and strspn.\n</misra_rule>\n<response format>\nProvide your answer with these fields.\n- is_rule_violated: whether the rule is violated or not (true/false),\n- scenario: a specific violation scenario.\n</response format>\n<target_code>\nHere is the code of unescape_wrapper:\n```c\nstatic size_t\nunescape_wrapper (void *cls,\n                  struct MHD_Connection *connection,\n                  char *val)\n{\n  bool broken;\n  size_t res;\n  (void) cls; /* Mute compiler warning. */\n\n  /* TODO: add individual parameter */\n  if (0 <= connection->daemon->client_discipline)\n    return MHD_str_pct_decode_in_place_strict_ (val);\n\n  res = MHD_str_pct_decode_in_place_lenient_ (val, &broken);\n#ifdef HAVE_MESSAGES\n  if (broken)\n  {\n    MHD_DLOG (connection->daemon,\n              _ (\"The URL encoding is broken.\\n\"));\n  }\n#endif /* HAVE_MESSAGES */\n  return res;\n}\n```\n</target_code>\n<target_code>\nHere is the code fragment that you need to analyze:\n```c\n  if (0 <= connection->daemon->client_discipline)\n    return MHD_str_pct_decode_in_place_strict_ (val);\n\n```\nFocus on the above code fragment and judge whether it violates the rule 21.17 or not.\n</target_code>\n",
  "is_rule_violated": false,
  "scenario": "The call itself uses a project-specific function (MHD_str_pct_decode_in_place_strict_) rather than a <string.h> library function, so Rule 21.17 is not directly violated by this fragment. A concrete violation scenario would be: if val does not point to a NUL-terminated buffer or the buffer is shorter than the function assumes, and MHD_str_pct_decode_in_place_strict_ internally calls string.h routines (for example strlen/strcpy/memcpy/strcat) or otherwise copies/reads based on strlen(val) or an assumed capacity, those internal calls could read or write past the bounds of the object referenced by val (e.g. strlen reads past the end if no NUL is present, or a subsequent strcpy/memcpy writes beyond the allocated buffer)."
}