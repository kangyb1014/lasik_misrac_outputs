{
  "user_message": "<misra_rule>\nMISRA C 2023 Rule 17.8 is: A function parameter should not be modified.\nNote that the object referred to by a pointer parameter may be modified, but the pointer itself shall not be modified.\n</misra_rule>\n<response format>\nProvide your answer with these fields.\n- is_rule_violated: whether the rule is violated or not (true/false),\n- scenario: a specific violation scenario.\n</response format>\n<target_code>\nHere is the code of MHD_update_last_activity_:\n```c\nvoid\nMHD_update_last_activity_ (struct MHD_Connection *connection)\n{\n  struct MHD_Daemon *daemon = connection->daemon;\n#if defined(MHD_USE_THREADS)\n  mhd_assert (NULL == daemon->worker_pool);\n#endif /* MHD_USE_THREADS */\n\n  if (0 == connection->connection_timeout_ms)\n    return;  /* Skip update of activity for connections\n               without timeout timer. */\n  if (connection->suspended)\n    return;  /* no activity on suspended connections */\n\n  connection->last_activity = MHD_monotonic_msec_counter ();\n  if (MHD_D_IS_USING_THREAD_PER_CONN_ (daemon))\n    return; /* each connection has personal timeout */\n\n  if (connection->connection_timeout_ms != daemon->connection_timeout_ms)\n    return; /* custom timeout, no need to move it in \"normal\" DLL */\n#if defined(MHD_USE_POSIX_THREADS) || defined(MHD_USE_W32_THREADS)\n  MHD_mutex_lock_chk_ (&daemon->cleanup_connection_mutex);\n#endif\n  /* move connection to head of timeout list (by remove + add operation) */\n  XDLL_remove (daemon->normal_timeout_head,\n               daemon->normal_timeout_tail,\n               connection);\n  XDLL_insert (daemon->normal_timeout_head,\n               daemon->normal_timeout_tail,\n               connection);\n#if defined(MHD_USE_POSIX_THREADS) || defined(MHD_USE_W32_THREADS)\n  MHD_mutex_unlock_chk_ (&daemon->cleanup_connection_mutex);\n#endif\n}\n```\n</target_code>\n<target_code>\nHere is the code fragment that you need to analyze:\n```c\n  XDLL_insert (daemon->normal_timeout_head,\n               daemon->normal_timeout_tail,\n               connection);\n```\nFocus on the above code fragment and judge whether it violates the rule 17.8 or not.\n</target_code>\n",
  "is_rule_violated": false,
  "scenario": "From the call site alone there is no evidence of a Rule 17.8 violation. Rule 17.8 forbids modifying a function\u2019s parameter variable inside the function; it does allow modifying the object pointed to by a pointer parameter. The fragment only shows a call to XDLL_insert(daemon->normal_timeout_head, daemon->normal_timeout_tail, connection). This is not itself a violation. A violation would occur if XDLL_insert is implemented as a function that assigns to its pointer parameters (for example, void XDLL_insert(struct node *head, struct node *tail, struct node *node) { head = some_value; /* modifies the parameter variable */ ... } ), because assigning to the formal parameter is disallowed. By contrast, if XDLL_insert modifies the list nodes (e.g. head->next = \u2026) or updates the daemon\u2019s members via assignments produced by a macro expansion (e.g. assigns to daemon->normal_timeout_head), those actions do not violate 17.8 (modifying the pointed-to object is permitted)."
}