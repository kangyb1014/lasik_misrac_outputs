{
  "user_message": "An agent A claimed that the following serve_simple_form code violates the MISRA C 2023 rule 21.17.\n<misra_rule>\nMISRA C 2023 Rule 21.17 is Use of the string handling functions from <string.h> shall not result in accesses beyond the bounds of the objects referenced by their pointer parameters.\nThis rule strictly applies to the Standard Library functions in <string.h> such as memcpy, memmove, memset, memcmp, strcpy, strncpy, strcat, strncat, strlen, and strspn.\n</misra_rule>\n<target_code>\nHere is the original code of serve_simple_form.\n```c\nstatic enum MHD_Result\nserve_simple_form (const void *cls,\n                   const char *mime,\n                   struct Session *session,\n                   struct MHD_Connection *connection)\n{\n  enum MHD_Result ret;\n  const char *form = cls;\n  struct MHD_Response *response;\n\n  /* return static form */\n  response = MHD_create_response_from_buffer_static (strlen (form),\n                                                     (const void *) form);\n  if (NULL == response)\n    return MHD_NO;\n  add_session_cookie (session, response);\n  if (MHD_YES !=\n      MHD_add_response_header (response,\n                               MHD_HTTP_HEADER_CONTENT_ENCODING,\n                               mime))\n  {\n    fprintf (stderr,\n             \"Failed to set content encoding header!\\n\");\n  }\n  ret = MHD_queue_response (connection,\n                            MHD_HTTP_OK,\n                            response);\n  MHD_destroy_response (response);\n  return ret;\n}\n```\n</target_code>\n<response format>\nProvide your answer with these fields.\n- explanation: your evaluation of the scenario provided by the agent A.\n- is_report_correct: whether the report is correct or not (true/false). True means there is a violation.\n</response format>\n<scenario>\nThe agent A provided the following violation scenario:\nCalling strlen(form) assumes that 'form' points to a NUL-terminated char array. If the caller passed cls that is not a NUL-terminated string (for example a fixed-size buffer filled with data but without a terminating '\\0', or binary data, or a pointer to a buffer that has been truncated/freed), strlen(form) will read past the bounds of the referenced object searching for a '\\0' and thus perform an out-of-bounds access. This violates MISRA C 2023 Rule 21.17.\n</scenario>\n\n<instruction>\nJudge whether the report is correct or not.\n</instruction>\n",
  "is_report_correct": true,
  "explanation": "The report is correct. The code casts cls (declared as const void *) to const char * and calls strlen(form). strlen scans memory until it finds a NUL terminator; if the object referenced by cls is not a NUL-terminated char array (or the pointer is otherwise invalid), strlen will read past the object bounds and cause an out-of-bounds access. MISRA C 2023 Rule 21.17 requires that uses of string.h functions must not result in accesses beyond the bounds of the referenced objects. Because this function does not guarantee (by its signature or checks) that cls points to a NUL-terminated string, the call to strlen can violate 21.17 unless there is an external contract ensuring cls is a NUL-terminated string. To remediate, either: (a) change the parameter type to const char * and document/verify the NUL-termination contract (and preferably enforce it at call sites), (b) pass an explicit length instead of using strlen, or (c) validate/protect against missing terminator before calling strlen."
}