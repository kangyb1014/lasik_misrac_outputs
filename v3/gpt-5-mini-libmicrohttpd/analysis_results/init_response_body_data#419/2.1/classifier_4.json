{
  "user_message": "<misra_rule>\nMISRA C 2023 Rule 2.1 is: A project shall not contain unreachable code.\n\n</misra_rule>\n<response format>\nProvide your answer with these fields.\n- is_rule_violated: whether the rule is violated or not (true/false),\n- scenario: a specific violation scenario.\n</response format>\n<target_code>\nHere is the code of init_response_body_data:\n```c\nstatic int\ninit_response_body_data (void)\n{\n  if (0 != body_dyn_size)\n  {\n    body_dyn = (char *) malloc (body_dyn_size);\n    if (NULL == body_dyn)\n    {\n      fprintf (stderr, \"Failed to allocate memory.\\n\");\n      return 0;\n    }\n    if (tool_params.medium)\n    {\n      /* Fill the body with HTML-like content */\n      size_t pos;\n      size_t filler_pos;\n      static const char body_header[] =\n        \"<html>\\n\"\n        \"<head>\\n<title>Sample page title</title>\\n<head>\\n\"\n        \"<body>\\n\";\n      static const char body_filler[] =\n        \"The quick brown fox jumps over the lazy dog.<br>\\n\";\n      static const char body_footer[] =\n        \"</body>\\n\"\n        \"</html>\\n\";\n      pos = 0;\n      memcpy (body_dyn + pos, body_header, MHD_STATICSTR_LEN_ (body_header));\n      pos += MHD_STATICSTR_LEN_ (body_header);\n      for (filler_pos = 0;\n           filler_pos < (body_dyn_size - (MHD_STATICSTR_LEN_ (body_header)\n                                          + MHD_STATICSTR_LEN_ (body_footer)));\n           ++filler_pos)\n      {\n        body_dyn[pos + filler_pos] =\n          body_filler[filler_pos % MHD_STATICSTR_LEN_ (body_filler)];\n      }\n      pos += filler_pos;\n      memcpy (body_dyn + pos, body_footer, MHD_STATICSTR_LEN_ (body_footer));\n    }\n    else\n    {\n      /* Fill the body with binary-like content */\n      size_t pos;\n      for (pos = 0; pos < body_dyn_size; ++pos)\n      {\n        body_dyn[pos] = (char) (unsigned char) (255U - pos % 256U);\n      }\n    }\n  }\n  return ! 0;\n}\n```\n</target_code>\n<target_code>\nHere is the code fragment that you need to analyze:\n```c\nif (0 != body_dyn_size)\n  {\n    body_dyn = (char *) malloc (body_dyn_size);\n    if (NULL == body_dyn)\n    {\n      fprintf (stderr, \"Failed to allocate memory.\\n\");\n      return 0;\n    }\n    if (tool_params.medium)\n    {\n      /* Fill the body with HTML-like content */\n      size_t pos;\n      size_t filler_pos;\n      static const char body_header[] =\n        \"<html>\\n\"\n        \"<head>\\n<title>Sample page title</title>\\n<head>\\n\"\n        \"<body>\\n\";\n      static const char body_filler[] =\n        \"The quick brown fox jumps over the lazy dog.<br>\\n\";\n      static const char body_footer[] =\n        \"</body>\\n\"\n        \"</html>\\n\";\n      pos = 0;\n      memcpy (body_dyn + pos, body_header, MHD_STATICSTR_LEN_ (body_header));\n      pos += MHD_STATICSTR_LEN_ (body_header);\n      for (filler_pos = 0;\n           filler_pos < (body_dyn_size - (MHD_STATICSTR_LEN_ (body_header)\n                                          + MHD_STATICSTR_LEN_ (body_footer)));\n           ++filler_pos)\n      {\n        body_dyn[pos + filler_pos] =\n          body_filler[filler_pos % MHD_STATICSTR_LEN_ (body_filler)];\n      }\n      pos += filler_pos;\n      memcpy (body_dyn + pos, body_footer, MHD_STATICSTR_LEN_ (body_footer));\n    }\n    else\n    {\n      /* Fill the body with binary-like content */\n      size_t pos;\n      for (pos = 0; pos < body_dyn_size; ++pos)\n      {\n        body_dyn[pos] = (char) (unsigned char) (255U - pos % 256U);\n      }\n    }\n  }\n```\nFocus on the above code fragment and judge whether it violates the rule 2.1 or not.\n</target_code>\n",
  "is_rule_violated": false,
  "scenario": "No violation. The fragment contains conditional branches (if (0 != body_dyn_size), if (tool_params.medium)) and an early return on allocation failure; none of these make code statically unreachable. Each statement can be executed depending on runtime conditions (body_dyn_size non\u2011zero vs zero, malloc success vs failure, tool_params.medium true vs false). There is no code that can never be reached regardless of runtime inputs, so MISRA C 2023 Rule 2.1 is not violated."
}