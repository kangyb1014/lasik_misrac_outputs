{
  "user_message": "An agent A claimed that the following init_response_body_data code violates the MISRA C 2023 rule 21.17.\n<misra_rule>\nMISRA C 2023 Rule 21.17 is Use of the string handling functions from <string.h> shall not result in accesses beyond the bounds of the objects referenced by their pointer parameters.\nThis rule strictly applies to the Standard Library functions in <string.h> such as memcpy, memmove, memset, memcmp, strcpy, strncpy, strcat, strncat, strlen, and strspn.\n</misra_rule>\n<target_code>\nHere is the original code of init_response_body_data.\n```c\nstatic int\ninit_response_body_data (void)\n{\n  if (0 != body_dyn_size)\n  {\n    body_dyn = (char *) malloc (body_dyn_size);\n    if (NULL == body_dyn)\n    {\n      fprintf (stderr, \"Failed to allocate memory.\\n\");\n      return 0;\n    }\n    if (tool_params.medium)\n    {\n      /* Fill the body with HTML-like content */\n      size_t pos;\n      size_t filler_pos;\n      static const char body_header[] =\n        \"<html>\\n\"\n        \"<head>\\n<title>Sample page title</title>\\n<head>\\n\"\n        \"<body>\\n\";\n      static const char body_filler[] =\n        \"The quick brown fox jumps over the lazy dog.<br>\\n\";\n      static const char body_footer[] =\n        \"</body>\\n\"\n        \"</html>\\n\";\n      pos = 0;\n      memcpy (body_dyn + pos, body_header, MHD_STATICSTR_LEN_ (body_header));\n      pos += MHD_STATICSTR_LEN_ (body_header);\n      for (filler_pos = 0;\n           filler_pos < (body_dyn_size - (MHD_STATICSTR_LEN_ (body_header)\n                                          + MHD_STATICSTR_LEN_ (body_footer)));\n           ++filler_pos)\n      {\n        body_dyn[pos + filler_pos] =\n          body_filler[filler_pos % MHD_STATICSTR_LEN_ (body_filler)];\n      }\n      pos += filler_pos;\n      memcpy (body_dyn + pos, body_footer, MHD_STATICSTR_LEN_ (body_footer));\n    }\n    else\n    {\n      /* Fill the body with binary-like content */\n      size_t pos;\n      for (pos = 0; pos < body_dyn_size; ++pos)\n      {\n        body_dyn[pos] = (char) (unsigned char) (255U - pos % 256U);\n      }\n    }\n  }\n  return ! 0;\n}\n```\n</target_code>\n<response format>\nProvide your answer with these fields.\n- explanation: your evaluation of the scenario provided by the agent A.\n- is_report_correct: whether the report is correct or not (true/false). True means there is a violation.\n</response format>\n<scenario>\nThe agent A provided the following violation scenario:\nThe statement itself (pos += MHD_STATICSTR_LEN_(body_header)) is not a string.h call, but it updates the offset used by subsequent memcpy and indexed writes without any checks that the allocation (body_dyn_size) is large enough. If body_dyn_size < MHD_STATICSTR_LEN_(body_header) then the prior memcpy(body_dyn, body_header, MHD_STATICSTR_LEN_(body_header)) already writes out of bounds. If body_dyn_size < MHD_STATICSTR_LEN_(body_header) + MHD_STATICSTR_LEN_(body_footer) the subtraction in the for condition (body_dyn_size - (len_header + len_footer)) will underflow (size_t) and the filler loop will write far beyond the allocated buffer; the final memcpy(body_dyn + pos, body_footer, MHD_STATICSTR_LEN_(body_footer)) will also write out of bounds. Thus the code can cause accesses beyond the bounds of the objects passed to memcpy and the rule is violated.\n</scenario>\n\n<instruction>\nJudge whether the report is correct or not.\n</instruction>\n",
  "is_report_correct": true,
  "explanation": "Agent A is correct. The code calls memcpy(body_dyn, body_header, MHD_STATICSTR_LEN_(body_header)) and later memcpy(body_dyn + pos, body_footer, MHD_STATICSTR_LEN_(body_footer)) without any checks that the allocated buffer (body_dyn_size) is large enough to hold these copies. If body_dyn_size < MHD_STATICSTR_LEN_(body_header) the first memcpy writes out of bounds. The filler loop uses the condition filler_pos < (body_dyn_size - (header_len + footer_len)) where the subtraction is on size_t; if body_dyn_size < (header_len + footer_len) this underflows to a very large value and the loop will perform many out\u2011of\u2011bounds writes, and the final memcpy likewise can write out of bounds. Because memcpy (a <string.h> function) can therefore be invoked such that it accesses beyond the bounds of the destination object, this violates MISRA C 2023 Rule 21.17. (Fix: validate body_dyn_size against the required header+footer lengths and limit copies/loops to the allocated size.)"
}