{
  "user_message": "<misra_rule>\nMISRA C 2023 Rule 21.17 is: Use of the string handling functions from <string.h> shall not result in accesses beyond the bounds of the objects referenced by their pointer parameters.\nThis rule strictly applies to the Standard Library functions in <string.h> such as memcpy, memmove, memset, memcmp, strcpy, strncpy, strcat, strncat, strlen, and strspn.\n</misra_rule>\n<response format>\nProvide your answer with these fields.\n- is_rule_violated: whether the rule is violated or not (true/false),\n- scenario: a specific violation scenario.\n</response format>\n<target_code>\nHere is the code of MHD_create_response_from_callback:\n```c\n_MHD_EXTERN struct MHD_Response *\nMHD_create_response_from_callback (uint64_t size,\n                                   size_t block_size,\n                                   MHD_ContentReaderCallback crc,\n                                   void *crc_cls,\n                                   MHD_ContentReaderFreeCallback crfc)\n{\n  struct MHD_Response *response;\n\n  if ((NULL == crc) || (0 == block_size))\n    return NULL;\n  if (NULL == (response = MHD_calloc_ (1, sizeof (struct MHD_Response)\n                                       + block_size)))\n    return NULL;\n  response->fd = -1;\n  response->data = (void *) &response[1];\n  response->data_buffer_size = block_size;\n#if defined(MHD_USE_POSIX_THREADS) || defined(MHD_USE_W32_THREADS)\n  if (! MHD_mutex_init_ (&response->mutex))\n  {\n    free (response);\n    return NULL;\n  }\n#endif\n  response->crc = crc;\n  response->crfc = crfc;\n  response->crc_cls = crc_cls;\n  response->reference_count = 1;\n  response->total_size = size;\n  return response;\n}\n```\n</target_code>\n<target_code>\nHere is the code fragment that you need to analyze:\n```c\nif ((NULL == crc) || (0 == block_size))\n    return NULL;\n```\nFocus on the above code fragment and judge whether it violates the rule 21.17 or not.\n</target_code>\n",
  "is_rule_violated": false,
  "scenario": "No violation in the shown fragment. The code only checks crc for NULL and block_size for zero and does not call any functions from <string.h> or perform buffer accesses. A specific violation scenario (not present here) would be, for example, later calling memcpy(response->data, crc, block_size) where crc points to a smaller source buffer than block_size, or using strcpy/strcat/strncpy/strncat with a destination buffer smaller than the copied/concatenated data \u2014 those would violate Rule 21.17."
}