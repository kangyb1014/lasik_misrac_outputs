{
  "user_message": "<misra_rule>\nMISRA C 2023 Rule 2.2 is: A project shall not contain dead code.\nAny operation that is executed but whose removal would not affect program behaviour constitutes dead code. Notes:\n1. The behaviour of an embedded sytem is often determined not just by the nature of its actions, but also by the time at which they occur.\n2. unreachable code is not dead code, as it cannot be executed.\n3.Initialization is not the same as an assignment operation and is therfore not a candidate for dead code.\n</misra_rule>\n<response format>\nProvide your answer with these fields.\n- is_rule_violated: whether the rule is violated or not (true/false),\n- scenario: a specific violation scenario.\n</response format>\n<target_code>\nHere is the code of check_nonce_nc:\n```c\nstatic enum MHD_CheckNonceNC_\ncheck_nonce_nc (struct MHD_Connection *connection,\n                const char *nonce,\n                size_t noncelen,\n                uint64_t nonce_time,\n                uint64_t nc)\n{\n  struct MHD_Daemon *daemon = MHD_get_master (connection->daemon);\n  struct MHD_NonceNc *nn;\n  uint32_t mod;\n  enum MHD_CheckNonceNC_ ret;\n\n  mhd_assert (0 != noncelen);\n  mhd_assert (0 != nc);\n  if (MAX_DIGEST_NONCE_LENGTH < noncelen)\n    return MHD_CHECK_NONCENC_WRONG; /* This should be impossible, but static analysis\n                      tools have a hard time with it *and* this also\n                      protects against unsafe modifications that may\n                      happen in the future... */\n  mod = daemon->nonce_nc_size;\n  if (0 == mod)\n    return MHD_CHECK_NONCENC_STALE;  /* no array! */\n  if (nc >= UINT32_MAX - 64)\n    return MHD_CHECK_NONCENC_STALE;  /* Overflow, unrealistically high value */\n\n  nn = &daemon->nnc[get_nonce_nc_idx (mod, nonce, noncelen)];\n\n  MHD_mutex_lock_chk_ (&daemon->nnc_lock);\n\n  mhd_assert (0 == nn->nonce[noncelen]); /* The old value must be valid */\n\n  if ( (0 != memcmp (nn->nonce, nonce, noncelen)) ||\n       (0 != nn->nonce[noncelen]) )\n  { /* The nonce in the slot does not match nonce from the client */\n    if (0 == nn->nonce[0])\n    { /* The slot was never used, while the client's nonce value should be\n       * recorded when it was generated by MHD */\n      ret = MHD_CHECK_NONCENC_WRONG;\n    }\n    else if (0 != nn->nonce[noncelen])\n    { /* The value is the slot is wrong */\n      ret =  MHD_CHECK_NONCENC_STALE;\n    }\n    else\n    {\n      uint64_t slot_ts; /**< The timestamp in the slot */\n      if (! get_nonce_timestamp (nn->nonce, noncelen, &slot_ts))\n      {\n        mhd_assert (0); /* The value is the slot is wrong */\n        ret = MHD_CHECK_NONCENC_STALE;\n      }\n      else\n      {\n        /* Unsigned value, will be large if nonce_time is less than slot_ts */\n        const uint64_t ts_diff = TRIM_TO_TIMESTAMP (nonce_time - slot_ts);\n        if ((REUSE_TIMEOUT * 1000) >= ts_diff)\n        {\n          /* The nonce from the client may not have been placed in the slot\n           * because another nonce in that slot has not yet expired. */\n          ret = MHD_CHECK_NONCENC_STALE;\n        }\n        else if (TRIM_TO_TIMESTAMP (UINT64_MAX) / 2 >= ts_diff)\n        {\n          /* Too large value means that nonce_time is less than slot_ts.\n           * The nonce from the client may have been overwritten by the newer\n           * nonce. */\n          ret = MHD_CHECK_NONCENC_STALE;\n        }\n        else\n        {\n          /* The nonce from the client should be generated after the nonce\n           * in the slot has been expired, the nonce must be recorded, but\n           * it's not. */\n          ret = MHD_CHECK_NONCENC_WRONG;\n        }\n      }\n    }\n  }\n  else if (nc > nn->nc)\n  {\n    /* 'nc' is larger, shift bitmask and bump limit */\n    const uint32_t jump_size = (uint32_t) nc - nn->nc;\n    if (64 > jump_size)\n    {\n      /* small jump, less than mask width */\n      nn->nmask <<= jump_size;\n      /* Set bit for the old 'nc' value */\n      nn->nmask |= (UINT64_C (1) << (jump_size - 1));\n    }\n    else if (64 == jump_size)\n      nn->nmask = (UINT64_C (1) << 63);\n    else\n      nn->nmask = 0;                /* big jump, unset all bits in the mask */\n    nn->nc = (uint32_t) nc;\n    ret = MHD_CHECK_NONCENC_OK;\n  }\n  else if (nc < nn->nc)\n  {\n    /* Note that we use 64 here, as we do not store the\n       bit for 'nn->nc' itself in 'nn->nmask' */\n    if ( (nc + 64 >= nn->nc) &&\n         (0 == ((UINT64_C (1) << (nn->nc - nc - 1)) & nn->nmask)) )\n    {\n      /* Out-of-order nonce, but within 64-bit bitmask, set bit */\n      nn->nmask |= (UINT64_C (1) << (nn->nc - nc - 1));\n      ret = MHD_CHECK_NONCENC_OK;\n    }\n    else\n      /* 'nc' was already used or too old (more then 64 values ago) */\n      ret = MHD_CHECK_NONCENC_STALE;\n  }\n  else /* if (nc == nn->nc) */\n    /* 'nc' was already used */\n    ret = MHD_CHECK_NONCENC_STALE;\n\n  MHD_mutex_unlock_chk_ (&daemon->nnc_lock);\n\n  return ret;\n}\n```\n</target_code>\n<target_code>\nHere is the code fragment that you need to analyze:\n```c\nif (MAX_DIGEST_NONCE_LENGTH < noncelen)\n    return MHD_CHECK_NONCENC_WRONG; /* This should be impossible, but static analysis\n                      tools have a hard time with it *and* this also\n                      protects against unsafe modifications that may\n                      happen in the future... */\n```\nFocus on the above code fragment and judge whether it violates the rule 2.2 or not.\n</target_code>\n",
  "is_rule_violated": false,
  "scenario": "The fragment is a defensive runtime check: if noncelen can ever exceed MAX_DIGEST_NONCE_LENGTH (for example due to corrupted input or future code changes), the return prevents out-of-bounds use \u2014 removing it would change program behaviour in that case. If noncelen is provably never greater (statically guaranteed elsewhere), the branch becomes unreachable; note 2 of Rule 2.2 states unreachable code is not considered dead code. Therefore this check is not dead code."
}