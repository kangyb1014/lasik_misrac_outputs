{
  "user_message": "An agent A claimed that the following check_nonce_nc code violates the MISRA C 2023 rule 21.17.\n<misra_rule>\nMISRA C 2023 Rule 21.17 is Use of the string handling functions from <string.h> shall not result in accesses beyond the bounds of the objects referenced by their pointer parameters.\nThis rule strictly applies to the Standard Library functions in <string.h> such as memcpy, memmove, memset, memcmp, strcpy, strncpy, strcat, strncat, strlen, and strspn.\n</misra_rule>\n<target_code>\nHere is the original code of check_nonce_nc.\n```c\nstatic enum MHD_CheckNonceNC_\ncheck_nonce_nc (struct MHD_Connection *connection,\n                const char *nonce,\n                size_t noncelen,\n                uint64_t nonce_time,\n                uint64_t nc)\n{\n  struct MHD_Daemon *daemon = MHD_get_master (connection->daemon);\n  struct MHD_NonceNc *nn;\n  uint32_t mod;\n  enum MHD_CheckNonceNC_ ret;\n\n  mhd_assert (0 != noncelen);\n  mhd_assert (0 != nc);\n  if (MAX_DIGEST_NONCE_LENGTH < noncelen)\n    return MHD_CHECK_NONCENC_WRONG; /* This should be impossible, but static analysis\n                      tools have a hard time with it *and* this also\n                      protects against unsafe modifications that may\n                      happen in the future... */\n  mod = daemon->nonce_nc_size;\n  if (0 == mod)\n    return MHD_CHECK_NONCENC_STALE;  /* no array! */\n  if (nc >= UINT32_MAX - 64)\n    return MHD_CHECK_NONCENC_STALE;  /* Overflow, unrealistically high value */\n\n  nn = &daemon->nnc[get_nonce_nc_idx (mod, nonce, noncelen)];\n\n  MHD_mutex_lock_chk_ (&daemon->nnc_lock);\n\n  mhd_assert (0 == nn->nonce[noncelen]); /* The old value must be valid */\n\n  if ( (0 != memcmp (nn->nonce, nonce, noncelen)) ||\n       (0 != nn->nonce[noncelen]) )\n  { /* The nonce in the slot does not match nonce from the client */\n    if (0 == nn->nonce[0])\n    { /* The slot was never used, while the client's nonce value should be\n       * recorded when it was generated by MHD */\n      ret = MHD_CHECK_NONCENC_WRONG;\n    }\n    else if (0 != nn->nonce[noncelen])\n    { /* The value is the slot is wrong */\n      ret =  MHD_CHECK_NONCENC_STALE;\n    }\n    else\n    {\n      uint64_t slot_ts; /**< The timestamp in the slot */\n      if (! get_nonce_timestamp (nn->nonce, noncelen, &slot_ts))\n      {\n        mhd_assert (0); /* The value is the slot is wrong */\n        ret = MHD_CHECK_NONCENC_STALE;\n      }\n      else\n      {\n        /* Unsigned value, will be large if nonce_time is less than slot_ts */\n        const uint64_t ts_diff = TRIM_TO_TIMESTAMP (nonce_time - slot_ts);\n        if ((REUSE_TIMEOUT * 1000) >= ts_diff)\n        {\n          /* The nonce from the client may not have been placed in the slot\n           * because another nonce in that slot has not yet expired. */\n          ret = MHD_CHECK_NONCENC_STALE;\n        }\n        else if (TRIM_TO_TIMESTAMP (UINT64_MAX) / 2 >= ts_diff)\n        {\n          /* Too large value means that nonce_time is less than slot_ts.\n           * The nonce from the client may have been overwritten by the newer\n           * nonce. */\n          ret = MHD_CHECK_NONCENC_STALE;\n        }\n        else\n        {\n          /* The nonce from the client should be generated after the nonce\n           * in the slot has been expired, the nonce must be recorded, but\n           * it's not. */\n          ret = MHD_CHECK_NONCENC_WRONG;\n        }\n      }\n    }\n  }\n  else if (nc > nn->nc)\n  {\n    /* 'nc' is larger, shift bitmask and bump limit */\n    const uint32_t jump_size = (uint32_t) nc - nn->nc;\n    if (64 > jump_size)\n    {\n      /* small jump, less than mask width */\n      nn->nmask <<= jump_size;\n      /* Set bit for the old 'nc' value */\n      nn->nmask |= (UINT64_C (1) << (jump_size - 1));\n    }\n    else if (64 == jump_size)\n      nn->nmask = (UINT64_C (1) << 63);\n    else\n      nn->nmask = 0;                /* big jump, unset all bits in the mask */\n    nn->nc = (uint32_t) nc;\n    ret = MHD_CHECK_NONCENC_OK;\n  }\n  else if (nc < nn->nc)\n  {\n    /* Note that we use 64 here, as we do not store the\n       bit for 'nn->nc' itself in 'nn->nmask' */\n    if ( (nc + 64 >= nn->nc) &&\n         (0 == ((UINT64_C (1) << (nn->nc - nc - 1)) & nn->nmask)) )\n    {\n      /* Out-of-order nonce, but within 64-bit bitmask, set bit */\n      nn->nmask |= (UINT64_C (1) << (nn->nc - nc - 1));\n      ret = MHD_CHECK_NONCENC_OK;\n    }\n    else\n      /* 'nc' was already used or too old (more then 64 values ago) */\n      ret = MHD_CHECK_NONCENC_STALE;\n  }\n  else /* if (nc == nn->nc) */\n    /* 'nc' was already used */\n    ret = MHD_CHECK_NONCENC_STALE;\n\n  MHD_mutex_unlock_chk_ (&daemon->nnc_lock);\n\n  return ret;\n}\n```\n</target_code>\n<response format>\nProvide your answer with these fields.\n- explanation: your evaluation of the scenario provided by the agent A.\n- is_report_correct: whether the report is correct or not (true/false). True means there is a violation.\n</response format>\n<scenario>\nThe agent A provided the following violation scenario:\nThe code indexes nn->nonce at position noncelen. The function only checks if (MAX_DIGEST_NONCE_LENGTH < noncelen) return; which allows noncelen == MAX_DIGEST_NONCE_LENGTH. If nn->nonce is declared as an array of length MAX_DIGEST_NONCE_LENGTH (bytes 0..MAX_DIGEST_NONCE_LENGTH-1), then accessing nn->nonce[noncelen] when noncelen == MAX_DIGEST_NONCE_LENGTH is out-of-bounds, violating Rule 21.17. (If, however, nn->nonce is defined with size at least MAX_DIGEST_NONCE_LENGTH+1 to hold a terminator, the access would be safe.)\n</scenario>\n\n<instruction>\nJudge whether the report is correct or not.\n</instruction>\n",
  "is_report_correct": true,
  "explanation": "Agent A's report is correct as a potential MISRA 21.17 violation. The function permits noncelen == MAX_DIGEST_NONCE_LENGTH (the check only returns if noncelen > MAX_DIGEST_NONCE_LENGTH). Later the code does memcmp(nn->nonce, nonce, noncelen) and directly accesses nn->nonce[noncelen] (one past the compared bytes). For these operations to be guaranteed safe the storage for nn->nonce must be at least noncelen+1 bytes long (i.e. at least MAX_DIGEST_NONCE_LENGTH+1 when noncelen == MAX_DIGEST_NONCE_LENGTH). If, as Agent A hypothesised, nn->nonce is declared with length exactly MAX_DIGEST_NONCE_LENGTH, then the access nn->nonce[noncelen] is out-of-bounds and thus violates Rule 21.17. Without the struct definition you cannot prove safety; therefore the report is justified unless the codebase guarantees nn->nonce has that extra byte (in which case the code would be safe)."
}