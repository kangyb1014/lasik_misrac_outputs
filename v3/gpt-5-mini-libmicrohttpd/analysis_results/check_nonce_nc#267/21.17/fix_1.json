{
  "user_message": "<target code>Here is the code that failed to compile:\n```c\n\nstatic enum MHD_CheckNonceNC_\ncheck_nonce_nc (struct MHD_Connection *connection,\n                const char *nonce,\n                size_t noncelen,\n                uint64_t nonce_time,\n                uint64_t nc)\n{\n  struct MHD_Daemon *daemon = MHD_get_master (connection->daemon);\n  struct MHD_NonceNc *nn;\n  uint32_t mod;\n  enum MHD_CheckNonceNC_ ret;\n\n  /* Minimal forward declarations for logging functions to avoid adding headers\n     in this snippet. These are standard stdio functions. */\n  typedef struct __FILE FILE;\n  extern FILE *fopen (const char *path, const char *mode);\n  extern int fprintf (FILE *stream, const char *format, ...);\n  extern int fclose (FILE *stream);\n\n  FILE *log = NULL;\n\n  mhd_assert (0 != noncelen);\n  mhd_assert (0 != nc);\n\n  /* Open log early so we can capture early-return scenarios. */\n  log = fopen(\"/tmp/logs/2679.txt\", \"a\");\n  if (log)\n  {\n    fprintf (log, \"check_nonce_nc: enter\\n\");\n    fprintf (log, \"  connection=%p daemon=%p noncelen=%zu MAX_DIGEST_NONCE_LENGTH=%d nc=%llu\\n\",\n             (void *) connection, (void *) daemon, noncelen, (int) MAX_DIGEST_NONCE_LENGTH, (unsigned long long) nc);\n  }\n\n  if (MAX_DIGEST_NONCE_LENGTH < noncelen)\n  {\n    /* preserve original behavior but ensure we close the log before returning */\n    ret = MHD_CHECK_NONCENC_WRONG; /* This should be impossible, but static analysis\n                      tools have a hard time with it *and* this also\n                      protects against unsafe modifications that may\n                      happen in the future... */\n    if (log)\n    {\n      fprintf (log, \"  early-return: noncelen too large (noncelen=%zu > MAX_DIGEST_NONCE_LENGTH=%d)\\n\",\n               noncelen, (int) MAX_DIGEST_NONCE_LENGTH);\n      fprintf (log, \"check_nonce_nc: exit ret=%d\\n\", (int) ret);\n      fclose (log);\n    }\n    return ret;\n  }\n\n  mod = daemon->nonce_nc_size;\n  if (log)\n    fprintf (log, \"  mod=%u\\n\", mod);\n\n  if (0 == mod)\n  {\n    ret = MHD_CHECK_NONCENC_STALE;  /* no array! */\n    if (log)\n    {\n      fprintf (log, \"  early-return: mod == 0 -> STALE\\n\");\n      fprintf (log, \"check_nonce_nc: exit ret=%d\\n\", (int) ret);\n      fclose (log);\n    }\n    return ret;\n  }\n  if (nc >= UINT32_MAX - 64)\n  {\n    ret = MHD_CHECK_NONCENC_STALE;  /* Overflow, unrealistically high value */\n    if (log)\n    {\n      fprintf (log, \"  early-return: nc too large (nc=%llu) -> STALE\\n\", (unsigned long long) nc);\n      fprintf (log, \"check_nonce_nc: exit ret=%d\\n\", (int) ret);\n      fclose (log);\n    }\n    return ret;\n  }\n\n  /* compute index and pointer to slot */\n  {\n    uint32_t idx = get_nonce_nc_idx (mod, nonce, noncelen);\n    nn = &daemon->nnc[idx];\n    if (log)\n    {\n      fprintf (log, \"  computed idx=%u nn=%p &nn->nonce[0]=%p &nn->nonce[noncelen]=%p\\n\",\n               idx, (void *) nn, (void *) &nn->nonce[0], (void *) &nn->nonce[noncelen]);\n      /* Log the first byte from the slot (safe) but avoid dereferencing arbitrary index */\n      fprintf (log, \"  nn->nonce[0]=%u (as unsigned)\\n\", (unsigned) (unsigned char) nn->nonce[0]);\n    }\n  }\n\n  MHD_mutex_lock_chk_ (&daemon->nnc_lock);\n\n  if (log)\n    fprintf (log, \"  acquired nnc_lock\\n\");\n\n  mhd_assert (0 == nn->nonce[noncelen]); /* The old value must be valid */\n\n  if (log)\n    fprintf (log, \"  after assert: memcmp check about to run (noncelen=%zu)\\n\", noncelen);\n\n  if ( (0 != memcmp (nn->nonce, nonce, noncelen)) ||\n       (0 != nn->nonce[noncelen]) )\n  { /* The nonce in the slot does not match nonce from the client */\n    if (log)\n      fprintf (log, \"  branch: slot nonce != client nonce or terminator mismatch\\n\");\n\n    if (0 == nn->nonce[0])\n    { /* The slot was never used, while the client's nonce value should be\n       * recorded when it was generated by MHD */\n      ret = MHD_CHECK_NONCENC_WRONG;\n      if (log)\n        fprintf (log, \"    slot unused -> WRONG\\n\");\n    }\n    else if (0 != nn->nonce[noncelen])\n    { /* The value is the slot is wrong */\n      ret =  MHD_CHECK_NONCENC_STALE;\n      if (log)\n        fprintf (log, \"    terminator mismatch -> STALE\\n\");\n    }\n    else\n    {\n      uint64_t slot_ts; /**< The timestamp in the slot */\n      if (! get_nonce_timestamp (nn->nonce, noncelen, &slot_ts))\n      {\n        mhd_assert (0); /* The value is the slot is wrong */\n        ret = MHD_CHECK_NONCENC_STALE;\n        if (log)\n          fprintf (log, \"    get_nonce_timestamp failed -> STALE\\n\");\n      }\n      else\n      {\n        /* Unsigned value, will be large if nonce_time is less than slot_ts */\n        const uint64_t ts_diff = TRIM_TO_TIMESTAMP (nonce_time - slot_ts);\n        if (log)\n          fprintf (log, \"    slot_ts=%llu nonce_time=%llu ts_diff=%llu\\n\",\n                   (unsigned long long) slot_ts, (unsigned long long) nonce_time,\n                   (unsigned long long) ts_diff);\n        if ((REUSE_TIMEOUT * 1000) >= ts_diff)\n        {\n          /* The nonce from the client may not have been placed in the slot\n           * because another nonce in that slot has not yet expired. */\n          ret = MHD_CHECK_NONCENC_STALE;\n          if (log)\n            fprintf (log, \"    ts_diff <= REUSE_TIMEOUT -> STALE\\n\");\n        }\n        else if (TRIM_TO_TIMESTAMP (UINT64_MAX) / 2 >= ts_diff)\n        {\n          /* Too large value means that nonce_time is less than slot_ts.\n           * The nonce from the client may have been overwritten by the newer\n           * nonce. */\n          ret = MHD_CHECK_NONCENC_STALE;\n          if (log)\n            fprintf (log, \"    ts_diff large -> STALE\\n\");\n        }\n        else\n        {\n          /* The nonce from the client should be generated after the nonce\n           * in the slot has been expired, the nonce must be recorded, but\n           * it's not. */\n          ret = MHD_CHECK_NONCENC_WRONG;\n          if (log)\n            fprintf (log, \"    nonce should have been recorded -> WRONG\\n\");\n        }\n      }\n    }\n  }\n  else if (nc > nn->nc)\n  {\n    /* 'nc' is larger, shift bitmask and bump limit */\n    const uint32_t jump_size = (uint32_t) nc - nn->nc;\n    if (log)\n      fprintf (log, \"  branch: nc > nn->nc (nc=%llu nn->nc=%u) jump_size=%u\\n\",\n               (unsigned long long) nc, nn->nc, jump_size);\n    if (64 > jump_size)\n    {\n      /* small jump, less than mask width */\n      nn->nmask <<= jump_size;\n      /* Set bit for the old 'nc' value */\n      nn->nmask |= (UINT64_C (1) << (jump_size - 1));\n    }\n    else if (64 == jump_size)\n      nn->nmask = (UINT64_C (1) << 63);\n    else\n      nn->nmask = 0;                /* big jump, unset all bits in the mask */\n    nn->nc = (uint32_t) nc;\n    ret = MHD_CHECK_NONCENC_OK;\n    if (log)\n      fprintf (log, \"    updated nn->nc=%u nn->nmask=%llu -> OK\\n\",\n               nn->nc, (unsigned long long) nn->nmask);\n  }\n  else if (nc < nn->nc)\n  {\n    if (log)\n      fprintf (log, \"  branch: nc < nn->nc (nc=%llu nn->nc=%u)\\n\",\n               (unsigned long long) nc, nn->nc);\n    /* Note that we use 64 here, as we do not store the\n       bit for 'nn->nc' itself in 'nn->nmask' */\n    if ( (nc + 64 >= nn->nc) &&\n         (0 == ((UINT64_C (1) << (nn->nc - nc - 1)) & nn->nmask)) )\n    {\n      /* Out-of-order nonce, but within 64-bit bitmask, set bit */\n      nn->nmask |= (UINT64_C (1) << (nn->nc - nc - 1));\n      ret = MHD_CHECK_NONCENC_OK;\n      if (log)\n        fprintf (log, \"    marked out-of-order -> OK\\n\");\n    }\n    else\n      /* 'nc' was already used or too old (more then 64 values ago) */\n      ret = MHD_CHECK_NONCENC_STALE;\n  }\n  else /* if (nc == nn->nc) */\n  {\n    /* 'nc' was already used */\n    ret = MHD_CHECK_NONCENC_STALE;\n    if (log)\n      fprintf (log, \"  branch: nc == nn->nc -> STALE\\n\");\n  }\n\n  MHD_mutex_unlock_chk_ (&daemon->nnc_lock);\n  if (log)\n    fprintf (log, \"  released nnc_lock\\n\");\n\n  if (log)\n  {\n    fprintf (log, \"check_nonce_nc: exit ret=%d\\n\", (int) ret);\n    fclose (log);\n  }\n\n  return ret;\n}\n\n```\n</target code>\n<build error>\nThe build failed with the following error:\n```\ndigestauth.c:852:16: error: conflicting types for 'fopen'\n  852 |   extern FILE *fopen (const char *path, const char *mode);\n      |                ^\n/usr/include/stdio.h:258:14: note: previous declaration is here\n  258 | extern FILE *fopen (const char *__restrict __filename,\n      |              ^\ndigestauth.c:853:14: error: conflicting types for 'fprintf'\n  853 |   extern int fprintf (FILE *stream, const char *format, ...);\n      |              ^\n/usr/include/stdio.h:350:12: note: previous declaration is here\n  350 | extern int fprintf (FILE *__restrict __stream,\n      |            ^\ndigestauth.c:854:14: error: conflicting types for 'fclose'\n  854 |   extern int fclose (FILE *stream);\n      |              ^\n/usr/include/stdio.h:178:12: note: previous declaration is here\n  178 | extern int fclose (FILE *__stream);\n      |            ^\n3 errors generated.\nmake[3]: *** [Makefile:2224: libmicrohttpd_la-digestauth.lo] Error 1\nmake[2]: *** [Makefile:449: all-recursive] Error 1\nmake[1]: *** [Makefile:788: all-recursive] Error 1\nmake: *** [Makefile:693: all] Error 2\n```\n</build error>\n<response format>\nProvide your answer with these answers.\n- fixed_test_code: the fixed test code that compiles successfully.\n- explanation: a brief explanation of the changes you made to fix the code.\nHere are the constraints for the test code:\n- The test code MUST be compilable and executable.\n- The test code MUST include line breaks.\n- The test code MUST preserve the original logic of check_nonce_nc as much as possible.\n- You MUST not define the main function.\n- You MUST not define macros.\n- The test code MUST not contain any mock functions.\n</response format>\n<instruction>\nPlease fix the code so that it compiles successfully.\n</instruction>\n",
  "fixed_test_code": "#include <stdio.h>\n\nstatic enum MHD_CheckNonceNC_\ncheck_nonce_nc (struct MHD_Connection *connection,\n                const char *nonce,\n                size_t noncelen,\n                uint64_t nonce_time,\n                uint64_t nc)\n{\n  struct MHD_Daemon *daemon = MHD_get_master (connection->daemon);\n  struct MHD_NonceNc *nn;\n  uint32_t mod;\n  enum MHD_CheckNonceNC_ ret;\n\n  FILE *log = NULL;\n\n  mhd_assert (0 != noncelen);\n  mhd_assert (0 != nc);\n\n  /* Open log early so we can capture early-return scenarios. */\n  log = fopen(\"/tmp/logs/2679.txt\", \"a\");\n  if (log)\n  {\n    fprintf (log, \"check_nonce_nc: enter\\n\");\n    fprintf (log, \"  connection=%p daemon=%p noncelen=%zu MAX_DIGEST_NONCE_LENGTH=%d nc=%llu\\n\",\n             (void *) connection, (void *) daemon, noncelen, (int) MAX_DIGEST_NONCE_LENGTH, (unsigned long long) nc);\n  }\n\n  if (MAX_DIGEST_NONCE_LENGTH < noncelen)\n  {\n    /* preserve original behavior but ensure we close the log before returning */\n    ret = MHD_CHECK_NONCENC_WRONG; /* This should be impossible, but static analysis\n                      tools have a hard time with it *and* this also\n                      protects against unsafe modifications that may\n                      happen in the future... */\n    if (log)\n    {\n      fprintf (log, \"  early-return: noncelen too large (noncelen=%zu > MAX_DIGEST_NONCE_LENGTH=%d)\\n\",\n               noncelen, (int) MAX_DIGEST_NONCE_LENGTH);\n      fprintf (log, \"check_nonce_nc: exit ret=%d\\n\", (int) ret);\n      fclose (log);\n    }\n    return ret;\n  }\n\n  mod = daemon->nonce_nc_size;\n  if (log)\n    fprintf (log, \"  mod=%u\\n\", mod);\n\n  if (0 == mod)\n  {\n    ret = MHD_CHECK_NONCENC_STALE;  /* no array! */\n    if (log)\n    {\n      fprintf (log, \"  early-return: mod == 0 -> STALE\\n\");\n      fprintf (log, \"check_nonce_nc: exit ret=%d\\n\", (int) ret);\n      fclose (log);\n    }\n    return ret;\n  }\n  if (nc >= UINT32_MAX - 64)\n  {\n    ret = MHD_CHECK_NONCENC_STALE;  /* Overflow, unrealistically high value */\n    if (log)\n    {\n      fprintf (log, \"  early-return: nc too large (nc=%llu) -> STALE\\n\", (unsigned long long) nc);\n      fprintf (log, \"check_nonce_nc: exit ret=%d\\n\", (int) ret);\n      fclose (log);\n    }\n    return ret;\n  }\n\n  /* compute index and pointer to slot */\n  {\n    uint32_t idx = get_nonce_nc_idx (mod, nonce, noncelen);\n    nn = &daemon->nnc[idx];\n    if (log)\n    {\n      fprintf (log, \"  computed idx=%u nn=%p &nn->nonce[0]=%p &nn->nonce[noncelen]=%p\\n\",\n               idx, (void *) nn, (void *) &nn->nonce[0], (void *) &nn->nonce[noncelen]);\n      /* Log the first byte from the slot (safe) but avoid dereferencing arbitrary index */\n      fprintf (log, \"  nn->nonce[0]=%u (as unsigned)\\n\", (unsigned) (unsigned char) nn->nonce[0]);\n    }\n  }\n\n  MHD_mutex_lock_chk_ (&daemon->nnc_lock);\n\n  if (log)\n    fprintf (log, \"  acquired nnc_lock\\n\");\n\n  mhd_assert (0 == nn->nonce[noncelen]); /* The old value must be valid */\n\n  if (log)\n    fprintf (log, \"  after assert: memcmp check about to run (noncelen=%zu)\\n\", noncelen);\n\n  if ( (0 != memcmp (nn->nonce, nonce, noncelen)) ||\n       (0 != nn->nonce[noncelen]) )\n  { /* The nonce in the slot does not match nonce from the client */\n    if (log)\n      fprintf (log, \"  branch: slot nonce != client nonce or terminator mismatch\\n\");\n\n    if (0 == nn->nonce[0])\n    { /* The slot was never used, while the client's nonce value should be\n       * recorded when it was generated by MHD */\n      ret = MHD_CHECK_NONCENC_WRONG;\n      if (log)\n        fprintf (log, \"    slot unused -> WRONG\\n\");\n    }\n    else if (0 != nn->nonce[noncelen])\n    { /* The value is the slot is wrong */\n      ret =  MHD_CHECK_NONCENC_STALE;\n      if (log)\n        fprintf (log, \"    terminator mismatch -> STALE\\n\");\n    }\n    else\n    {\n      uint64_t slot_ts; /**< The timestamp in the slot */\n      if (! get_nonce_timestamp (nn->nonce, noncelen, &slot_ts))\n      {\n        mhd_assert (0); /* The value is the slot is wrong */\n        ret = MHD_CHECK_NONCENC_STALE;\n        if (log)\n          fprintf (log, \"    get_nonce_timestamp failed -> STALE\\n\");\n      }\n      else\n      {\n        /* Unsigned value, will be large if nonce_time is less than slot_ts */\n        const uint64_t ts_diff = TRIM_TO_TIMESTAMP (nonce_time - slot_ts);\n        if (log)\n          fprintf (log, \"    slot_ts=%llu nonce_time=%llu ts_diff=%llu\\n\",\n                   (unsigned long long) slot_ts, (unsigned long long) nonce_time,\n                   (unsigned long long) ts_diff);\n        if ((REUSE_TIMEOUT * 1000) >= ts_diff)\n        {\n          /* The nonce from the client may not have been placed in the slot\n           * because another nonce in that slot has not yet expired. */\n          ret = MHD_CHECK_NONCENC_STALE;\n          if (log)\n            fprintf (log, \"    ts_diff <= REUSE_TIMEOUT -> STALE\\n\");\n        }\n        else if (TRIM_TO_TIMESTAMP (UINT64_MAX) / 2 >= ts_diff)\n        {\n          /* Too large value means that nonce_time is less than slot_ts.\n           * The nonce from the client may have been overwritten by the newer\n           * nonce. */\n          ret = MHD_CHECK_NONCENC_STALE;\n          if (log)\n            fprintf (log, \"    ts_diff large -> STALE\\n\");\n        }\n        else\n        {\n          /* The nonce from the client should be generated after the nonce\n           * in the slot has been expired, the nonce must be recorded, but\n           * it's not. */\n          ret = MHD_CHECK_NONCENC_WRONG;\n          if (log)\n            fprintf (log, \"    nonce should have been recorded -> WRONG\\n\");\n        }\n      }\n    }\n  }\n  else if (nc > nn->nc)\n  {\n    /* 'nc' is larger, shift bitmask and bump limit */\n    const uint32_t jump_size = (uint32_t) nc - nn->nc;\n    if (log)\n      fprintf (log, \"  branch: nc > nn->nc (nc=%llu nn->nc=%u) jump_size=%u\\n\",\n               (unsigned long long) nc, nn->nc, jump_size);\n    if (64 > jump_size)\n    {\n      /* small jump, less than mask width */\n      nn->nmask <<= jump_size;\n      /* Set bit for the old 'nc' value */\n      nn->nmask |= (UINT64_C (1) << (jump_size - 1));\n    }\n    else if (64 == jump_size)\n      nn->nmask = (UINT64_C (1) << 63);\n    else\n      nn->nmask = 0;                /* big jump, unset all bits in the mask */\n    nn->nc = (uint32_t) nc;\n    ret = MHD_CHECK_NONCENC_OK;\n    if (log)\n      fprintf (log, \"    updated nn->nc=%u nn->nmask=%llu -> OK\\n\",\n               nn->nc, (unsigned long long) nn->nmask);\n  }\n  else if (nc < nn->nc)\n  {\n    if (log)\n      fprintf (log, \"  branch: nc < nn->nc (nc=%llu nn->nc=%u)\\n\",\n               (unsigned long long) nc, nn->nc);\n    /* Note that we use 64 here, as we do not store the\n       bit for 'nn->nc' itself in 'nn->nmask' */\n    if ( (nc + 64 >= nn->nc) &&\n         (0 == ((UINT64_C (1) << (nn->nc - nc - 1)) & nn->nmask)) )\n    {\n      /* Out-of-order nonce, but within 64-bit bitmask, set bit */\n      nn->nmask |= (UINT64_C (1) << (nn->nc - nc - 1));\n      ret = MHD_CHECK_NONCENC_OK;\n      if (log)\n        fprintf (log, \"    marked out-of-order -> OK\\n\");\n    }\n    else\n      /* 'nc' was already used or too old (more then 64 values ago) */\n      ret = MHD_CHECK_NONCENC_STALE;\n  }\n  else /* if (nc == nn->nc) */\n  {\n    /* 'nc' was already used */\n    ret = MHD_CHECK_NONCENC_STALE;\n    if (log)\n      fprintf (log, \"  branch: nc == nn->nc -> STALE\\n\");\n  }\n\n  MHD_mutex_unlock_chk_ (&daemon->nnc_lock);\n  if (log)\n    fprintf (log, \"  released nnc_lock\\n\");\n\n  if (log)\n  {\n    fprintf (log, \"check_nonce_nc: exit ret=%d\\n\", (int) ret);\n    fclose (log);\n  }\n\n  return ret;\n}\n",
  "explanation": "Removed the manual forward declarations of FILE and the stdio functions which conflicted with the system <stdio.h> prototypes. Instead the code now includes <stdio.h> so the standard declarations are used. No logic was changed; only the incorrect local declarations were removed and replaced by the proper header include to resolve the conflicting types error."
}