{
  "user_message": "<misra_rule>\nMISRA C 2023 Rule 8.13 is: A pointer should point to a const-qualified type whenever possible.\n\n</misra_rule>\n\nAnother agent reported that the target code violated the Rule 8.13.\nHere is the comment from the agent.\n<violation scenario>\nThe parameter 'line' is declared as 'char *line' but the function does not modify the characters it points to (it only reads them and advances the pointer). According to MISRA C 2023 Rule 8.13 the pointer should point to a const-qualified type whenever possible \u2014 'line' should be 'const char *line'. The 'suffix' parameter is acceptable as 'char **' because the function stores a newly allocated (modifiable) char * into *suffix.\n</violation scenario>\n\nYour job is to insert logging code to capture the control flow and state information of the program.\nInsert logging code so that other agents can reproduce and get evidence for the violation scenario.\n<response format>\n- test_code: a modified try_match_header code that contains useful probe functions that print useful logs to a file \"/tmp/logs/2383.txt\". The logs should contain the control path and state information of the violation scenario. If test code is not required to validate the scenario, you can leave this blank.\nHere are the constraints for the test code:\n- The test code MUST preserve the original logic of try_match_header as much as possible.\nYou CAN just insert probe functions to the original code.\n- DO NOT introduce new violations to demonstrate your scenario.\n- The test code MUST be compilable and executable.\n- The test code MUST include line breaks.\n- You MUST NOT define the main function.\n- You MUST NOT define macros.\n</response format>\n<target_code>\nHere is the code of try_match_header:\n```c\nstatic int\ntry_match_header (const char *prefix,\n                  size_t prefix_len,\n                  char *line,\n                  char **suffix)\n{\n  if (NULL != *suffix)\n    return MHD_NO;\n  while (0 != *line)\n  {\n    if (MHD_str_equal_caseless_n_ (prefix,\n                                   line,\n                                   prefix_len))\n    {\n      *suffix = strdup (&line[prefix_len]);\n      return MHD_YES;\n    }\n    ++line;\n  }\n  return MHD_NO;\n}\n```\n</target_code>\nPlease provide the modified try_match_header code.\n",
  "test_code": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <stddef.h>\n\n/*\n * Probe logger helpers. These intentionally do not change the logic\n * of try_match_header; they only observe state and write logs so that\n * the control flow and the fact that 'line' is only read (not modified)\n * can be reproduced.\n */\nstatic FILE *open_log_file(void)\n{\n    FILE *f = fopen(\"/tmp/logs/2383.txt\", \"a\");\n    if (f == NULL)\n    {\n        /* Fallback if directory /tmp/logs does not exist. */\n        f = fopen(\"/tmp/2383_2383.txt\", \"a\");\n    }\n    return f;\n}\n\nstatic void log_state(const char *stage,\n                      const char *prefix,\n                      size_t prefix_len,\n                      const char *start,\n                      const char *cur,\n                      size_t idx,\n                      unsigned int cur_ch,\n                      char **suffix,\n                      const char *note)\n{\n    FILE *f = open_log_file();\n    if (f == NULL)\n    {\n        return;\n    }\n\n    /* Print a compact record: stage, prefix (length limited), pointers, index, current char as integer, suffix pointer, note */\n    fprintf(f,\n            \"[%s] prefix_len=%zu prefix='%.*s' prefix_ptr=%p start=%p cur=%p idx=%zu cur_ch=%u *suffix=%p note=%s\\n\",\n            stage,\n            prefix_len,\n            (int)prefix_len, prefix ? prefix : \"\",\n            (const void *)prefix,\n            (const void *)start,\n            (const void *)cur,\n            idx,\n            cur_ch,\n            (const void *)(suffix ? *suffix : NULL),\n            note ? note : \"(null)\");\n\n    fclose(f);\n}\n\nstatic void log_match_suffix(char **suffix)\n{\n    FILE *f = open_log_file();\n    if (f == NULL)\n    {\n        return;\n    }\n    if (suffix == NULL)\n    {\n        fprintf(f, \"[MATCH] suffix pointer argument is NULL\\n\");\n    }\n    else if (*suffix == NULL)\n    {\n        fprintf(f, \"[MATCH] suffix assigned NULL\\n\");\n    }\n    else\n    {\n        fprintf(f, \"[MATCH] suffix_ptr=%p suffix_contents='%s'\\n\",\n                (void *)*suffix,\n                *suffix);\n    }\n    fclose(f);\n}\n\n/*\n * Original function logic preserved. The only additions are logging calls\n * that record entry, each iteration, early return, successful match and\n * final no-match return. We do not modify the characters pointed to by\n * 'line' (we only read them and advance a pointer), so this produces\n * evidence for the MISRA Rule 8.13 scenario described.\n */\nstatic int\ntry_match_header (const char *prefix,\n                  size_t prefix_len,\n                  char *line,\n                  char **suffix)\n{\n  /* Entry log. Note: cast line to const char* for logging to reflect read-only use. */\n  log_state(\"ENTER\", prefix, prefix_len, (const char *)line, (const char *)line, 0U, (unsigned int)(unsigned char)line[0], suffix, \"entry\");\n\n  if (NULL != *suffix)\n  {\n    log_state(\"EARLY_RETURN\", prefix, prefix_len, (const char *)line, (const char *)line, 0U, (unsigned int)(unsigned char)line[0], suffix, \"suffix already set\");\n    return MHD_NO;\n  }\n\n  /* Use a local pointer 'p' so we do not modify the original pointer variable 'line' that was passed in. */\n  const char *start = (const char *)line;\n  char *p = line;\n  size_t idx = 0U;\n\n  while (0 != *p)\n  {\n    /* Log current iteration state: pointer, index and current character. */\n    log_state(\"ITER\", prefix, prefix_len, start, (const char *)p, idx, (unsigned int)(unsigned char)*p, suffix, \"loop iteration\");\n\n    if (MHD_str_equal_caseless_n_ (prefix,\n                                   p,\n                                   prefix_len))\n    {\n      /* Found a match: duplicate the suffix. Preserve original behavior. */\n      *suffix = strdup (&p[prefix_len]);\n\n      /* Log the result after assignment so we capture the allocated pointer and its contents. */\n      log_match_suffix(suffix);\n\n      return MHD_YES;\n    }\n    ++p;\n    ++idx;\n  }\n\n  log_state(\"NO_MATCH\", prefix, prefix_len, start, (const char *)p, idx, 0U, suffix, \"end of line reached\");\n  return MHD_NO;\n}\n"
}