{
  "user_message": "<misra_rule>\nMISRA C 2023 Rule 8.13 is: A pointer should point to a const-qualified type whenever possible.\n\n</misra_rule>\n\nAnother agent reported that the target code violated the Rule 8.13.\nHere is the comment from the agent.\n<violation scenario>\nThe call passes string-style pointers (\"TCP_NODELAY\", the result of the translation macro _(\"ON\")/_(\"OFF\"), and MHD_socket_strerr_(err_code)). If the translation macro _ and/or MHD_socket_strerr_ return non-const char * (or if MHD_DLOG expects non-const char * parameters), this uses pointers to non-const-qualified characters where const qualification is possible. That violates MISRA C 2023 Rule 8.13\u2014string/format arguments should be const char * (or the called functions should be declared to take const char *).\n</violation scenario>\n\nYour job is to insert logging code to capture the control flow and state information of the program.\nInsert logging code so that other agents can reproduce and get evidence for the violation scenario.\n<response format>\n- test_code: a modified MHD_connection_set_nodelay_state_ code that contains useful probe functions that print useful logs to a file \"/tmp/logs/1743.txt\". The logs should contain the control path and state information of the violation scenario. If test code is not required to validate the scenario, you can leave this blank.\nHere are the constraints for the test code:\n- The test code MUST preserve the original logic of MHD_connection_set_nodelay_state_ as much as possible.\nYou CAN just insert probe functions to the original code.\n- DO NOT introduce new violations to demonstrate your scenario.\n- The test code MUST be compilable and executable.\n- The test code MUST include line breaks.\n- You MUST NOT define the main function.\n- You MUST NOT define macros.\n</response format>\n<target_code>\nHere is the code of MHD_connection_set_nodelay_state_:\n```c\nbool\nMHD_connection_set_nodelay_state_ (struct MHD_Connection *connection,\n                                   bool nodelay_state)\n{\n#ifdef TCP_NODELAY\n  const MHD_SCKT_OPT_BOOL_ off_val = 0;\n  const MHD_SCKT_OPT_BOOL_ on_val = 1;\n  int err_code;\n\n  if (_MHD_YES == connection->is_nonip)\n    return false;\n\n  if (0 == setsockopt (connection->socket_fd,\n                       IPPROTO_TCP,\n                       TCP_NODELAY,\n                       (const void *) (nodelay_state ? &on_val : &off_val),\n                       sizeof (off_val)))\n  {\n    connection->sk_nodelay = nodelay_state;\n    return true;\n  }\n\n  err_code = MHD_socket_get_error_ ();\n  if (MHD_SCKT_ERR_IS_ (err_code, MHD_SCKT_EINVAL_) ||\n      MHD_SCKT_ERR_IS_ (err_code, MHD_SCKT_ENOPROTOOPT_) ||\n      MHD_SCKT_ERR_IS_ (err_code, MHD_SCKT_ENOTSOCK_))\n  {\n    if (_MHD_UNKNOWN == connection->is_nonip)\n      connection->is_nonip = _MHD_YES;\n#ifdef HAVE_MESSAGES\n    else\n    {\n      MHD_DLOG (connection->daemon,\n                _ (\"Setting %s option to %s state failed \"\n                   \"for TCP/IP socket %d: %s\\n\"),\n                \"TCP_NODELAY\",\n                nodelay_state ? _ (\"ON\") : _ (\"OFF\"),\n                (int) connection->socket_fd,\n                MHD_socket_strerr_ (err_code));\n    }\n#endif /* HAVE_MESSAGES */\n  }\n#ifdef HAVE_MESSAGES\n  else\n  {\n    MHD_DLOG (connection->daemon,\n              _ (\"Setting %s option to %s state failed: %s\\n\"),\n              \"TCP_NODELAY\",\n              nodelay_state ? _ (\"ON\") : _ (\"OFF\"),\n              MHD_socket_strerr_ (err_code));\n  }\n#endif /* HAVE_MESSAGES */\n\n#else  /* ! TCP_NODELAY */\n  (void) connection; (void) nodelay_state; /* Mute compiler warnings */\n#endif /* ! TCP_NODELAY */\n  return false;\n}\n```\n</target_code>\nPlease provide the modified MHD_connection_set_nodelay_state_ code.\n",
  "test_code": "#include <stdio.h>\n#include <stdbool.h>\n#include <sys/stat.h>\n#include <errno.h>\n\n/* Probe: append human-readable trace to /tmp/logs/1743.txt. */\nstatic void\nmhd_probe_log (const char *tag,\n               int is_nonip,\n               int socket_fd,\n               bool nodelay_state,\n               int err_code,\n               const void *setsockopt_val_ptr,\n               const void *tcp_str_ptr,\n               const void *onoff_str_ptr,\n               const void *sockstrr_ptr)\n{\n  /* Ensure directory exists; ignore error if it already does. */\n  (void) mkdir(\"/tmp/logs\", 0777); /* best-effort, ignore return value */\n\n  {\n    FILE *f = fopen(\"/tmp/logs/1743.txt\", \"a\");\n    if (f != NULL)\n    {\n      fprintf (f, \"[%s] connection->is_nonip=%d socket_fd=%d nodelay_state=%d err_code=%d\\n\",\n               tag, is_nonip, socket_fd, nodelay_state ? 1 : 0, err_code);\n      fprintf (f, \"[%s] setsockopt_val_ptr=%p tcp_str_ptr=%p onoff_str_ptr=%p sockstrr_ptr=%p\\n\",\n               tag, setsockopt_val_ptr, tcp_str_ptr, onoff_str_ptr, sockstrr_ptr);\n\n      /* Optionally also log small snippets of the strings if pointers are non-NULL. */\n      if (tcp_str_ptr != NULL)\n        fprintf (f, \"[%s] tcp_str begins: '%s'\\n\", tag, (const char *) tcp_str_ptr);\n      if (onoff_str_ptr != NULL)\n        fprintf (f, \"[%s] onoff_str begins: '%s'\\n\", tag, (const char *) onoff_str_ptr);\n      if (sockstrr_ptr != NULL)\n        fprintf (f, \"[%s] socket_strerr begins: '%s'\\n\", tag, (const char *) sockstrr_ptr);\n\n      fclose (f);\n    }\n  }\n}\n\nbool\nMHD_connection_set_nodelay_state_ (struct MHD_Connection *connection,\n                                   bool nodelay_state)\n{\n#ifdef TCP_NODELAY\n  const MHD_SCKT_OPT_BOOL_ off_val = 0;\n  const MHD_SCKT_OPT_BOOL_ on_val = 1;\n  int err_code;\n\n  /* Log entry and initial state */\n  mhd_probe_log (\"ENTRY\",\n                 (int) connection->is_nonip,\n                 (int) connection->socket_fd,\n                 nodelay_state,\n                 0,\n                 NULL,\n                 \"TCP_NODELAY\",\n                 nodelay_state ? (const void *) _ (\"ON\") : (const void *) _ (\"OFF\"),\n                 NULL);\n\n  if (_MHD_YES == connection->is_nonip)\n    return false;\n\n  /* Log chosen setsockopt value pointer */\n  mhd_probe_log (\"BEFORE_SETSOCKOPT\",\n                 (int) connection->is_nonip,\n                 (int) connection->socket_fd,\n                 nodelay_state,\n                 0,\n                 (const void *) (nodelay_state ? &on_val : &off_val),\n                 \"TCP_NODELAY\",\n                 nodelay_state ? (const void *) _ (\"ON\") : (const void *) _ (\"OFF\"),\n                 NULL);\n\n  if (0 == setsockopt (connection->socket_fd,\n                       IPPROTO_TCP,\n                       TCP_NODELAY,\n                       (const void *) (nodelay_state ? &on_val : &off_val),\n                       sizeof (off_val)))\n  {\n    connection->sk_nodelay = nodelay_state;\n\n    /* Log success */\n    mhd_probe_log (\"SETSOCKOPT_OK\",\n                   (int) connection->is_nonip,\n                   (int) connection->socket_fd,\n                   nodelay_state,\n                   0,\n                   (const void *) (nodelay_state ? &on_val : &off_val),\n                   \"TCP_NODELAY\",\n                   nodelay_state ? (const void *) _ (\"ON\") : (const void *) _ (\"OFF\"),\n                   NULL);\n\n    return true;\n  }\n\n  err_code = MHD_socket_get_error_ ();\n\n  /* Retrieve socket error string (probe, do not alter behavior). */\n  const char *probe_sockerr = MHD_socket_strerr_ (err_code);\n\n  if (MHD_SCKT_ERR_IS_ (err_code, MHD_SCKT_EINVAL_) ||\n      MHD_SCKT_ERR_IS_ (err_code, MHD_SCKT_ENOPROTOOPT_) ||\n      MHD_SCKT_ERR_IS_ (err_code, MHD_SCKT_ENOTSOCK_))\n  {\n    if (_MHD_UNKNOWN == connection->is_nonip)\n      connection->is_nonip = _MHD_YES;\n#ifdef HAVE_MESSAGES\n    else\n    {\n      /* Probe logging immediately before diagnostic log that may use non-const strings */\n      mhd_probe_log (\"ERR_BRANCH_SPECIFIC\",\n                     (int) connection->is_nonip,\n                     (int) connection->socket_fd,\n                     nodelay_state,\n                     err_code,\n                     (const void *) (nodelay_state ? &on_val : &off_val),\n                     \"TCP_NODELAY\",\n                     nodelay_state ? (const void *) _ (\"ON\") : (const void *) _ (\"OFF\"),\n                     (const void *) probe_sockerr);\n\n      MHD_DLOG (connection->daemon,\n                _ (\"Setting %s option to %s state failed \"\n                   \"for TCP/IP socket %d: %s\\n\"),\n                \"TCP_NODELAY\",\n                nodelay_state ? _ (\"ON\") : _ (\"OFF\"),\n                (int) connection->socket_fd,\n                MHD_socket_strerr_ (err_code));\n    }\n#endif /* HAVE_MESSAGES */\n  }\n#ifdef HAVE_MESSAGES\n  else\n  {\n    /* Probe logging for general error branch */\n    mhd_probe_log (\"ERR_BRANCH_GENERAL\",\n                   (int) connection->is_nonip,\n                   (int) connection->socket_fd,\n                   nodelay_state,\n                   err_code,\n                   (const void *) (nodelay_state ? &on_val : &off_val),\n                   \"TCP_NODELAY\",\n                   nodelay_state ? (const void *) _ (\"ON\") : (const void *) _ (\"OFF\"),\n                   (const void *) probe_sockerr);\n\n    MHD_DLOG (connection->daemon,\n              _ (\"Setting %s option to %s state failed: %s\\n\"),\n              \"TCP_NODELAY\",\n              nodelay_state ? _ (\"ON\") : _ (\"OFF\"),\n              MHD_socket_strerr_ (err_code));\n  }\n#endif /* HAVE_MESSAGES */\n\n#else  /* ! TCP_NODELAY */\n  (void) connection; (void) nodelay_state; /* Mute compiler warnings */\n#endif /* ! TCP_NODELAY */\n  return false;\n}\n"
}