{
  "user_message": "<misra_rule>\nMISRA C 2023 Rule 21.17 is: Use of the string handling functions from <string.h> shall not result in accesses beyond the bounds of the objects referenced by their pointer parameters.\nThis rule strictly applies to the Standard Library functions in <string.h> such as memcpy, memmove, memset, memcmp, strcpy, strncpy, strcat, strncat, strlen, and strspn.\n</misra_rule>\n<response format>\nProvide your answer with these fields.\n- is_rule_violated: whether the rule is violated or not (true/false),\n- scenario: a specific violation scenario.\n</response format>\n<target_code>\nHere is the code of parse_http_version:\n```c\nstatic bool\nparse_http_version (struct MHD_Connection *connection,\n                    const char *http_string,\n                    size_t len)\n{\n  const char *const h = http_string; /**< short alias */\n  mhd_assert (NULL != http_string);\n\n  /* String must start with 'HTTP/d.d', case-sensetive match.\n   * See https://www.rfc-editor.org/rfc/rfc9112#name-http-version */\n  if ((HTTP_VER_LEN != len) ||\n      ('H' != h[0]) || ('T' != h[1]) || ('T' != h[2]) || ('P' != h[3]) ||\n      ('/' != h[4])\n      || ('.' != h[6]) ||\n      (('0' > h[5]) || ('9' < h[5])) ||\n      (('0' > h[7]) || ('9' < h[7])))\n  {\n    connection->rq.http_ver = MHD_HTTP_VER_INVALID;\n    transmit_error_response_static (connection,\n                                    MHD_HTTP_BAD_REQUEST,\n                                    REQUEST_MALFORMED);\n    return false;\n  }\n  if (1 == h[5] - '0')\n  {\n    /* HTTP/1.x */\n    if (1 == h[7] - '0')\n      connection->rq.http_ver = MHD_HTTP_VER_1_1;\n    else if (0 == h[7] - '0')\n      connection->rq.http_ver = MHD_HTTP_VER_1_0;\n    else\n      connection->rq.http_ver = MHD_HTTP_VER_1_2__1_9;\n\n    return true;\n  }\n\n  if (0 == h[5] - '0')\n  {\n    /* Too old major version */\n    connection->rq.http_ver = MHD_HTTP_VER_TOO_OLD;\n    transmit_error_response_static (connection,\n                                    MHD_HTTP_HTTP_VERSION_NOT_SUPPORTED,\n                                    REQ_HTTP_VER_IS_TOO_OLD);\n    return false;\n  }\n\n  connection->rq.http_ver = MHD_HTTP_VER_FUTURE;\n  transmit_error_response_static (connection,\n                                  MHD_HTTP_HTTP_VERSION_NOT_SUPPORTED,\n                                  REQ_HTTP_VER_IS_NOT_SUPPORTED);\n  return false;\n}\n```\n</target_code>\n<target_code>\nHere is the code fragment that you need to analyze:\n```c\nif ((HTTP_VER_LEN != len) ||\n      ('H' != h[0]) || ('T' != h[1]) || ('T' != h[2]) || ('P' != h[3]) ||\n      ('/' != h[4])\n      || ('.' != h[6]) ||\n      (('0' > h[5]) || ('9' < h[5])) ||\n      (('0' > h[7]) || ('9' < h[7])))\n```\nFocus on the above code fragment and judge whether it violates the rule 21.17 or not.\n</target_code>\n",
  "is_rule_violated": false,
  "scenario": "Not violated: the code first checks (HTTP_VER_LEN != len) as the initial operand of the || expression. Because || evaluates left-to-right with short\u2011circuiting, the h[0]..h[7] indexing expressions are only evaluated when len == HTTP_VER_LEN. Assuming HTTP_VER_LEN is the expected length (8) and the caller-supplied len accurately reflects the size of the object pointed to by http_string, the byte accesses are within bounds. (Note: if len does not actually represent the buffer size or HTTP_VER_LEN is incorrect, an out\u2011of\u2011bounds access could occur \u2014 that would be a caller/contract error, not a direct violation of this rule in this fragment.)"
}