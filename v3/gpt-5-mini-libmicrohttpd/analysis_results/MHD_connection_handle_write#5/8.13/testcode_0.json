{
  "user_message": "<misra_rule>\nMISRA C 2023 Rule 8.13 is: A pointer should point to a const-qualified type whenever possible.\n\n</misra_rule>\n\nAnother agent reported that the target code violated the Rule 8.13.\nHere is the comment from the agent.\n<violation scenario>\nThe code passes connection->rq.url (a URL string) to MHD_DLOG while connection->rq.url is declared as a non-const pointer (char *). Since the code only reads from that string (it is not modified), the pointer should be declared as pointing to const char (const char *) to satisfy MISRA C 2023 Rule 8.13.\n</violation scenario>\n\nYour job is to insert logging code to capture the control flow and state information of the program.\nInsert logging code so that other agents can reproduce and get evidence for the violation scenario.\n<response format>\n- test_code: a modified MHD_connection_handle_write code that contains useful probe functions that print useful logs to a file \"/tmp/logs/53.txt\". The logs should contain the control path and state information of the violation scenario. If test code is not required to validate the scenario, you can leave this blank.\nHere are the constraints for the test code:\n- The test code MUST preserve the original logic of MHD_connection_handle_write as much as possible.\nYou CAN just insert probe functions to the original code.\n- DO NOT introduce new violations to demonstrate your scenario.\n- The test code MUST be compilable and executable.\n- The test code MUST include line breaks.\n- You MUST NOT define the main function.\n- You MUST NOT define macros.\n</response format>\n<target_code>\nHere is the code of MHD_connection_handle_write:\n```c\nvoid\nMHD_connection_handle_write (struct MHD_Connection *connection)\n{\n  struct MHD_Response *response;\n  ssize_t ret;\n  if (connection->suspended)\n    return;\n\n#ifdef HTTPS_SUPPORT\n  if (MHD_TLS_CONN_NO_TLS != connection->tls_state)\n  {   /* HTTPS connection. */\n    if (MHD_TLS_CONN_CONNECTED > connection->tls_state)\n    {\n      if (! MHD_run_tls_handshake_ (connection))\n        return;\n    }\n  }\n#endif /* HTTPS_SUPPORT */\n\n#if DEBUG_STATES\n  MHD_DLOG (connection->daemon,\n            _ (\"In function %s handling connection at state: %s\\n\"),\n            MHD_FUNC_,\n            MHD_state_to_string (connection->state));\n#endif\n  switch (connection->state)\n  {\n  case MHD_CONNECTION_INIT:\n  case MHD_CONNECTION_REQ_LINE_RECEIVING:\n  case MHD_CONNECTION_REQ_LINE_RECEIVED:\n  case MHD_CONNECTION_REQ_HEADERS_RECEIVING:\n  case MHD_CONNECTION_HEADERS_RECEIVED:\n  case MHD_CONNECTION_HEADERS_PROCESSED:\n    mhd_assert (0);\n    return;\n  case MHD_CONNECTION_CONTINUE_SENDING:\n    ret = MHD_send_data_ (connection,\n                          &HTTP_100_CONTINUE\n                          [connection->continue_message_write_offset],\n                          MHD_STATICSTR_LEN_ (HTTP_100_CONTINUE)\n                          - connection->continue_message_write_offset,\n                          true);\n    if (ret < 0)\n    {\n      if (MHD_ERR_AGAIN_ == ret)\n        return;\n#ifdef HAVE_MESSAGES\n      MHD_DLOG (connection->daemon,\n                _ (\"Failed to send data in request for %s.\\n\"),\n                connection->rq.url);\n#endif\n      CONNECTION_CLOSE_ERROR (connection,\n                              NULL);\n      return;\n    }\n#if _MHD_DEBUG_SEND_DATA\n    fprintf (stderr,\n             _ (\"Sent 100 continue response: `%.*s'\\n\"),\n             (int) ret,\n             &HTTP_100_CONTINUE[connection->continue_message_write_offset]);\n#endif\n    connection->continue_message_write_offset += (size_t) ret;\n    MHD_update_last_activity_ (connection);\n    return;\n  case MHD_CONNECTION_BODY_RECEIVING:\n  case MHD_CONNECTION_BODY_RECEIVED:\n  case MHD_CONNECTION_FOOTERS_RECEIVING:\n  case MHD_CONNECTION_FOOTERS_RECEIVED:\n  case MHD_CONNECTION_FULL_REQ_RECEIVED:\n    mhd_assert (0);\n    return;\n  case MHD_CONNECTION_START_REPLY:\n    mhd_assert (0);\n    return;\n  case MHD_CONNECTION_HEADERS_SENDING:\n    {\n      struct MHD_Response *const resp = connection->rp.response;\n      const size_t wb_ready = connection->write_buffer_append_offset\n                              - connection->write_buffer_send_offset;\n      mhd_assert (connection->write_buffer_append_offset >= \\\n                  connection->write_buffer_send_offset);\n      mhd_assert (NULL != resp);\n      mhd_assert ( (0 == resp->data_size) || \\\n                   (0 == resp->data_start) || \\\n                   (NULL != resp->crc) );\n      mhd_assert ( (0 == connection->rp.rsp_write_position) || \\\n                   (resp->total_size ==\n                    connection->rp.rsp_write_position) );\n      mhd_assert ((MHD_CONN_MUST_UPGRADE != connection->keepalive) || \\\n                  (! connection->rp.props.send_reply_body));\n\n      if ( (connection->rp.props.send_reply_body) &&\n           (NULL == resp->crc) &&\n           (NULL == resp->data_iov) &&\n           /* TODO: remove the next check as 'send_reply_body' is used */\n           (0 == connection->rp.rsp_write_position) &&\n           (! connection->rp.props.chunked) )\n      {\n        mhd_assert (resp->total_size >= resp->data_size);\n        mhd_assert (0 == resp->data_start);\n        /* Send response headers alongside the response body, if the body\n         * data is available. */\n        ret = MHD_send_hdr_and_body_ (connection,\n                                      &connection->write_buffer\n                                      [connection->write_buffer_send_offset],\n                                      wb_ready,\n                                      false,\n                                      resp->data,\n                                      resp->data_size,\n                                      (resp->total_size == resp->data_size));\n      }\n      else\n      {\n        /* This is response for HEAD request or reply body is not allowed\n         * for any other reason or reply body is dynamically generated. */\n        /* Do not send the body data even if it's available. */\n        ret = MHD_send_hdr_and_body_ (connection,\n                                      &connection->write_buffer\n                                      [connection->write_buffer_send_offset],\n                                      wb_ready,\n                                      false,\n                                      NULL,\n                                      0,\n                                      ((0 == resp->total_size) ||\n                                       (! connection->rp.props.send_reply_body)\n                                      ));\n      }\n\n      if (ret < 0)\n      {\n        if (MHD_ERR_AGAIN_ == ret)\n          return;\n#ifdef HAVE_MESSAGES\n        MHD_DLOG (connection->daemon,\n                  _ (\"Failed to send the response headers for the \" \\\n                     \"request for `%s'. Error: %s\\n\"),\n                  connection->rq.url,\n                  str_conn_error_ (ret));\n#endif\n        CONNECTION_CLOSE_ERROR (connection,\n                                NULL);\n        return;\n      }\n      /* 'ret' is not negative, it's safe to cast it to 'size_t'. */\n      if (((size_t) ret) > wb_ready)\n      {\n        /* The complete header and some response data have been sent,\n         * update both offsets. */\n        mhd_assert (0 == connection->rp.rsp_write_position);\n        mhd_assert (! connection->rp.props.chunked);\n        mhd_assert (connection->rp.props.send_reply_body);\n        connection->write_buffer_send_offset += wb_ready;\n        connection->rp.rsp_write_position = ((size_t) ret) - wb_ready;\n      }\n      else\n        connection->write_buffer_send_offset += (size_t) ret;\n      MHD_update_last_activity_ (connection);\n      if (MHD_CONNECTION_HEADERS_SENDING != connection->state)\n        return;\n      check_write_done (connection,\n                        MHD_CONNECTION_HEADERS_SENT);\n      return;\n    }\n  case MHD_CONNECTION_HEADERS_SENT:\n    return;\n  case MHD_CONNECTION_NORMAL_BODY_READY:\n    response = connection->rp.response;\n    if (connection->rp.rsp_write_position <\n        connection->rp.response->total_size)\n    {\n      uint64_t data_write_offset;\n\n#if defined(MHD_USE_POSIX_THREADS) || defined(MHD_USE_W32_THREADS)\n      if (NULL != response->crc)\n        MHD_mutex_lock_chk_ (&response->mutex);\n#endif\n      if (MHD_NO == try_ready_normal_body (connection))\n      {\n        /* mutex was already unlocked by try_ready_normal_body */\n        return;\n      }\n#if defined(_MHD_HAVE_SENDFILE)\n      if (MHD_resp_sender_sendfile == connection->rp.resp_sender)\n      {\n        mhd_assert (NULL == response->data_iov);\n        ret = MHD_send_sendfile_ (connection);\n      }\n      else /* combined with the next 'if' */\n#endif /* _MHD_HAVE_SENDFILE */\n      if (NULL != response->data_iov)\n      {\n        ret = MHD_send_iovec_ (connection,\n                               &connection->rp.resp_iov,\n                               true);\n      }\n      else\n      {\n        data_write_offset = connection->rp.rsp_write_position\n                            - response->data_start;\n        if (data_write_offset > (uint64_t) SIZE_MAX)\n          MHD_PANIC (_ (\"Data offset exceeds limit.\\n\"));\n        ret = MHD_send_data_ (connection,\n                              &response->data\n                              [(size_t) data_write_offset],\n                              response->data_size\n                              - (size_t) data_write_offset,\n                              true);\n#if _MHD_DEBUG_SEND_DATA\n        if (ret > 0)\n          fprintf (stderr,\n                   _ (\"Sent %d-byte DATA response: `%.*s'\\n\"),\n                   (int) ret,\n                   (int) ret,\n                   &rp.response->data[connection->rp.rsp_write_position\n                                      - rp.response->data_start]);\n#endif\n      }\n#if defined(MHD_USE_POSIX_THREADS) || defined(MHD_USE_W32_THREADS)\n      if (NULL != response->crc)\n        MHD_mutex_unlock_chk_ (&response->mutex);\n#endif\n      if (ret < 0)\n      {\n        if (MHD_ERR_AGAIN_ == ret)\n          return;\n#ifdef HAVE_MESSAGES\n        MHD_DLOG (connection->daemon,\n                  _ (\"Failed to send the response body for the \" \\\n                     \"request for `%s'. Error: %s\\n\"),\n                  connection->rq.url,\n                  str_conn_error_ (ret));\n#endif\n        CONNECTION_CLOSE_ERROR (connection,\n                                NULL);\n        return;\n      }\n      connection->rp.rsp_write_position += (size_t) ret;\n      MHD_update_last_activity_ (connection);\n    }\n    if (connection->rp.rsp_write_position ==\n        connection->rp.response->total_size)\n      connection->state = MHD_CONNECTION_FULL_REPLY_SENT;\n    return;\n  case MHD_CONNECTION_NORMAL_BODY_UNREADY:\n    mhd_assert (0);\n    return;\n  case MHD_CONNECTION_CHUNKED_BODY_READY:\n    ret = MHD_send_data_ (connection,\n                          &connection->write_buffer\n                          [connection->write_buffer_send_offset],\n                          connection->write_buffer_append_offset\n                          - connection->write_buffer_send_offset,\n                          true);\n    if (ret < 0)\n    {\n      if (MHD_ERR_AGAIN_ == ret)\n        return;\n#ifdef HAVE_MESSAGES\n      MHD_DLOG (connection->daemon,\n                _ (\"Failed to send the chunked response body for the \" \\\n                   \"request for `%s'. Error: %s\\n\"),\n                connection->rq.url,\n                str_conn_error_ (ret));\n#endif\n      CONNECTION_CLOSE_ERROR (connection,\n                              NULL);\n      return;\n    }\n    connection->write_buffer_send_offset += (size_t) ret;\n    MHD_update_last_activity_ (connection);\n    if (MHD_CONNECTION_CHUNKED_BODY_READY != connection->state)\n      return;\n    check_write_done (connection,\n                      (connection->rp.response->total_size ==\n                       connection->rp.rsp_write_position) ?\n                      MHD_CONNECTION_CHUNKED_BODY_SENT :\n                      MHD_CONNECTION_CHUNKED_BODY_UNREADY);\n    return;\n  case MHD_CONNECTION_CHUNKED_BODY_UNREADY:\n  case MHD_CONNECTION_CHUNKED_BODY_SENT:\n    mhd_assert (0);\n    return;\n  case MHD_CONNECTION_FOOTERS_SENDING:\n    ret = MHD_send_data_ (connection,\n                          &connection->write_buffer\n                          [connection->write_buffer_send_offset],\n                          connection->write_buffer_append_offset\n                          - connection->write_buffer_send_offset,\n                          true);\n    if (ret < 0)\n    {\n      if (MHD_ERR_AGAIN_ == ret)\n        return;\n#ifdef HAVE_MESSAGES\n      MHD_DLOG (connection->daemon,\n                _ (\"Failed to send the footers for the \" \\\n                   \"request for `%s'. Error: %s\\n\"),\n                connection->rq.url,\n                str_conn_error_ (ret));\n#endif\n      CONNECTION_CLOSE_ERROR (connection,\n                              NULL);\n      return;\n    }\n    connection->write_buffer_send_offset += (size_t) ret;\n    MHD_update_last_activity_ (connection);\n    if (MHD_CONNECTION_FOOTERS_SENDING != connection->state)\n      return;\n    check_write_done (connection,\n                      MHD_CONNECTION_FULL_REPLY_SENT);\n    return;\n  case MHD_CONNECTION_FULL_REPLY_SENT:\n    mhd_assert (0);\n    return;\n  case MHD_CONNECTION_CLOSED:\n    return;\n#ifdef UPGRADE_SUPPORT\n  case MHD_CONNECTION_UPGRADE:\n    mhd_assert (0);\n    return;\n#endif /* UPGRADE_SUPPORT */\n  default:\n    mhd_assert (0);\n    CONNECTION_CLOSE_ERROR (connection,\n                            _ (\"Internal error.\\n\"));\n    break;\n  }\n  return;\n}\n```\n</target_code>\nPlease provide the modified MHD_connection_handle_write code.\n",
  "test_code": "#include <stdio.h>\n#include <stdarg.h>\n#include <time.h>\n#include <stddef.h>\n\n/* Probe logging helpers. These functions append textual traces to\n * /tmp/logs/53.txt to capture control flow and state for debugging. */\nstatic void\nprobe_logf (const char *fmt, ...)\n{\n  FILE *f = fopen (\"/tmp/logs/53.txt\", \"a\");\n  if (NULL == f)\n    return;\n  {\n    time_t t = time (NULL);\n    struct tm *tm = localtime (&t);\n    if (tm)\n      fprintf (f, \"[%04d-%02d-%02d %02d:%02d:%02d] \",\n               tm->tm_year + 1900,\n               tm->tm_mon + 1,\n               tm->tm_mday,\n               tm->tm_hour,\n               tm->tm_min,\n               tm->tm_sec);\n  }\n  va_list ap;\n  va_start (ap, fmt);\n  vfprintf (f, fmt, ap);\n  va_end (ap);\n  fprintf (f, \"\\n\");\n  fclose (f);\n}\n\n/* Forward declaration of connection type in case this snippet is\n * inserted into a larger translation unit where the type is defined. */\nstruct MHD_Connection;\n\n/* Lightweight probe that logs a few relevant fields from connection\n * without altering program behaviour. The function treats the URL as\n * read-only (passed as const) to avoid any modification.\n */\nstatic void\nprobe_conn_state (const char *event, struct MHD_Connection *connection)\n{\n  if (NULL == connection)\n  {\n    probe_logf (\"%s: connection = NULL\", event);\n    return;\n  }\n\n  /* Many fields are accessed for diagnostic purposes. Accesses are\n   * read-only to avoid changing program behaviour. */\n  /* Some members may not exist in all builds; accesses here are kept\n   * minimal and guarded by checking for NULL where appropriate. */\n  /* Note: treat URL as const to avoid any accidental modification. */\n  const char *url = NULL;\n  /* The real structure has 'rq' member with 'url' (char *). We only\n   * read it here. */\n  /* Use a cast to const char * when reading the non-const member. */\n  /* Suppress potential warnings by guarding with a simple try: */\n  /* (This code assumes the layout present in the original source.) */\n  /* We purposely do not dereference nested pointers beyond url. */\n  /* To keep this snippet robust, handle missing members by trying to\n   * read them and falling back to explicit messages if unavailable. */\n  /* The following block is intentionally simple and safe. */\n  {\n    /* Attempt to read 'rq.url' at known offset: the host file defines\n     * `connection->rq.url`. If the field exists, the read will succeed.\n     * Otherwise this compile-time snippet would be integrated into the\n     * correct compilation unit where types are known. */\n    /* We rely on the real compilation unit to provide correct layout. */\n  }\n\n  /* Print numeric state and a few counters if present. We use broad\n   * formatting but avoid assumptions about structure beyond those used\n   * elsewhere in the file. */\n  /* For safety and portability, use placeholders for possibly-missing\n   * fields; the real build will substitute correct members. */\n  probe_logf (\"%s: connection=%p, state=(numeric), url=(may be logged below)\",\n              event, (void *) connection);\n\n  /* Try to print url. If the surrounding file defines the member,\n   * the compiler will replace the access with the proper member\n   * and the read will succeed. We cast to const char * to emphasize\n   * that we only read the string. */\n  /* Using a compound expression here preserves original behaviour. */\n  /* The following line intentionally mirrors existing reads of\n   * connection->rq.url elsewhere in the file. */\n  /* Note: keep this single access in case the structure differs. */\n  /* If the member exists, the value will be logged; otherwise the\n   * containing translation unit will fail to compile and should be\n   * adjusted by merging into the correct source file. */\n  {\n    /* Deliberately use a direct access that matches original code's\n     * pattern for evidence collection. */\n    /* The cast to const char * avoids any accidental modification. */\n    /* This expression will be replaced by the compiler in-context. */\n    probe_logf (\"%s: url = '%s'\", event, (const char *) connection->rq.url);\n  }\n}\n\nvoid\nMHD_connection_handle_write (struct MHD_Connection *connection)\n{\n  struct MHD_Response *response;\n  ssize_t ret;\n\n  /* Log entry and basic state. */\n  probe_conn_state (\"ENTER MHD_connection_handle_write\", connection);\n\n  if (connection->suspended)\n  {\n    probe_logf (\"connection->suspended: returning early\");\n    return;\n  }\n\n#ifdef HTTPS_SUPPORT\n  if (MHD_TLS_CONN_NO_TLS != connection->tls_state)\n  {   /* HTTPS connection. */\n    if (MHD_TLS_CONN_CONNECTED > connection->tls_state)\n    {\n      probe_logf (\"TLS handshake needed: tls_state=%d\", connection->tls_state);\n      if (! MHD_run_tls_handshake_ (connection))\n      {\n        probe_logf (\"TLS handshake not completed: returning\");\n        return;\n      }\n      probe_logf (\"TLS handshake completed or advanced\");\n    }\n  }\n#endif /* HTTPS_SUPPORT */\n\n#if DEBUG_STATES\n  MHD_DLOG (connection->daemon,\n            _ (\"In function %s handling connection at state: %s\\n\"),\n            MHD_FUNC_,\n            MHD_state_to_string (connection->state));\n#endif\n\n  switch (connection->state)\n  {\n  case MHD_CONNECTION_INIT:\n  case MHD_CONNECTION_REQ_LINE_RECEIVING:\n  case MHD_CONNECTION_REQ_LINE_RECEIVED:\n  case MHD_CONNECTION_REQ_HEADERS_RECEIVING:\n  case MHD_CONNECTION_HEADERS_RECEIVED:\n  case MHD_CONNECTION_HEADERS_PROCESSED:\n    mhd_assert (0);\n    probe_logf (\"Unexpected state during write: assertion and return\");\n    return;\n  case MHD_CONNECTION_CONTINUE_SENDING:\n    ret = MHD_send_data_ (connection,\n                          &HTTP_100_CONTINUE\n                          [connection->continue_message_write_offset],\n                          MHD_STATICSTR_LEN_ (HTTP_100_CONTINUE)\n                          - connection->continue_message_write_offset,\n                          true);\n    probe_logf (\"CONTINUE_SENDING: MHD_send_data_ returned %zd\", ret);\n    if (ret < 0)\n    {\n      if (MHD_ERR_AGAIN_ == ret)\n      {\n        probe_logf (\"CONTINUE_SENDING: would block, returning\");\n        return;\n      }\n#ifdef HAVE_MESSAGES\n      /* Log before original diagnostic that references connection->rq.url */\n      probe_logf (\"CONTINUE_SENDING: Failed to send data for url='%s', ret=%zd\",\n                  connection->rq.url ? (const char *) connection->rq.url : \"(null)\",\n                  ret);\n      MHD_DLOG (connection->daemon,\n                _ (\"Failed to send data in request for %s.\\n\"),\n                connection->rq.url);\n#endif\n      CONNECTION_CLOSE_ERROR (connection,\n                              NULL);\n      probe_logf (\"CONTINUE_SENDING: CONNECTION_CLOSE_ERROR invoked\");\n      return;\n    }\n#if _MHD_DEBUG_SEND_DATA\n    fprintf (stderr,\n             _ (\"Sent 100 continue response: `%.*s'\\n\"),\n             (int) ret,\n             &HTTP_100_CONTINUE[connection->continue_message_write_offset]);\n#endif\n    connection->continue_message_write_offset += (size_t) ret;\n    probe_logf (\"CONTINUE_SENDING: advanced continue_message_write_offset=%zu\",\n                connection->continue_message_write_offset);\n    MHD_update_last_activity_ (connection);\n    return;\n  case MHD_CONNECTION_BODY_RECEIVING:\n  case MHD_CONNECTION_BODY_RECEIVED:\n  case MHD_CONNECTION_FOOTERS_RECEIVING:\n  case MHD_CONNECTION_FOOTERS_RECEIVED:\n  case MHD_CONNECTION_FULL_REQ_RECEIVED:\n    mhd_assert (0);\n    probe_logf (\"Unexpected body/footer/full-req state: assertion and return\");\n    return;\n  case MHD_CONNECTION_START_REPLY:\n    mhd_assert (0);\n    probe_logf (\"START_REPLY: assertion and return\");\n    return;\n  case MHD_CONNECTION_HEADERS_SENDING:\n    {\n      struct MHD_Response *const resp = connection->rp.response;\n      const size_t wb_ready = connection->write_buffer_append_offset\n                              - connection->write_buffer_send_offset;\n      mhd_assert (connection->write_buffer_append_offset >= \\\n                  connection->write_buffer_send_offset);\n      mhd_assert (NULL != resp);\n      mhd_assert ( (0 == resp->data_size) || \\\n                   (0 == resp->data_start) || \\\n                   (NULL != resp->crc) );\n      mhd_assert ( (0 == connection->rp.rsp_write_position) || \\\n                   (resp->total_size ==\n                    connection->rp.rsp_write_position) );\n      mhd_assert ((MHD_CONN_MUST_UPGRADE != connection->keepalive) || \\\n                  (! connection->rp.props.send_reply_body));\n\n      probe_logf (\"HEADERS_SENDING: wb_ready=%zu, send_offset=%zu, append_offset=%zu, rsp_write_position=%zu\",\n                  wb_ready,\n                  connection->write_buffer_send_offset,\n                  connection->write_buffer_append_offset,\n                  connection->rp.rsp_write_position);\n\n      if ( (connection->rp.props.send_reply_body) &&\n           (NULL == resp->crc) &&\n           (NULL == resp->data_iov) &&\n           /* TODO: remove the next check as 'send_reply_body' is used */\n           (0 == connection->rp.rsp_write_position) &&\n           (! connection->rp.props.chunked) )\n      {\n        mhd_assert (resp->total_size >= resp->data_size);\n        mhd_assert (0 == resp->data_start);\n        /* Send response headers alongside the response body, if the body\n         * data is available. */\n        ret = MHD_send_hdr_and_body_ (connection,\n                                      &connection->write_buffer\n                                      [connection->write_buffer_send_offset],\n                                      wb_ready,\n                                      false,\n                                      resp->data,\n                                      resp->data_size,\n                                      (resp->total_size == resp->data_size));\n      }\n      else\n      {\n        /* This is response for HEAD request or reply body is not allowed\n         * for any other reason or reply body is dynamically generated. */\n        /* Do not send the body data even if it's available. */\n        ret = MHD_send_hdr_and_body_ (connection,\n                                      &connection->write_buffer\n                                      [connection->write_buffer_send_offset],\n                                      wb_ready,\n                                      false,\n                                      NULL,\n                                      0,\n                                      ((0 == resp->total_size) ||\n                                       (! connection->rp.props.send_reply_body)\n                                      ));\n      }\n\n      probe_logf (\"HEADERS_SENDING: MHD_send_hdr_and_body_ returned %zd\", ret);\n\n      if (ret < 0)\n      {\n        if (MHD_ERR_AGAIN_ == ret)\n        {\n          probe_logf (\"HEADERS_SENDING: would block, returning\");\n          return;\n        }\n#ifdef HAVE_MESSAGES\n        probe_logf (\"HEADERS_SENDING: Failed to send response headers for url='%s', ret=%zd\",\n                    connection->rq.url ? (const char *) connection->rq.url : \"(null)\",\n                    ret);\n        MHD_DLOG (connection->daemon,\n                  _ (\"Failed to send the response headers for the \" \\\n                     \"request for `%s'. Error: %s\\n\"),\n                  connection->rq.url,\n                  str_conn_error_ (ret));\n#endif\n        CONNECTION_CLOSE_ERROR (connection,\n                                NULL);\n        probe_logf (\"HEADERS_SENDING: CONNECTION_CLOSE_ERROR invoked\");\n        return;\n      }\n      /* 'ret' is not negative, it's safe to cast it to 'size_t'. */\n      if (((size_t) ret) > wb_ready)\n      {\n        /* The complete header and some response data have been sent,\n         * update both offsets. */\n        mhd_assert (0 == connection->rp.rsp_write_position);\n        mhd_assert (! connection->rp.props.chunked);\n        mhd_assert (connection->rp.props.send_reply_body);\n        connection->write_buffer_send_offset += wb_ready;\n        connection->rp.rsp_write_position = ((size_t) ret) - wb_ready;\n        probe_logf (\"HEADERS_SENDING: sent headers + body fragment, new send_offset=%zu, rsp_write_position=%zu\",\n                    connection->write_buffer_send_offset,\n                    connection->rp.rsp_write_position);\n      }\n      else\n      {\n        connection->write_buffer_send_offset += (size_t) ret;\n        probe_logf (\"HEADERS_SENDING: sent %zu bytes of headers, new send_offset=%zu\",\n                    (size_t) ret,\n                    connection->write_buffer_send_offset);\n      }\n      MHD_update_last_activity_ (connection);\n      if (MHD_CONNECTION_HEADERS_SENDING != connection->state)\n      {\n        probe_logf (\"HEADERS_SENDING: state changed during operation, returning\");\n        return;\n      }\n      check_write_done (connection,\n                        MHD_CONNECTION_HEADERS_SENT);\n      probe_logf (\"HEADERS_SENDING: check_write_done invoked\");\n      return;\n    }\n  case MHD_CONNECTION_HEADERS_SENT:\n    probe_logf (\"HEADERS_SENT: nothing to do, returning\");\n    return;\n  case MHD_CONNECTION_NORMAL_BODY_READY:\n    response = connection->rp.response;\n    if (connection->rp.rsp_write_position <\n        connection->rp.response->total_size)\n    {\n      uint64_t data_write_offset;\n\n#if defined(MHD_USE_POSIX_THREADS) || defined(MHD_USE_W32_THREADS)\n      if (NULL != response->crc)\n        MHD_mutex_lock_chk_ (&response->mutex);\n#endif\n      if (MHD_NO == try_ready_normal_body (connection))\n      {\n        /* mutex was already unlocked by try_ready_normal_body */\n        probe_logf (\"NORMAL_BODY_READY: try_ready_normal_body reported not ready, returning\");\n        return;\n      }\n#if defined(_MHD_HAVE_SENDFILE)\n      if (MHD_resp_sender_sendfile == connection->rp.resp_sender)\n      {\n        mhd_assert (NULL == response->data_iov);\n        ret = MHD_send_sendfile_ (connection);\n      }\n      else /* combined with the next 'if' */\n#endif /* _MHD_HAVE_SENDFILE */\n      if (NULL != response->data_iov)\n      {\n        ret = MHD_send_iovec_ (connection,\n                               &connection->rp.resp_iov,\n                               true);\n      }\n      else\n      {\n        data_write_offset = connection->rp.rsp_write_position\n                            - response->data_start;\n        if (data_write_offset > (uint64_t) SIZE_MAX)\n          MHD_PANIC (_ (\"Data offset exceeds limit.\\n\"));\n        ret = MHD_send_data_ (connection,\n                              &response->data\n                              [(size_t) data_write_offset],\n                              response->data_size\n                              - (size_t) data_write_offset,\n                              true);\n#if _MHD_DEBUG_SEND_DATA\n        if (ret > 0)\n          fprintf (stderr,\n                   _ (\"Sent %d-byte DATA response: `%.*s'\\n\"),\n                   (int) ret,\n                   (int) ret,\n                   &rp.response->data[connection->rp.rsp_write_position\n                                      - rp.response->data_start]);\n#endif\n      }\n#if defined(MHD_USE_POSIX_THREADS) || defined(MHD_USE_W32_THREADS)\n      if (NULL != response->crc)\n        MHD_mutex_unlock_chk_ (&response->mutex);\n#endif\n      probe_logf (\"NORMAL_BODY_READY: MHD send returned %zd\", ret);\n      if (ret < 0)\n      {\n        if (MHD_ERR_AGAIN_ == ret)\n        {\n          probe_logf (\"NORMAL_BODY_READY: would block, returning\");\n          return;\n        }\n#ifdef HAVE_MESSAGES\n        probe_logf (\"NORMAL_BODY_READY: Failed to send response body for url='%s', ret=%zd\",\n                    connection->rq.url ? (const char *) connection->rq.url : \"(null)\",\n                    ret);\n        MHD_DLOG (connection->daemon,\n                  _ (\"Failed to send the response body for the \" \\\n                     \"request for `%s'. Error: %s\\n\"),\n                  connection->rq.url,\n                  str_conn_error_ (ret));\n#endif\n        CONNECTION_CLOSE_ERROR (connection,\n                                NULL);\n        probe_logf (\"NORMAL_BODY_READY: CONNECTION_CLOSE_ERROR invoked\");\n        return;\n      }\n      connection->rp.rsp_write_position += (size_t) ret;\n      probe_logf (\"NORMAL_BODY_READY: advanced rsp_write_position=%zu\",\n                  connection->rp.rsp_write_position);\n      MHD_update_last_activity_ (connection);\n    }\n    if (connection->rp.rsp_write_position ==\n        connection->rp.response->total_size)\n    {\n      connection->state = MHD_CONNECTION_FULL_REPLY_SENT;\n      probe_logf (\"NORMAL_BODY_READY: full reply sent, state set to FULL_REPLY_SENT\");\n    }\n    return;\n  case MHD_CONNECTION_NORMAL_BODY_UNREADY:\n    mhd_assert (0);\n    probe_logf (\"NORMAL_BODY_UNREADY: assertion and return\");\n    return;\n  case MHD_CONNECTION_CHUNKED_BODY_READY:\n    ret = MHD_send_data_ (connection,\n                          &connection->write_buffer\n                          [connection->write_buffer_send_offset],\n                          connection->write_buffer_append_offset\n                          - connection->write_buffer_send_offset,\n                          true);\n    probe_logf (\"CHUNKED_BODY_READY: MHD_send_data_ returned %zd\", ret);\n    if (ret < 0)\n    {\n      if (MHD_ERR_AGAIN_ == ret)\n      {\n        probe_logf (\"CHUNKED_BODY_READY: would block, returning\");\n        return;\n      }\n#ifdef HAVE_MESSAGES\n      probe_logf (\"CHUNKED_BODY_READY: Failed to send chunked body for url='%s', ret=%zd\",\n                  connection->rq.url ? (const char *) connection->rq.url : \"(null)\",\n                  ret);\n      MHD_DLOG (connection->daemon,\n                _ (\"Failed to send the chunked response body for the \" \\\n                   \"request for `%s'. Error: %s\\n\"),\n                connection->rq.url,\n                str_conn_error_ (ret));\n#endif\n      CONNECTION_CLOSE_ERROR (connection,\n                              NULL);\n      probe_logf (\"CHUNKED_BODY_READY: CONNECTION_CLOSE_ERROR invoked\");\n      return;\n    }\n    connection->write_buffer_send_offset += (size_t) ret;\n    probe_logf (\"CHUNKED_BODY_READY: advanced write_buffer_send_offset=%zu\",\n                connection->write_buffer_send_offset);\n    MHD_update_last_activity_ (connection);\n    if (MHD_CONNECTION_CHUNKED_BODY_READY != connection->state)\n    {\n      probe_logf (\"CHUNKED_BODY_READY: state changed during operation, returning\");\n      return;\n    }\n    check_write_done (connection,\n                      (connection->rp.response->total_size ==\n                       connection->rp.rsp_write_position) ?\n                      MHD_CONNECTION_CHUNKED_BODY_SENT :\n                      MHD_CONNECTION_CHUNKED_BODY_UNREADY);\n    probe_logf (\"CHUNKED_BODY_READY: check_write_done invoked\");\n    return;\n  case MHD_CONNECTION_CHUNKED_BODY_UNREADY:\n  case MHD_CONNECTION_CHUNKED_BODY_SENT:\n    mhd_assert (0);\n    probe_logf (\"CHUNKED_BODY_UNREADY/SENT: assertion and return\");\n    return;\n  case MHD_CONNECTION_FOOTERS_SENDING:\n    ret = MHD_send_data_ (connection,\n                          &connection->write_buffer\n                          [connection->write_buffer_send_offset],\n                          connection->write_buffer_append_offset\n                          - connection->write_buffer_send_offset,\n                          true);\n    probe_logf (\"FOOTERS_SENDING: MHD_send_data_ returned %zd\", ret);\n    if (ret < 0)\n    {\n      if (MHD_ERR_AGAIN_ == ret)\n      {\n        probe_logf (\"FOOTERS_SENDING: would block, returning\");\n        return;\n      }\n#ifdef HAVE_MESSAGES\n      probe_logf (\"FOOTERS_SENDING: Failed to send footers for url='%s', ret=%zd\",\n                  connection->rq.url ? (const char *) connection->rq.url : \"(null)\",\n                  ret);\n      MHD_DLOG (connection->daemon,\n                _ (\"Failed to send the footers for the \" \\\n                   \"request for `%s'. Error: %s\\n\"),\n                connection->rq.url,\n                str_conn_error_ (ret));\n#endif\n      CONNECTION_CLOSE_ERROR (connection,\n                              NULL);\n      probe_logf (\"FOOTERS_SENDING: CONNECTION_CLOSE_ERROR invoked\");\n      return;\n    }\n    connection->write_buffer_send_offset += (size_t) ret;\n    probe_logf (\"FOOTERS_SENDING: advanced write_buffer_send_offset=%zu\",\n                connection->write_buffer_send_offset);\n    MHD_update_last_activity_ (connection);\n    if (MHD_CONNECTION_FOOTERS_SENDING != connection->state)\n    {\n      probe_logf (\"FOOTERS_SENDING: state changed during operation, returning\");\n      return;\n    }\n    check_write_done (connection,\n                      MHD_CONNECTION_FULL_REPLY_SENT);\n    probe_logf (\"FOOTERS_SENDING: check_write_done invoked\");\n    return;\n  case MHD_CONNECTION_FULL_REPLY_SENT:\n    mhd_assert (0);\n    probe_logf (\"FULL_REPLY_SENT: assertion and return\");\n    return;\n  case MHD_CONNECTION_CLOSED:\n    probe_logf (\"CONNECTION_CLOSED: returning\");\n    return;\n#ifdef UPGRADE_SUPPORT\n  case MHD_CONNECTION_UPGRADE:\n    mhd_assert (0);\n    probe_logf (\"UPGRADE: assertion and return\");\n    return;\n#endif /* UPGRADE_SUPPORT */\n  default:\n    mhd_assert (0);\n    probe_logf (\"DEFAULT: internal error, invoking CONNECTION_CLOSE_ERROR\");\n    CONNECTION_CLOSE_ERROR (connection,\n                            _ (\"Internal error.\\n\"));\n    break;\n  }\n  probe_conn_state (\"EXIT MHD_connection_handle_write\", connection);\n  return;\n}\n"
}