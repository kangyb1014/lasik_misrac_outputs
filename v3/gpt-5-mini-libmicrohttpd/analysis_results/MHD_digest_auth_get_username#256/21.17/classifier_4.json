{
  "user_message": "<misra_rule>\nMISRA C 2023 Rule 21.17 is: Use of the string handling functions from <string.h> shall not result in accesses beyond the bounds of the objects referenced by their pointer parameters.\nThis rule strictly applies to the Standard Library functions in <string.h> such as memcpy, memmove, memset, memcmp, strcpy, strncpy, strcat, strncat, strlen, and strspn.\n</misra_rule>\n<response format>\nProvide your answer with these fields.\n- is_rule_violated: whether the rule is violated or not (true/false),\n- scenario: a specific violation scenario.\n</response format>\n<target_code>\nHere is the code of MHD_digest_auth_get_username:\n```c\n_MHD_EXTERN char *\nMHD_digest_auth_get_username (struct MHD_Connection *connection)\n{\n  const struct MHD_RqDAuth *params;\n  char *username;\n  size_t buf_size;\n  enum MHD_DigestAuthUsernameType uname_type;\n\n  params = MHD_get_rq_dauth_params_ (connection);\n  if (NULL == params)\n    return NULL;\n\n  uname_type = get_rq_uname_type (params);\n\n  if ( (MHD_DIGEST_AUTH_UNAME_TYPE_STANDARD != uname_type) &&\n       (MHD_DIGEST_AUTH_UNAME_TYPE_EXTENDED != uname_type) )\n    return NULL;\n\n  buf_size = get_rq_unames_size (params, uname_type);\n\n  mhd_assert (0 != buf_size);\n\n  username = (char *) MHD_calloc_ (1, buf_size);\n  if (NULL == username)\n    return NULL;\n\n  if (1)\n  {\n    struct MHD_DigestAuthUsernameInfo uname_strct;\n    size_t used;\n\n    memset (&uname_strct, 0, sizeof(uname_strct));\n\n    used = get_rq_uname (params, uname_type, &uname_strct,\n                         (uint8_t *) username, buf_size);\n    if (uname_type != uname_strct.uname_type)\n    { /* Broken encoding for extended notation */\n      free (username);\n      return NULL;\n    }\n    (void) used; /* Mute compiler warning for non-debug builds */\n    mhd_assert (buf_size >= used);\n  }\n\n  return username;\n}\n```\n</target_code>\n<target_code>\nHere is the code fragment that you need to analyze:\n```c\nbuf_size = get_rq_unames_size (params, uname_type);\n```\nFocus on the above code fragment and judge whether it violates the rule 21.17 or not.\n</target_code>\n",
  "is_rule_violated": false,
  "scenario": "The single statement buf_size = get_rq_unames_size(params, uname_type); by itself does not call any <string.h> functions and therefore does not directly violate MISRA C 2023 Rule 21.17. However a concrete violation can occur if get_rq_unames_size() returns a value that is too small (or zero) for the bytes actually written later by get_rq_uname(). For example, if get_rq_unames_size() omits space for a terminating NUL or otherwise underestimates the required length, and get_rq_uname() uses memcpy/memmove/strcpy/etc. to write more bytes than buf_size, those string functions will access beyond the bounds of the allocated object. Note also that the code relies on mhd_assert(0 != buf_size) which may be compiled out \u2014 leaving no runtime check for buf_size==0 \u2014 and calloc(1,0) behavior can be implementation-defined, further enabling an overflow scenario. To prevent violation, ensure get_rq_unames_size() always returns a safe size (including NUL), check the return value at runtime, and ensure get_rq_uname() never writes more than buf_size bytes."
}