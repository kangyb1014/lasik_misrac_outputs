{
  "user_message": "<misra_rule>\nMISRA C 2023 Rule 21.17 is: Use of the string handling functions from <string.h> shall not result in accesses beyond the bounds of the objects referenced by their pointer parameters.\nThis rule strictly applies to the Standard Library functions in <string.h> such as memcpy, memmove, memset, memcmp, strcpy, strncpy, strcat, strncat, strlen, and strspn.\n</misra_rule>\n<response format>\nProvide your answer with these fields.\n- is_rule_violated: whether the rule is violated or not (true/false),\n- scenario: a specific violation scenario.\n</response format>\n<target_code>\nHere is the code of MHD_bin_to_hex_z:\n```c\nsize_t\nMHD_bin_to_hex_z (const void *bin,\n                  size_t size,\n                  char *hex)\n{\n  size_t res;\n\n  res = MHD_bin_to_hex (bin, size, hex);\n  hex[res] = 0;\n\n  return res;\n}\n```\n</target_code>\n<target_code>\nHere is the code fragment that you need to analyze:\n```c\nhex[res] = 0;\n```\nFocus on the above code fragment and judge whether it violates the rule 21.17 or not.\n</target_code>\n",
  "is_rule_violated": false,
  "scenario": "Although the assignment hex[res] = 0 can write past the end of the hex buffer (e.g. if the caller provided a buffer of exactly the number of bytes produced and no space for a NUL, or if MHD_bin_to_hex returns a length equal to the provided buffer capacity), this statement is not a use of a <string.h> function. Therefore it does not itself violate MISRA C 2023 Rule 21.17. However it can produce an out\u2011of\u2011bounds write (a separate safety defect) if the caller did not allocate one extra byte for the terminating NUL or if MHD_bin_to_hex wrote up to the buffer limit."
}