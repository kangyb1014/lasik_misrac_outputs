{
  "user_message": "<misra_rule>\nMISRA C 2023 Rule 8.13 is: A pointer should point to a const-qualified type whenever possible.\n\n</misra_rule>\n<response format>\nProvide your answer with these fields.\n- is_rule_violated: whether the rule is violated or not (true/false),\n- scenario: a specific violation scenario.\n</response format>\n<target_code>\nHere is the code of MHD_set_connection_option:\n```c\n_MHD_EXTERN enum MHD_Result\nMHD_set_connection_option (struct MHD_Connection *connection,\n                           enum MHD_CONNECTION_OPTION option,\n                           ...)\n{\n  va_list ap;\n  struct MHD_Daemon *daemon;\n  unsigned int ui_val;\n\n  daemon = connection->daemon;\n  switch (option)\n  {\n  case MHD_CONNECTION_OPTION_TIMEOUT:\n    if (0 == connection->connection_timeout_ms)\n      connection->last_activity = MHD_monotonic_msec_counter ();\n    va_start (ap, option);\n    ui_val = va_arg (ap, unsigned int);\n    va_end (ap);\n#if (SIZEOF_UINT64_T - 2) <= SIZEOF_UNSIGNED_INT\n    if ((UINT64_MAX / 4000 - 1) < ui_val)\n    {\n#ifdef HAVE_MESSAGES\n      MHD_DLOG (connection->daemon,\n                _ (\"The specified connection timeout (%u) is too \" \\\n                   \"large. Maximum allowed value (%\" PRIu64 \") will be used \" \\\n                   \"instead.\\n\"),\n                ui_val,\n                (UINT64_MAX / 4000 - 1));\n#endif\n      ui_val = UINT64_MAX / 4000 - 1;\n    }\n#endif /* (SIZEOF_UINT64_T - 2) <= SIZEOF_UNSIGNED_INT */\n    if (! MHD_D_IS_USING_THREAD_PER_CONN_ (daemon))\n    {\n#if defined(MHD_USE_THREADS)\n      MHD_mutex_lock_chk_ (&daemon->cleanup_connection_mutex);\n#endif\n      if (! connection->suspended)\n      {\n        if (connection->connection_timeout_ms == daemon->connection_timeout_ms)\n          XDLL_remove (daemon->normal_timeout_head,\n                       daemon->normal_timeout_tail,\n                       connection);\n        else\n          XDLL_remove (daemon->manual_timeout_head,\n                       daemon->manual_timeout_tail,\n                       connection);\n        connection->connection_timeout_ms = ((uint64_t) ui_val) * 1000;\n        if (connection->connection_timeout_ms == daemon->connection_timeout_ms)\n          XDLL_insert (daemon->normal_timeout_head,\n                       daemon->normal_timeout_tail,\n                       connection);\n        else\n          XDLL_insert (daemon->manual_timeout_head,\n                       daemon->manual_timeout_tail,\n                       connection);\n      }\n#if defined(MHD_USE_THREADS)\n      MHD_mutex_unlock_chk_ (&daemon->cleanup_connection_mutex);\n#endif\n    }\n    return MHD_YES;\n  default:\n    return MHD_NO;\n  }\n}\n```\n</target_code>\n<target_code>\nHere is the code fragment that you need to analyze:\n```c\nXDLL_remove (daemon->normal_timeout_head,\n                       daemon->normal_timeout_tail,\n                       connection);\n```\nFocus on the above code fragment and judge whether it violates the rule 8.13 or not.\n</target_code>\n",
  "is_rule_violated": false,
  "scenario": "Not violated. The call XDLL_remove(daemon->normal_timeout_head, daemon->normal_timeout_tail, connection) is removing a connection from a (doubly-)linked list and therefore must modify the pointed-to list nodes and the connection structure (list pointers, head/tail links). Because the pointed-to objects are intentionally mutable, they should not be const-qualified; making them const would prevent the required modifications. (If, conversely, XDLL_remove did not modify the pointees, then taking const-qualified pointers would be preferable and omission would violate Rule 8.13.)"
}