{
  "user_message": "<misra_rule>\nMISRA C 2023 Rule 17.2 is: Functions shall not call themselves, either directly or indirectly.\n\n</misra_rule>\n<response format>\nProvide your answer with these fields.\n- is_rule_violated: whether the rule is violated or not (true/false),\n- scenario: a specific violation scenario.\n</response format>\n<target_code>\nHere is the code of get_session:\n```c\nstatic struct Session *\nget_session (struct MHD_Connection *connection)\n{\n  struct Session *ret;\n  const char *cookie;\n\n  cookie = MHD_lookup_connection_value (connection,\n                                        MHD_COOKIE_KIND,\n                                        COOKIE_NAME);\n  if (cookie != NULL)\n  {\n    /* find existing session */\n    ret = sessions;\n    while (NULL != ret)\n    {\n      if (0 == strcmp (cookie, ret->sid))\n        break;\n      ret = ret->next;\n    }\n    if (NULL != ret)\n    {\n      ret->rc++;\n      return ret;\n    }\n  }\n  /* create fresh session */\n  ret = calloc (1, sizeof (struct Session));\n  if (NULL == ret)\n  {\n    fprintf (stderr, \"calloc error: %s\\n\", strerror (errno));\n    return NULL;\n  }\n  /* not a super-secure way to generate a random session ID,\n     but should do for a simple example... */\n  snprintf (ret->sid,\n            sizeof (ret->sid),\n            \"%X%X%X%X\",\n            (unsigned int) rand (),\n            (unsigned int) rand (),\n            (unsigned int) rand (),\n            (unsigned int) rand ());\n  ret->rc++;\n  ret->start = time (NULL);\n  ret->next = sessions;\n  sessions = ret;\n  return ret;\n}\n```\n</target_code>\n<target_code>\nHere is the code fragment that you need to analyze:\n```c\nsnprintf (ret->sid, sizeof (ret->sid), \"%X%X%X%X\", (unsigned int) rand (), (unsigned int) rand (), (unsigned int) rand (), (unsigned int) rand ());\n```\nFocus on the above code fragment and judge whether it violates the rule 17.2 or not.\n</target_code>\n",
  "is_rule_violated": false,
  "scenario": "The fragment calls snprintf and rand to format a session ID. Neither snprintf nor rand (standard library functions) call get_session, so there is no direct or indirect self-call. No evidence of recursion in this snippet; an indirect recursion would require a called function to call back into get_session, which is not shown here."
}