{
  "user_message": "An agent A claimed that the following get_session code violates the MISRA C 2023 rule 8.13.\n<misra_rule>\nMISRA C 2023 Rule 8.13 is A pointer should point to a const-qualified type whenever possible.\n\n</misra_rule>\n<target_code>\nHere is the original code of get_session.\n```c\nstatic struct Session *\nget_session (struct MHD_Connection *connection)\n{\n  struct Session *ret;\n  const char *cookie;\n\n  cookie = MHD_lookup_connection_value (connection,\n                                        MHD_COOKIE_KIND,\n                                        COOKIE_NAME);\n  if (cookie != NULL)\n  {\n    /* find existing session */\n    ret = sessions;\n    while (NULL != ret)\n    {\n      if (0 == strcmp (cookie, ret->sid))\n        break;\n      ret = ret->next;\n    }\n    if (NULL != ret)\n    {\n      ret->rc++;\n      return ret;\n    }\n  }\n  /* create fresh session */\n  ret = calloc (1, sizeof (struct Session));\n  if (NULL == ret)\n  {\n    fprintf (stderr, \"calloc error: %s\\n\", strerror (errno));\n    return NULL;\n  }\n  /* not a super-secure way to generate a random session ID,\n     but should do for a simple example... */\n  snprintf (ret->sid,\n            sizeof (ret->sid),\n            \"%X%X%X%X\",\n            (unsigned int) rand (),\n            (unsigned int) rand (),\n            (unsigned int) rand (),\n            (unsigned int) rand ());\n  ret->rc++;\n  ret->start = time (NULL);\n  ret->next = sessions;\n  sessions = ret;\n  return ret;\n}\n```\n</target_code>\n<response format>\nProvide your answer with these fields.\n- explanation: your evaluation of the scenario provided by the agent A.\n- is_report_correct: whether the report is correct or not (true/false). True means there is a violation.\n</response format>\n<scenario>\nThe agent A provided the following violation scenario:\nThe function parameter 'connection' is declared as 'struct MHD_Connection *connection' but the function body only uses it as an input to MHD_lookup_connection_value and never modifies the pointed-to object. According to MISRA C 2023 Rule 8.13, the pointer should be to a const-qualified type when possible. Therefore the parameter should be declared as 'const struct MHD_Connection *connection' (unless the called API requires a non-const pointer), so in the shown code this is a rule violation.\n</scenario>\n\n<instruction>\nJudge whether the report is correct or not.\n</instruction>\n",
  "is_report_correct": false,
  "explanation": "MISRA C:2023 Rule 8.13 is a \u201cprefer const\u201d rule: a pointer should point to const-qualified type whenever that is possible. Whether get_session violates the rule depends on whether the pointer could actually be made const in this translation unit without breaking type compatibility with the called API. In the function body the connection parameter is only used as an input to MHD_lookup_connection_value, so from the function\u2019s local usage it could be const. However, the MHD_lookup_connection_value API (libmicrohttpd) takes a pointer of type struct MHD_Connection * (non-const). Because you must match the called function\u2019s prototype, you cannot change the parameter to const without either changing the API prototype or performing a cast (the latter would itself be discouraged). Therefore this code is not necessarily a MISRA 8.13 violation: it only would be if the MHD API actually accepted a const pointer (or if there are other places where a const signature is possible). In practice the correct action is to check the MHD_lookup_connection_value prototype \u2014 if it takes a const struct MHD_Connection * then get_session should be changed to accept const; if it takes a non-const pointer, keeping the current signature is appropriate (and casting away const would be wrong)."
}