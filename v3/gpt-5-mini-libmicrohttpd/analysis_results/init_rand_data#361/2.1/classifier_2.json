{
  "user_message": "<misra_rule>\nMISRA C 2023 Rule 2.1 is: A project shall not contain unreachable code.\n\n</misra_rule>\n<response format>\nProvide your answer with these fields.\n- is_rule_violated: whether the rule is violated or not (true/false),\n- scenario: a specific violation scenario.\n</response format>\n<target_code>\nHere is the code of init_rand_data:\n```c\nstatic int\ninit_rand_data (void)\n{\n#if ! defined(_WIN32) || defined(__CYGWIN__)\n  int fd;\n  ssize_t len;\n  size_t off;\n\n  fd = open (\"/dev/urandom\", O_RDONLY);\n  if (-1 == fd)\n  {\n    fprintf (stderr, \"Failed to open '%s': %s\\n\",\n             \"/dev/urandom\",\n             strerror (errno));\n    return 0;\n  }\n  for (off = 0; off < sizeof(rand_data); off += (size_t) len)\n  {\n    len = read (fd, rand_data, 8);\n    if (0 > len)\n    {\n      fprintf (stderr, \"Failed to read '%s': %s\\n\",\n               \"/dev/urandom\",\n               strerror (errno));\n      (void) close (fd);\n      return 0;\n    }\n  }\n  (void) close (fd);\n#else  /* Native W32 */\n  HCRYPTPROV cc;\n  BOOL b;\n\n  b = CryptAcquireContext (&cc,\n                           NULL,\n                           NULL,\n                           PROV_RSA_FULL,\n                           CRYPT_VERIFYCONTEXT);\n  if (FALSE == b)\n  {\n    fprintf (stderr,\n             \"Failed to acquire crypto provider context: %lu\\n\",\n             (unsigned long) GetLastError ());\n    return 0;\n  }\n  b = CryptGenRandom (cc, sizeof(rand_data), (BYTE *) rand_data);\n  if (FALSE == b)\n  {\n    fprintf (stderr,\n             \"Failed to generate 8 random bytes: %lu\\n\",\n             GetLastError ());\n  }\n  CryptReleaseContext (cc, 0);\n  if (FALSE == b)\n    return 0;\n#endif /* Native W32 */\n\n  return ! 0;\n}\n```\n</target_code>\n<target_code>\nHere is the code fragment that you need to analyze:\n```c\nlen = read (fd, rand_data, 8);\n```\nFocus on the above code fragment and judge whether it violates the rule 2.1 or not.\n</target_code>\n",
  "is_rule_violated": true,
  "scenario": "In the POSIX branch the code uses: for (off = 0; off < sizeof(rand_data); off += (size_t) len) { len = read(fd, rand_data, 8); ... } If read() returns 0 (EOF) the loop body does not update off (off += 0) and the loop becomes non-terminating, rendering the code after the loop unreachable. Because the code assumes read() always returns >0, but this is not guaranteed, this creates a possible execution path with unreachable code (infinite loop), violating MISRA C 2023 Rule 2.1."
}