{
  "user_message": "An agent A claimed that the following MHD_digest_auth_calc_userdigest code violates the MISRA C 2023 rule 21.17.\n<misra_rule>\nMISRA C 2023 Rule 21.17 is Use of the string handling functions from <string.h> shall not result in accesses beyond the bounds of the objects referenced by their pointer parameters.\nThis rule strictly applies to the Standard Library functions in <string.h> such as memcpy, memmove, memset, memcmp, strcpy, strncpy, strcat, strncat, strlen, and strspn.\n</misra_rule>\n<target_code>\nHere is the original code of MHD_digest_auth_calc_userdigest.\n```c\n_MHD_EXTERN enum MHD_Result\nMHD_digest_auth_calc_userdigest (enum MHD_DigestAuthAlgo3 algo3,\n                                 const char *username,\n                                 const char *realm,\n                                 const char *password,\n                                 void *userdigest_bin,\n                                 size_t bin_buf_size)\n{\n  struct DigestAlgorithm da;\n  enum MHD_Result ret;\n  if (! digest_init_one_time (&da, get_base_digest_algo (algo3)))\n    return MHD_NO;\n\n  if (digest_get_size (&da) > bin_buf_size)\n    ret = MHD_NO;\n  else\n  {\n    calc_userdigest (&da,\n                     username,\n                     strlen (username),\n                     realm,\n                     strlen (realm),\n                     password,\n                     userdigest_bin);\n    ret = MHD_YES;\n\n#ifdef MHD_DIGEST_HAS_EXT_ERROR\n    if (digest_ext_error (&da))\n      ret = MHD_NO;\n#endif /* MHD_DIGEST_HAS_EXT_ERROR */\n  }\n  digest_deinit (&da);\n\n  return ret;\n}\n```\n</target_code>\n<response format>\nProvide your answer with these fields.\n- explanation: your evaluation of the scenario provided by the agent A.\n- is_report_correct: whether the report is correct or not (true/false). True means there is a violation.\n</response format>\n<scenario>\nThe agent A provided the following violation scenario:\nCalling strlen(username) and strlen(realm) without checking the pointers can read out-of-bounds. For example, if the caller passes username == NULL (or realm == NULL) the strlen call dereferences a NULL pointer; or if the provided buffers are not NUL-terminated within their allocated bounds, strlen will scan past the object. This can result in accesses beyond the bounds of the objects referenced by the pointer parameters, violating MISRA C 2023 Rule 21.17.\n</scenario>\n\n<execution_log>\nThe agent A also provided the following output log:\n[entry] algo=65 username=0x555b3a3b50fa realm=0x555b3a3b5122 password=0x555b3a3b50fc bin_buf_size=16 digest_size=18446744073709551615 username_len=18446744073709551615 realm_len=18446744073709551615\n[after_init] algo=65 username=0x555b3a3b50fa realm=0x555b3a3b5122 password=0x555b3a3b50fc bin_buf_size=16 digest_size=16 username_len=18446744073709551615 realm_len=18446744073709551615\n[before_strlen] algo=65 username=0x555b3a3b50fa realm=0x555b3a3b5122 password=0x555b3a3b50fc bin_buf_size=16 digest_size=16 username_len=18446744073709551615 realm_len=18446744073709551615\n[strlen_results] algo=65 username=0x555b3a3b50fa realm=0x555b3a3b5122 password=0x555b3a3b50fc bin_buf_size=16 digest_size=16 username_len=1 realm_len=1\n[after_calc_userdigest] algo=65 username=0x555b3a3b50fa realm=0x555b3a3b5122 password=0x555b3a3b50fc bin_buf_size=16 digest_size=16 username_len=1 realm_len=1\n[exit] algo=65 username=0x555b3a3b50fa realm=0x555b3a3b5122 password=0x555b3a3b50fc bin_buf_size=16 digest_size=18446744073709551615 username_len=18446744073709551615 realm_len=18446744073709551615\n[entry] algo=65 username=0x555b3a3b50fe realm=0x555b3a3b5107 password=0x555b3a3b5111 bin_buf_size=16 digest_size=18446744073709551615 username_len=18446744073709551615 realm_len=18446744073709551615\n[after_init] algo=65 username=0x555b3a3b50fe realm=0x555b3a3b5107 password=0x555b3a3b5111 bin_buf_size=16 digest_size=16 username_len=18446744073709551615 realm_len=18446744073709551615\n[before_strlen] algo=65 username=0x555b3a3b50fe realm=0x555b3a3b5107 password=0x555b3a3b5111 bin_buf_size=16 digest_size=16 username_len=18446744073709551615 realm_len=18446744073709551615\n[strlen_results] algo=65 username=0x555b3a3b50fe realm=0x555b3a3b5107 password=0x555b3a3b5111 bin_buf_size=16 digest_size=16 username_len=8 realm_len=9\n[after_calc_userdigest] algo=65 username=0x555b3a3b50fe realm=0x555b3a3b5107 password=0x555b3a3b5111 bin_buf_size=16 digest_size=16 username_len=8 realm_len=9\n[exit] algo=65 username=0x555b3a3b50fe realm=0x555b3a3b5107 password=0x555b3a3b5111 bin_buf_size=16 digest_size=18446744073709551615 username_len=18446744073709551615 realm_len=18446744073709551615\n[entry] algo=65 username=0x555b3a3b511a realm=0x555b3a3b5124 password=0x555b3a3b512e bin_buf_size=16 digest_size=18446744073709551615 username_len=18446744073709551615 realm_len=18446744073709551615\n[after_init] algo=65 username=0x555b3a3b511a realm=0x555b3a3b5124 password=0x555b3a3b512e bin_buf_size=16 digest_size=16 username_len=18446744073709551615 realm_len=18446744073709551615\n[before_strlen] algo=65 username=0x555b3a3b511a realm=0x555b3a3b5124 password=0x555b3a3b512e bin_buf_size=16 digest_size=16 username_len=18446744073709551615 realm_len=18446744073709551615\n[strlen_results] algo=65 username=0x555b3a3b511a realm=0x555b3a3b5124 password=0x555b3a3b512e bin_buf_size=16 digest_size=16 username_len=9 realm_len=9\n[after_calc_userdigest] algo=65 username=0x555b3a3b511a realm=0x555b3a3b5124 password=0x555b3a3b512e bin_buf_size=16 digest_size=16 username_len=9 realm_len=9\n[exit] algo=65 username=0x555b3a3b511a realm=0x555b3a3b5124 password=0x555b3a3b512e bin_buf_size=16 digest_size=18446744073709551615 username_len=18446744073709551615 realm_len=18446744073709551615\n[entry] algo=65 username=0x555b3a3b5138 realm=0x555b3a3b513f password=0x555b3a3b5154 bin_buf_size=16 digest_size=18446744073709551615 username_len=18446744073709551615 realm_len=18446744073709551615\n[after_init] algo=65 username=0x555b3a3b5138 realm=0x555b3a3b513f password=0x555b3a3b5154 bin_buf_size=16 digest_size=16 username_len=18446744073709551615 realm_len=18446744073709551615\n[before_strlen] algo=65 username=0x555b3a3b5138 realm=0x555b3a3b513f password=0x555b3a3b5154 bin_buf_size=16 digest_size=16 username_len=18446744073709551615 realm_len=18446744073709551615\n[strlen_results] algo=65 username=0x555b3a3b5138 realm=0x555b3a3b513f password=0x555b3a3b5154 bin_buf_size=16 digest_size=16 username_len=6 realm_len=20\n[after_calc_userdigest] algo=65 username=0x555b3a3b5138 realm=0x555b3a3b513f password=0x555b3a3b5154 bin_buf_size=16 dig\n</execution_log>\n\n<instruction>\nJudge whether the report is correct or not.\n</instruction>\n",
  "is_report_correct": true,
  "explanation": "The report is correct. The code calls strlen(username) and strlen(realm) without any check that those pointer parameters are non-NULL and point to NUL-terminated character arrays. MISRA C:2023 Rule 21.17 requires that uses of <string.h> functions must not result in accesses beyond the bounds of the objects referenced by their pointer parameters. As written, there is nothing in the function which enforces or documents that username and realm are valid, NUL-terminated strings; a caller could pass NULL or a non-terminated buffer and strlen would read out-of-bounds (or dereference NULL), violating the rule. The runtime log does not prove safety for all calls. To conform, the function must ensure the pointers reference valid, NUL-terminated objects (e.g. check for NULL and enforce maximum lengths or use a bounded-length API/contract), or the non-NULL/NUL-terminated preconditions must be explicitly guaranteed and documented by the API contract."
}