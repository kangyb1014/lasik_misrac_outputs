{
  "user_message": "An agent A claimed that the following MHD_digest_auth_calc_userdigest code violates the MISRA C 2023 rule 21.17.\n<misra_rule>\nMISRA C 2023 Rule 21.17 is Use of the string handling functions from <string.h> shall not result in accesses beyond the bounds of the objects referenced by their pointer parameters.\nThis rule strictly applies to the Standard Library functions in <string.h> such as memcpy, memmove, memset, memcmp, strcpy, strncpy, strcat, strncat, strlen, and strspn.\n</misra_rule>\n<target_code>\nHere is the original code of MHD_digest_auth_calc_userdigest.\n```c\n_MHD_EXTERN enum MHD_Result\nMHD_digest_auth_calc_userdigest (enum MHD_DigestAuthAlgo3 algo3,\n                                 const char *username,\n                                 const char *realm,\n                                 const char *password,\n                                 void *userdigest_bin,\n                                 size_t bin_buf_size)\n{\n  struct DigestAlgorithm da;\n  enum MHD_Result ret;\n  if (! digest_init_one_time (&da, get_base_digest_algo (algo3)))\n    return MHD_NO;\n\n  if (digest_get_size (&da) > bin_buf_size)\n    ret = MHD_NO;\n  else\n  {\n    calc_userdigest (&da,\n                     username,\n                     strlen (username),\n                     realm,\n                     strlen (realm),\n                     password,\n                     userdigest_bin);\n    ret = MHD_YES;\n\n#ifdef MHD_DIGEST_HAS_EXT_ERROR\n    if (digest_ext_error (&da))\n      ret = MHD_NO;\n#endif /* MHD_DIGEST_HAS_EXT_ERROR */\n  }\n  digest_deinit (&da);\n\n  return ret;\n}\n```\n</target_code>\n<response format>\nProvide your answer with these fields.\n- explanation: your evaluation of the scenario provided by the agent A.\n- is_report_correct: whether the report is correct or not (true/false). True means there is a violation.\n</response format>\n<scenario>\nThe agent A provided the following violation scenario:\nCalling strlen(realm) without validating 'realm' may read beyond the object bounds. For example, if the caller passes realm == NULL, strlen(realm) dereferences a null pointer; or if 'realm' points to a buffer that is not NUL-terminated, strlen will scan past the buffer until a NUL byte is found. Both situations violate MISRA C 2023 Rule 21.17.\n</scenario>\n\n<instruction>\nJudge whether the report is correct or not.\n</instruction>\n",
  "is_report_correct": true,
  "explanation": "The report is correct. The code calls strlen(username) and strlen(realm) with no prior checks that those pointers are non-NULL and point to NUL-terminated objects. If a caller passes realm==NULL (or username==NULL) or a buffer lacking a terminating '\\0', strlen will read out of bounds (or dereference NULL), which violates MISRA C 2023 Rule 21.17. The only way this would not be a violation is if the function's contract (documented preconditions) guarantees the pointers are non-NULL and NUL-terminated; no such guarantee or validation is visible in the snippet, so the use of strlen here is unsafe with respect to Rule 21.17."
}