{
  "user_message": "An agent A claimed that the following ahc_echo code violates the MISRA C 2023 rule 8.13.\n<misra_rule>\nMISRA C 2023 Rule 8.13 is A pointer should point to a const-qualified type whenever possible.\n\n</misra_rule>\n<target_code>\nHere is the original code of ahc_echo.\n```c\nstatic enum MHD_Result\nahc_echo (void *cls,\n          struct MHD_Connection *connection,\n          const char *url,\n          const char *method,\n          const char *version,\n          const char *upload_data, size_t *upload_data_size, void **req_cls)\n{\n  static int aptr;\n  struct MHD_Response *response;\n  enum MHD_Result ret;\n  (void) cls;               /* Unused. Silent compiler warning. */\n  (void) url;               /* Unused. Silent compiler warning. */\n  (void) version;           /* Unused. Silent compiler warning. */\n  (void) upload_data;       /* Unused. Silent compiler warning. */\n  (void) upload_data_size;  /* Unused. Silent compiler warning. */\n\n  if (0 != strcmp (method, \"GET\"))\n    return MHD_NO;              /* unexpected method */\n  if (&aptr != *req_cls)\n  {\n    /* do never respond on first call */\n    *req_cls = &aptr;\n    return MHD_YES;\n  }\n  *req_cls = NULL;                  /* reset when done */\n  response = MHD_create_response_from_callback (MHD_SIZE_UNKNOWN,\n                                                80,\n                                                &data_generator, NULL, NULL);\n  ret = MHD_queue_response (connection, MHD_HTTP_OK, response);\n  MHD_destroy_response (response);\n  return ret;\n}\n```\n</target_code>\n<response format>\nProvide your answer with these fields.\n- explanation: your evaluation of the scenario provided by the agent A.\n- is_report_correct: whether the report is correct or not (true/false). True means there is a violation.\n</response format>\n<scenario>\nThe agent A provided the following violation scenario:\nThe static object 'aptr' is declared as a non-const int and its address (&aptr, type int *) is stored in *req_cls (a void *). The object is only used as an opaque marker and is not modified, so it could be declared const (e.g. const int aptr). Per MISRA C 2023 Rule 8.13, a pointer should point to a const-qualified type whenever possible. Because &aptr is a pointer to a non-const object that could be const-qualified, this fragment violates Rule 8.13.\n</scenario>\n\n<instruction>\nJudge whether the report is correct or not.\n</instruction>\n",
  "is_report_correct": true,
  "explanation": "Agent A is essentially correct: aptr is never modified and therefore could be declared const, so storing &aptr into a (non-const) void * means a pointer is pointing at a non-const object when it could point to a const-qualified object \u2014 which conflicts with the intent of MISRA C 2023 Rule 8.13. In other words, the code as shown does not use a const-qualified target type even though it appears possible to do so. \n\nOne important caveat: the function uses the external API's req_cls parameter (a void **). If that API requires a plain void * (i.e. the signature cannot be changed), then you cannot fully express the const qualification without changing the API; in that case the code would need a documented deviation from MISRA or another acceptable workaround (for example change the API to use const void * if possible). If the API can be changed, the proper remediation is to make the object const (e.g. static const int aptr;) and propagate const qualification through the pointer types (e.g. const void ** or const void * usage) so that pointers point to const-qualified types."
}