{
  "user_message": "An agent A claimed that the following MHD_send_iovec_ code violates the MISRA C 2023 rule 8.13.\n<misra_rule>\nMISRA C 2023 Rule 8.13 is A pointer should point to a const-qualified type whenever possible.\n\n</misra_rule>\n<target_code>\nHere is the original code of MHD_send_iovec_.\n```c\nssize_t\nMHD_send_iovec_ (struct MHD_Connection *connection,\n                 struct MHD_iovec_track_ *const r_iov,\n                 bool push_data)\n{\n#ifdef MHD_VECT_SEND\n#if defined(HTTPS_SUPPORT) || \\\n  defined(_MHD_VECT_SEND_NEEDS_SPIPE_SUPPRESSED)\n  bool use_iov_send = true;\n#endif /* HTTPS_SUPPORT || _MHD_VECT_SEND_NEEDS_SPIPE_SUPPRESSED */\n#endif /* MHD_VECT_SEND */\n\n  mhd_assert (NULL != connection->rp.resp_iov.iov);\n  mhd_assert (NULL != connection->rp.response->data_iov);\n  mhd_assert (connection->rp.resp_iov.cnt > connection->rp.resp_iov.sent);\n#ifdef MHD_VECT_SEND\n#if defined(HTTPS_SUPPORT) || \\\n  defined(_MHD_VECT_SEND_NEEDS_SPIPE_SUPPRESSED)\n#ifdef HTTPS_SUPPORT\n  use_iov_send = use_iov_send &&\n                 (0 == (connection->daemon->options & MHD_USE_TLS));\n#endif /* HTTPS_SUPPORT */\n#ifdef _MHD_VECT_SEND_NEEDS_SPIPE_SUPPRESSED\n  use_iov_send = use_iov_send && (connection->daemon->sigpipe_blocked ||\n                                  connection->sk_spipe_suppress);\n#endif /* _MHD_VECT_SEND_NEEDS_SPIPE_SUPPRESSED */\n  if (use_iov_send)\n#endif /* HTTPS_SUPPORT || _MHD_VECT_SEND_NEEDS_SPIPE_SUPPRESSED */\n  return send_iov_nontls (connection, r_iov, push_data);\n#endif /* MHD_VECT_SEND */\n\n#if ! defined(MHD_VECT_SEND) || defined(HTTPS_SUPPORT) || \\\n  defined(_MHD_VECT_SEND_NEEDS_SPIPE_SUPPRESSED)\n  return send_iov_emu (connection, r_iov, push_data);\n#endif /* !MHD_VECT_SEND || HTTPS_SUPPORT\n          || _MHD_VECT_SEND_NEEDS_SPIPE_SUPPRESSED */\n}\n```\n</target_code>\n<response format>\nProvide your answer with these fields.\n- explanation: your evaluation of the scenario provided by the agent A.\n- is_report_correct: whether the report is correct or not (true/false). True means there is a violation.\n</response format>\n<scenario>\nThe agent A provided the following violation scenario:\nThe parameter is declared as a const pointer to a non-const object: 'struct MHD_iovec_track_ *const r_iov'. Rule 8.13 expects the pointee to be const whenever possible. If MHD_send_iovec_ does not modify the object pointed to by r_iov (it only reads it or forwards it to callees that do not modify it), then the declaration should be 'const struct MHD_iovec_track_ * const r_iov' (or at least 'const struct MHD_iovec_track_ * r_iov'). In that usage scenario the current declaration violates MISRA C 2023 Rule 8.13.\n</scenario>\n\n<instruction>\nJudge whether the report is correct or not.\n</instruction>\n",
  "is_report_correct": false,
  "explanation": "The report is not proven by the snippet. Rule 8.13 requires the pointee to be const when the function (and any callees it relies on) do not modify the object. In the shown code the parameter is declared as a const pointer to a non-const object: 'struct MHD_iovec_track_ *const r_iov' (the pointer itself is const, not the pointee). Whether this violates MISRA 8.13 depends on whether MHD_send_iovec_ or the functions it forwards r_iov to (send_iov_nontls / send_iov_emu) modify the pointed-to object. The snippet does not show those functions or any direct modifications, so you cannot conclude a violation from this fragment alone. To confirm a violation you must inspect the prototypes/implementations of send_iov_nontls and send_iov_emu (and any other use of r_iov) \u2014 if none of them modify the pointee, then the parameter should indeed be const-qualified (e.g. 'const struct MHD_iovec_track_ * const r_iov') and the report would be correct. If any callee or this function writes through r_iov, the current declaration is appropriate and there is no violation. Recommendation: check the callees and, if they do not modify the pointee, update the declaration and related prototypes to use const-qualified pointee types to satisfy MISRA 8.13."
}