{
  "user_message": "<misra_rule>\nMISRA C 2023 Rule 17.8 is: A function parameter should not be modified.\nNote that the object referred to by a pointer parameter may be modified, but the pointer itself shall not be modified.\n</misra_rule>\n\nAnother agent reported that the target code violated the Rule 17.8.\nHere is the comment from the agent.\n<violation scenario>\nThe code performs a compound assignment on the function parameter 'val' (uint32_t) via 'val <<= 4;'. This modifies the parameter variable itself rather than using a separate local copy, which violates MISRA C 2023 Rule 17.8 (a function parameter should not be modified).\n</violation scenario>\n\nYour job is to insert logging code to capture the control flow and state information of the program.\nInsert logging code so that other agents can reproduce and get evidence for the violation scenario.\n<response format>\n- test_code: a modified MHD_uint32_to_strx code that contains useful probe functions that print useful logs to a file \"/tmp/logs/1697.txt\". The logs should contain the control path and state information of the violation scenario. If test code is not required to validate the scenario, you can leave this blank.\nHere are the constraints for the test code:\n- The test code MUST preserve the original logic of MHD_uint32_to_strx as much as possible.\nYou CAN just insert probe functions to the original code.\n- DO NOT introduce new violations to demonstrate your scenario.\n- The test code MUST be compilable and executable.\n- The test code MUST include line breaks.\n- You MUST NOT define the main function.\n- You MUST NOT define macros.\n</response format>\n<target_code>\nHere is the code of MHD_uint32_to_strx:\n```c\nsize_t\nMHD_uint32_to_strx (uint32_t val,\n                    char *buf,\n                    size_t buf_size)\n{\n  size_t o_pos = 0; /**< position of the output character */\n  int digit_pos = 8; /** zero-based, digit position in @a 'val' */\n  int digit;\n\n  /* Skip leading zeros */\n  do\n  {\n    digit_pos--;\n    digit = (int) (val >> 28);\n    val <<= 4;\n  } while ((0 == digit) && (0 != digit_pos));\n\n  while (o_pos < buf_size)\n  {\n    buf[o_pos++] =\n      (char) ((digit <= 9) ?\n              ('0' + (char) digit) :\n              ('A' + (char) digit - 10));\n    if (0 == digit_pos)\n      return o_pos;\n    digit_pos--;\n    digit = (int) (val >> 28);\n    val <<= 4;\n  }\n  return 0; /* The buffer is too small */\n}\n```\n</target_code>\nPlease provide the modified MHD_uint32_to_strx code.\n",
  "test_code": "#include <stdio.h>\n#include <stdint.h>\n#include <stddef.h>\n\n/* Probe helpers: append logs to /tmp/logs/1697.txt to record control flow\n   and state needed to reproduce the violation (modification of the\n   function parameter 'val' via shifts). These helpers keep the original\n   behavior of MHD_uint32_to_strx unchanged. */\nstatic void probe_log_state(const char *stage,\n                            uint32_t val,\n                            int digit_pos,\n                            int digit,\n                            size_t o_pos,\n                            size_t buf_size,\n                            const char *buf_ptr)\n{\n  FILE *f = fopen(\"/tmp/logs/1697.txt\", \"a\");\n  if (f != NULL)\n  {\n    fprintf(f, \"STAGE=%s: val=0x%08X (%u), digit_pos=%d, digit=%d, o_pos=%zu, buf_size=%zu, buf=%s\\n\",\n            stage,\n            (unsigned) val,\n            (unsigned) val,\n            digit_pos,\n            digit,\n            o_pos,\n            buf_size,\n            (buf_ptr != NULL) ? buf_ptr : \"(null)\");\n    fclose(f);\n  }\n}\n\nstatic void probe_log_msg(const char *msg)\n{\n  FILE *f = fopen(\"/tmp/logs/1697.txt\", \"a\");\n  if (f != NULL)\n  {\n    fprintf(f, \"%s\\n\", msg);\n    fclose(f);\n  }\n}\n\nsize_t\nMHD_uint32_to_strx (uint32_t val,\n                    char *buf,\n                    size_t buf_size)\n{\n  size_t o_pos = 0; /**< position of the output character */\n  int digit_pos = 8; /** zero-based, digit position in @a 'val' */\n  int digit;\n\n  /* Log function entry state (captures original parameter value) */\n  probe_log_state(\"entry\", val, digit_pos, -1, o_pos, buf_size, buf);\n\n  /* Skip leading zeros */\n  do\n  {\n    digit_pos--;\n    digit = (int) (val >> 28);\n    /* Log after computing digit but before shifting to show value used */\n    probe_log_state(\"do-after-digit-before-shift\", val, digit_pos, digit, o_pos, buf_size, buf);\n    val <<= 4; /* This is the parameter modification reported as the violation */\n    /* Log after the shift to show the parameter has been modified */\n    probe_log_state(\"do-after-shift\", val, digit_pos, digit, o_pos, buf_size, buf);\n  } while ((0 == digit) && (0 != digit_pos));\n\n  /* Log state after skipping leading zeros */\n  probe_log_state(\"after-skip-leading-zeros\", val, digit_pos, digit, o_pos, buf_size, buf);\n\n  while (o_pos < buf_size)\n  {\n    buf[o_pos++] =\n      (char) ((digit <= 9) ?\n              ('0' + (char) digit) :\n              ('A' + (char) digit - 10));\n    /* Log each character written and the buffer position */\n    probe_log_state(\"after-write-char\", val, digit_pos, digit, o_pos, buf_size, buf);\n    if (0 == digit_pos)\n    {\n      /* Log before successful return */\n      probe_log_state(\"return-success\", val, digit_pos, digit, o_pos, buf_size, buf);\n      return o_pos;\n    }\n    digit_pos--;\n    digit = (int) (val >> 28);\n    /* Log before performing the next shift */\n    probe_log_state(\"while-after-digit-before-shift\", val, digit_pos, digit, o_pos, buf_size, buf);\n    val <<= 4; /* Parameter modification occurs repeatedly as in original logic */\n    probe_log_state(\"while-after-shift\", val, digit_pos, digit, o_pos, buf_size, buf);\n  }\n\n  /* Log buffer-too-small case before returning 0 */\n  probe_log_state(\"return-buffer-too-small\", val, digit_pos, digit, o_pos, buf_size, buf);\n  return 0; /* The buffer is too small */\n}\n"
}