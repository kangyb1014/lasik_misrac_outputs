{
  "user_message": "An agent A claimed that the following internal_add_connection code violates the MISRA C 2023 rule 8.13.\n<misra_rule>\nMISRA C 2023 Rule 8.13 is A pointer should point to a const-qualified type whenever possible.\n\n</misra_rule>\n<target_code>\nHere is the original code of internal_add_connection.\n```c\nstatic enum MHD_Result\ninternal_add_connection (struct MHD_Daemon *daemon,\n                         MHD_socket client_socket,\n                         const struct sockaddr_storage *addr,\n                         socklen_t addrlen,\n                         bool external_add,\n                         bool non_blck,\n                         bool sk_spipe_supprs,\n                         enum MHD_tristate sk_is_nonip)\n{\n  struct MHD_Connection *connection;\n\n#if defined(MHD_USE_POSIX_THREADS) || defined(MHD_USE_W32_THREADS)\n  /* Direct add to master daemon could never happen. */\n  mhd_assert (NULL == daemon->worker_pool);\n#endif\n\n  if (MHD_D_IS_USING_SELECT_ (daemon) &&\n      (! MHD_D_DOES_SCKT_FIT_FDSET_ (client_socket, daemon)) )\n  {\n#ifdef HAVE_MESSAGES\n    MHD_DLOG (daemon,\n              _ (\"New connection socket descriptor (%d) is not less \" \\\n                 \"than FD_SETSIZE (%d).\\n\"),\n              (int) client_socket,\n              (int) MHD_D_GET_FD_SETSIZE_ (daemon));\n#endif\n    MHD_socket_close_chk_ (client_socket);\n#if defined(ENFILE) && (ENFILE + 0 != 0)\n    errno = ENFILE;\n#endif\n    return MHD_NO;\n  }\n\n  if (MHD_D_IS_USING_EPOLL_ (daemon) &&\n      (! non_blck) )\n  {\n#ifdef HAVE_MESSAGES\n    MHD_DLOG (daemon,\n              _ (\"Epoll mode supports only non-blocking sockets\\n\"));\n#endif\n    MHD_socket_close_chk_ (client_socket);\n#if defined(EINVAL) && (EINVAL + 0 != 0)\n    errno = EINVAL;\n#endif\n    return MHD_NO;\n  }\n\n  connection = new_connection_prepare_ (daemon,\n                                        client_socket,\n                                        addr, addrlen,\n                                        external_add,\n                                        non_blck,\n                                        sk_spipe_supprs,\n                                        sk_is_nonip);\n  if (NULL == connection)\n    return MHD_NO;\n\n  if ((external_add) &&\n      MHD_D_IS_THREAD_SAFE_ (daemon))\n  {\n    /* Connection is added externally and MHD is thread safe mode. */\n    MHD_mutex_lock_chk_ (&daemon->new_connections_mutex);\n    DLL_insert (daemon->new_connections_head,\n                daemon->new_connections_tail,\n                connection);\n    daemon->have_new = true;\n    MHD_mutex_unlock_chk_ (&daemon->new_connections_mutex);\n\n    /* The rest of connection processing must be handled in\n     * the daemon thread. */\n    if ((MHD_ITC_IS_VALID_ (daemon->itc)) &&\n        (! MHD_itc_activate_ (daemon->itc, \"n\")))\n    {\n#ifdef HAVE_MESSAGES\n      MHD_DLOG (daemon,\n                _ (\"Failed to signal new connection via inter-thread \" \\\n                   \"communication channel.\\n\"));\n#endif\n    }\n    return MHD_YES;\n  }\n\n  return new_connection_process_ (daemon, connection);\n}\n```\n</target_code>\n<response format>\nProvide your answer with these fields.\n- explanation: your evaluation of the scenario provided by the agent A.\n- is_report_correct: whether the report is correct or not (true/false). True means there is a violation.\n</response format>\n<scenario>\nThe agent A provided the following violation scenario:\nIf the function MHD_itc_activate_ is declared with a non-const pointer parameter for the second argument (e.g. char * or void *), then passing the string literal \"n\" means a pointer is used that is not const-qualified even though the pointed object is not intended to be modified. That violates MISRA C 2023 Rule 8.13. The fix is to declare the parameter as const char * (or const void *) so the pointer points to a const-qualified type.\n</scenario>\n\n<execution_log>\nThe agent A also provided the following output log:\ninternal_add_connection: entry: daemon=0x555946b758d0, client_socket=5, addr=0x7ffcf0752fc0, addrlen=16, external_add=0, non_blck=1, sk_spipe_supprs=0, sk_is_nonip=0\ninternal_add_connection: new_connection_prepare_ returned connection=0x555946b763c0\ninternal_add_connection: passing connection to new_connection_process_: connection=0x555946b763c0\ninternal_add_connection: new_connection_process_ returned 1 -> returning to caller\ninternal_add_connection: entry: daemon=0x555946b758d0, client_socket=5, addr=0x7ffcf0752fc0, addrlen=16, external_add=0, non_blck=1, sk_spipe_supprs=0, sk_is_nonip=0\ninternal_add_connection: new_connection_prepare_ returned connection=0x555946b77670\ninternal_add_connection: passing connection to new_connection_process_: connection=0x555946b77670\ninternal_add_connection: new_connection_process_ returned 1 -> returning to caller\ninternal_add_connection: entry: daemon=0x555946b758d0, client_socket=5, addr=0x7ffcf0752fc0, addrlen=16, external_add=0, non_blck=1, sk_spipe_supprs=0, sk_is_nonip=0\ninternal_add_connection: new_connection_prepare_ returned connection=0x555946b778c0\ninternal_add_connection: passing connection to new_connection_process_: connection=0x555946b778c0\ninternal_add_connection: new_connection_process_ returned 1 -> returning to caller\ninternal_add_connection: entry: daemon=0x555946b758d0, client_socket=5, addr=0x7ffcf0752fc0, addrlen=16, external_add=0, non_blck=1, sk_spipe_supprs=0, sk_is_nonip=0\ninternal_add_connection: new_connection_prepare_ returned connection=0x555946b77b10\ninternal_add_connection: passing connection to new_connection_process_: connection=0x555946b77b10\ninternal_add_connection: new_connection_process_ returned 1 -> returning to caller\ninternal_add_connection: entry: daemon=0x555946b758d0, client_socket=5, addr=0x7ffcf0752fc0, addrlen=16, external_add=0, non_blck=1, sk_spipe_supprs=0, sk_is_nonip=0\ninternal_add_connection: new_connection_prepare_ returned connection=0x555946b77d60\ninternal_add_connection: passing connection to new_connection_process_: connection=0x555946b77d60\ninternal_add_connection: new_connection_process_ returned 1 -> returning to caller\ninternal_add_connection: entry: daemon=0x555946b758d0, client_socket=5, addr=0x7ffcf0752fc0, addrlen=16, external_add=0, non_blck=1, sk_spipe_supprs=0, sk_is_nonip=0\ninternal_add_connection: new_connection_prepare_ returned connection=0x555946b77fb0\ninternal_add_connection: passing connection to new_connection_process_: connection=0x555946b77fb0\ninternal_add_connection: new_connection_process_ returned 1 -> returning to caller\ninternal_add_connection: entry: daemon=0x555946b758d0, client_socket=5, addr=0x7ffcf0752fc0, addrlen=16, external_add=0, non_blck=1, sk_spipe_supprs=0, sk_is_nonip=0\ninternal_add_connection: new_connection_prepare_ returned connection=0x555946b78200\ninternal_add_connection: passing connection to new_connection_process_: connection=0x555946b78200\ninternal_add_connection: new_connection_process_ returned 1 -> returning to caller\ninternal_add_connection: entry: daemon=0x555946b758d0, client_socket=5, addr=0x7ffcf0752fc0, addrlen=16, external_add=0, non_blck=1, sk_spipe_supprs=0, sk_is_nonip=0\ninternal_add_connection: new_connection_prepare_ returned connection=0x555946b78450\ninternal_add_connection: passing connection to new_connection_process_: connection=0x555946b78450\ninternal_add_connection: new_connection_process_ returned 1 -> returning to caller\ninternal_add_connection: entry: daemon=0x555946b758d0, client_socket=5, addr=0x7ffcf0752fc0, addrlen=16, external_add=0, non_blck=1, sk_spipe_supprs=0, sk_is_nonip=0\ninternal_add_connection: new_connection_prepare_ returned connection=0x555946b78450\ninternal_add_connection: passing connection to new_connection_process_: connection=0x555946b78450\ninternal_add_connection: new_connection_process_ returned 1 -> returning to caller\ninternal_add_connection: entry: daemon=0x555946b758d0, client_socket=5, addr=0x7ffcf0752fc0, addrlen=16, external_add=0, non_blck=1, sk_spipe_supprs=0, sk_is_nonip=0\ninternal_add_connection: new_connection_prepare_ re\n</execution_log>\n\n<instruction>\nJudge whether the report is correct or not.\n</instruction>\n",
  "is_report_correct": false,
  "explanation": "Agent A's underlying point is sensible (passing a string literal such as \"n\" should use a const-qualified pointer), but the report as stated is not correct. Rule 8.13 concerns pointer declarations (a pointer should point to a const-qualified type when possible). The shown internal_add_connection function merely calls MHD_itc_activate_(daemon->itc, \"n\"); the MISRA violation would only exist if the prototype of MHD_itc_activate_ declares its parameter as a non-const pointer (e.g. char * or void *) while the function does not need to modify the pointed data. In other words, the problem, if any, is in the declaration/definition of MHD_itc_activate_, not in the body of internal_add_connection shown here. Without the callee's declaration we cannot conclude that internal_add_connection itself violates Rule 8.13. The correct fix (if the callee indeed takes a non-const pointer but does not modify the data) is to change the callee parameter to const char * (or const void *)."
}