{
  "user_message": "<misra_rule>\nMISRA C 2023 Rule 21.17 is: Use of the string handling functions from <string.h> shall not result in accesses beyond the bounds of the objects referenced by their pointer parameters.\nThis rule strictly applies to the Standard Library functions in <string.h> such as memcpy, memmove, memset, memcmp, strcpy, strncpy, strcat, strncat, strlen, and strspn.\n</misra_rule>\n<response format>\nProvide your answer with these fields.\n- is_rule_violated: whether the rule is violated or not (true/false),\n- scenario: a specific violation scenario.\n</response format>\n<target_code>\nHere is the code of MHD_ip_addr_to_key:\n```c\nstatic enum MHD_Result\nMHD_ip_addr_to_key (const struct sockaddr_storage *addr,\n                    socklen_t addrlen,\n                    struct MHD_IPCount *key)\n{\n  memset (key,\n          0,\n          sizeof(*key));\n\n  /* IPv4 addresses */\n  if (sizeof (struct sockaddr_in) <= (size_t) addrlen)\n  {\n    if (AF_INET == addr->ss_family)\n    {\n      key->family = AF_INET;\n      memcpy (&key->addr.ipv4,\n              &((const struct sockaddr_in *) addr)->sin_addr,\n              sizeof(((const struct sockaddr_in *) NULL)->sin_addr));\n      return MHD_YES;\n    }\n  }\n\n#ifdef HAVE_INET6\n  if (sizeof (struct sockaddr_in6) <= (size_t) addrlen)\n  {\n    /* IPv6 addresses */\n    if (AF_INET6 == addr->ss_family)\n    {\n      key->family = AF_INET6;\n      memcpy (&key->addr.ipv6,\n              &((const struct sockaddr_in6 *) addr)->sin6_addr,\n              sizeof(((const struct sockaddr_in6 *) NULL)->sin6_addr));\n      return MHD_YES;\n    }\n  }\n#endif\n\n  /* Some other address */\n  return MHD_NO;\n}\n```\n</target_code>\n<target_code>\nHere is the code fragment that you need to analyze:\n```c\n#ifdef HAVE_INET6\n```\nFocus on the above code fragment and judge whether it violates the rule 21.17 or not.\n</target_code>\n",
  "is_rule_violated": false,
  "scenario": "No violation. The #ifdef HAVE_INET6 is a compile-time inclusion guard and by itself does not cause any string.h function to access out-of-bounds memory. The IPv6 memcpy is only compiled when HAVE_INET6 is defined and, in the shown code, is protected at run-time by the checks sizeof(struct sockaddr_in6) <= (size_t)addrlen and addr->ss_family == AF_INET6 before the memcpy, so no out-of-bounds access occurs. A violation would occur only if those runtime checks were removed or bypassed (e.g. omission of the addrlen or family checks), not because of the #ifdef fragment itself."
}