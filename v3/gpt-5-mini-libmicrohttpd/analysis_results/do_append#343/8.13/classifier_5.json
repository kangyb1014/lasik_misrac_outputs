{
  "user_message": "<misra_rule>\nMISRA C 2023 Rule 8.13 is: A pointer should point to a const-qualified type whenever possible.\n\n</misra_rule>\n<response format>\nProvide your answer with these fields.\n- is_rule_violated: whether the rule is violated or not (true/false),\n- scenario: a specific violation scenario.\n</response format>\n<target_code>\nHere is the code of do_append:\n```c\nstatic enum MHD_Result\ndo_append (char **ret,\n           const char *data,\n           size_t size)\n{\n  char *buf;\n  size_t old_len;\n\n  if (NULL == *ret)\n    old_len = 0;\n  else\n    old_len = strlen (*ret);\n  if (NULL == (buf = malloc (old_len + size + 1)))\n    return MHD_NO;\n  if (NULL != *ret)\n  {\n    memcpy (buf,\n            *ret,\n            old_len);\n    free (*ret);\n  }\n  memcpy (&buf[old_len],\n          data,\n          size);\n  buf[old_len + size] = '\\0';\n  *ret = buf;\n  return MHD_YES;\n}\n```\n</target_code>\n<target_code>\nHere is the code fragment that you need to analyze:\n```c\nfree (*ret);\n```\nFocus on the above code fragment and judge whether it violates the rule 8.13 or not.\n</target_code>\n",
  "is_rule_violated": false,
  "scenario": "Not violated. In do_append the object pointed to by *ret is deallocated (free(*ret)) and the pointer itself is updated (*ret = buf). Because the function must pass the pointer to free (which expects a non-const void*) and must update the stored pointer, the pointed-to type cannot practically be made const here without unsafe casts. If the code only read from *ret and never freed or reassigned it, then leaving the pointee non-const would be a violation of R8.13."
}