{
  "user_message": "An agent A claimed that the following do_append code violates the MISRA C 2023 rule 2.2.\n<misra_rule>\nMISRA C 2023 Rule 2.2 is A project shall not contain dead code.\nAny operation that is executed but whose removal would not affect program behaviour constitutes dead code. Notes:\n1. The behaviour of an embedded sytem is often determined not just by the nature of its actions, but also by the time at which they occur.\n2. unreachable code is not dead code, as it cannot be executed.\n3.Initialization is not the same as an assignment operation and is therfore not a candidate for dead code.\n</misra_rule>\n<target_code>\nHere is the original code of do_append.\n```c\nstatic enum MHD_Result\ndo_append (char **ret,\n           const char *data,\n           size_t size)\n{\n  char *buf;\n  size_t old_len;\n\n  if (NULL == *ret)\n    old_len = 0;\n  else\n    old_len = strlen (*ret);\n  if (NULL == (buf = malloc (old_len + size + 1)))\n    return MHD_NO;\n  if (NULL != *ret)\n  {\n    memcpy (buf,\n            *ret,\n            old_len);\n    free (*ret);\n  }\n  memcpy (&buf[old_len],\n          data,\n          size);\n  buf[old_len + size] = '\\0';\n  *ret = buf;\n  return MHD_YES;\n}\n```\n</target_code>\n<response format>\nProvide your answer with these fields.\n- explanation: your evaluation of the scenario provided by the agent A.\n- is_report_correct: whether the report is correct or not (true/false). True means there is a violation.\n</response format>\n<scenario>\nThe agent A provided the following violation scenario:\nIf *ret points to an allocated empty string (\"\"), then old_len == 0 while *ret != NULL. In that case memcpy(buf, *ret, old_len) is executed with size 0 (a no-op); removing that memcpy call would not affect program behaviour, so the operation is dead code in that execution scenario. A simple fix is to guard the copy with if (old_len > 0) before calling memcpy.\n</scenario>\n\n<instruction>\nJudge whether the report is correct or not.\n</instruction>\n",
  "is_report_correct": false,
  "explanation": "The report is not correct. MISRA 2.2 targets operations that are superfluous in all executions (i.e. their removal would not change program behaviour). The memcpy here is required when old_len > 0 (it performs the actual copy). In the particular execution where old_len == 0 the call is a no\u2011op, but being a no\u2011op in some executions does not automatically make it dead code. Removing the call could change timing (note 1 of the rule) or other observable behaviour in an embedded context, so it is not safe to claim it is dead in the general sense MISRA uses. Guarding the copy with if (old_len > 0) is a valid micro\u2011optimization, but the unconditional memcpy is not by itself a MISRA 2.2 violation."
}