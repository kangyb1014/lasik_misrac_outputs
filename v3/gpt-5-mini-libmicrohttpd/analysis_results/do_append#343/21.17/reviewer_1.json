{
  "user_message": "An agent A claimed that the following do_append code violates the MISRA C 2023 rule 21.17.\n<misra_rule>\nMISRA C 2023 Rule 21.17 is Use of the string handling functions from <string.h> shall not result in accesses beyond the bounds of the objects referenced by their pointer parameters.\nThis rule strictly applies to the Standard Library functions in <string.h> such as memcpy, memmove, memset, memcmp, strcpy, strncpy, strcat, strncat, strlen, and strspn.\n</misra_rule>\n<target_code>\nHere is the original code of do_append.\n```c\nstatic enum MHD_Result\ndo_append (char **ret,\n           const char *data,\n           size_t size)\n{\n  char *buf;\n  size_t old_len;\n\n  if (NULL == *ret)\n    old_len = 0;\n  else\n    old_len = strlen (*ret);\n  if (NULL == (buf = malloc (old_len + size + 1)))\n    return MHD_NO;\n  if (NULL != *ret)\n  {\n    memcpy (buf,\n            *ret,\n            old_len);\n    free (*ret);\n  }\n  memcpy (&buf[old_len],\n          data,\n          size);\n  buf[old_len + size] = '\\0';\n  *ret = buf;\n  return MHD_YES;\n}\n```\n</target_code>\n<response format>\nProvide your answer with these fields.\n- explanation: your evaluation of the scenario provided by the agent A.\n- is_report_correct: whether the report is correct or not (true/false). True means there is a violation.\n</response format>\n<scenario>\nThe agent A provided the following violation scenario:\nIf *ret is non-NULL but does not point to a valid NUL-terminated character array (for example it points to a buffer without a terminating '\\0' or to memory smaller than the strlen scan), calling strlen(*ret) may read past the object bounds and thus violate Rule 21.17.\n</scenario>\n\n<instruction>\nJudge whether the report is correct or not.\n</instruction>\n",
  "is_report_correct": true,
  "explanation": "Agent A's scenario is correct as a potential MISRA C 2023 Rule 21.17 violation. The code calls strlen(*ret) whenever *ret != NULL; strlen requires that the object pointed to by *ret be a NUL-terminated character array. If *ret is non-NULL but does not actually point to a NUL-terminated buffer (or the allocated object is smaller than the extent strlen scans), strlen may read past the object's bounds, which is exactly what Rule 21.17 forbids. \n\nThat said, this is a potential/contract issue rather than an intrinsic syntactic misuse: if the surrounding code/module guarantees the invariant \u201c*ret is either NULL or points to a valid NUL-terminated string\u201d then the call is safe and there is no violation. Because that invariant is not established in the shown function, the agent's report that a violation can occur is correct. \n\n(Also note: memcpy(buf + old_len, data, size) likewise requires that data points to at least size accessible bytes \u2014 a separate potential bounds issue if that contract is not met.)"
}