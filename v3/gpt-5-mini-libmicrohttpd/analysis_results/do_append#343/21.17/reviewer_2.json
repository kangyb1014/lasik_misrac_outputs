{
  "user_message": "An agent A claimed that the following do_append code violates the MISRA C 2023 rule 21.17.\n<misra_rule>\nMISRA C 2023 Rule 21.17 is Use of the string handling functions from <string.h> shall not result in accesses beyond the bounds of the objects referenced by their pointer parameters.\nThis rule strictly applies to the Standard Library functions in <string.h> such as memcpy, memmove, memset, memcmp, strcpy, strncpy, strcat, strncat, strlen, and strspn.\n</misra_rule>\n<target_code>\nHere is the original code of do_append.\n```c\nstatic enum MHD_Result\ndo_append (char **ret,\n           const char *data,\n           size_t size)\n{\n  char *buf;\n  size_t old_len;\n\n  if (NULL == *ret)\n    old_len = 0;\n  else\n    old_len = strlen (*ret);\n  if (NULL == (buf = malloc (old_len + size + 1)))\n    return MHD_NO;\n  if (NULL != *ret)\n  {\n    memcpy (buf,\n            *ret,\n            old_len);\n    free (*ret);\n  }\n  memcpy (&buf[old_len],\n          data,\n          size);\n  buf[old_len + size] = '\\0';\n  *ret = buf;\n  return MHD_YES;\n}\n```\n</target_code>\n<response format>\nProvide your answer with these fields.\n- explanation: your evaluation of the scenario provided by the agent A.\n- is_report_correct: whether the report is correct or not (true/false). True means there is a violation.\n</response format>\n<scenario>\nThe agent A provided the following violation scenario:\nYes. The destination buffer is allocated with old_len + size + 1 so the write side (&buf[old_len], size) is safe, but the source side is not guaranteed safe. If data points into the original *ret buffer (for example data == *ret + k) the code frees(*ret) before the memcpy, so memcpy reads from freed/dangling memory (undefined) and thus may access beyond the bounds/lifetime of the object. Also, if the caller-provided data does not actually point to at least size bytes, memcpy will read past the source object. Either case violates MISRA C 2023 Rule 21.17.\n</scenario>\n\n<instruction>\nJudge whether the report is correct or not.\n</instruction>\n",
  "is_report_correct": true,
  "explanation": "Agent A is correct. The first memcpy(buf, *ret, old_len) is safe (it copies from *ret before free), and the destination allocations are sized correctly. However, the second call memcpy(&buf[old_len], data, size) can read from memory that is no longer valid in at least two plausible scenarios: (1) if data points into the original *ret buffer (e.g. data == *ret + k), the code frees *ret before performing the second memcpy, so memcpy would read from freed/dangling memory (undefined behavior); (2) if the caller does not guarantee that data points to at least size bytes (or data is NULL when size>0), memcpy may read beyond the source object. Both situations violate MISRA C 2023 Rule 21.17 because the use of memcpy can result in accesses outside the bounds/lifetime of the referenced objects. To fix this, copy the data into the new buffer while the source is still valid (for example perform the second memcpy before free(*ret)), or otherwise ensure the caller contract prevents these cases or adjust the implementation to handle overlapping/aliasing safely."
}