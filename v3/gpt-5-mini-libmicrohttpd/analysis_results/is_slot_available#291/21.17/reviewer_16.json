{
  "user_message": "An agent A claimed that the following is_slot_available code violates the MISRA C 2023 rule 21.17.\n<misra_rule>\nMISRA C 2023 Rule 21.17 is Use of the string handling functions from <string.h> shall not result in accesses beyond the bounds of the objects referenced by their pointer parameters.\nThis rule strictly applies to the Standard Library functions in <string.h> such as memcpy, memmove, memset, memcmp, strcpy, strncpy, strcat, strncat, strlen, and strspn.\n</misra_rule>\n<target_code>\nHere is the original code of is_slot_available.\n```c\nstatic bool\nis_slot_available (const struct MHD_NonceNc *const nn,\n                   const uint64_t now,\n                   const char *const new_nonce,\n                   size_t new_nonce_len)\n{\n  uint64_t timestamp;\n  bool timestamp_valid;\n  mhd_assert (new_nonce_len <= NONCE_STD_LEN (MAX_DIGEST));\n  mhd_assert (NONCE_STD_LEN (MAX_DIGEST) <= MAX_DIGEST_NONCE_LENGTH);\n  if (0 == nn->nonce[0])\n    return true; /* The slot is empty */\n\n  if (0 == memcmp (nn->nonce, new_nonce, new_nonce_len))\n  {\n    /* The slot has the same nonce already. This nonce cannot be registered\n     * again as it would just clear 'nc' usage history. */\n    return false;\n  }\n\n  if (0 != nn->nc)\n    return true; /* Client already used the nonce in this slot at least\n                    one time, re-use the slot */\n\n  /* The nonce must be zero-terminated */\n  mhd_assert (0 == nn->nonce[sizeof(nn->nonce) - 1]);\n  if (0 != nn->nonce[sizeof(nn->nonce) - 1])\n    return true; /* Wrong nonce format in the slot */\n\n  timestamp_valid = get_nonce_timestamp (nn->nonce, 0, &timestamp);\n  mhd_assert (timestamp_valid);\n  if (! timestamp_valid)\n    return true; /* Invalid timestamp in nonce-nc, should not be possible */\n\n  if ((REUSE_TIMEOUT * 1000) < TRIM_TO_TIMESTAMP (now - timestamp))\n    return true;\n\n  return false;\n}\n```\n</target_code>\n<response format>\nProvide your answer with these fields.\n- explanation: your evaluation of the scenario provided by the agent A.\n- is_report_correct: whether the report is correct or not (true/false). True means there is a violation.\n</response format>\n<scenario>\nThe agent A provided the following violation scenario:\nThe code asserts new_nonce_len <= NONCE_STD_LEN(MAX_DIGEST) but memcmp(nn->nonce, new_nonce, new_nonce_len) is called before any check that nn->nonce (or new_nonce) actually contains at least new_nonce_len bytes. The assertion only constrains new_nonce_len relative to NONCE_STD_LEN(MAX_DIGEST) (and can be compiled out), not relative to sizeof(nn->nonce) or the actual buffer length of new_nonce. Example violation: if NONCE_STD_LEN(MAX_DIGEST) == 32 and sizeof(nn->nonce) == 16, a new_nonce_len of 24 satisfies the assertion but causes memcmp to read beyond nn->nonce bounds (reads bytes 16..23), violating Rule 21.17.\n</scenario>\n\n<execution_log>\nThe agent A also provided the following output log:\n[entry] nn=0x55cc8cdb32b0 new_nonce=0x7fd15c008f03 new_nonce_len=44 nonce_array_size=77 nn->nonce[0]=0 nn->nonce[last]=0 nn->nc=0 now=914\n[empty_slot_return_true] nn=0x55cc8cdb32b0 new_nonce=0x7fd15c008f03 new_nonce_len=44 nonce_array_size=77 nn->nonce[0]=0 nn->nonce[last]=0 nn->nc=0 now=914\n[entry] nn=0x55af4b680370 new_nonce=0x7f5400008f07 new_nonce_len=76 nonce_array_size=77 nn->nonce[0]=0 nn->nonce[last]=0 nn->nc=0 now=946\n[empty_slot_return_true] nn=0x55af4b680370 new_nonce=0x7f5400008f07 new_nonce_len=76 nonce_array_size=77 nn->nonce[0]=0 nn->nonce[last]=0 nn->nc=0 now=946\n\n</execution_log>\n\n<instruction>\nJudge whether the report is correct or not.\n</instruction>\n",
  "is_report_correct": true,
  "explanation": "Agent A is correct. memcmp(nn->nonce, new_nonce, new_nonce_len) reads new_nonce_len bytes from both pointer arguments. In the shown code there is no preceding check that nn->nonce (or the caller-supplied new_nonce buffer) actually contains at least new_nonce_len bytes. The only related asserts constrain new_nonce_len relative to NONCE_STD_LEN(MAX_DIGEST) (and that value relative to MAX_DIGEST_NONCE_LENGTH), but those asserts can be compiled out and do not, in the code shown, prove at the point of the call that sizeof(nn->nonce) >= new_nonce_len or that new_nonce points to new_nonce_len bytes. The later assertion that the last byte of nn->nonce is zero occurs after the memcmp, so it does not prevent an out-of-bounds access. Therefore the use of memcmp can result in accesses beyond the bounds of the objects referenced by the pointer parameters and so violates MISRA C 2023 Rule 21.17. A correct fix is to ensure (by a runtime check or a compile-time/static assertion on array sizes) that new_nonce_len <= sizeof nn->nonce and that the caller guarantees new_nonce has at least new_nonce_len bytes before calling memcmp."
}