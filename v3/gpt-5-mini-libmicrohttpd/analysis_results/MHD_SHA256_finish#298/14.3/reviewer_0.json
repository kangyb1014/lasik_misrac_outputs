{
  "user_message": "An agent A claimed that the following MHD_SHA256_finish code violates the MISRA C 2023 rule 14.3.\n<misra_rule>\nMISRA C 2023 Rule 14.3 is Controlling expressions shall not be invariant.\nHere are exceptions to this rule:\n1. Invariants that are used to create infinite loops are permitted.\n2. A do-while loop with an essentially Boolean controlling expression that evaluates to false and satisfies the constraints and semantics for an integer constant expression is permitted.\n</misra_rule>\n<target_code>\nHere is the original code of MHD_SHA256_finish.\n```c\nvoid\nMHD_SHA256_finish (struct Sha256Ctx *ctx,\n                   uint8_t digest[SHA256_DIGEST_SIZE])\n{\n  uint64_t num_bits;   /**< Number of processed bits */\n  unsigned bytes_have; /**< Number of bytes in buffer */\n\n  num_bits = ctx->count << 3;\n  /* Note: (count & (SHA256_BLOCK_SIZE-1))\n           equal (count % SHA256_BLOCK_SIZE) for this block size. */\n  bytes_have = (unsigned) (ctx->count & (SHA256_BLOCK_SIZE - 1));\n\n  /* Input data must be padded with a single bit \"1\", then with zeros and\n     the finally the length of data in bits must be added as the final bytes\n     of the last block.\n     See FIPS PUB 180-4 paragraph 5.1.1. */\n\n  /* Data is always processed in form of bytes (not by individual bits),\n     therefore position of first padding bit in byte is always\n     predefined (0x80). */\n  /* Buffer always have space at least for one byte (as full buffers are\n     processed immediately). */\n  ((uint8_t *) ctx->buffer)[bytes_have++] = 0x80;\n\n  if (SHA256_BLOCK_SIZE - bytes_have < SHA256_SIZE_OF_LEN_ADD)\n  {   /* No space in current block to put total length of message.\n         Pad current block with zeros and process it. */\n    if (bytes_have < SHA256_BLOCK_SIZE)\n      memset (((uint8_t *) ctx->buffer) + bytes_have, 0,\n              SHA256_BLOCK_SIZE - bytes_have);\n    /* Process full block. */\n    sha256_transform (ctx->H, ctx->buffer);\n    /* Start new block. */\n    bytes_have = 0;\n  }\n\n  /* Pad the rest of the buffer with zeros. */\n  memset (((uint8_t *) ctx->buffer) + bytes_have, 0,\n          SHA256_BLOCK_SIZE - SHA256_SIZE_OF_LEN_ADD - bytes_have);\n  /* Put the number of bits in processed message as big-endian value. */\n  _MHD_PUT_64BIT_BE_SAFE (ctx->buffer + SHA256_BLOCK_SIZE_WORDS - 2, num_bits);\n  /* Process full final block. */\n  sha256_transform (ctx->H, ctx->buffer);\n\n  /* Put final hash/digest in BE mode */\n#ifndef _MHD_PUT_32BIT_BE_UNALIGNED\n  if (1\n#ifndef MHD_FAVOR_SMALL_CODE\n      && (0 != ((uintptr_t) digest) % _MHD_UINT32_ALIGN)\n#endif /* MHD_FAVOR_SMALL_CODE */\n      )\n  {\n    /* If storing of the final result requires aligned address and\n       the destination address is not aligned or compact code is used,\n       store the final digest in aligned temporary buffer first, then\n       copy it to the destination. */\n    uint32_t alig_dgst[SHA256_DIGEST_SIZE_WORDS];\n    _MHD_PUT_32BIT_BE (alig_dgst + 0, ctx->H[0]);\n    _MHD_PUT_32BIT_BE (alig_dgst + 1, ctx->H[1]);\n    _MHD_PUT_32BIT_BE (alig_dgst + 2, ctx->H[2]);\n    _MHD_PUT_32BIT_BE (alig_dgst + 3, ctx->H[3]);\n    _MHD_PUT_32BIT_BE (alig_dgst + 4, ctx->H[4]);\n    _MHD_PUT_32BIT_BE (alig_dgst + 5, ctx->H[5]);\n    _MHD_PUT_32BIT_BE (alig_dgst + 6, ctx->H[6]);\n    _MHD_PUT_32BIT_BE (alig_dgst + 7, ctx->H[7]);\n    /* Copy result to unaligned destination address */\n    memcpy (digest, alig_dgst, SHA256_DIGEST_SIZE);\n  }\n#ifndef MHD_FAVOR_SMALL_CODE\n  else /* Combined with the next 'if' */\n#endif /* MHD_FAVOR_SMALL_CODE */\n#endif /* ! _MHD_PUT_32BIT_BE_UNALIGNED */\n#if ! defined(MHD_FAVOR_SMALL_CODE) || defined(_MHD_PUT_32BIT_BE_UNALIGNED)\n  if (1)\n  {\n    /* Use cast to (void*) here to mute compiler alignment warnings.\n     * Compilers are not smart enough to see that alignment has been checked. */\n    _MHD_PUT_32BIT_BE ((void *) (digest + 0 * SHA256_BYTES_IN_WORD), ctx->H[0]);\n    _MHD_PUT_32BIT_BE ((void *) (digest + 1 * SHA256_BYTES_IN_WORD), ctx->H[1]);\n    _MHD_PUT_32BIT_BE ((void *) (digest + 2 * SHA256_BYTES_IN_WORD), ctx->H[2]);\n    _MHD_PUT_32BIT_BE ((void *) (digest + 3 * SHA256_BYTES_IN_WORD), ctx->H[3]);\n    _MHD_PUT_32BIT_BE ((void *) (digest + 4 * SHA256_BYTES_IN_WORD), ctx->H[4]);\n    _MHD_PUT_32BIT_BE ((void *) (digest + 5 * SHA256_BYTES_IN_WORD), ctx->H[5]);\n    _MHD_PUT_32BIT_BE ((void *) (digest + 6 * SHA256_BYTES_IN_WORD), ctx->H[6]);\n    _MHD_PUT_32BIT_BE ((void *) (digest + 7 * SHA256_BYTES_IN_WORD), ctx->H[7]);\n  }\n#endif /* ! MHD_FAVOR_SMALL_CODE || _MHD_PUT_32BIT_BE_UNALIGNED */\n\n  /* Erase potentially sensitive data. */\n  memset (ctx, 0, sizeof(struct Sha256Ctx));\n}\n```\n</target_code>\n<response format>\nProvide your answer with these fields.\n- explanation: your evaluation of the scenario provided by the agent A.\n- is_report_correct: whether the report is correct or not (true/false). True means there is a violation.\n</response format>\n<scenario>\nThe agent A provided the following violation scenario:\nThe controlling expression 'if (1)' is an invariant (constant true) and is not being used to create an infinite loop or one of the permitted do-while constant-false cases. Therefore this use of a constant controlling expression violates MISRA C 2023 Rule 14.3.\n</scenario>\n\n<execution_log>\nThe agent A also provided the following output log:\nENTER MHD_SHA256_finish: ctx=0x7ffd1ef362d0, ctx->count=3, digest=0x7ffd1ef362b0\nComputed num_bits=24, bytes_have=3\nAppended 0x80, bytes_have now=4\nPut num_bits into buffer (big-endian)\nProcessing final block via sha256_transform\nEncounter about to evaluate invariant 'if (1' (aligned-temp-buffer branch candidate)\ndigest pointer=0x7ffd1ef362b0, digest mod _MHD_UINT32_ALIGN = 0\nEncounter about to evaluate invariant 'if (1' (direct-store branch candidate)\nTaking direct-store branch (inside if(1) true)\nErased context and exiting MHD_SHA256_finish\nENTER MHD_SHA256_finish: ctx=0x7ffd1ef362d0, ctx->count=56, digest=0x7ffd1ef362b0\nComputed num_bits=448, bytes_have=56\nAppended 0x80, bytes_have now=57\nNo space for length in current block: SHA256_BLOCK_SIZE - bytes_have = 7\nProcessing full block via sha256_transform (first finalization block)\nStarted new block, bytes_have reset to 0\nPut num_bits into buffer (big-endian)\nProcessing final block via sha256_transform\nEncounter about to evaluate invariant 'if (1' (aligned-temp-buffer branch candidate)\ndigest pointer=0x7ffd1ef362b0, digest mod _MHD_UINT32_ALIGN = 0\nEncounter about to evaluate invariant 'if (1' (direct-store branch candidate)\nTaking direct-store branch (inside if(1) true)\nErased context and exiting MHD_SHA256_finish\nENTER MHD_SHA256_finish: ctx=0x7ffd1ef362d0, ctx->count=0, digest=0x7ffd1ef362b0\nComputed num_bits=0, bytes_have=0\nAppended 0x80, bytes_have now=1\nPut num_bits into buffer (big-endian)\nProcessing final block via sha256_transform\nEncounter about to evaluate invariant 'if (1' (aligned-temp-buffer branch candidate)\ndigest pointer=0x7ffd1ef362b0, digest mod _MHD_UINT32_ALIGN = 0\nEncounter about to evaluate invariant 'if (1' (direct-store branch candidate)\nTaking direct-store branch (inside if(1) true)\nErased context and exiting MHD_SHA256_finish\nENTER MHD_SHA256_finish: ctx=0x7ffd1ef362d0, ctx->count=28, digest=0x7ffd1ef362b0\nComputed num_bits=224, bytes_have=28\nAppended 0x80, bytes_have now=29\nPut num_bits into buffer (big-endian)\nProcessing final block via sha256_transform\nEncounter about to evaluate invariant 'if (1' (aligned-temp-buffer branch candidate)\ndigest pointer=0x7ffd1ef362b0, digest mod _MHD_UINT32_ALIGN = 0\nEncounter about to evaluate invariant 'if (1' (direct-store branch candidate)\nTaking direct-store branch (inside if(1) true)\nErased context and exiting MHD_SHA256_finish\nENTER MHD_SHA256_finish: ctx=0x7ffd1ef362d0, ctx->count=14, digest=0x7ffd1ef362b0\nComputed num_bits=112, bytes_have=14\nAppended 0x80, bytes_have now=15\nPut num_bits into buffer (big-endian)\nProcessing final block via sha256_transform\nEncounter about to evaluate invariant 'if (1' (aligned-temp-buffer branch candidate)\ndigest pointer=0x7ffd1ef362b0, digest mod _MHD_UINT32_ALIGN = 0\nEncounter about to evaluate invariant 'if (1' (direct-store branch candidate)\nTaking direct-store branch (inside if(1) true)\nErased context and exiting MHD_SHA256_finish\nENTER MHD_SHA256_finish: ctx=0x7ffd1ef362d0, ctx->count=26, digest=0x7ffd1ef362b0\nComputed num_bits=208, bytes_have=26\nAppended 0x80, bytes_have now=27\nPut num_bits into buffer (big-endian)\nProcessing final block via sha256_transform\nEncounter about to evaluate invariant 'if (1' (aligned-temp-buffer branch candidate)\ndigest pointer=0x7ffd1ef362b0, digest mod _MHD_UINT32_ALIGN = 0\nEncounter about to evaluate invariant 'if (1' (direct-store branch candidate)\nTaking direct-store branch (inside if(1) true)\nErased context and exiting MHD_SHA256_finish\nENTER MHD_SHA256_finish: ctx=0x7ffd1ef362d0, ctx->count=26, digest=0x7ffd1ef362b0\nComputed num_bits=208, bytes_have=26\nAppended 0x80, bytes_have now=27\nPut num_bits into buffer (big-endian)\nProcessing final block via sha256_transform\nEncounter about to evaluate invariant 'if (1' (aligned-temp-buffer branch candidate)\ndigest pointer=0x7ffd1ef362b0, digest mod _MHD_UINT32_ALIGN = 0\nEncounter about to evaluate invariant 'if (1' (direct-store branch candidate)\nTaking direct-store branch (inside if(1) true)\nErased context and exiting MHD_SHA256_finish\nENTER MHD_SHA256_finish: ctx=0x7ffd1ef362d0, ctx->\n</execution_log>\n\n<instruction>\nJudge whether the report is correct or not.\n</instruction>\n",
  "is_report_correct": true,
  "explanation": "Agent A is correct. The code contains two occurrences of an if(1) controlling expression (one explicitly and one created by the conditional compilation structure). MISRA C:2023 Rule 14.3 forbids invariant controlling expressions except for the narrow, documented exceptions (infinite loops or the do-while false idiom). These if(1) constructs are constant-true controlling expressions and are not used to form an infinite loop nor a permitted do-while false. Although they arise from preprocessor-driven combination of alternative branches, that fact does not remove the violation for any translation unit in which the preprocessor yields an if(1). Therefore the report of a Rule 14.3 violation is correct (some build configurations will produce non-compliant code)."
}