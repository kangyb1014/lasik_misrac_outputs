{
  "user_message": "An agent A claimed that the following MHD_digest_auth_get_username3 code violates the MISRA C 2023 rule 2.2.\n<misra_rule>\nMISRA C 2023 Rule 2.2 is A project shall not contain dead code.\nAny operation that is executed but whose removal would not affect program behaviour constitutes dead code. Notes:\n1. The behaviour of an embedded sytem is often determined not just by the nature of its actions, but also by the time at which they occur.\n2. unreachable code is not dead code, as it cannot be executed.\n3.Initialization is not the same as an assignment operation and is therfore not a candidate for dead code.\n</misra_rule>\n<target_code>\nHere is the original code of MHD_digest_auth_get_username3.\n```c\n_MHD_EXTERN struct MHD_DigestAuthUsernameInfo *\nMHD_digest_auth_get_username3 (struct MHD_Connection *connection)\n{\n  const struct MHD_RqDAuth *params;\n  struct MHD_DigestAuthUsernameInfo *uname_info;\n  enum MHD_DigestAuthUsernameType uname_type;\n  size_t unif_buf_size;\n  uint8_t *unif_buf_ptr;\n  size_t unif_buf_used;\n\n  params = MHD_get_rq_dauth_params_ (connection);\n  if (NULL == params)\n    return NULL;\n\n  uname_type = get_rq_uname_type (params);\n  if ( (MHD_DIGEST_AUTH_UNAME_TYPE_MISSING == uname_type) ||\n       (MHD_DIGEST_AUTH_UNAME_TYPE_INVALID == uname_type) )\n    return NULL;\n\n  unif_buf_size = get_rq_unames_size (params, uname_type);\n\n  uname_info = (struct MHD_DigestAuthUsernameInfo *)\n               MHD_calloc_ (1, (sizeof(struct MHD_DigestAuthUsernameInfo))\n                            + unif_buf_size);\n  unif_buf_ptr = (uint8_t *) (uname_info + 1);\n  unif_buf_used = get_rq_uname (params, uname_type, uname_info, unif_buf_ptr,\n                                unif_buf_size);\n  mhd_assert (unif_buf_size >= unif_buf_used);\n  (void) unif_buf_used; /* Mute compiler warning on non-debug builds */\n  mhd_assert (MHD_DIGEST_AUTH_UNAME_TYPE_MISSING != uname_info->uname_type);\n\n  if (MHD_DIGEST_AUTH_UNAME_TYPE_INVALID == uname_info->uname_type)\n  {\n    free (uname_info);\n    return NULL;\n  }\n  mhd_assert (uname_type == uname_info->uname_type);\n  uname_info->algo3 = params->algo3;\n\n  return uname_info;\n}\n```\n</target_code>\n<response format>\nProvide your answer with these fields.\n- explanation: your evaluation of the scenario provided by the agent A.\n- is_report_correct: whether the report is correct or not (true/false). True means there is a violation.\n</response format>\n<scenario>\nThe agent A provided the following violation scenario:\nIf mhd_assert is implemented as a diagnostic macro that compiles to a no-op in production builds (for example #define mhd_assert(x) ((void)0) or an empty do { } while (0)), then the statement mhd_assert (MHD_DIGEST_AUTH_UNAME_TYPE_MISSING != uname_info->uname_type); becomes an executed no-op whose removal would not affect program behaviour. In that configuration it is dead code and thus violates MISRA C 2023 Rule 2.2. If, instead, mhd_assert expands to a runtime check that can alter control flow (e.g. aborts or logs and terminates on failure), then the statement is not dead and does not violate Rule 2.2.\n</scenario>\n\n<instruction>\nJudge whether the report is correct or not.\n</instruction>\n",
  "is_report_correct": true,
  "explanation": "Agent A's reasoning is correct but conditional. MISRA C 2023 Rule 2.2 forbids dead code: an operation that is executed but whose removal would not affect program behaviour. In the shown function the statement\n  mhd_assert (MHD_DIGEST_AUTH_UNAME_TYPE_MISSING != uname_info->uname_type);\nevaluates a pure boolean expression that has no observable side effects (it only reads uname_info->uname_type). If, in the project configuration, mhd_assert is defined as a compile-time no-op (e.g. #define mhd_assert(x) ((void)0) or an empty do { } while (0)), that statement becomes an executed no-op. Removing it would not change program behaviour, so it is dead code and therefore in violation of Rule 2.2 for that build configuration.\n\nIf, however, mhd_assert expands to code that performs observable actions (logging, aborting, altering control flow, etc.), then the statement is not dead and there is no Rule 2.2 violation. Thus the report is correct in the scenario described (mhd_assert as a no-op), but the presence of a violation depends on how mhd_assert is defined in the project."
}