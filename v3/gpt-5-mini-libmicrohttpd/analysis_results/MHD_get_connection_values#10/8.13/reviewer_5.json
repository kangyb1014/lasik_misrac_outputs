{
  "user_message": "An agent A claimed that the following MHD_get_connection_values code violates the MISRA C 2023 rule 8.13.\n<misra_rule>\nMISRA C 2023 Rule 8.13 is A pointer should point to a const-qualified type whenever possible.\n\n</misra_rule>\n<target_code>\nHere is the original code of MHD_get_connection_values.\n```c\n_MHD_EXTERN int\nMHD_get_connection_values (struct MHD_Connection *connection,\n                           enum MHD_ValueKind kind,\n                           MHD_KeyValueIterator iterator,\n                           void *iterator_cls)\n{\n  int ret;\n  struct MHD_HTTP_Req_Header *pos;\n\n  if (NULL == connection)\n    return -1;\n  ret = 0;\n  for (pos = connection->rq.headers_received; NULL != pos; pos = pos->next)\n    if (0 != (pos->kind & kind))\n    {\n      ret++;\n      if ( (NULL != iterator) &&\n           (MHD_NO == iterator (iterator_cls,\n                                pos->kind,\n                                pos->header,\n                                pos->value)) )\n        return ret;\n    }\n  return ret;\n}\n```\n</target_code>\n<response format>\nProvide your answer with these fields.\n- explanation: your evaluation of the scenario provided by the agent A.\n- is_report_correct: whether the report is correct or not (true/false). True means there is a violation.\n</response format>\n<scenario>\nThe agent A provided the following violation scenario:\nThe fragment pos->header is used only for reading (passed into the iterator as a header name/value). If the struct member is declared as a non-const pointer (e.g. char *header) then Rule 8.13 is violated because the pointer should point to const-qualified data when it is not modified. A specific violation scenario: struct MHD_HTTP_Req_Header { char *header; char *value; ... }; header/value are never modified but are passed as read-only parameters to the iterator \u2014 they should be declared const char *header; const char *value;.\n</scenario>\n\n<instruction>\nJudge whether the report is correct or not.\n</instruction>\n",
  "is_report_correct": false,
  "explanation": "MISRA C:2023 Rule 8.13 recommends that pointer types should be qualified with const when the pointed-to object is not modified \u2014 i.e. you should use const char * for read\u2011only character data when possible. Agent A\u2019s description correctly describes a common const\u2011correctness issue: if struct MHD_HTTP_Req_Header is declared as\n\n  struct MHD_HTTP_Req_Header { char *header; char *value; ... };\n\nand those members are never modified anywhere (only read and passed to an iterator), then they should be const char * and that would be a violation of Rule 8.13 as reported.\n\nHowever, the code fragment shown does not include the definition of MHD_HTTP_Req_Header nor the prototype of MHD_KeyValueIterator, nor the rest of the codebase. Without inspecting the struct definition and all uses of header/value, you cannot definitively conclude a Rule 8.13 breach. There are legitimate reasons the members might be non\u2011const (they are modified elsewhere, assigned from API that returns non\u2011const, or part of a public API that requires mutable pointers), or the iterator may expect non\u2011const pointers, preventing a straightforward change. Thus the claim is plausible but not proven by the provided fragment alone.\n\nConclusion: the reported violation is potentially correct if the struct members are declared as non\u2011const and never modified, but the available evidence is insufficient to prove a definite MISRA 8.13 violation across the codebase. Further inspection of the MHD_HTTP_Req_Header definition and all uses of header/value (and the iterator prototype) is required to confirm the violation and to apply a safe fix."
}