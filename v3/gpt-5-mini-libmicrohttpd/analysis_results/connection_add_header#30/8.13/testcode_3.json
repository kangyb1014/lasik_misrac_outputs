{
  "user_message": "<misra_rule>\nMISRA C 2023 Rule 8.13 is: A pointer should point to a const-qualified type whenever possible.\n\n</misra_rule>\n\nAnother agent reported that the target code violated the Rule 8.13.\nHere is the comment from the agent.\n<violation scenario>\nThe call passes a translated string via _(\"...\") and the daemon pointer to MHD_DLOG. If the _ macro/gettext and/or MHD_DLOG are declared to use non-const char * (a common case for gettext returning char * and logging APIs taking char *), then an immutable string literal and a parameter that is not modified are being referenced by non-const pointers. Per MISRA C 2023 Rule 8.13 both should use const-qualified types (const char * and/or a pointer-to-const daemon) whenever possible. Therefore, if _() or MHD_DLOG use non-const pointer types, this is a violation.\n</violation scenario>\n\nYour job is to insert logging code to capture the control flow and state information of the program.\nInsert logging code so that other agents can reproduce and get evidence for the violation scenario.\n<response format>\n- test_code: a modified connection_add_header code that contains useful probe functions that print useful logs to a file \"/tmp/logs/303.txt\". The logs should contain the control path and state information of the violation scenario. If test code is not required to validate the scenario, you can leave this blank.\nHere are the constraints for the test code:\n- The test code MUST preserve the original logic of connection_add_header as much as possible.\nYou CAN just insert probe functions to the original code.\n- DO NOT introduce new violations to demonstrate your scenario.\n- The test code MUST be compilable and executable.\n- The test code MUST include line breaks.\n- You MUST NOT define the main function.\n- You MUST NOT define macros.\n</response format>\n<target_code>\nHere is the code of connection_add_header:\n```c\nstatic enum MHD_Result\nconnection_add_header (void *cls,\n                       const char *key,\n                       size_t key_size,\n                       const char *value,\n                       size_t value_size,\n                       enum MHD_ValueKind kind)\n{\n  struct MHD_Connection *connection = (struct MHD_Connection *) cls;\n  if (MHD_NO ==\n      MHD_set_connection_value_n (connection,\n                                  kind,\n                                  key,\n                                  key_size,\n                                  value,\n                                  value_size))\n  {\n#ifdef HAVE_MESSAGES\n    MHD_DLOG (connection->daemon,\n              _ (\"Not enough memory in pool to allocate header record!\\n\"));\n#endif\n    transmit_error_response_static (connection,\n                                    MHD_HTTP_REQUEST_HEADER_FIELDS_TOO_LARGE,\n                                    ERR_MSG_REQUEST_TOO_BIG);\n    return MHD_NO;\n  }\n  return MHD_YES;\n}\n```\n</target_code>\nPlease provide the modified connection_add_header code.\n",
  "test_code": "static enum MHD_Result\nconnection_add_header (void *cls,\n                       const char *key,\n                       size_t key_size,\n                       const char *value,\n                       size_t value_size,\n                       enum MHD_ValueKind kind)\n{\n  struct MHD_Connection *connection = (struct MHD_Connection *) cls;\n\n  /* Probe log file to capture control flow and relevant state for analysis */\n  {\n    FILE *log = fopen(\"/tmp/logs/303.txt\", \"a\");\n    if (log)\n    {\n      fprintf(log, \"connection_add_header: enter\\n\");\n      fprintf(log, \"  cls=%p, connection=%p\\n\", cls, (void *)connection);\n      fprintf(log, \"  key=%p, key_size=%zu\\n\", (const void *)key, key_size);\n      if (key && key_size > 0)\n      {\n        /* print a prefix of the key to avoid huge logs */\n        size_t lim = key_size < 256 ? key_size : 256;\n        fprintf(log, \"  key[0..%zu]=\\'\", lim);\n        fwrite(key, 1, lim, log);\n        if (key_size > lim) fprintf(log, \"...\\'\"); else fprintf(log, \"'\\n\");\n      }\n      fprintf(log, \"  value=%p, value_size=%zu\\n\", (const void *)value, value_size);\n      if (value && value_size > 0)\n      {\n        size_t lim = value_size < 256 ? value_size : 256;\n        fprintf(log, \"  value[0..%zu]=\\'\", lim);\n        fwrite(value, 1, lim, log);\n        if (value_size > lim) fprintf(log, \"...\\'\\n\"); else fprintf(log, \"'\\n\");\n      }\n      fprintf(log, \"  kind=%d\\n\", (int)kind);\n      if (connection)\n        fprintf(log, \"  connection->daemon=%p\\n\", (void *)connection->daemon);\n      else\n        fprintf(log, \"  connection is NULL\\n\");\n      fflush(log);\n      fclose(log);\n    }\n  }\n\n  if (MHD_NO ==\n      MHD_set_connection_value_n (connection,\n                                  kind,\n                                  key,\n                                  key_size,\n                                  value,\n                                  value_size))\n  {\n#ifdef HAVE_MESSAGES\n    /* Capture the translated message pointer and content for analysis.\n       Use a const-qualified pointer here for logging to avoid casting away const.\n       We deliberately do not change the subsequent MHD_DLOG invocation, so\n       the original call behavior is preserved exactly. */\n    {\n      const char *probe_msg = _ (\"Not enough memory in pool to allocate header record!\\n\");\n      FILE *log = fopen(\"/tmp/logs/303.txt\", \"a\");\n      if (log)\n      {\n        fprintf(log, \"connection_add_header: header allocation FAILED\\n\");\n        fprintf(log, \"  probe_msg pointer=%p\\n\", (const void *)probe_msg);\n        if (probe_msg)\n        {\n          /* log up to 1024 chars of the message to avoid excessive output */\n          size_t max = 1024;\n          size_t len = strlen(probe_msg);\n          size_t use = len < max ? len : max;\n          fprintf(log, \"  probe_msg[0..%zu]=\\'\", use);\n          fwrite(probe_msg, 1, use, log);\n          if (len > use) fprintf(log, \"...\\'\\n\"); else fprintf(log, \"'\\n\");\n        }\n        if (connection)\n          fprintf(log, \"  daemon pointer for MHD_DLOG=%p\\n\", (void *)connection->daemon);\n        fflush(log);\n        fclose(log);\n      }\n    }\n\n    /* Original logging call retained exactly to preserve behavior */\n    MHD_DLOG (connection->daemon,\n              _ (\"Not enough memory in pool to allocate header record!\\n\"));\n#endif\n    transmit_error_response_static (connection,\n                                    MHD_HTTP_REQUEST_HEADER_FIELDS_TOO_LARGE,\n                                    ERR_MSG_REQUEST_TOO_BIG);\n    return MHD_NO;\n  }\n  return MHD_YES;\n}"
}