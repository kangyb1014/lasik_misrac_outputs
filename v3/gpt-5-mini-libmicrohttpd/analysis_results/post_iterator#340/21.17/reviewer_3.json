{
  "user_message": "An agent A claimed that the following post_iterator code violates the MISRA C 2023 rule 21.17.\n<misra_rule>\nMISRA C 2023 Rule 21.17 is Use of the string handling functions from <string.h> shall not result in accesses beyond the bounds of the objects referenced by their pointer parameters.\nThis rule strictly applies to the Standard Library functions in <string.h> such as memcpy, memmove, memset, memcmp, strcpy, strncpy, strcat, strncat, strlen, and strspn.\n</misra_rule>\n<target_code>\nHere is the original code of post_iterator.\n```c\nstatic enum MHD_Result\npost_iterator (void *cls,\n               enum MHD_ValueKind kind,\n               const char *key,\n               const char *filename,\n               const char *content_type,\n               const char *transfer_encoding,\n               const char *data, uint64_t off, size_t size)\n{\n  struct Request *request = cls;\n  struct Session *session = request->session;\n  (void) kind;              /* Unused. Silent compiler warning. */\n  (void) filename;          /* Unused. Silent compiler warning. */\n  (void) content_type;      /* Unused. Silent compiler warning. */\n  (void) transfer_encoding; /* Unused. Silent compiler warning. */\n\n  if (0 == strcmp (\"DONE\", key))\n  {\n    fprintf (stdout,\n             \"Session `%s' submitted `%s', `%s'\\n\",\n             session->sid,\n             session->value_1,\n             session->value_2);\n    return MHD_YES;\n  }\n  if (0 == strcmp (\"v1\", key))\n  {\n    if (off >= sizeof(session->value_1) - 1)\n      return MHD_YES; /* Discard extra data */\n    if (size + off >= sizeof(session->value_1))\n      size = (size_t) (sizeof (session->value_1) - off - 1); /* crop extra data */\n    memcpy (&session->value_1[off],\n            data,\n            size);\n    session->value_1[size + off] = '\\0';\n    return MHD_YES;\n  }\n  if (0 == strcmp (\"v2\", key))\n  {\n    if (off >= sizeof(session->value_2) - 1)\n      return MHD_YES; /* Discard extra data */\n    if (size + off >= sizeof(session->value_2))\n      size = (size_t) (sizeof (session->value_2) - off - 1); /* crop extra data */\n    memcpy (&session->value_2[off],\n            data,\n            size);\n    session->value_2[size + off] = '\\0';\n    return MHD_YES;\n  }\n  fprintf (stderr,\n           \"Unsupported form value `%s'\\n\",\n           key);\n  return MHD_YES;\n}\n```\n</target_code>\n<response format>\nProvide your answer with these fields.\n- explanation: your evaluation of the scenario provided by the agent A.\n- is_report_correct: whether the report is correct or not (true/false). True means there is a violation.\n</response format>\n<scenario>\nThe agent A provided the following violation scenario:\nCalling strcmp(\"v1\", key) without first ensuring that key points to a valid NUL-terminated object can read out of bounds. For example, if key == NULL (or points to memory that is not NUL-terminated within accessible bounds), strcmp will dereference/read beyond the object referenced by the pointer parameter, violating Rule 21.17.\n</scenario>\n\n<instruction>\nJudge whether the report is correct or not.\n</instruction>\n",
  "is_report_correct": true,
  "explanation": "MISRA C:2023 Rule 21.17 forbids using string.h functions in a way that can cause accesses beyond the bounds of the objects referenced by their pointer parameters. strcmp reads from both pointer parameters until it finds a NUL byte; passing a NULL pointer or a pointer to a non-NUL-terminated object can cause out\u2011of\u2011bounds accesses (undefined behaviour).\n\nThe posted code calls strcmp(\"DONE\", key), strcmp(\"v1\", key) and strcmp(\"v2\", key) without first validating key. If key were NULL or not NUL\u2011terminated (for example if the calling library could pass NULL or a non-terminated buffer), these calls could read beyond the bounds of the object referenced by key and therefore violate Rule 21.17. Agent A\u2019s scenario (key == NULL or not NUL\u2011terminated) is a plausible way to trigger the violation.\n\nIf, however, the surrounding context / API (the MHD post iterator callback contract) formally guarantees that key is always a valid, non-NULL, NUL\u2011terminated string, then the calls are safe and no violation occurs. MISRA guidance is conservative: in the absence of a documented, enforced guarantee, the code should validate the pointer (e.g. check key != NULL) before calling strcmp.\n\nConclusion: given the code as shown (no validation of key) and absent an explicit guarantee from the API in the snippet, the report is correct \u2014 the code can violate Rule 21.17."
}