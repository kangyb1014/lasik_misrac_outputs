{
  "user_message": "An agent A claimed that the following MHD_get_timeout64 code violates the MISRA C 2023 rule 8.13.\n<misra_rule>\nMISRA C 2023 Rule 8.13 is A pointer should point to a const-qualified type whenever possible.\n\n</misra_rule>\n<target_code>\nHere is the original code of MHD_get_timeout64.\n```c\n_MHD_EXTERN enum MHD_Result\nMHD_get_timeout64 (struct MHD_Daemon *daemon,\n                   uint64_t *timeout64)\n{\n  uint64_t earliest_deadline;\n  struct MHD_Connection *pos;\n  struct MHD_Connection *earliest_tmot_conn; /**< the connection with earliest timeout */\n\n#ifdef MHD_USE_THREADS\n  mhd_assert ( (! MHD_D_IS_USING_THREADS_ (daemon)) || \\\n               MHD_thread_handle_ID_is_current_thread_ (daemon->tid) );\n#endif /* MHD_USE_THREADS */\n\n  if (MHD_D_IS_USING_THREAD_PER_CONN_ (daemon))\n  {\n#ifdef HAVE_MESSAGES\n    MHD_DLOG (daemon,\n              _ (\"Illegal call to MHD_get_timeout.\\n\"));\n#endif\n    return MHD_NO;\n  }\n  if (daemon->data_already_pending\n      || (NULL != daemon->cleanup_head)\n      || daemon->resuming\n      || daemon->have_new\n      || daemon->shutdown)\n  {\n    /* Some data or connection statuses already waiting to be processed. */\n    *timeout64 = 0;\n    return MHD_YES;\n  }\n#ifdef EPOLL_SUPPORT\n  if (MHD_D_IS_USING_EPOLL_ (daemon) &&\n      ((NULL != daemon->eready_head)\n#if defined(UPGRADE_SUPPORT) && defined(HTTPS_SUPPORT)\n       || (NULL != daemon->eready_urh_head)\n#endif /* UPGRADE_SUPPORT && HTTPS_SUPPORT */\n      ) )\n  {\n    /* Some connection(s) already have some data pending. */\n    *timeout64 = 0;\n    return MHD_YES;\n  }\n#endif /* EPOLL_SUPPORT */\n\n  earliest_tmot_conn = NULL;\n  earliest_deadline = 0; /* mute compiler warning */\n  /* normal timeouts are sorted, so we only need to look at the 'tail' (oldest) */\n  pos = daemon->normal_timeout_tail;\n  if ( (NULL != pos) &&\n       (0 != pos->connection_timeout_ms) )\n  {\n    earliest_tmot_conn = pos;\n    earliest_deadline = pos->last_activity + pos->connection_timeout_ms;\n  }\n\n  for (pos = daemon->manual_timeout_tail; NULL != pos; pos = pos->prevX)\n  {\n    if (0 != pos->connection_timeout_ms)\n    {\n      if ( (NULL == earliest_tmot_conn) ||\n           (earliest_deadline - pos->last_activity >\n            pos->connection_timeout_ms) )\n      {\n        earliest_tmot_conn = pos;\n        earliest_deadline = pos->last_activity + pos->connection_timeout_ms;\n      }\n    }\n  }\n\n  if (NULL != earliest_tmot_conn)\n  {\n    *timeout64 = connection_get_wait (earliest_tmot_conn);\n    return MHD_YES;\n  }\n  return MHD_NO;\n}\n```\n</target_code>\n<response format>\nProvide your answer with these fields.\n- explanation: your evaluation of the scenario provided by the agent A.\n- is_report_correct: whether the report is correct or not (true/false). True means there is a violation.\n</response format>\n<scenario>\nThe agent A provided the following violation scenario:\nThe pointer earliest_tmot_conn is declared as a plain 'struct MHD_Connection *' but, in the shown function it is only assigned from pos and later only used for read-only access (passed to connection_get_wait to compute a timeout). If the pointer-target objects are not modified through earliest_tmot_conn, the pointer should be declared to point to a const-qualified type (e.g. 'const struct MHD_Connection *earliest_tmot_conn') per MISRA C 2023 Rule 8.13. (If, however, later code or the called function requires a non-const pointer and modifies the connection via this pointer, then keeping it non-const is required and there is no violation.)\n</scenario>\n\n<execution_log>\nThe agent A also provided the following output log:\nMHD_get_timeout64 enter: daemon=0x55c95338d8d0\ninitial normal_timeout_tail chosen: daemon=0x55c95338d8d0 conn=0x55c95338e1e0 timeout_ms=5000 last_activity=692 earliest_deadline=5692\ncalling connection_get_wait: conn=0x55c95338e1e0 -> wait=5000\nreturning MHD_YES with earliest_tmot_conn: daemon=0x55c95338d8d0 conn=0x55c95338e1e0 timeout_ms=5000 last_activity=692 earliest_deadline=5692\nMHD_get_timeout64 enter: daemon=0x55c95338d8d0\nno earliest timeout connection found -> returning MHD_NO: daemon=0x55c95338d8d0\nMHD_get_timeout64 enter: daemon=0x55c95338d8d0\ninitial normal_timeout_tail chosen: daemon=0x55c95338d8d0 conn=0x55c95338f490 timeout_ms=5000 last_activity=692 earliest_deadline=5692\ncalling connection_get_wait: conn=0x55c95338f490 -> wait=5000\nreturning MHD_YES with earliest_tmot_conn: daemon=0x55c95338d8d0 conn=0x55c95338f490 timeout_ms=5000 last_activity=692 earliest_deadline=5692\nMHD_get_timeout64 enter: daemon=0x55c95338d8d0\nno earliest timeout connection found -> returning MHD_NO: daemon=0x55c95338d8d0\nMHD_get_timeout64 enter: daemon=0x55c95338d8d0\ninitial normal_timeout_tail chosen: daemon=0x55c95338d8d0 conn=0x55c95338f6e0 timeout_ms=5000 last_activity=692 earliest_deadline=5692\ncalling connection_get_wait: conn=0x55c95338f6e0 -> wait=5000\nreturning MHD_YES with earliest_tmot_conn: daemon=0x55c95338d8d0 conn=0x55c95338f6e0 timeout_ms=5000 last_activity=692 earliest_deadline=5692\nMHD_get_timeout64 enter: daemon=0x55c95338d8d0\nno earliest timeout connection found -> returning MHD_NO: daemon=0x55c95338d8d0\nMHD_get_timeout64 enter: daemon=0x55c95338d8d0\ninitial normal_timeout_tail chosen: daemon=0x55c95338d8d0 conn=0x55c95338f930 timeout_ms=5000 last_activity=692 earliest_deadline=5692\ncalling connection_get_wait: conn=0x55c95338f930 -> wait=5000\nreturning MHD_YES with earliest_tmot_conn: daemon=0x55c95338d8d0 conn=0x55c95338f930 timeout_ms=5000 last_activity=692 earliest_deadline=5692\nMHD_get_timeout64 enter: daemon=0x55c95338d8d0\nno earliest timeout connection found -> returning MHD_NO: daemon=0x55c95338d8d0\nMHD_get_timeout64 enter: daemon=0x55c95338d8d0\ninitial normal_timeout_tail chosen: daemon=0x55c95338d8d0 conn=0x55c95338fb80 timeout_ms=5000 last_activity=692 earliest_deadline=5692\ncalling connection_get_wait: conn=0x55c95338fb80 -> wait=5000\nreturning MHD_YES with earliest_tmot_conn: daemon=0x55c95338d8d0 conn=0x55c95338fb80 timeout_ms=5000 last_activity=692 earliest_deadline=5692\nMHD_get_timeout64 enter: daemon=0x55c95338d8d0\nno earliest timeout connection found -> returning MHD_NO: daemon=0x55c95338d8d0\nMHD_get_timeout64 enter: daemon=0x55c95338d8d0\ninitial normal_timeout_tail chosen: daemon=0x55c95338d8d0 conn=0x55c95338fdd0 timeout_ms=5000 last_activity=692 earliest_deadline=5692\ncalling connection_get_wait: conn=0x55c95338fdd0 -> wait=5000\nreturning MHD_YES with earliest_tmot_conn: daemon=0x55c95338d8d0 conn=0x55c95338fdd0 timeout_ms=5000 last_activity=692 earliest_deadline=5692\nMHD_get_timeout64 enter: daemon=0x55c95338d8d0\nno earliest timeout connection found -> returning MHD_NO: daemon=0x55c95338d8d0\nMHD_get_timeout64 enter: daemon=0x55c95338d8d0\ninitial normal_timeout_tail chosen: daemon=0x55c95338d8d0 conn=0x55c953390020 timeout_ms=5000 last_activity=692 earliest_deadline=5692\ncalling connection_get_wait: conn=0x55c953390020 -> wait=5000\nreturning MHD_YES with earliest_tmot_conn: daemon=0x55c95338d8d0 conn=0x55c953390020 timeout_ms=5000 last_activity=692 earliest_deadline=5692\nMHD_get_timeout64 enter: daemon=0x55c95338d8d0\nno earliest timeout connection found -> returning MHD_NO: daemon=0x55c95338d8d0\nMHD_get_timeout64 enter: daemon=0x55c95338d8d0\ninitial normal_timeout_tail chosen: daemon=0x55c95338d8d0 conn=0x55c953390270 timeout_ms=5000 last_activity=692 earliest_deadline=5692\ncalling connection_get_wait: conn=0x55c953390270 -> wait=5000\nreturning MHD_YES with earliest_tmot_conn: daemon=0x55c95338d8d0 conn=0x55c953390270 timeout_ms=5000 last_activity=692 earliest_deadline=5692\nMHD_get_timeout64 enter: daemon=0x55c95338d8d0\nno earliest timeout connection found -> returning MHD_NO: daemon=0x55c95\n</execution_log>\n\n<instruction>\nJudge whether the report is correct or not.\n</instruction>\n",
  "is_report_correct": true,
  "explanation": "The pointer earliest_tmot_conn is only used for read-only purposes in the shown function: it is assigned from pos (a non-const pointer), compared/inspected and finally passed to connection_get_wait; there are no writes through earliest_tmot_conn. Under MISRA C 2023 Rule 8.13 a pointer should point to a const-qualified type whenever possible. It would be possible here to declare earliest_tmot_conn as const struct MHD_Connection * (assigning a non-const pointer to a pointer-to-const is allowed), which would satisfy the rule.\n\nOne caveat: if connection_get_wait (or any other code not shown) requires a non-const struct MHD_Connection * and modifies the object via that parameter, then earliest_tmot_conn must remain non-const and there is no violation. The source shown does not include connection_get_wait's prototype, so you should check that function: if it can accept a const pointer (or be changed to do so), then the current declaration is a MISRA 8.13 violation. Given only the code shown, the report is correct (the pointer could and should be const-qualified)."
}