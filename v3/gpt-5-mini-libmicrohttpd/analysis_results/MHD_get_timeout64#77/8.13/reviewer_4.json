{
  "user_message": "An agent A claimed that the following MHD_get_timeout64 code violates the MISRA C 2023 rule 8.13.\n<misra_rule>\nMISRA C 2023 Rule 8.13 is A pointer should point to a const-qualified type whenever possible.\n\n</misra_rule>\n<target_code>\nHere is the original code of MHD_get_timeout64.\n```c\n_MHD_EXTERN enum MHD_Result\nMHD_get_timeout64 (struct MHD_Daemon *daemon,\n                   uint64_t *timeout64)\n{\n  uint64_t earliest_deadline;\n  struct MHD_Connection *pos;\n  struct MHD_Connection *earliest_tmot_conn; /**< the connection with earliest timeout */\n\n#ifdef MHD_USE_THREADS\n  mhd_assert ( (! MHD_D_IS_USING_THREADS_ (daemon)) || \\\n               MHD_thread_handle_ID_is_current_thread_ (daemon->tid) );\n#endif /* MHD_USE_THREADS */\n\n  if (MHD_D_IS_USING_THREAD_PER_CONN_ (daemon))\n  {\n#ifdef HAVE_MESSAGES\n    MHD_DLOG (daemon,\n              _ (\"Illegal call to MHD_get_timeout.\\n\"));\n#endif\n    return MHD_NO;\n  }\n  if (daemon->data_already_pending\n      || (NULL != daemon->cleanup_head)\n      || daemon->resuming\n      || daemon->have_new\n      || daemon->shutdown)\n  {\n    /* Some data or connection statuses already waiting to be processed. */\n    *timeout64 = 0;\n    return MHD_YES;\n  }\n#ifdef EPOLL_SUPPORT\n  if (MHD_D_IS_USING_EPOLL_ (daemon) &&\n      ((NULL != daemon->eready_head)\n#if defined(UPGRADE_SUPPORT) && defined(HTTPS_SUPPORT)\n       || (NULL != daemon->eready_urh_head)\n#endif /* UPGRADE_SUPPORT && HTTPS_SUPPORT */\n      ) )\n  {\n    /* Some connection(s) already have some data pending. */\n    *timeout64 = 0;\n    return MHD_YES;\n  }\n#endif /* EPOLL_SUPPORT */\n\n  earliest_tmot_conn = NULL;\n  earliest_deadline = 0; /* mute compiler warning */\n  /* normal timeouts are sorted, so we only need to look at the 'tail' (oldest) */\n  pos = daemon->normal_timeout_tail;\n  if ( (NULL != pos) &&\n       (0 != pos->connection_timeout_ms) )\n  {\n    earliest_tmot_conn = pos;\n    earliest_deadline = pos->last_activity + pos->connection_timeout_ms;\n  }\n\n  for (pos = daemon->manual_timeout_tail; NULL != pos; pos = pos->prevX)\n  {\n    if (0 != pos->connection_timeout_ms)\n    {\n      if ( (NULL == earliest_tmot_conn) ||\n           (earliest_deadline - pos->last_activity >\n            pos->connection_timeout_ms) )\n      {\n        earliest_tmot_conn = pos;\n        earliest_deadline = pos->last_activity + pos->connection_timeout_ms;\n      }\n    }\n  }\n\n  if (NULL != earliest_tmot_conn)\n  {\n    *timeout64 = connection_get_wait (earliest_tmot_conn);\n    return MHD_YES;\n  }\n  return MHD_NO;\n}\n```\n</target_code>\n<response format>\nProvide your answer with these fields.\n- explanation: your evaluation of the scenario provided by the agent A.\n- is_report_correct: whether the report is correct or not (true/false). True means there is a violation.\n</response format>\n<scenario>\nThe agent A provided the following violation scenario:\nThe pointer 'pos' is only used for read-only access (iterating the list: pos = daemon->manual_timeout_tail; pos = pos->prevX; and reading pos->connection_timeout_ms and pos->last_activity). It does not modify the pointed-to object, so it could be declared as 'const struct MHD_Connection *pos;'. Thus the current declaration 'struct MHD_Connection *pos;' violates MISRA C 2023 Rule 8.13.\n</scenario>\n\n<execution_log>\nThe agent A also provided the following output log:\nMHD_get_timeout64: enter daemon=0x55cb978cb8d0 normal_tail=0x55cb978cc1e0 manual_tail=(nil)\nMHD_get_timeout64: initial earliest from normal_tail pos=0x55cb978cc1e0 connection_timeout_ms=5000 last_activity=598 earliest_deadline=5598\nMHD_get_timeout64: returning MHD_YES earliest_tmot_conn=0x55cb978cc1e0 timeout=5000\nMHD_get_timeout64: enter daemon=0x55cb978cb8d0 normal_tail=(nil) manual_tail=(nil)\nMHD_get_timeout64: no earliest timeout -> return MHD_NO\nMHD_get_timeout64: enter daemon=0x55cb978cb8d0 normal_tail=0x55cb978cd490 manual_tail=(nil)\nMHD_get_timeout64: initial earliest from normal_tail pos=0x55cb978cd490 connection_timeout_ms=5000 last_activity=598 earliest_deadline=5598\nMHD_get_timeout64: returning MHD_YES earliest_tmot_conn=0x55cb978cd490 timeout=5000\nMHD_get_timeout64: enter daemon=0x55cb978cb8d0 normal_tail=(nil) manual_tail=(nil)\nMHD_get_timeout64: no earliest timeout -> return MHD_NO\nMHD_get_timeout64: enter daemon=0x55cb978cb8d0 normal_tail=0x55cb978cd6e0 manual_tail=(nil)\nMHD_get_timeout64: initial earliest from normal_tail pos=0x55cb978cd6e0 connection_timeout_ms=5000 last_activity=598 earliest_deadline=5598\nMHD_get_timeout64: returning MHD_YES earliest_tmot_conn=0x55cb978cd6e0 timeout=5000\nMHD_get_timeout64: enter daemon=0x55cb978cb8d0 normal_tail=(nil) manual_tail=(nil)\nMHD_get_timeout64: no earliest timeout -> return MHD_NO\nMHD_get_timeout64: enter daemon=0x55cb978cb8d0 normal_tail=0x55cb978cd930 manual_tail=(nil)\nMHD_get_timeout64: initial earliest from normal_tail pos=0x55cb978cd930 connection_timeout_ms=5000 last_activity=598 earliest_deadline=5598\nMHD_get_timeout64: returning MHD_YES earliest_tmot_conn=0x55cb978cd930 timeout=5000\nMHD_get_timeout64: enter daemon=0x55cb978cb8d0 normal_tail=(nil) manual_tail=(nil)\nMHD_get_timeout64: no earliest timeout -> return MHD_NO\nMHD_get_timeout64: enter daemon=0x55cb978cb8d0 normal_tail=0x55cb978cdb80 manual_tail=(nil)\nMHD_get_timeout64: initial earliest from normal_tail pos=0x55cb978cdb80 connection_timeout_ms=5000 last_activity=598 earliest_deadline=5598\nMHD_get_timeout64: returning MHD_YES earliest_tmot_conn=0x55cb978cdb80 timeout=5000\nMHD_get_timeout64: enter daemon=0x55cb978cb8d0 normal_tail=(nil) manual_tail=(nil)\nMHD_get_timeout64: no earliest timeout -> return MHD_NO\nMHD_get_timeout64: enter daemon=0x55cb978cb8d0 normal_tail=0x55cb978cddd0 manual_tail=(nil)\nMHD_get_timeout64: initial earliest from normal_tail pos=0x55cb978cddd0 connection_timeout_ms=5000 last_activity=598 earliest_deadline=5598\nMHD_get_timeout64: returning MHD_YES earliest_tmot_conn=0x55cb978cddd0 timeout=5000\nMHD_get_timeout64: enter daemon=0x55cb978cb8d0 normal_tail=(nil) manual_tail=(nil)\nMHD_get_timeout64: no earliest timeout -> return MHD_NO\nMHD_get_timeout64: enter daemon=0x55cb978cb8d0 normal_tail=0x55cb978ce020 manual_tail=(nil)\nMHD_get_timeout64: initial earliest from normal_tail pos=0x55cb978ce020 connection_timeout_ms=5000 last_activity=598 earliest_deadline=5598\nMHD_get_timeout64: returning MHD_YES earliest_tmot_conn=0x55cb978ce020 timeout=5000\nMHD_get_timeout64: enter daemon=0x55cb978cb8d0 normal_tail=(nil) manual_tail=(nil)\nMHD_get_timeout64: no earliest timeout -> return MHD_NO\nMHD_get_timeout64: enter daemon=0x55cb978cb8d0 normal_tail=0x55cb978ce270 manual_tail=(nil)\nMHD_get_timeout64: initial earliest from normal_tail pos=0x55cb978ce270 connection_timeout_ms=5000 last_activity=598 earliest_deadline=5598\nMHD_get_timeout64: returning MHD_YES earliest_tmot_conn=0x55cb978ce270 timeout=5000\nMHD_get_timeout64: enter daemon=0x55cb978cb8d0 normal_tail=(nil) manual_tail=(nil)\nMHD_get_timeout64: no earliest timeout -> return MHD_NO\nMHD_get_timeout64: enter daemon=0x55cb978cb8d0 normal_tail=0x55cb978ce270 manual_tail=(nil)\nMHD_get_timeout64: initial earliest from normal_tail pos=0x55cb978ce270 connection_timeout_ms=5000 last_activity=598 earliest_deadline=5598\nMHD_get_timeout64: returning MHD_YES earliest_tmot_conn=0x55cb978ce270 timeout=5000\nMHD_get_timeout64: enter daemon=0x55cb978cb8d0 normal_tail=(nil) manual_tail=(nil)\nMHD_get_timeout64: no earliest timeout -> return MHD_NO\nM\n</execution_log>\n\n<instruction>\nJudge whether the report is correct or not.\n</instruction>\n",
  "is_report_correct": false,
  "explanation": "Not correct. Although the local variable 'pos' is only used for read access inside this function, it is assigned to 'earliest_tmot_conn' (earliest_tmot_conn = pos) and that non-const variable is later passed to connection_get_wait(earliest_tmot_conn). You cannot safely change only 'pos' to 'const struct MHD_Connection *' because that would create an implicit discard of const when assigning into a non-const pointer (or require a cast). Whether both pointers could be made const depends on the signature/usage of connection_get_wait and possibly other callers; you cannot conclude from this function alone that changing 'pos' to point to a const-qualified type is \u201cpossible\u201d without wider changes. Therefore the reported violation of MISRA C 2023 Rule 8.13 is not demonstrated by the given code as-is."
}