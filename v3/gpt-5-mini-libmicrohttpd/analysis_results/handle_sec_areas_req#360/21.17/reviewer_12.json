{
  "user_message": "An agent A claimed that the following handle_sec_areas_req code violates the MISRA C 2023 rule 21.17.\n<misra_rule>\nMISRA C 2023 Rule 21.17 is Use of the string handling functions from <string.h> shall not result in accesses beyond the bounds of the objects referenced by their pointer parameters.\nThis rule strictly applies to the Standard Library functions in <string.h> such as memcpy, memmove, memset, memcmp, strcpy, strncpy, strcat, strncat, strlen, and strspn.\n</misra_rule>\n<target_code>\nHere is the original code of handle_sec_areas_req.\n```c\nstatic enum MHD_Result\nhandle_sec_areas_req (struct MHD_Connection *c, const char *url, unsigned int\n                      sec_area_num)\n{\n  struct MHD_DigestAuthUsernameInfo *username_info;\n  struct UserEntry *user_entry;\n  void *userdigest;\n  size_t userdigest_size;\n  enum MHD_DigestAuthResult auth_res;\n\n  username_info = MHD_digest_auth_get_username3 (c);\n\n  if (NULL == username_info)\n    return reply_with_auth_required (c, 0, 0);\n\n  user_entry = find_entry_by_userinfo (username_info);\n\n  if (NULL == user_entry)\n    return reply_with_auth_required (c, 0, 1);\n\n  switch (username_info->algo3)\n  {\n  case MHD_DIGEST_AUTH_ALGO3_MD5:\n    userdigest = user_entry->userdigest_md5;\n    userdigest_size = sizeof(user_entry->userdigest_md5);\n    break;\n  case MHD_DIGEST_AUTH_ALGO3_SHA256:\n    userdigest = user_entry->userdigest_sha256;\n    userdigest_size = sizeof(user_entry->userdigest_sha256);\n    break;\n  case MHD_DIGEST_AUTH_ALGO3_SHA512_256:\n    userdigest = user_entry->userdigest_sha512_256;\n    userdigest_size = sizeof(user_entry->userdigest_sha512_256);\n    break;\n  case MHD_DIGEST_AUTH_ALGO3_MD5_SESSION:\n  case MHD_DIGEST_AUTH_ALGO3_SHA256_SESSION:\n  case MHD_DIGEST_AUTH_ALGO3_SHA512_256_SESSION:\n    /* Not supported currently and not used by MHD.\n       The client incorrectly used algorithm not advertised by the server. */\n    return reply_with_auth_required (c, 0, 1);\n  case MHD_DIGEST_AUTH_ALGO3_INVALID: /* Mute compiler warning */\n  default:\n    return MHD_NO; /* Should be unreachable */\n  }\n\n  auth_res = MHD_digest_auth_check_digest3 (\n    c,\n    REALM, /* Make sure to use the proper realm, not the realm provided by the client and returned by \"user_entry\" */\n    user_entry->username,\n    userdigest,\n    userdigest_size,\n    0, /* Use daemon's default value for nonce_timeout*/\n    0, /* Use daemon's default value for max_nc */\n    get_m_QOP (),\n    (enum MHD_DigestAuthMultiAlgo3) username_info->algo3 /* Direct cast from \"single algorithm\" to \"multi-algorithm\" is allowed */\n    );\n\n  if (MHD_DAUTH_OK != auth_res)\n  {\n    int need_just_refresh_nonce;\n    /* Actually MHD_DAUTH_NONCE_OTHER_COND should not be returned as\n       MHD_OPTION_DIGEST_AUTH_NONCE_BIND_TYPE is not used for the daemon.\n       To keep the code universal the MHD_DAUTH_NONCE_OTHER_COND is\n       still checked here. */\n    need_just_refresh_nonce =\n      (MHD_DAUTH_NONCE_STALE == auth_res)\n      || (MHD_DAUTH_NONCE_OTHER_COND == auth_res);\n    return reply_with_auth_required (c,\n                                     need_just_refresh_nonce,\n                                     ! need_just_refresh_nonce);\n  }\n\n  /* The user successfully authenticated */\n\n  /* Check whether access to the request area is allowed for the user */\n  if (1 == sec_area_num)\n  {\n    if (user_entry->allow_area_1)\n      return reply_with_area1_pages (c, url);\n    else\n      return reply_with_forbidden (c);\n  }\n  else if (2 == sec_area_num)\n  {\n    if (user_entry->allow_area_2)\n      return reply_with_area2_pages (c, url);\n    else\n      return reply_with_forbidden (c);\n  }\n\n  return MHD_NO; /* Should be unreachable */\n}\n```\n</target_code>\n<response format>\nProvide your answer with these fields.\n- explanation: your evaluation of the scenario provided by the agent A.\n- is_report_correct: whether the report is correct or not (true/false). True means there is a violation.\n</response format>\n<scenario>\nThe agent A provided the following violation scenario:\nThe expression sizeof(user_entry->userdigest_sha256) may produce an incorrect size if userdigest_sha256 is not an actual array embedded in struct UserEntry. For example, if UserEntry is defined with a pointer member (e.g. uint8_t *userdigest_sha256;) or the digest is stored in a separately allocated buffer, sizeof(user_entry->userdigest_sha256) yields the size of the pointer (typically 4 or 8) rather than the actual digest length (e.g. 32 or 64). That incorrect size, when later passed to a string/memory function (e.g. memcmp/memcpy inside MHD_digest_auth_check_digest3), can lead to reads/writes beyond the buffer bounds and thus violate MISRA C 2023 Rule 21.17.\n</scenario>\n\n<instruction>\nJudge whether the report is correct or not.\n</instruction>\n",
  "is_report_correct": false,
  "explanation": "Agent A\u2019s scenario is plausible as a *possible* bug, but it is not a proven MISRA 21.17 violation from the snippet alone. Rule 21.17 prohibits passing a pointer + an incorrect size to standard string/memory functions such that those functions access beyond the bounds of the referenced objects. In this function the pointer (userdigest) and a size (userdigest_size) are chosen and passed to MHD_digest_auth_check_digest3, which presumably uses memory functions internally. Whether a bounds violation can occur therefore depends on the definition and semantics of struct UserEntry and on the semantics of MHD_digest_auth_check_digest3:\n\n- If the members userdigest_md5, userdigest_sha256 and userdigest_sha512_256 are arrays embedded in struct UserEntry with the correct compile-time sizes for the digests, then sizeof(member) yields the correct digest length and there is no violation here.\n- If those members are pointer members (e.g. uint8_t *userdigest_sha256), then sizeof(user_entry->userdigest_sha256) yields the size of the pointer, not the buffer length. That is a logic error (wrong size passed to the digest check) and could lead to incorrect behaviour. However, sizeof(pointer) is normally smaller than the intended digest length, so the immediate effect would generally be under-using the buffer (missing bytes), not reading past its end. A real out\u2011of\u2011bounds access would only arise if the computed size is larger than the actual allocated buffer that userdigest points to \u2014 and whether that can happen depends on how the buffers are allocated and how sizes are tracked elsewhere.\n\nBecause the struct definition and the implementation/allocation policy for the digest buffers are not provided, you cannot conclude from this function alone that Rule 21.17 is violated. The report correctly identifies a risky coding practice (using sizeof on a member without knowing whether it is an array or pointer), but it overstates the certainty of a MISRA violation: the code only violates 21.17 if the sizeof expression yields an incorrect size that causes the called memory/string functions to access beyond the actual object bounds.\n\nRecommendation: make the intent explicit \u2014 either declare the digest members as fixed-size arrays (so sizeof yields the correct length) or, if pointers are used, store and pass an explicit length for each digest buffer (do not rely on sizeof of a pointer). That will remove the ambiguity and ensure compliance with Rule 21.17."
}