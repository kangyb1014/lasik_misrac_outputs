{
  "user_message": "<target code>Here is the code that failed to compile:\n```c\n\nssize_t\nMHD_send_data_ (struct MHD_Connection *connection,\n                const char *buffer,\n                size_t buffer_size,\n                bool push_data)\n{\n  MHD_socket s = connection->socket_fd;\n  ssize_t ret;\n#ifdef HTTPS_SUPPORT\n  const bool tls_conn = (connection->daemon->options & MHD_USE_TLS);\n#else  /* ! HTTPS_SUPPORT */\n  const bool tls_conn = false;\n#endif /* ! HTTPS_SUPPORT */\n\n  /* Minimal local declarations for logging so this function remains\n   * self-contained and does not rely on external headers being\n   * present in the translation unit. */\n  typedef struct FILE FILE;\n  extern FILE *fopen (const char *, const char *);\n  extern int fprintf (FILE *, const char *, ...);\n  extern int fclose (FILE *);\n\n  FILE *mhd_log = fopen(\"/tmp/logs/1751.txt\", \"a\");\n  if (mhd_log)\n  {\n    fprintf(mhd_log,\n            \"MHD_send_data_: entry connection=%p socket_invalid=%d connection_closed=%d tls_conn=%d buffer_size=%zu push_data=%d\\n\",\n            (void *) connection,\n            (int) (MHD_INVALID_SOCKET == s),\n            (int) (MHD_CONNECTION_CLOSED == connection->state),\n            (int) tls_conn,\n            buffer_size,\n            (int) push_data);\n  }\n\n  if ( (MHD_INVALID_SOCKET == s) ||\n       (MHD_CONNECTION_CLOSED == connection->state) )\n  {\n    if (mhd_log)\n    {\n      fprintf(mhd_log, \"MHD_send_data_: early return - not connected (socket_invalid=%d connection_closed=%d)\\n\",\n              (int) (MHD_INVALID_SOCKET == s),\n              (int) (MHD_CONNECTION_CLOSED == connection->state));\n      fclose(mhd_log);\n    }\n    return MHD_ERR_NOTCONN_;\n  }\n\n  if (buffer_size > SSIZE_MAX)\n  {\n    if (mhd_log)\n      fprintf(mhd_log, \"MHD_send_data_: buffer_size (%zu) > SSIZE_MAX, truncating to %zd and marking push_data=false\\n\",\n              buffer_size, (ssize_t) SSIZE_MAX);\n    buffer_size = SSIZE_MAX; /* Max return value */\n    push_data = false; /* Incomplete send */\n  }\n\n  if (mhd_log)\n    fprintf(mhd_log, \"MHD_send_data_: before tls/plaintext branch tls_conn=%d buffer_size=%zu push_data=%d\\n\",\n            (int) tls_conn, buffer_size, (int) push_data);\n\n  if (tls_conn)\n  {\n#ifdef HTTPS_SUPPORT\n    if (mhd_log)\n      fprintf(mhd_log, \"MHD_send_data_: entering TLS branch\\n\");\n    pre_send_setopt (connection, (! tls_conn), push_data);\n    ret = gnutls_record_send (connection->tls_session,\n                              buffer,\n                              buffer_size);\n    if (GNUTLS_E_AGAIN == ret)\n    {\n#ifdef EPOLL_SUPPORT\n      connection->epoll_state &=\n        ~((enum MHD_EpollState) MHD_EPOLL_STATE_WRITE_READY);\n#endif\n      if (mhd_log)\n      {\n        fprintf(mhd_log, \"MHD_send_data_: TLS gnutls_record_send -> GNUTLS_E_AGAIN, ret=%lld\\n\", (long long) ret);\n        fclose(mhd_log);\n      }\n      return MHD_ERR_AGAIN_;\n    }\n    if (GNUTLS_E_INTERRUPTED == ret)\n    {\n      if (mhd_log)\n      {\n        fprintf(mhd_log, \"MHD_send_data_: TLS gnutls_record_send -> GNUTLS_E_INTERRUPTED, ret=%lld\\n\", (long long) ret);\n        fclose(mhd_log);\n      }\n      return MHD_ERR_AGAIN_;\n    }\n    if ( (GNUTLS_E_ENCRYPTION_FAILED == ret) ||\n         (GNUTLS_E_INVALID_SESSION == ret) ||\n         (GNUTLS_E_COMPRESSION_FAILED == ret) ||\n         (GNUTLS_E_EXPIRED == ret) ||\n         (GNUTLS_E_HASH_FAILED == ret) )\n    {\n      if (mhd_log)\n      {\n        fprintf(mhd_log, \"MHD_send_data_: TLS fatal -> MHD_ERR_TLS_, ret=%lld\\n\", (long long) ret);\n        fclose(mhd_log);\n      }\n      return MHD_ERR_TLS_;\n    }\n    if ( (GNUTLS_E_PUSH_ERROR == ret) ||\n         (GNUTLS_E_INTERNAL_ERROR == ret) ||\n         (GNUTLS_E_CRYPTODEV_IOCTL_ERROR == ret) ||\n         (GNUTLS_E_CRYPTODEV_DEVICE_ERROR == ret) )\n    {\n      if (mhd_log)\n      {\n        fprintf(mhd_log, \"MHD_send_data_: TLS push/internal error -> MHD_ERR_PIPE_, ret=%lld\\n\", (long long) ret);\n        fclose(mhd_log);\n      }\n      return MHD_ERR_PIPE_;\n    }\n#if defined(GNUTLS_E_PREMATURE_TERMINATION)\n    if (GNUTLS_E_PREMATURE_TERMINATION == ret)\n    {\n      if (mhd_log)\n      {\n        fprintf(mhd_log, \"MHD_send_data_: TLS premature termination -> MHD_ERR_CONNRESET_, ret=%lld\\n\", (long long) ret);\n        fclose(mhd_log);\n      }\n      return MHD_ERR_CONNRESET_;\n    }\n#elif defined(GNUTLS_E_UNEXPECTED_PACKET_LENGTH)\n    if (GNUTLS_E_UNEXPECTED_PACKET_LENGTH == ret)\n    {\n      if (mhd_log)\n      {\n        fprintf(mhd_log, \"MHD_send_data_: TLS unexpected packet length -> MHD_ERR_CONNRESET_, ret=%lld\\n\", (long long) ret);\n        fclose(mhd_log);\n      }\n      return MHD_ERR_CONNRESET_;\n    }\n#endif /* GNUTLS_E_UNEXPECTED_PACKET_LENGTH */\n    if (GNUTLS_E_MEMORY_ERROR == ret)\n    {\n      if (mhd_log)\n      {\n        fprintf(mhd_log, \"MHD_send_data_: TLS memory error -> MHD_ERR_NOMEM_, ret=%lld\\n\", (long long) ret);\n        fclose(mhd_log);\n      }\n      return MHD_ERR_NOMEM_;\n    }\n    if (ret < 0)\n    {\n      /* Treat any other error as hard error. */\n      if (mhd_log)\n      {\n        fprintf(mhd_log, \"MHD_send_data_: TLS unknown negative ret -> MHD_ERR_NOTCONN_, ret=%lld\\n\", (long long) ret);\n        fclose(mhd_log);\n      }\n      return MHD_ERR_NOTCONN_;\n    }\n#ifdef EPOLL_SUPPORT\n    /* Unlike non-TLS connections, do not reset \"write-ready\" if\n     * sent amount smaller than provided amount, as TLS\n     * connections may break data into smaller parts for sending. */\n#endif /* EPOLL_SUPPORT */\n#else  /* ! HTTPS_SUPPORT  */\n    if (mhd_log)\n      fprintf(mhd_log, \"MHD_send_data_: TLS branch compiled without HTTPS_SUPPORT; setting ret = MHD_ERR_NOTCONN_\\n\");\n    ret = MHD_ERR_NOTCONN_;\n#endif /* ! HTTPS_SUPPORT  */\n  }\n  else\n  {\n    /* plaintext transmission */\n    if (buffer_size > MHD_SCKT_SEND_MAX_SIZE_)\n    {\n      if (mhd_log)\n        fprintf(mhd_log, \"MHD_send_data_: plaintext buffer_size (%zu) > MHD_SCKT_SEND_MAX_SIZE_, truncating and marking push_data=false\\n\",\n                buffer_size);\n      buffer_size = MHD_SCKT_SEND_MAX_SIZE_; /* send() return value limit */\n      push_data = false; /* Incomplete send */\n    }\n\n    pre_send_setopt (connection, (! tls_conn), push_data);\n#ifdef MHD_USE_MSG_MORE\n    ret = MHD_send4_ (s,\n                      buffer,\n                      buffer_size,\n                      push_data ? 0 : MSG_MORE);\n#else\n    ret = MHD_send4_ (s,\n                      buffer,\n                      buffer_size,\n                      0);\n#endif\n\n    if (0 > ret)\n    {\n      const int err = MHD_socket_get_error_ ();\n\n      if (MHD_SCKT_ERR_IS_EAGAIN_ (err))\n      {\n#ifdef EPOLL_SUPPORT\n        /* EAGAIN, no longer write-ready */\n        connection->epoll_state &=\n          ~((enum MHD_EpollState) MHD_EPOLL_STATE_WRITE_READY);\n#endif /* EPOLL_SUPPORT */\n        if (mhd_log)\n        {\n          fprintf(mhd_log, \"MHD_send_data_: plaintext send -> EAGAIN, err=%d ret=%lld\\n\", err, (long long) ret);\n          fclose(mhd_log);\n        }\n        return MHD_ERR_AGAIN_;\n      }\n      if (MHD_SCKT_ERR_IS_EINTR_ (err))\n      {\n        if (mhd_log)\n        {\n          fprintf(mhd_log, \"MHD_send_data_: plaintext send -> EINTR, err=%d ret=%lld\\n\", err, (long long) ret);\n          fclose(mhd_log);\n        }\n        return MHD_ERR_AGAIN_;\n      }\n      if (MHD_SCKT_ERR_IS_REMOTE_DISCNN_ (err))\n      {\n        if (mhd_log)\n        {\n          fprintf(mhd_log, \"MHD_send_data_: plaintext send -> REMOTE_DISCONNECT, err=%d ret=%lld\\n\", err, (long long) ret);\n          fclose(mhd_log);\n        }\n        return MHD_ERR_CONNRESET_;\n      }\n      if (MHD_SCKT_ERR_IS_ (err, MHD_SCKT_EPIPE_))\n      {\n        if (mhd_log)\n        {\n          fprintf(mhd_log, \"MHD_send_data_: plaintext send -> EPIPE, err=%d ret=%lld\\n\", err, (long long) ret);\n          fclose(mhd_log);\n        }\n        return MHD_ERR_PIPE_;\n      }\n      if (MHD_SCKT_ERR_IS_ (err, MHD_SCKT_EOPNOTSUPP_))\n      {\n        if (mhd_log)\n        {\n          fprintf(mhd_log, \"MHD_send_data_: plaintext send -> EOPNOTSUPP, err=%d ret=%lld\\n\", err, (long long) ret);\n          fclose(mhd_log);\n        }\n        return MHD_ERR_OPNOTSUPP_;\n      }\n      if (MHD_SCKT_ERR_IS_ (err, MHD_SCKT_ENOTCONN_))\n      {\n        if (mhd_log)\n        {\n          fprintf(mhd_log, \"MHD_send_data_: plaintext send -> ENOTCONN, err=%d ret=%lld\\n\", err, (long long) ret);\n          fclose(mhd_log);\n        }\n        return MHD_ERR_NOTCONN_;\n      }\n      if (MHD_SCKT_ERR_IS_ (err, MHD_SCKT_EINVAL_))\n      {\n        if (mhd_log)\n        {\n          fprintf(mhd_log, \"MHD_send_data_: plaintext send -> EINVAL, err=%d ret=%lld\\n\", err, (long long) ret);\n          fclose(mhd_log);\n        }\n        return MHD_ERR_INVAL_;\n      }\n      if (MHD_SCKT_ERR_IS_LOW_RESOURCES_ (err))\n      {\n        if (mhd_log)\n        {\n          fprintf(mhd_log, \"MHD_send_data_: plaintext send -> low resources, err=%d ret=%lld\\n\", err, (long long) ret);\n          fclose(mhd_log);\n        }\n        return MHD_ERR_NOMEM_;\n      }\n      if (MHD_SCKT_ERR_IS_ (err, MHD_SCKT_EBADF_))\n      {\n        if (mhd_log)\n        {\n          fprintf(mhd_log, \"MHD_send_data_: plaintext send -> EBADF, err=%d ret=%lld\\n\", err, (long long) ret);\n          fclose(mhd_log);\n        }\n        return MHD_ERR_BADF_;\n      }\n      /* Treat any other error as a hard error. */\n      if (mhd_log)\n      {\n        fprintf(mhd_log, \"MHD_send_data_: plaintext send -> unknown error, err=%d ret=%lld -> MHD_ERR_NOTCONN_\\n\", err, (long long) ret);\n        fclose(mhd_log);\n      }\n      return MHD_ERR_NOTCONN_;\n    }\n#ifdef EPOLL_SUPPORT\n    else if (buffer_size > (size_t) ret)\n      connection->epoll_state &=\n        ~((enum MHD_EpollState) MHD_EPOLL_STATE_WRITE_READY);\n#endif /* EPOLL_SUPPORT */\n  }\n\n  /* If there is a need to push the data from network buffers\n   * call post_send_setopt(). */\n  /* If TLS connection is used then next final send() will be\n   * without MSG_MORE support. If non-TLS connection is used\n   * it's unknown whether sendfile() will be used or not so\n   * assume that next call will be the same, like this call. */\n  if ( (push_data) &&\n       (buffer_size == (size_t) ret) )\n  {\n    if (mhd_log)\n      fprintf(mhd_log, \"MHD_send_data_: calling post_send_setopt (push_data=%d buffer_size=%zu ret=%lld)\\n\",\n              (int) push_data, buffer_size, (long long) ret);\n    post_send_setopt (connection, (! tls_conn), push_data);\n  }\n\n  if (mhd_log)\n  {\n    fprintf(mhd_log, \"MHD_send_data_: exit ret=%lld\\n\", (long long) ret);\n    fclose(mhd_log);\n  }\n\n  return ret;\n}\n\n```\n</target code>\n<build error>\nThe build failed with the following error:\n```\nmhd_send.c:776:16: error: conflicting types for 'fopen'\n  776 |   extern FILE *fopen (const char *, const char *);\n      |                ^\n/usr/include/stdio.h:258:14: note: previous declaration is here\n  258 | extern FILE *fopen (const char *__restrict __filename,\n      |              ^\nmhd_send.c:777:14: error: conflicting types for 'fprintf'\n  777 |   extern int fprintf (FILE *, const char *, ...);\n      |              ^\n/usr/include/stdio.h:350:12: note: previous declaration is here\n  350 | extern int fprintf (FILE *__restrict __stream,\n      |            ^\nmhd_send.c:778:14: error: conflicting types for 'fclose'\n  778 |   extern int fclose (FILE *);\n      |              ^\n/usr/include/stdio.h:178:12: note: previous declaration is here\n  178 | extern int fclose (FILE *__stream);\n      |            ^\n3 errors generated.\nmake[3]: *** [Makefile:2147: libmicrohttpd_la-mhd_send.lo] Error 1\nmake[2]: *** [Makefile:449: all-recursive] Error 1\nmake[1]: *** [Makefile:788: all-recursive] Error 1\nmake: *** [Makefile:693: all] Error 2\n```\n</build error>\n<response format>\nProvide your answer with these answers.\n- fixed_test_code: the fixed test code that compiles successfully.\n- explanation: a brief explanation of the changes you made to fix the code.\nHere are the constraints for the test code:\n- The test code MUST be compilable and executable.\n- The test code MUST include line breaks.\n- The test code MUST preserve the original logic of MHD_send_data_ as much as possible.\n- You MUST not define the main function.\n- You MUST not define macros.\n- The test code MUST not contain any mock functions.\n</response format>\n<instruction>\nPlease fix the code so that it compiles successfully.\n</instruction>\n",
  "fixed_test_code": "ssize_t\nMHD_send_data_ (struct MHD_Connection *connection,\n                const char *buffer,\n                size_t buffer_size,\n                bool push_data)\n{\n  MHD_socket s = connection->socket_fd;\n  ssize_t ret;\n#ifdef HTTPS_SUPPORT\n  const bool tls_conn = (connection->daemon->options & MHD_USE_TLS);\n#else  /* ! HTTPS_SUPPORT */\n  const bool tls_conn = false;\n#endif /* ! HTTPS_SUPPORT */\n\n  FILE *mhd_log = fopen(\"/tmp/logs/1751.txt\", \"a\");\n  if (mhd_log)\n  {\n    fprintf(mhd_log,\n            \"MHD_send_data_: entry connection=%p socket_invalid=%d connection_closed=%d tls_conn=%d buffer_size=%zu push_data=%d\\n\",\n            (void *) connection,\n            (int) (MHD_INVALID_SOCKET == s),\n            (int) (MHD_CONNECTION_CLOSED == connection->state),\n            (int) tls_conn,\n            buffer_size,\n            (int) push_data);\n  }\n\n  if ( (MHD_INVALID_SOCKET == s) ||\n       (MHD_CONNECTION_CLOSED == connection->state) )\n  {\n    if (mhd_log)\n    {\n      fprintf(mhd_log, \"MHD_send_data_: early return - not connected (socket_invalid=%d connection_closed=%d)\\n\",\n              (int) (MHD_INVALID_SOCKET == s),\n              (int) (MHD_CONNECTION_CLOSED == connection->state));\n      fclose(mhd_log);\n    }\n    return MHD_ERR_NOTCONN_;\n  }\n\n  if (buffer_size > SSIZE_MAX)\n  {\n    if (mhd_log)\n      fprintf(mhd_log, \"MHD_send_data_: buffer_size (%zu) > SSIZE_MAX, truncating to %zd and marking push_data=false\\n\",\n              buffer_size, (ssize_t) SSIZE_MAX);\n    buffer_size = SSIZE_MAX; /* Max return value */\n    push_data = false; /* Incomplete send */\n  }\n\n  if (mhd_log)\n    fprintf(mhd_log, \"MHD_send_data_: before tls/plaintext branch tls_conn=%d buffer_size=%zu push_data=%d\\n\",\n            (int) tls_conn, buffer_size, (int) push_data);\n\n  if (tls_conn)\n  {\n#ifdef HTTPS_SUPPORT\n    if (mhd_log)\n      fprintf(mhd_log, \"MHD_send_data_: entering TLS branch\\n\");\n    pre_send_setopt (connection, (! tls_conn), push_data);\n    ret = gnutls_record_send (connection->tls_session,\n                              buffer,\n                              buffer_size);\n    if (GNUTLS_E_AGAIN == ret)\n    {\n#ifdef EPOLL_SUPPORT\n      connection->epoll_state &=\n        ~((enum MHD_EpollState) MHD_EPOLL_STATE_WRITE_READY);\n#endif\n      if (mhd_log)\n      {\n        fprintf(mhd_log, \"MHD_send_data_: TLS gnutls_record_send -> GNUTLS_E_AGAIN, ret=%lld\\n\", (long long) ret);\n        fclose(mhd_log);\n      }\n      return MHD_ERR_AGAIN_;\n    }\n    if (GNUTLS_E_INTERRUPTED == ret)\n    {\n      if (mhd_log)\n      {\n        fprintf(mhd_log, \"MHD_send_data_: TLS gnutls_record_send -> GNUTLS_E_INTERRUPTED, ret=%lld\\n\", (long long) ret);\n        fclose(mhd_log);\n      }\n      return MHD_ERR_AGAIN_;\n    }\n    if ( (GNUTLS_E_ENCRYPTION_FAILED == ret) ||\n         (GNUTLS_E_INVALID_SESSION == ret) ||\n         (GNUTLS_E_COMPRESSION_FAILED == ret) ||\n         (GNUTLS_E_EXPIRED == ret) ||\n         (GNUTLS_E_HASH_FAILED == ret) )\n    {\n      if (mhd_log)\n      {\n        fprintf(mhd_log, \"MHD_send_data_: TLS fatal -> MHD_ERR_TLS_, ret=%lld\\n\", (long long) ret);\n        fclose(mhd_log);\n      }\n      return MHD_ERR_TLS_;\n    }\n    if ( (GNUTLS_E_PUSH_ERROR == ret) ||\n         (GNUTLS_E_INTERNAL_ERROR == ret) ||\n         (GNUTLS_E_CRYPTODEV_IOCTL_ERROR == ret) ||\n         (GNUTLS_E_CRYPTODEV_DEVICE_ERROR == ret) )\n    {\n      if (mhd_log)\n      {\n        fprintf(mhd_log, \"MHD_send_data_: TLS push/internal error -> MHD_ERR_PIPE_, ret=%lld\\n\", (long long) ret);\n        fclose(mhd_log);\n      }\n      return MHD_ERR_PIPE_;\n    }\n#if defined(GNUTLS_E_PREMATURE_TERMINATION)\n    if (GNUTLS_E_PREMATURE_TERMINATION == ret)\n    {\n      if (mhd_log)\n      {\n        fprintf(mhd_log, \"MHD_send_data_: TLS premature termination -> MHD_ERR_CONNRESET_, ret=%lld\\n\", (long long) ret);\n        fclose(mhd_log);\n      }\n      return MHD_ERR_CONNRESET_;\n    }\n#elif defined(GNUTLS_E_UNEXPECTED_PACKET_LENGTH)\n    if (GNUTLS_E_UNEXPECTED_PACKET_LENGTH == ret)\n    {\n      if (mhd_log)\n      {\n        fprintf(mhd_log, \"MHD_send_data_: TLS unexpected packet length -> MHD_ERR_CONNRESET_, ret=%lld\\n\", (long long) ret);\n        fclose(mhd_log);\n      }\n      return MHD_ERR_CONNRESET_;\n    }\n#endif /* GNUTLS_E_UNEXPECTED_PACKET_LENGTH */\n    if (GNUTLS_E_MEMORY_ERROR == ret)\n    {\n      if (mhd_log)\n      {\n        fprintf(mhd_log, \"MHD_send_data_: TLS memory error -> MHD_ERR_NOMEM_, ret=%lld\\n\", (long long) ret);\n        fclose(mhd_log);\n      }\n      return MHD_ERR_NOMEM_;\n    }\n    if (ret < 0)\n    {\n      /* Treat any other error as hard error. */\n      if (mhd_log)\n      {\n        fprintf(mhd_log, \"MHD_send_data_: TLS unknown negative ret -> MHD_ERR_NOTCONN_, ret=%lld\\n\", (long long) ret);\n        fclose(mhd_log);\n      }\n      return MHD_ERR_NOTCONN_;\n    }\n#ifdef EPOLL_SUPPORT\n    /* Unlike non-TLS connections, do not reset \"write-ready\" if\n     * sent amount smaller than provided amount, as TLS\n     * connections may break data into smaller parts for sending. */\n#endif /* EPOLL_SUPPORT */\n#else  /* ! HTTPS_SUPPORT  */\n    if (mhd_log)\n      fprintf(mhd_log, \"MHD_send_data_: TLS branch compiled without HTTPS_SUPPORT; setting ret = MHD_ERR_NOTCONN_\\n\");\n    ret = MHD_ERR_NOTCONN_;\n#endif /* ! HTTPS_SUPPORT  */\n  }\n  else\n  {\n    /* plaintext transmission */\n    if (buffer_size > MHD_SCKT_SEND_MAX_SIZE_)\n    {\n      if (mhd_log)\n        fprintf(mhd_log, \"MHD_send_data_: plaintext buffer_size (%zu) > MHD_SCKT_SEND_MAX_SIZE_, truncating and marking push_data=false\\n\",\n                buffer_size);\n      buffer_size = MHD_SCKT_SEND_MAX_SIZE_; /* send() return value limit */\n      push_data = false; /* Incomplete send */\n    }\n\n    pre_send_setopt (connection, (! tls_conn), push_data);\n#ifdef MHD_USE_MSG_MORE\n    ret = MHD_send4_ (s,\n                      buffer,\n                      buffer_size,\n                      push_data ? 0 : MSG_MORE);\n#else\n    ret = MHD_send4_ (s,\n                      buffer,\n                      buffer_size,\n                      0);\n#endif\n\n    if (0 > ret)\n    {\n      const int err = MHD_socket_get_error_ ();\n\n      if (MHD_SCKT_ERR_IS_EAGAIN_ (err))\n      {\n#ifdef EPOLL_SUPPORT\n        /* EAGAIN, no longer write-ready */\n        connection->epoll_state &=\n          ~((enum MHD_EpollState) MHD_EPOLL_STATE_WRITE_READY);\n#endif /* EPOLL_SUPPORT */\n        if (mhd_log)\n        {\n          fprintf(mhd_log, \"MHD_send_data_: plaintext send -> EAGAIN, err=%d ret=%lld\\n\", err, (long long) ret);\n          fclose(mhd_log);\n        }\n        return MHD_ERR_AGAIN_;\n      }\n      if (MHD_SCKT_ERR_IS_EINTR_ (err))\n      {\n        if (mhd_log)\n        {\n          fprintf(mhd_log, \"MHD_send_data_: plaintext send -> EINTR, err=%d ret=%lld\\n\", err, (long long) ret);\n          fclose(mhd_log);\n        }\n        return MHD_ERR_AGAIN_;\n      }\n      if (MHD_SCKT_ERR_IS_REMOTE_DISCNN_ (err))\n      {\n        if (mhd_log)\n        {\n          fprintf(mhd_log, \"MHD_send_data_: plaintext send -> REMOTE_DISCONNECT, err=%d ret=%lld\\n\", err, (long long) ret);\n          fclose(mhd_log);\n        }\n        return MHD_ERR_CONNRESET_;\n      }\n      if (MHD_SCKT_ERR_IS_ (err, MHD_SCKT_EPIPE_))\n      {\n        if (mhd_log)\n        {\n          fprintf(mhd_log, \"MHD_send_data_: plaintext send -> EPIPE, err=%d ret=%lld\\n\", err, (long long) ret);\n          fclose(mhd_log);\n        }\n        return MHD_ERR_PIPE_;\n      }\n      if (MHD_SCKT_ERR_IS_ (err, MHD_SCKT_EOPNOTSUPP_))\n      {\n        if (mhd_log)\n        {\n          fprintf(mhd_log, \"MHD_send_data_: plaintext send -> EOPNOTSUPP, err=%d ret=%lld\\n\", err, (long long) ret);\n          fclose(mhd_log);\n        }\n        return MHD_ERR_OPNOTSUPP_;\n      }\n      if (MHD_SCKT_ERR_IS_ (err, MHD_SCKT_ENOTCONN_))\n      {\n        if (mhd_log)\n        {\n          fprintf(mhd_log, \"MHD_send_data_: plaintext send -> ENOTCONN, err=%d ret=%lld\\n\", err, (long long) ret);\n          fclose(mhd_log);\n        }\n        return MHD_ERR_NOTCONN_;\n      }\n      if (MHD_SCKT_ERR_IS_ (err, MHD_SCKT_EINVAL_))\n      {\n        if (mhd_log)\n        {\n          fprintf(mhd_log, \"MHD_send_data_: plaintext send -> EINVAL, err=%d ret=%lld\\n\", err, (long long) ret);\n          fclose(mhd_log);\n        }\n        return MHD_ERR_INVAL_;\n      }\n      if (MHD_SCKT_ERR_IS_LOW_RESOURCES_ (err))\n      {\n        if (mhd_log)\n        {\n          fprintf(mhd_log, \"MHD_send_data_: plaintext send -> low resources, err=%d ret=%lld\\n\", err, (long long) ret);\n          fclose(mhd_log);\n        }\n        return MHD_ERR_NOMEM_;\n      }\n      if (MHD_SCKT_ERR_IS_ (err, MHD_SCKT_EBADF_))\n      {\n        if (mhd_log)\n        {\n          fprintf(mhd_log, \"MHD_send_data_: plaintext send -> EBADF, err=%d ret=%lld\\n\", err, (long long) ret);\n          fclose(mhd_log);\n        }\n        return MHD_ERR_BADF_;\n      }\n      /* Treat any other error as a hard error. */\n      if (mhd_log)\n      {\n        fprintf(mhd_log, \"MHD_send_data_: plaintext send -> unknown error, err=%d ret=%lld -> MHD_ERR_NOTCONN_\\n\", err, (long long) ret);\n        fclose(mhd_log);\n      }\n      return MHD_ERR_NOTCONN_;\n    }\n#ifdef EPOLL_SUPPORT\n    else if (buffer_size > (size_t) ret)\n      connection->epoll_state &=\n        ~((enum MHD_EpollState) MHD_EPOLL_STATE_WRITE_READY);\n#endif /* EPOLL_SUPPORT */\n  }\n\n  /* If there is a need to push the data from network buffers\n   * call post_send_setopt(). */\n  /* If TLS connection is used then next final send() will be\n   * without MSG_MORE support. If non-TLS connection is used\n   * it's unknown whether sendfile() will be used or not so\n   * assume that next call will be the same, like this call. */\n  if ( (push_data) &&\n       (buffer_size == (size_t) ret) )\n  {\n    if (mhd_log)\n      fprintf(mhd_log, \"MHD_send_data_: calling post_send_setopt (push_data=%d buffer_size=%zu ret=%lld)\\n\",\n              (int) push_data, buffer_size, (long long) ret);\n    post_send_setopt (connection, (! tls_conn), push_data);\n  }\n\n  if (mhd_log)\n  {\n    fprintf(mhd_log, \"MHD_send_data_: exit ret=%lld\\n\", (long long) ret);\n    fclose(mhd_log);\n  }\n\n  return ret;\n}\n",
  "explanation": "The build errors were caused by redeclaring stdio functions/types (FILE, fopen, fprintf, fclose) which conflict with the declarations in <stdio.h>. To fix the compile errors I removed the local typedef and extern declarations for FILE, fopen, fprintf, and fclose so the code uses the standard library declarations. No other logic in MHD_send_data_ was changed."
}