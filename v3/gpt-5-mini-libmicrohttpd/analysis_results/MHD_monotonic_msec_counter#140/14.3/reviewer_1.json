{
  "user_message": "An agent A claimed that the following MHD_monotonic_msec_counter code violates the MISRA C 2023 rule 14.3.\n<misra_rule>\nMISRA C 2023 Rule 14.3 is Controlling expressions shall not be invariant.\nHere are exceptions to this rule:\n1. Invariants that are used to create infinite loops are permitted.\n2. A do-while loop with an essentially Boolean controlling expression that evaluates to false and satisfies the constraints and semantics for an integer constant expression is permitted.\n</misra_rule>\n<target_code>\nHere is the original code of MHD_monotonic_msec_counter.\n```c\nuint64_t\nMHD_monotonic_msec_counter (void)\n{\n#if defined(HAVE_CLOCK_GETTIME) || defined(HAVE_TIMESPEC_GET)\n  struct timespec ts;\n#endif /* HAVE_CLOCK_GETTIME || HAVE_TIMESPEC_GET */\n\n#ifdef HAVE_CLOCK_GETTIME\n  if ( (_MHD_UNWANTED_CLOCK != mono_clock_id) &&\n       (0 == clock_gettime (mono_clock_id,\n                            &ts)) )\n    return (uint64_t) (((uint64_t) (ts.tv_sec - mono_clock_start)) * 1000\n                       + (uint64_t) (ts.tv_nsec / 1000000));\n#endif /* HAVE_CLOCK_GETTIME */\n#ifdef HAVE_CLOCK_GET_TIME\n  if (_MHD_INVALID_CLOCK_SERV != mono_clock_service)\n  {\n    mach_timespec_t cur_time;\n\n    if (KERN_SUCCESS == clock_get_time (mono_clock_service,\n                                        &cur_time))\n      return (uint64_t) (((uint64_t) (cur_time.tv_sec - mono_clock_start))\n                         * 1000 + (uint64_t) (cur_time.tv_nsec / 1000000));\n  }\n#endif /* HAVE_CLOCK_GET_TIME */\n#if defined(_WIN32)\n#if _WIN32_WINNT >= 0x0600\n  if (1)\n    return (uint64_t) (GetTickCount64 () - tick_start);\n#else  /* _WIN32_WINNT < 0x0600 */\n  if (0 != perf_freq)\n  {\n    LARGE_INTEGER perf_counter;\n    uint64_t num_ticks;\n\n    QueryPerformanceCounter (&perf_counter);   /* never fail on XP and later */\n    num_ticks = (uint64_t) (perf_counter.QuadPart - perf_start);\n    return ((num_ticks / perf_freq) * 1000)\n           + ((num_ticks % perf_freq) / (perf_freq / 1000));\n  }\n#endif /* _WIN32_WINNT < 0x0600 */\n#endif /* _WIN32 */\n#ifdef HAVE_GETHRTIME\n  if (1)\n    return ((uint64_t) (gethrtime () - hrtime_start)) / 1000000;\n#endif /* HAVE_GETHRTIME */\n\n  /* Fallbacks, affected by system time change */\n#ifdef HAVE_TIMESPEC_GET\n  if (TIME_UTC == timespec_get (&ts, TIME_UTC))\n    return (uint64_t) (((uint64_t) (ts.tv_sec - gettime_start)) * 1000\n                       + (uint64_t) (ts.tv_nsec / 1000000));\n#elif defined(HAVE_GETTIMEOFDAY)\n  if (1)\n  {\n    struct timeval tv;\n    if (0 == gettimeofday (&tv, NULL))\n      return (uint64_t) (((uint64_t) (tv.tv_sec - gettime_start)) * 1000\n                         + (uint64_t) (tv.tv_usec / 1000));\n  }\n#endif /* HAVE_GETTIMEOFDAY */\n\n  /* The last resort fallback with very low resolution */\n  return (uint64_t) (time (NULL) - sys_clock_start) * 1000;\n}\n```\n</target_code>\n<response format>\nProvide your answer with these fields.\n- explanation: your evaluation of the scenario provided by the agent A.\n- is_report_correct: whether the report is correct or not (true/false). True means there is a violation.\n</response format>\n<scenario>\nThe agent A provided the following violation scenario:\nThe controlling expression of the if statement is the integer constant 1: \"if (1) return (uint64_t) (GetTickCount64 () - tick_start);\". This is an invariant controlling expression (always true) that is not used to create an infinite loop nor is it the permitted do-while false constant exception, so it violates MISRA C 2023 Rule 14.3.\n</scenario>\n\n<execution_log>\nThe agent A also provided the following output log:\nenter - MHD_monotonic_msec_counter: value=0\nclock_gettime - monotonic: value=646\nenter - MHD_monotonic_msec_counter: value=0\nclock_gettime - monotonic: value=646\nenter - MHD_monotonic_msec_counter: value=0\nclock_gettime - monotonic: value=646\nenter - MHD_monotonic_msec_counter: value=0\nclock_gettime - monotonic: value=646\nenter - MHD_monotonic_msec_counter: value=0\nclock_gettime - monotonic: value=646\nenter - MHD_monotonic_msec_counter: value=0\nclock_gettime - monotonic: value=646\nenter - MHD_monotonic_msec_counter: value=0\nclock_gettime - monotonic: value=646\nenter - MHD_monotonic_msec_counter: value=0\nclock_gettime - monotonic: value=646\nenter - MHD_monotonic_msec_counter: value=0\nclock_gettime - monotonic: value=646\nenter - MHD_monotonic_msec_counter: value=0\nclock_gettime - monotonic: value=646\nenter - MHD_monotonic_msec_counter: value=0\nclock_gettime - monotonic: value=646\nenter - MHD_monotonic_msec_counter: value=0\nclock_gettime - monotonic: value=646\nenter - MHD_monotonic_msec_counter: value=0\nclock_gettime - monotonic: value=646\nenter - MHD_monotonic_msec_counter: value=0\nclock_gettime - monotonic: value=646\nenter - MHD_monotonic_msec_counter: value=0\nclock_gettime - monotonic: value=646\nenter - MHD_monotonic_msec_counter: value=0\nclock_gettime - monotonic: value=646\nenter - MHD_monotonic_msec_counter: value=0\nclock_gettime - monotonic: value=646\nenter - MHD_monotonic_msec_counter: value=0\nclock_gettime - monotonic: value=646\nenter - MHD_monotonic_msec_counter: value=0\nclock_gettime - monotonic: value=646\nenter - MHD_monotonic_msec_counter: value=0\nclock_gettime - monotonic: value=646\nenter - MHD_monotonic_msec_counter: value=0\nclock_gettime - monotonic: value=646\nenter - MHD_monotonic_msec_counter: value=0\nclock_gettime - monotonic: value=646\nenter - MHD_monotonic_msec_counter: value=0\nclock_gettime - monotonic: value=646\nenter - MHD_monotonic_msec_counter: value=0\nclock_gettime - monotonic: value=646\nenter - MHD_monotonic_msec_counter: value=0\nclock_gettime - monotonic: value=646\nenter - MHD_monotonic_msec_counter: value=0\nclock_gettime - monotonic: value=646\nenter - MHD_monotonic_msec_counter: value=0\nclock_gettime - monotonic: value=646\nenter - MHD_monotonic_msec_counter: value=0\nclock_gettime - monotonic: value=646\nenter - MHD_monotonic_msec_counter: value=0\nclock_gettime - monotonic: value=646\nenter - MHD_monotonic_msec_counter: value=0\nclock_gettime - monotonic: value=646\nenter - MHD_monotonic_msec_counter: value=0\nclock_gettime - monotonic: value=646\nenter - MHD_monotonic_msec_counter: value=0\nclock_gettime - monotonic: value=646\nenter - MHD_monotonic_msec_counter: value=0\nclock_gettime - monotonic: value=646\nenter - MHD_monotonic_msec_counter: value=0\nclock_gettime - monotonic: value=646\nenter - MHD_monotonic_msec_counter: value=0\nclock_gettime - monotonic: value=646\nenter - MHD_monotonic_msec_counter: value=0\nclock_gettime - monotonic: value=646\nenter - MHD_monotonic_msec_counter: value=0\nclock_gettime - monotonic: value=646\nenter - MHD_monotonic_msec_counter: value=0\nclock_gettime - monotonic: value=646\nenter - MHD_monotonic_msec_counter: value=0\nclock_gettime - monotonic: value=646\nenter - MHD_monotonic_msec_counter: value=0\nclock_gettime - monotonic: value=646\nenter - MHD_monotonic_msec_counter: value=0\nclock_gettime - monotonic: value=650\nenter - MHD_monotonic_msec_counter: value=0\nclock_gettime - monotonic: value=650\nenter - MHD_monotonic_msec_counter: value=0\nclock_gettime - monotonic: value=650\nenter - MHD_monotonic_msec_counter: value=0\nclock_gettime - monotonic: value=650\nenter - MHD_monotonic_msec_counter: value=0\nclock_gettime - monotonic: value=650\nenter - MHD_monotonic_msec_counter: value=0\nclock_gettime - monotonic: value=650\nenter - MHD_monotonic_msec_counter: value=0\nclock_gettime - monotonic: value=650\nenter - MHD_monotonic_msec_counter: value=0\nclock_gettime - monotonic: value=650\nenter - MHD_monotonic_msec_counter: value=0\nclock_gettime - monotonic: value=650\nenter - MHD_monotonic_msec_counter: value=0\nclock_gettime - monotonic: value=650\nenter - MHD_monotonic_msec_counter: value=0\ncl\n</execution_log>\n\n<instruction>\nJudge whether the report is correct or not.\n</instruction>\n",
  "is_report_correct": true,
  "explanation": "MISRA C:2023 Rule 14.3 prohibits invariant controlling expressions (except for infinite loops or the specific do-while false exception). The code contains at least three occurrences of an invariant controlling expression \"if (1) ...\" (e.g. the _WIN32_WINNT >= 0x0600 branch: if (1) return (uint64_t) (GetTickCount64 () - tick_start); and similar if (1) uses under HAVE_GETHRTIME and the gettimeofday fallback). These are not used to form infinite loops nor are they the permitted do-while false pattern, so they are invariant controlling expressions in violation of Rule 14.3. Therefore the report is correct."
}