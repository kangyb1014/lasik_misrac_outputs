{
  "user_message": "An agent A claimed that the following MHD_monotonic_msec_counter code violates the MISRA C 2023 rule 2.1.\n<misra_rule>\nMISRA C 2023 Rule 2.1 is A project shall not contain unreachable code.\n\n</misra_rule>\n<target_code>\nHere is the original code of MHD_monotonic_msec_counter.\n```c\nuint64_t\nMHD_monotonic_msec_counter (void)\n{\n#if defined(HAVE_CLOCK_GETTIME) || defined(HAVE_TIMESPEC_GET)\n  struct timespec ts;\n#endif /* HAVE_CLOCK_GETTIME || HAVE_TIMESPEC_GET */\n\n#ifdef HAVE_CLOCK_GETTIME\n  if ( (_MHD_UNWANTED_CLOCK != mono_clock_id) &&\n       (0 == clock_gettime (mono_clock_id,\n                            &ts)) )\n    return (uint64_t) (((uint64_t) (ts.tv_sec - mono_clock_start)) * 1000\n                       + (uint64_t) (ts.tv_nsec / 1000000));\n#endif /* HAVE_CLOCK_GETTIME */\n#ifdef HAVE_CLOCK_GET_TIME\n  if (_MHD_INVALID_CLOCK_SERV != mono_clock_service)\n  {\n    mach_timespec_t cur_time;\n\n    if (KERN_SUCCESS == clock_get_time (mono_clock_service,\n                                        &cur_time))\n      return (uint64_t) (((uint64_t) (cur_time.tv_sec - mono_clock_start))\n                         * 1000 + (uint64_t) (cur_time.tv_nsec / 1000000));\n  }\n#endif /* HAVE_CLOCK_GET_TIME */\n#if defined(_WIN32)\n#if _WIN32_WINNT >= 0x0600\n  if (1)\n    return (uint64_t) (GetTickCount64 () - tick_start);\n#else  /* _WIN32_WINNT < 0x0600 */\n  if (0 != perf_freq)\n  {\n    LARGE_INTEGER perf_counter;\n    uint64_t num_ticks;\n\n    QueryPerformanceCounter (&perf_counter);   /* never fail on XP and later */\n    num_ticks = (uint64_t) (perf_counter.QuadPart - perf_start);\n    return ((num_ticks / perf_freq) * 1000)\n           + ((num_ticks % perf_freq) / (perf_freq / 1000));\n  }\n#endif /* _WIN32_WINNT < 0x0600 */\n#endif /* _WIN32 */\n#ifdef HAVE_GETHRTIME\n  if (1)\n    return ((uint64_t) (gethrtime () - hrtime_start)) / 1000000;\n#endif /* HAVE_GETHRTIME */\n\n  /* Fallbacks, affected by system time change */\n#ifdef HAVE_TIMESPEC_GET\n  if (TIME_UTC == timespec_get (&ts, TIME_UTC))\n    return (uint64_t) (((uint64_t) (ts.tv_sec - gettime_start)) * 1000\n                       + (uint64_t) (ts.tv_nsec / 1000000));\n#elif defined(HAVE_GETTIMEOFDAY)\n  if (1)\n  {\n    struct timeval tv;\n    if (0 == gettimeofday (&tv, NULL))\n      return (uint64_t) (((uint64_t) (tv.tv_sec - gettime_start)) * 1000\n                         + (uint64_t) (tv.tv_usec / 1000));\n  }\n#endif /* HAVE_GETTIMEOFDAY */\n\n  /* The last resort fallback with very low resolution */\n  return (uint64_t) (time (NULL) - sys_clock_start) * 1000;\n}\n```\n</target_code>\n<response format>\nProvide your answer with these fields.\n- explanation: your evaluation of the scenario provided by the agent A.\n- is_report_correct: whether the report is correct or not (true/false). True means there is a violation.\n</response format>\n<scenario>\nThe agent A provided the following violation scenario:\nWhen the code is compiled so that one of the unconditional-return branches is active (for example on Windows with _WIN32 and _WIN32_WINNT >= 0x0600 the block with \"if (1) return (uint64_t) (GetTickCount64 () - tick_start);\" is included, or when HAVE_GETHRTIME is defined which contains \"if (1) return ...\"), that unconditional return will always transfer control out of the function and the final fallback statement\n    return (uint64_t) (time (NULL) - sys_clock_start) * 1000;\ncan never be reached. In such a build configuration the final return is unreachable, violating MISRA C 2023 Rule 2.1.\n</scenario>\n\n<execution_log>\nThe agent A also provided the following output log:\n[1756197312] path=HAVE_CLOCK_GETTIME; mono_clock_id=6; _MHD_UNWANTED_CLOCK=0; ts.tv_sec=10955762; ts.tv_nsec=526383035; mono_clock_start=10955762; result=526\n[1756197312] path=HAVE_CLOCK_GETTIME; mono_clock_id=6; _MHD_UNWANTED_CLOCK=0; ts.tv_sec=10955762; ts.tv_nsec=526383035; mono_clock_start=10955762; result=526\n[1756197312] path=HAVE_CLOCK_GETTIME; mono_clock_id=6; _MHD_UNWANTED_CLOCK=0; ts.tv_sec=10955762; ts.tv_nsec=526383035; mono_clock_start=10955762; result=526\n[1756197312] path=HAVE_CLOCK_GETTIME; mono_clock_id=6; _MHD_UNWANTED_CLOCK=0; ts.tv_sec=10955762; ts.tv_nsec=526383035; mono_clock_start=10955762; result=526\n[1756197312] path=HAVE_CLOCK_GETTIME; mono_clock_id=6; _MHD_UNWANTED_CLOCK=0; ts.tv_sec=10955762; ts.tv_nsec=526383035; mono_clock_start=10955762; result=526\n[1756197312] path=HAVE_CLOCK_GETTIME; mono_clock_id=6; _MHD_UNWANTED_CLOCK=0; ts.tv_sec=10955762; ts.tv_nsec=526383035; mono_clock_start=10955762; result=526\n[1756197312] path=HAVE_CLOCK_GETTIME; mono_clock_id=6; _MHD_UNWANTED_CLOCK=0; ts.tv_sec=10955762; ts.tv_nsec=526383035; mono_clock_start=10955762; result=526\n[1756197312] path=HAVE_CLOCK_GETTIME; mono_clock_id=6; _MHD_UNWANTED_CLOCK=0; ts.tv_sec=10955762; ts.tv_nsec=526383035; mono_clock_start=10955762; result=526\n[1756197312] path=HAVE_CLOCK_GETTIME; mono_clock_id=6; _MHD_UNWANTED_CLOCK=0; ts.tv_sec=10955762; ts.tv_nsec=526383035; mono_clock_start=10955762; result=526\n[1756197312] path=HAVE_CLOCK_GETTIME; mono_clock_id=6; _MHD_UNWANTED_CLOCK=0; ts.tv_sec=10955762; ts.tv_nsec=526383035; mono_clock_start=10955762; result=526\n[1756197312] path=HAVE_CLOCK_GETTIME; mono_clock_id=6; _MHD_UNWANTED_CLOCK=0; ts.tv_sec=10955762; ts.tv_nsec=526383035; mono_clock_start=10955762; result=526\n[1756197312] path=HAVE_CLOCK_GETTIME; mono_clock_id=6; _MHD_UNWANTED_CLOCK=0; ts.tv_sec=10955762; ts.tv_nsec=526383035; mono_clock_start=10955762; result=526\n[1756197312] path=HAVE_CLOCK_GETTIME; mono_clock_id=6; _MHD_UNWANTED_CLOCK=0; ts.tv_sec=10955762; ts.tv_nsec=526383035; mono_clock_start=10955762; result=526\n[1756197312] path=HAVE_CLOCK_GETTIME; mono_clock_id=6; _MHD_UNWANTED_CLOCK=0; ts.tv_sec=10955762; ts.tv_nsec=526383035; mono_clock_start=10955762; result=526\n[1756197312] path=HAVE_CLOCK_GETTIME; mono_clock_id=6; _MHD_UNWANTED_CLOCK=0; ts.tv_sec=10955762; ts.tv_nsec=526383035; mono_clock_start=10955762; result=526\n[1756197312] path=HAVE_CLOCK_GETTIME; mono_clock_id=6; _MHD_UNWANTED_CLOCK=0; ts.tv_sec=10955762; ts.tv_nsec=526383035; mono_clock_start=10955762; result=526\n[1756197312] path=HAVE_CLOCK_GETTIME; mono_clock_id=6; _MHD_UNWANTED_CLOCK=0; ts.tv_sec=10955762; ts.tv_nsec=526383035; mono_clock_start=10955762; result=526\n[1756197312] path=HAVE_CLOCK_GETTIME; mono_clock_id=6; _MHD_UNWANTED_CLOCK=0; ts.tv_sec=10955762; ts.tv_nsec=526383035; mono_clock_start=10955762; result=526\n[1756197312] path=HAVE_CLOCK_GETTIME; mono_clock_id=6; _MHD_UNWANTED_CLOCK=0; ts.tv_sec=10955762; ts.tv_nsec=526383035; mono_clock_start=10955762; result=526\n[1756197312] path=HAVE_CLOCK_GETTIME; mono_clock_id=6; _MHD_UNWANTED_CLOCK=0; ts.tv_sec=10955762; ts.tv_nsec=526383035; mono_clock_start=10955762; result=526\n[1756197312] path=HAVE_CLOCK_GETTIME; mono_clock_id=6; _MHD_UNWANTED_CLOCK=0; ts.tv_sec=10955762; ts.tv_nsec=526383035; mono_clock_start=10955762; result=526\n[1756197312] path=HAVE_CLOCK_GETTIME; mono_clock_id=6; _MHD_UNWANTED_CLOCK=0; ts.tv_sec=10955762; ts.tv_nsec=526383035; mono_clock_start=10955762; result=526\n[1756197312] path=HAVE_CLOCK_GETTIME; mono_clock_id=6; _MHD_UNWANTED_CLOCK=0; ts.tv_sec=10955762; ts.tv_nsec=526383035; mono_clock_start=10955762; result=526\n[1756197312] path=HAVE_CLOCK_GETTIME; mono_clock_id=6; _MHD_UNWANTED_CLOCK=0; ts.tv_sec=10955762; ts.tv_nsec=526383035; mono_clock_start=10955762; result=526\n[1756197312] path=HAVE_CLOCK_GETTIME; mono_clock_id=6; _MHD_UNWANTED_CLOCK=0; ts.tv_sec=10955762; ts.tv_nsec=526383035; mono_clock_start=10955762; result=526\n[1756197312] path=HAVE_CLOCK_GETTIME; mono_clock_id=6; _MHD_UNWANTED_CLOCK=0; ts.tv_sec=10955762; ts.tv_nsec=526383035; mono_clock_start=10955762;\n</execution_log>\n\n<instruction>\nJudge whether the report is correct or not.\n</instruction>\n",
  "is_report_correct": true,
  "explanation": "MISRA C:2023 Rule 2.1 forbids unreachable code. In the posted function several compile-time branches contain unconditional returns (e.g. the #if _WIN32 && _WIN32_WINNT >= 0x0600 branch has \"if (1) return ...\"; similarly HAVE_GETHRTIME yields \"if (1) return ...\"). When the source is preprocessed/compiled with such a branch active, control will always leave the function at that early return and the final fallback return (the return (uint64_t) (time (NULL) - sys_clock_start) * 1000;) can never be reached. In other words, for those build configurations the final return is indeed unreachable, which is a breach of Rule 2.1. (Note: the code is only unreachable in the translation-unit configuration that defines the corresponding macros; if the project never builds that configuration then there is no violation in the project \u2014 but for the example configurations given by Agent A the report is correct.)"
}