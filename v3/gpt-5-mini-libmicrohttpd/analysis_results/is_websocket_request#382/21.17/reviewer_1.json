{
  "user_message": "An agent A claimed that the following is_websocket_request code violates the MISRA C 2023 rule 21.17.\n<misra_rule>\nMISRA C 2023 Rule 21.17 is Use of the string handling functions from <string.h> shall not result in accesses beyond the bounds of the objects referenced by their pointer parameters.\nThis rule strictly applies to the Standard Library functions in <string.h> such as memcpy, memmove, memset, memcmp, strcpy, strncpy, strcat, strncat, strlen, and strspn.\n</misra_rule>\n<target_code>\nHere is the original code of is_websocket_request.\n```c\nstatic enum MHD_Result\nis_websocket_request (struct MHD_Connection *con, const char *upg_header,\n                      const char *con_header)\n{\n\n  (void) con;  /* Unused. Silent compiler warning. */\n\n  return ((upg_header != NULL) && (con_header != NULL)\n          && (0 == strcmp (upg_header, WS_UPGRADE_VALUE))\n          && (NULL != strstr (con_header, \"Upgrade\")))\n         ? MHD_YES\n         : MHD_NO;\n}\n```\n</target_code>\n<response format>\nProvide your answer with these fields.\n- explanation: your evaluation of the scenario provided by the agent A.\n- is_report_correct: whether the report is correct or not (true/false). True means there is a violation.\n</response format>\n<scenario>\nThe agent A provided the following violation scenario:\nThe code only checks upg_header != NULL but uses strcmp(upg_header, WS_UPGRADE_VALUE). If upg_header does not point to a null-terminated character array (for example it points into an HTTP header buffer that is not NUL-terminated or whose valid length is bounded and not terminated), strcmp will read past the object bounds searching for a '\\0', causing out-of-bounds access and undefined behavior. (WS_UPGRADE_VALUE as a string literal is safe, but the caller-supplied upg_header may be unsafe.)\n</scenario>\n\n<instruction>\nJudge whether the report is correct or not.\n</instruction>\n",
  "is_report_correct": true,
  "explanation": "Agent A is correct. MISRA C 2023 Rule 21.17 requires that uses of string.h functions must not cause accesses beyond the bounds of the objects referenced by their pointer parameters. The code only checks for NULL but does not ensure that upg_header (and similarly con_header used with strstr) points to a NUL-terminated character array or to an object large enough for strcmp()/strstr() to read. If upg_header is non-NULL but not NUL-terminated (for example it points into a header buffer with an explicit length), strcmp(upg_header, WS_UPGRADE_VALUE) may read past the end of the object, causing out-of-bounds access and undefined behavior. The call is therefore a potential violation of Rule 21.17 unless there is an external, provable contract that guarantees the pointers reference NUL-terminated strings. Recommended fixes: ensure the inputs are NUL-terminated before calling strcmp/strstr, or use bounded comparisons (e.g. strncmp with known length of the literal, memcmp with the documented header length, or check with strnlen/explicit length from the HTTP parser)."
}