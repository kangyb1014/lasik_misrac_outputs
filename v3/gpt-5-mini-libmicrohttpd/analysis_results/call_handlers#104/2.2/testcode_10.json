{
  "user_message": "<misra_rule>\nMISRA C 2023 Rule 2.2 is: A project shall not contain dead code.\nAny operation that is executed but whose removal would not affect program behaviour constitutes dead code. Notes:\n1. The behaviour of an embedded sytem is often determined not just by the nature of its actions, but also by the time at which they occur.\n2. unreachable code is not dead code, as it cannot be executed.\n3.Initialization is not the same as an assignment operation and is therfore not a candidate for dead code.\n</misra_rule>\n\nAnother agent reported that the target code violated the Rule 2.2.\nHere is the comment from the agent.\n<violation scenario>\nThe mhd_assert call contains a function call MHD_thread_handle_ID_is_valid_ID_(con->tid) which is used only for diagnostic checking. If mhd_assert is a macro that is compiled out in production (e.g. defined to ((void)0)) or if the checked function has no side effects, then the call is an operation that can be removed without changing program behaviour (except diagnostics). In builds where the assertion is evaluated the function call is executed but its removal would not affect normal program behaviour, so this constitutes dead code under MISRA C 2023 Rule 2.2.\n</violation scenario>\n\nYour job is to insert logging code to capture the control flow and state information of the program.\nInsert logging code so that other agents can reproduce and get evidence for the violation scenario.\n<response format>\n- test_code: a modified call_handlers code that contains useful probe functions that print useful logs to a file \"/tmp/logs/1042.txt\". The logs should contain the control path and state information of the violation scenario. If test code is not required to validate the scenario, you can leave this blank.\nHere are the constraints for the test code:\n- The test code MUST preserve the original logic of call_handlers as much as possible.\nYou CAN just insert probe functions to the original code.\n- DO NOT introduce new violations to demonstrate your scenario.\n- The test code MUST be compilable and executable.\n- The test code MUST include line breaks.\n- You MUST NOT define the main function.\n- You MUST NOT define macros.\n</response format>\n<target_code>\nHere is the code of call_handlers:\n```c\nstatic enum MHD_Result\ncall_handlers (struct MHD_Connection *con,\n               bool read_ready,\n               bool write_ready,\n               bool force_close)\n{\n  enum MHD_Result ret;\n  bool states_info_processed = false;\n  /* Fast track flag */\n  bool on_fasttrack = (con->state == MHD_CONNECTION_INIT);\n  ret = MHD_YES;\n\n  mhd_assert ((0 == (con->daemon->options & MHD_USE_SELECT_INTERNALLY)) || \\\n              (MHD_thread_handle_ID_is_valid_ID_ (con->tid)));\n  mhd_assert ((0 != (con->daemon->options & MHD_USE_SELECT_INTERNALLY)) || \\\n              (! MHD_thread_handle_ID_is_valid_ID_ (con->tid)));\n  mhd_assert ((0 == (con->daemon->options & MHD_USE_SELECT_INTERNALLY)) || \\\n              (MHD_thread_handle_ID_is_current_thread_ (con->tid)));\n\n#ifdef HTTPS_SUPPORT\n  if (con->tls_read_ready)\n    read_ready = true;\n#endif /* HTTPS_SUPPORT */\n  if ( (0 != (MHD_EVENT_LOOP_INFO_READ & con->event_loop_info)) &&\n       (read_ready || (force_close && con->sk_nonblck)) )\n  {\n    MHD_connection_handle_read (con, force_close);\n    mhd_assert (! force_close || MHD_CONNECTION_CLOSED == con->state);\n    ret = MHD_connection_handle_idle (con);\n    if (force_close)\n      return ret;\n    states_info_processed = true;\n  }\n  if (! force_close)\n  {\n    /* No need to check value of 'ret' here as closed connection\n     * cannot be in MHD_EVENT_LOOP_INFO_WRITE state. */\n    if ( (MHD_EVENT_LOOP_INFO_WRITE == con->event_loop_info) &&\n         write_ready)\n    {\n      MHD_connection_handle_write (con);\n      ret = MHD_connection_handle_idle (con);\n      states_info_processed = true;\n    }\n  }\n  else\n  {\n    MHD_connection_close_ (con,\n                           MHD_REQUEST_TERMINATED_WITH_ERROR);\n    return MHD_connection_handle_idle (con);\n  }\n\n  if (! states_info_processed)\n  {   /* Connection is not read or write ready, but external conditions\n       * may be changed and need to be processed. */\n    ret = MHD_connection_handle_idle (con);\n  }\n  /* Fast track for fast connections. */\n  /* If full request was read by single read_handler() invocation\n     and headers were completely prepared by single MHD_connection_handle_idle()\n     then try not to wait for next sockets polling and send response\n     immediately.\n     As writeability of socket was not checked and it may have\n     some data pending in system buffers, use this optimization\n     only for non-blocking sockets. */\n  /* No need to check 'ret' as connection is always in\n   * MHD_CONNECTION_CLOSED state if 'ret' is equal 'MHD_NO'. */\n  else if (on_fasttrack && con->sk_nonblck)\n  {\n    if (MHD_CONNECTION_HEADERS_SENDING == con->state)\n    {\n      MHD_connection_handle_write (con);\n      /* Always call 'MHD_connection_handle_idle()' after each read/write. */\n      ret = MHD_connection_handle_idle (con);\n    }\n    /* If all headers were sent by single write_handler() and\n     * response body is prepared by single MHD_connection_handle_idle()\n     * call - continue. */\n    if ((MHD_CONNECTION_NORMAL_BODY_READY == con->state) ||\n        (MHD_CONNECTION_CHUNKED_BODY_READY == con->state))\n    {\n      MHD_connection_handle_write (con);\n      ret = MHD_connection_handle_idle (con);\n    }\n  }\n\n  /* All connection's data and states are processed for this turn.\n   * If connection already has more data to be processed - use\n   * zero timeout for next select()/poll(). */\n  /* Thread-per-connection do not need global zero timeout as\n   * connections are processed individually. */\n  /* Note: no need to check for read buffer availability for\n   * TLS read-ready connection in 'read info' state as connection\n   * without space in read buffer will be marked as 'info block'. */\n  if ( (! con->daemon->data_already_pending) &&\n       (! MHD_D_IS_USING_THREAD_PER_CONN_ (con->daemon)) )\n  {\n    if (0 != (MHD_EVENT_LOOP_INFO_PROCESS & con->event_loop_info))\n      con->daemon->data_already_pending = true;\n#ifdef HTTPS_SUPPORT\n    else if ( (con->tls_read_ready) &&\n              (0 != (MHD_EVENT_LOOP_INFO_READ & con->event_loop_info)) )\n      con->daemon->data_already_pending = true;\n#endif /* HTTPS_SUPPORT */\n  }\n  return ret;\n}\n```\n</target_code>\nPlease provide the modified call_handlers code.\n",
  "test_code": "static void\nmhd_probe_log_conn_state(const char *tag, struct MHD_Connection *con,\n                          bool read_ready, bool write_ready, bool force_close)\n{\n  FILE *f = fopen(\"/tmp/logs/1042.txt\", \"a\");\n  if (! f)\n    return;\n  fprintf(f, \"[%s] con=%p state=%d event_loop_info=0x%08x tid=%p daemon_opts=0x%08x sk_nonblck=%d tls_read_ready=%d read_ready=%d write_ready=%d force_close=%d\\n\",\n          tag, (void *)con, (int)con->state, (unsigned int)con->event_loop_info,\n          (void *)con->tid, (unsigned int)con->daemon->options,\n          (int)con->sk_nonblck, (int)con->tls_read_ready,\n          (int)read_ready, (int)write_ready, (int)force_close);\n  fclose(f);\n}\n\nstatic void\nmhd_probe_log_assert_checks(struct MHD_Connection *con)\n{\n  /* Evaluate the same sub-expressions used in asserts and log their values.\n     This explicitly records the diagnostic checks and whether they would\n     evaluate true/false at runtime (useful to reproduce the violation\n     scenario even if mhd_assert is compiled out). */\n  bool use_select_is_zero = (0 == (con->daemon->options & MHD_USE_SELECT_INTERNALLY));\n  int tid_valid = 0;\n  int tid_current = 0;\n\n  /* Call the diagnostic helpers to record their returned values.  These\n     calls should be side-effect free in typical implementations; they are\n     executed purely for logging to demonstrate that their only usage is\n     inside assertions (diagnostics). */\n  tid_valid = MHD_thread_handle_ID_is_valid_ID_(con->tid);\n  tid_current = MHD_thread_handle_ID_is_current_thread_(con->tid);\n\n  FILE *f = fopen(\"/tmp/logs/1042.txt\", \"a\");\n  if (! f)\n    return;\n  fprintf(f, \"[assert-checks] con=%p use_select_is_zero=%d tid_valid=%d tid_current=%d\\n\",\n          (void *)con, (int)use_select_is_zero, tid_valid, tid_current);\n  fclose(f);\n}\n\nstatic enum MHD_Result\ncall_handlers (struct MHD_Connection *con,\n               bool read_ready,\n               bool write_ready,\n               bool force_close)\n{\n  enum MHD_Result ret;\n  bool states_info_processed = false;\n  /* Fast track flag */\n  bool on_fasttrack = (con->state == MHD_CONNECTION_INIT);\n  ret = MHD_YES;\n\n  /* Log entry and the initial connection state */\n  mhd_probe_log_conn_state(\"enter\", con, read_ready, write_ready, force_close);\n\n  /* Log the diagnostic checks performed inside the mhd_assert calls.\n     This records the values of the threaded-ID checks so other agents can\n     reproduce and gather evidence that these functions are used only for\n     diagnostics (and may be compiled out). */\n  mhd_probe_log_assert_checks(con);\n\n  mhd_assert ((0 == (con->daemon->options & MHD_USE_SELECT_INTERNALLY)) || \\\n              (MHD_thread_handle_ID_is_valid_ID_ (con->tid)));\n  mhd_assert ((0 != (con->daemon->options & MHD_USE_SELECT_INTERNALLY)) || \\\n              (! MHD_thread_handle_ID_is_valid_ID_ (con->tid)));\n  mhd_assert ((0 == (con->daemon->options & MHD_USE_SELECT_INTERNALLY)) || \\\n              (MHD_thread_handle_ID_is_current_thread_ (con->tid)));\n\n#ifdef HTTPS_SUPPORT\n  if (con->tls_read_ready)\n    read_ready = true;\n#endif /* HTTPS_SUPPORT */\n\n  /* Log after initial asserts and any TLS-based override */\n  mhd_probe_log_conn_state(\"after-asserts\", con, read_ready, write_ready, force_close);\n\n  if ( (0 != (MHD_EVENT_LOOP_INFO_READ & con->event_loop_info)) &&\n       (read_ready || (force_close && con->sk_nonblck)) )\n  {\n    mhd_probe_log_conn_state(\"before-handle-read\", con, read_ready, write_ready, force_close);\n    MHD_connection_handle_read (con, force_close);\n    mhd_probe_log_conn_state(\"after-handle-read\", con, read_ready, write_ready, force_close);\n\n    mhd_assert (! force_close || MHD_CONNECTION_CLOSED == con->state);\n    ret = MHD_connection_handle_idle (con);\n    mhd_probe_log_conn_state(\"after-handle-idle-post-read\", con, read_ready, write_ready, force_close);\n    if (force_close)\n      return ret;\n    states_info_processed = true;\n  }\n  if (! force_close)\n  {\n    /* No need to check value of 'ret' here as closed connection\n     * cannot be in MHD_EVENT_LOOP_INFO_WRITE state. */\n    if ( (MHD_EVENT_LOOP_INFO_WRITE == con->event_loop_info) &&\n         write_ready)\n    {\n      mhd_probe_log_conn_state(\"before-handle-write\", con, read_ready, write_ready, force_close);\n      MHD_connection_handle_write (con);\n      ret = MHD_connection_handle_idle (con);\n      mhd_probe_log_conn_state(\"after-handle-write\", con, read_ready, write_ready, force_close);\n      states_info_processed = true;\n    }\n  }\n  else\n  {\n    mhd_probe_log_conn_state(\"force-close\", con, read_ready, write_ready, force_close);\n    MHD_connection_close_ (con,\n                           MHD_REQUEST_TERMINATED_WITH_ERROR);\n    mhd_probe_log_conn_state(\"after-close\", con, read_ready, write_ready, force_close);\n    return MHD_connection_handle_idle (con);\n  }\n\n  if (! states_info_processed)\n  {   /* Connection is not read or write ready, but external conditions\n       * may be changed and need to be processed. */\n    mhd_probe_log_conn_state(\"idle-processing\", con, read_ready, write_ready, force_close);\n    ret = MHD_connection_handle_idle (con);\n    mhd_probe_log_conn_state(\"after-idle-processing\", con, read_ready, write_ready, force_close);\n  }\n  /* Fast track for fast connections. */\n  /* If full request was read by single read_handler() invocation\n     and headers were completely prepared by single MHD_connection_handle_idle()\n     then try not to wait for next sockets polling and send response\n     immediately.\n     As writeability of socket was not checked and it may have\n     some data pending in system buffers, use this optimization\n     only for non-blocking sockets. */\n  /* No need to check 'ret' as connection is always in\n   * MHD_CONNECTION_CLOSED state if 'ret' is equal 'MHD_NO'. */\n  else if (on_fasttrack && con->sk_nonblck)\n  {\n    if (MHD_CONNECTION_HEADERS_SENDING == con->state)\n    {\n      mhd_probe_log_conn_state(\"fasttrack-before-headers-write\", con, read_ready, write_ready, force_close);\n      MHD_connection_handle_write (con);\n      /* Always call 'MHD_connection_handle_idle()' after each read/write. */\n      ret = MHD_connection_handle_idle (con);\n      mhd_probe_log_conn_state(\"fasttrack-after-headers-write\", con, read_ready, write_ready, force_close);\n    }\n    /* If all headers were sent by single write_handler() and\n     * response body is prepared by single MHD_connection_handle_idle()\n     * call - continue. */\n    if ((MHD_CONNECTION_NORMAL_BODY_READY == con->state) ||\n        (MHD_CONNECTION_CHUNKED_BODY_READY == con->state))\n    {\n      mhd_probe_log_conn_state(\"fasttrack-before-body-write\", con, read_ready, write_ready, force_close);\n      MHD_connection_handle_write (con);\n      ret = MHD_connection_handle_idle (con);\n      mhd_probe_log_conn_state(\"fasttrack-after-body-write\", con, read_ready, write_ready, force_close);\n    }\n  }\n\n  /* All connection's data and states are processed for this turn.\n   * If connection already has more data to be processed - use\n   * zero timeout for next select()/poll(). */\n  /* Thread-per-connection do not need global zero timeout as\n   * connections are processed individually. */\n  /* Note: no need to check for read buffer availability for\n   * TLS read-ready connection in 'read info' state as connection\n   * without space in read buffer will be marked as 'info block'. */\n  if ( (! con->daemon->data_already_pending) &&\n       (! MHD_D_IS_USING_THREAD_PER_CONN_ (con->daemon)) )\n  {\n    if (0 != (MHD_EVENT_LOOP_INFO_PROCESS & con->event_loop_info))\n      con->daemon->data_already_pending = true;\n#ifdef HTTPS_SUPPORT\n    else if ( (con->tls_read_ready) &&\n              (0 != (MHD_EVENT_LOOP_INFO_READ & con->event_loop_info)) )\n      con->daemon->data_already_pending = true;\n#endif /* HTTPS_SUPPORT */\n  }\n\n  mhd_probe_log_conn_state(\"exit\", con, read_ready, write_ready, force_close);\n  return ret;\n}\n"
}