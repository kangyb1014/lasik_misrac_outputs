{
  "user_message": "An agent A claimed that the following MHD_uint64_to_str code violates the MISRA C 2023 rule 17.8.\n<misra_rule>\nMISRA C 2023 Rule 17.8 is A function parameter should not be modified.\nNote that the object referred to by a pointer parameter may be modified, but the pointer itself shall not be modified.\n</misra_rule>\n<target_code>\nHere is the original code of MHD_uint64_to_str.\n```c\nsize_t\nMHD_uint64_to_str (uint64_t val,\n                   char *buf,\n                   size_t buf_size)\n{\n  char *chr;  /**< pointer to the current printed digit */\n  /* The biggest printable number is 18446744073709551615 */\n  uint64_t divisor = UINT64_C (10000000000000000000);\n  int digit;\n\n  chr = buf;\n  digit = (int) (val / divisor);\n  mhd_assert (digit < 10);\n\n  /* Do not print leading zeros */\n  while ((0 == digit) && (1 < divisor))\n  {\n    divisor /= 10;\n    digit = (int) (val / divisor);\n    mhd_assert (digit < 10);\n  }\n\n  while (0 != buf_size)\n  {\n    *chr = (char) ((char) digit + '0');\n    chr++;\n    buf_size--;\n    if (1 == divisor)\n      return (size_t) (chr - buf);\n    val %= divisor;\n    divisor /= 10;\n    digit = (int) (val / divisor);\n    mhd_assert (digit < 10);\n  }\n  return 0; /* The buffer is too small */\n}\n```\n</target_code>\n<response format>\nProvide your answer with these fields.\n- explanation: your evaluation of the scenario provided by the agent A.\n- is_report_correct: whether the report is correct or not (true/false). True means there is a violation.\n</response format>\n<scenario>\nThe agent A provided the following violation scenario:\nThe function decrements the value of the parameter 'buf_size' (buf_size--), i.e. modifies the function parameter object itself inside MHD_uint64_to_str. This is a direct violation of MISRA C 2023 Rule 17.8. Use a local copy (e.g. size_t remaining = buf_size;) and decrement that instead to comply.\n</scenario>\n\n<execution_log>\nThe agent A also provided the following output log:\nENTRY: val=1, buf=0x7fffd887d1d0, buf_size=0, divisor=10000000000000000000\nSKIP_LEADING_ZERO: divisor(before)=10000000000000000000, digit(before)=0\nSKIP_LEADING_ZERO: divisor(after)=1000000000000000000, digit(after)=0\nSKIP_LEADING_ZERO: divisor(before)=1000000000000000000, digit(before)=0\nSKIP_LEADING_ZERO: divisor(after)=100000000000000000, digit(after)=0\nSKIP_LEADING_ZERO: divisor(before)=100000000000000000, digit(before)=0\nSKIP_LEADING_ZERO: divisor(after)=10000000000000000, digit(after)=0\nSKIP_LEADING_ZERO: divisor(before)=10000000000000000, digit(before)=0\nSKIP_LEADING_ZERO: divisor(after)=1000000000000000, digit(after)=0\nSKIP_LEADING_ZERO: divisor(before)=1000000000000000, digit(before)=0\nSKIP_LEADING_ZERO: divisor(after)=100000000000000, digit(after)=0\nSKIP_LEADING_ZERO: divisor(before)=100000000000000, digit(before)=0\nSKIP_LEADING_ZERO: divisor(after)=10000000000000, digit(after)=0\nSKIP_LEADING_ZERO: divisor(before)=10000000000000, digit(before)=0\nSKIP_LEADING_ZERO: divisor(after)=1000000000000, digit(after)=0\nSKIP_LEADING_ZERO: divisor(before)=1000000000000, digit(before)=0\nSKIP_LEADING_ZERO: divisor(after)=100000000000, digit(after)=0\nSKIP_LEADING_ZERO: divisor(before)=100000000000, digit(before)=0\nSKIP_LEADING_ZERO: divisor(after)=10000000000, digit(after)=0\nSKIP_LEADING_ZERO: divisor(before)=10000000000, digit(before)=0\nSKIP_LEADING_ZERO: divisor(after)=1000000000, digit(after)=0\nSKIP_LEADING_ZERO: divisor(before)=1000000000, digit(before)=0\nSKIP_LEADING_ZERO: divisor(after)=100000000, digit(after)=0\nSKIP_LEADING_ZERO: divisor(before)=100000000, digit(before)=0\nSKIP_LEADING_ZERO: divisor(after)=10000000, digit(after)=0\nSKIP_LEADING_ZERO: divisor(before)=10000000, digit(before)=0\nSKIP_LEADING_ZERO: divisor(after)=1000000, digit(after)=0\nSKIP_LEADING_ZERO: divisor(before)=1000000, digit(before)=0\nSKIP_LEADING_ZERO: divisor(after)=100000, digit(after)=0\nSKIP_LEADING_ZERO: divisor(before)=100000, digit(before)=0\nSKIP_LEADING_ZERO: divisor(after)=10000, digit(after)=0\nSKIP_LEADING_ZERO: divisor(before)=10000, digit(before)=0\nSKIP_LEADING_ZERO: divisor(after)=1000, digit(after)=0\nSKIP_LEADING_ZERO: divisor(before)=1000, digit(before)=0\nSKIP_LEADING_ZERO: divisor(after)=100, digit(after)=0\nSKIP_LEADING_ZERO: divisor(before)=100, digit(before)=0\nSKIP_LEADING_ZERO: divisor(after)=10, digit(after)=0\nSKIP_LEADING_ZERO: divisor(before)=10, digit(before)=0\nSKIP_LEADING_ZERO: divisor(after)=1, digit(after)=1\nRETURN_FAILURE: buffer too small, final_buf_size=0\nENTRY: val=1, buf=0x7fffd887d1d0, buf_size=1, divisor=10000000000000000000\nSKIP_LEADING_ZERO: divisor(before)=10000000000000000000, digit(before)=0\nSKIP_LEADING_ZERO: divisor(after)=1000000000000000000, digit(after)=0\nSKIP_LEADING_ZERO: divisor(before)=1000000000000000000, digit(before)=0\nSKIP_LEADING_ZERO: divisor(after)=100000000000000000, digit(after)=0\nSKIP_LEADING_ZERO: divisor(before)=100000000000000000, digit(before)=0\nSKIP_LEADING_ZERO: divisor(after)=10000000000000000, digit(after)=0\nSKIP_LEADING_ZERO: divisor(before)=10000000000000000, digit(before)=0\nSKIP_LEADING_ZERO: divisor(after)=1000000000000000, digit(after)=0\nSKIP_LEADING_ZERO: divisor(before)=1000000000000000, digit(before)=0\nSKIP_LEADING_ZERO: divisor(after)=100000000000000, digit(after)=0\nSKIP_LEADING_ZERO: divisor(before)=100000000000000, digit(before)=0\nSKIP_LEADING_ZERO: divisor(after)=10000000000000, digit(after)=0\nSKIP_LEADING_ZERO: divisor(before)=10000000000000, digit(before)=0\nSKIP_LEADING_ZERO: divisor(after)=1000000000000, digit(after)=0\nSKIP_LEADING_ZERO: divisor(before)=1000000000000, digit(before)=0\nSKIP_LEADING_ZERO: divisor(after)=100000000000, digit(after)=0\nSKIP_LEADING_ZERO: divisor(before)=100000000000, digit(before)=0\nSKIP_LEADING_ZERO: divisor(after)=10000000000, digit(after)=0\nSKIP_LEADING_ZERO: divisor(before)=10000000000, digit(before)=0\nSKIP_LEADING_ZERO: divisor(after)=1000000000, digit(after)=0\nSKIP_LEADING_ZERO: divisor(before)=1000000000, digit(before)=0\nSKIP_LEADING_ZERO: divisor(after)=100000000, digit(after)=0\nSKIP_LEADING_ZERO: divisor(before)=100000000, digit(befor\n</execution_log>\n\n<instruction>\nJudge whether the report is correct or not.\n</instruction>\n",
  "is_report_correct": true,
  "explanation": "The report is correct that the code violates MISRA C 2023 Rule 17.8. The function modifies its parameter buf_size (buf_size--), which is not allowed. In fact the function also modifies the parameter val (val %= divisor), so there are at least two direct violations of Rule 17.8. The pointer parameter buf itself is not modified (a local pointer chr = buf is used), so that part is OK. To comply, make local copies of any parameters that need to be changed (for example: size_t remaining = buf_size; uint64_t v = val;) and use/modify those locals instead of modifying the parameters themselves."
}