{
  "user_message": "An agent A claimed that the following calc_userdigest code violates the MISRA C 2023 rule 21.17.\n<misra_rule>\nMISRA C 2023 Rule 21.17 is Use of the string handling functions from <string.h> shall not result in accesses beyond the bounds of the objects referenced by their pointer parameters.\nThis rule strictly applies to the Standard Library functions in <string.h> such as memcpy, memmove, memset, memcmp, strcpy, strncpy, strcat, strncat, strlen, and strspn.\n</misra_rule>\n<target_code>\nHere is the original code of calc_userdigest.\n```c\n_MHD_static_inline void\ncalc_userdigest (struct DigestAlgorithm *da,\n                 const char *username, const size_t username_len,\n                 const char *realm, const size_t realm_len,\n                 const char *password,\n                 uint8_t *ha1_bin)\n{\n  mhd_assert (! da->hashing);\n  digest_update (da, username, username_len);\n  digest_update_with_colon (da);\n  digest_update (da, realm, realm_len);\n  digest_update_with_colon (da);\n  digest_update_str (da, password);\n  digest_calc_hash (da, ha1_bin);\n}\n```\n</target_code>\n<response format>\nProvide your answer with these fields.\n- explanation: your evaluation of the scenario provided by the agent A.\n- is_report_correct: whether the report is correct or not (true/false). True means there is a violation.\n</response format>\n<scenario>\nThe agent A provided the following violation scenario:\nThe call digest_update_str(da, password) provides only a char* with no explicit length. If digest_update_str internally uses <string.h> functions that expect a NUL-terminated C string (e.g. strlen, strcpy, strcat), and the password buffer is not NUL-terminated (or its termination lies past the allocated object), those functions will read beyond the bounds of the password object. Thus this call can violate Rule 21.17 when password is not a valid NUL-terminated string or otherwise not sized as the callee assumes.\n</scenario>\n\n<instruction>\nJudge whether the report is correct or not.\n</instruction>\n",
  "is_report_correct": false,
  "explanation": "The claim is speculative and not provably correct from the snippet alone. Rule 21.17 concerns actual uses of <string.h> functions that read past object bounds. The shown calc_userdigest() does not itself call any <string.h> functions \u2014 it simply calls digest_update_str(da, password). Whether a Rule 21.17 violation exists depends on the contract and implementation of digest_update_str (and on whether callers guarantee password is a NUL-terminated buffer). If digest_update_str internally calls strlen/strcpy/etc. and the caller can pass a non NUL-terminated or undersized password object, then that implementation/interface would indeed risk violating 21.17. But from the code shown you cannot demonstrate such a violation; the problem (if any) is in digest_update_str or in the lack of a documented requirement that password be NUL-terminated. To resolve: (a) inspect/modify digest_update_str to use bounds-aware APIs or take an explicit length, or (b) document and enforce that password must be a NUL-terminated string. Without that additional evidence, the report is not correct."
}