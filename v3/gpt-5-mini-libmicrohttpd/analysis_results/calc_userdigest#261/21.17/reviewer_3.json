{
  "user_message": "An agent A claimed that the following calc_userdigest code violates the MISRA C 2023 rule 21.17.\n<misra_rule>\nMISRA C 2023 Rule 21.17 is Use of the string handling functions from <string.h> shall not result in accesses beyond the bounds of the objects referenced by their pointer parameters.\nThis rule strictly applies to the Standard Library functions in <string.h> such as memcpy, memmove, memset, memcmp, strcpy, strncpy, strcat, strncat, strlen, and strspn.\n</misra_rule>\n<target_code>\nHere is the original code of calc_userdigest.\n```c\n_MHD_static_inline void\ncalc_userdigest (struct DigestAlgorithm *da,\n                 const char *username, const size_t username_len,\n                 const char *realm, const size_t realm_len,\n                 const char *password,\n                 uint8_t *ha1_bin)\n{\n  mhd_assert (! da->hashing);\n  digest_update (da, username, username_len);\n  digest_update_with_colon (da);\n  digest_update (da, realm, realm_len);\n  digest_update_with_colon (da);\n  digest_update_str (da, password);\n  digest_calc_hash (da, ha1_bin);\n}\n```\n</target_code>\n<response format>\nProvide your answer with these fields.\n- explanation: your evaluation of the scenario provided by the agent A.\n- is_report_correct: whether the report is correct or not (true/false). True means there is a violation.\n</response format>\n<scenario>\nThe agent A provided the following violation scenario:\nPotential violation: digest_update likely copies username_len bytes from the pointer username (e.g. via memcpy/memmove). If username does not actually point to an object at least username_len bytes long, this call can read beyond the bounds. Example concrete scenario: username points to the string \"bob\" (4 bytes including '\\0') but username_len is 10 (e.g. due to a bug or attacker-controlled value); if digest_update uses memcpy(dest, username, username_len) this will access bytes beyond the end of the username object, violating MISRA C 2023 Rule 21.17.\n</scenario>\n\n<instruction>\nJudge whether the report is correct or not.\n</instruction>\n",
  "is_report_correct": false,
  "explanation": "Not correct. MISRA C:2023 Rule 21.17 constrains uses of the <string.h> functions so they cannot access beyond the bounds of the objects referenced by their pointer parameters. The snippet shown does not itself call any <string.h> functions \u2014 it calls helper functions (digest_update, digest_update_with_colon, digest_update_str, digest_calc_hash). Whether a 21.17 violation actually occurs depends on the implementations and documented contracts of those helpers. If digest_update internally does a memcpy(username, username_len) and the caller supplies an invalid username_len greater than the actual object size, then the implementation of digest_update (or the caller that supplies the wrong length) would be the locus of the violation \u2014 not the calc_userdigest wrapper per se. Agent A\u2019s example is a hypothetical misuse (or an implementation bug) and cannot be used to prove that calc_userdigest violates 21.17 without inspecting the called functions or the API contract that guarantees username_len is correct. Recommendation: inspect and/or fix digest_update and digest_update_str to ensure they only read the object\u2019s valid bytes (e.g. take/verify lengths, use bounds-checked APIs or documented preconditions), or validate lengths before calling them."
}