{
  "user_message": "<misra_rule>\nMISRA C 2023 Rule 2.1 is: A project shall not contain unreachable code.\n\n</misra_rule>\n<response format>\nProvide your answer with these fields.\n- is_rule_violated: whether the rule is violated or not (true/false),\n- scenario: a specific violation scenario.\n</response format>\n<target_code>\nHere is the code of MHD_poll:\n```c\nstatic enum MHD_Result\nMHD_poll (struct MHD_Daemon *daemon,\n          int may_block)\n{\n  if (! MHD_D_IS_USING_THREAD_PER_CONN_ (daemon))\n    return MHD_poll_all (daemon,\n                         may_block ? -1 : 0);\n  return MHD_poll_listen_socket (daemon,\n                                 may_block);\n}\n```\n</target_code>\n<target_code>\nHere is the code fragment that you need to analyze:\n```c\nreturn MHD_poll_listen_socket (daemon,\n                                 may_block);\n```\nFocus on the above code fragment and judge whether it violates the rule 2.1 or not.\n</target_code>\n",
  "is_rule_violated": false,
  "scenario": "Not violated: the return of MHD_poll_listen_socket is reached whenever MHD_D_IS_USING_THREAD_PER_CONN_(daemon) evaluates true (the if body is taken only when that macro yields false). The code has two mutually exclusive return paths, so the fragment is reachable at runtime. (A violation would occur only if MHD_D_IS_USING_THREAD_PER_CONN_ were defined or optimized to a compile-time constant that makes the first return always taken \u2014 e.g. the macro always evaluates to false/0 \u2014 which would render the second return unreachable.)"
}