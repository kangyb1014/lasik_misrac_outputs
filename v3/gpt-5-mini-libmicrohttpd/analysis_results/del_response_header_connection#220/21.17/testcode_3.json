{
  "user_message": "<misra_rule>\nMISRA C 2023 Rule 21.17 is: Use of the string handling functions from <string.h> shall not result in accesses beyond the bounds of the objects referenced by their pointer parameters.\nThis rule strictly applies to the Standard Library functions in <string.h> such as memcpy, memmove, memset, memcmp, strcpy, strncpy, strcat, strncat, strlen, and strspn.\n</misra_rule>\n\nAnother agent reported that the target code violated the Rule 21.17.\nHere is the comment from the agent.\n<violation scenario>\nPossible out-of-bounds write when the stored header buffer does not have space for a terminating NUL. If hdr->value points to a buffer whose allocated size equals hdr->value_size (i.e. no extra byte reserved for the '\\0'), then the statement hdr->value[hdr->value_size] = 0 writes one past the allocated object and is an out-of-bounds access. This can trigger violations of Rule 21.17 if subsequent uses of string.h functions (e.g. memcmp/strlen) operate on that buffer.\n</violation scenario>\n\nYour job is to insert logging code to capture the control flow and state information of the program.\nInsert logging code so that other agents can reproduce and get evidence for the violation scenario.\n<response format>\n- test_code: a modified del_response_header_connection code that contains useful probe functions that print useful logs to a file \"/tmp/logs/2209.txt\". The logs should contain the control path and state information of the violation scenario. If test code is not required to validate the scenario, you can leave this blank.\nHere are the constraints for the test code:\n- The test code MUST preserve the original logic of del_response_header_connection as much as possible.\nYou CAN just insert probe functions to the original code.\n- DO NOT introduce new violations to demonstrate your scenario.\n- The test code MUST be compilable and executable.\n- The test code MUST include line breaks.\n- You MUST NOT define the main function.\n- You MUST NOT define macros.\n</response format>\n<target_code>\nHere is the code of del_response_header_connection:\n```c\nstatic enum MHD_Result\ndel_response_header_connection (struct MHD_Response *response,\n                                const char *value)\n{\n  struct MHD_HTTP_Res_Header *hdr; /**< existing \"Connection\" header */\n\n  hdr = MHD_get_response_element_n_ (response, MHD_HEADER_KIND,\n                                     MHD_HTTP_HEADER_CONNECTION,\n                                     MHD_STATICSTR_LEN_ ( \\\n                                       MHD_HTTP_HEADER_CONNECTION));\n  if (NULL == hdr)\n    return MHD_NO;\n\n  if (! MHD_str_remove_tokens_caseless_ (hdr->value, &hdr->value_size, value,\n                                         strlen (value)))\n    return MHD_NO;\n  if (0 == hdr->value_size)\n  {\n    _MHD_remove_header (response, hdr);\n    free (hdr->value);\n    free (hdr->header);\n    free (hdr);\n    response->flags_auto &=\n      ~((enum MHD_ResponseAutoFlags) MHD_RAF_HAS_CONNECTION_HDR\n        | (enum MHD_ResponseAutoFlags) MHD_RAF_HAS_CONNECTION_CLOSE);\n  }\n  else\n  {\n    hdr->value[hdr->value_size] = 0; /* Null-terminate the result */\n    if (0 != (response->flags_auto\n              & ~((enum MHD_ResponseAutoFlags) MHD_RAF_HAS_CONNECTION_CLOSE)))\n    {\n      if (MHD_STATICSTR_LEN_ (\"close\") == hdr->value_size)\n      {\n        if (0 != memcmp (hdr->value, \"close\", MHD_STATICSTR_LEN_ (\"close\")))\n          response->flags_auto &=\n            ~((enum MHD_ResponseAutoFlags) MHD_RAF_HAS_CONNECTION_CLOSE);\n      }\n      else if (MHD_STATICSTR_LEN_ (\"close, \") < hdr->value_size)\n      {\n        if (0 != memcmp (hdr->value, \"close, \",\n                         MHD_STATICSTR_LEN_ (\"close, \")))\n          response->flags_auto &=\n            ~((enum MHD_ResponseAutoFlags) MHD_RAF_HAS_CONNECTION_CLOSE);\n      }\n      else\n        response->flags_auto &=\n          ~((enum MHD_ResponseAutoFlags) MHD_RAF_HAS_CONNECTION_CLOSE);\n    }\n  }\n  return MHD_YES;\n}\n```\n</target_code>\nPlease provide the modified del_response_header_connection code.\n",
  "test_code": "static void\nlog_probe_hdr(const char *stage,\n              struct MHD_Response *response,\n              struct MHD_HTTP_Res_Header *hdr,\n              const char *value_param)\n{\n  FILE *f = fopen(\"/tmp/logs/2209.txt\", \"a\");\n  if (NULL == f)\n    return;\n\n  fprintf(f, \"---- del_response_header_connection probe: %s ----\\n\", stage);\n  fprintf(f, \"response=%p, hdr=%p, value_param=%p\\n\",\n          (void *) response, (void *) hdr, (const void *) value_param);\n  if (NULL == hdr)\n  {\n    fprintf(f, \"hdr is NULL\\n\\n\");\n    fclose(f);\n    return;\n  }\n\n  fprintf(f, \"hdr->value=%p, hdr->value_size=%zu\\n\",\n          (void *) hdr->value, (size_t) hdr->value_size);\n\n  /* Safely dump up to the first 64 bytes present in hdr->value. Do not\n     read past hdr->value_size. If value_size is 0, do not dereference. */\n  if (hdr->value != NULL && hdr->value_size > 0)\n  {\n    size_t dump = hdr->value_size < 64 ? hdr->value_size : 64;\n    fprintf(f, \"hdr->value dump (up to %zu bytes):\\n\", dump);\n    for (size_t i = 0; i < dump; ++i)\n    {\n      /* Print as hex and ascii (printable) for easier inspection */\n      unsigned char c = (unsigned char) hdr->value[i];\n      fprintf(f, \"%02x \", c);\n    }\n    fprintf(f, \"\\n\");\n\n    /* Print ASCII (printable) representation but only for bytes we safely read */\n    fprintf(f, \"ascii: '\");\n    for (size_t i = 0; i < dump; ++i)\n    {\n      unsigned char c = (unsigned char) hdr->value[i];\n      fprintf(f, \"%c\", (c >= 32 && c < 127) ? c : '.');\n    }\n    fprintf(f, \"'\\n\");\n  }\n  else\n  {\n    fprintf(f, \"hdr->value is NULL or value_size is 0, no dump\\n\");\n  }\n\n  /* Log current flags_auto if response pointer is available. */\n  if (response != NULL)\n  {\n    fprintf(f, \"response->flags_auto=0x%08x\\n\", (unsigned) response->flags_auto);\n  }\n\n  fprintf(f, \"---- end probe: %s ----\\n\\n\", stage);\n  fclose(f);\n}\n\nstatic enum MHD_Result\ndel_response_header_connection (struct MHD_Response *response,\n                                const char *value)\n{\n  struct MHD_HTTP_Res_Header *hdr; /**< existing \"Connection\" header */\n\n  hdr = MHD_get_response_element_n_ (response, MHD_HEADER_KIND,\n                                     MHD_HTTP_HEADER_CONNECTION,\n                                     MHD_STATICSTR_LEN_ ( \\\n                                       MHD_HTTP_HEADER_CONNECTION));\n  if (NULL == hdr)\n  {\n    /* Log: no header found */\n    log_probe_hdr(\"no-hdr-found\", response, hdr, value);\n    return MHD_NO;\n  }\n\n  /* Log: header found prior to token removal */\n  log_probe_hdr(\"before-remove-tokens\", response, hdr, value);\n\n  if (! MHD_str_remove_tokens_caseless_ (hdr->value, &hdr->value_size, value,\n                                         strlen (value)))\n  {\n    /* Log: token removal failed */\n    log_probe_hdr(\"remove-tokens-failed\", response, hdr, value);\n    return MHD_NO;\n  }\n\n  /* Log: token removal succeeded and current state */\n  log_probe_hdr(\"after-remove-tokens\", response, hdr, value);\n\n  if (0 == hdr->value_size)\n  {\n    log_probe_hdr(\"value_size-zero-before-remove\", response, hdr, value);\n    _MHD_remove_header (response, hdr);\n    free (hdr->value);\n    free (hdr->header);\n    free (hdr);\n    response->flags_auto &=\n      ~((enum MHD_ResponseAutoFlags) MHD_RAF_HAS_CONNECTION_HDR\n        | (enum MHD_ResponseAutoFlags) MHD_RAF_HAS_CONNECTION_CLOSE);\n\n    /* Log: header removed */\n    log_probe_hdr(\"header-removed\", response, NULL, value);\n  }\n  else\n  {\n    /* Log right before null-termination write that is the subject of the\n       reported possible out-of-bounds access. We intentionally do not perform\n       any additional reads beyond hdr->value_size here; log_probe_hdr will\n       only read up to hdr->value_size (bounded) so it is safe. */\n    log_probe_hdr(\"before-null-terminate\", response, hdr, value);\n\n    hdr->value[hdr->value_size] = 0; /* Null-terminate the result */\n\n    /* Log immediately after the potentially problematic write. This will\n       help reproduce and capture the exact hdr->value_size and pointer\n       values at the moment of the write. */\n    log_probe_hdr(\"after-null-terminate\", response, hdr, value);\n\n    if (0 != (response->flags_auto\n              & ~((enum MHD_ResponseAutoFlags) MHD_RAF_HAS_CONNECTION_CLOSE)))\n    {\n      if (MHD_STATICSTR_LEN_ (\"close\") == hdr->value_size)\n      {\n        if (0 != memcmp (hdr->value, \"close\", MHD_STATICSTR_LEN_ (\"close\")))\n          response->flags_auto &=\n            ~((enum MHD_ResponseAutoFlags) MHD_RAF_HAS_CONNECTION_CLOSE);\n      }\n      else if (MHD_STATICSTR_LEN_ (\"close, \") < hdr->value_size)\n      {\n        if (0 != memcmp (hdr->value, \"close, \",\n                         MHD_STATICSTR_LEN_ (\"close, \")))\n          response->flags_auto &=\n            ~((enum MHD_ResponseAutoFlags) MHD_RAF_HAS_CONNECTION_CLOSE);\n      }\n      else\n        response->flags_auto &=\n          ~((enum MHD_ResponseAutoFlags) MHD_RAF_HAS_CONNECTION_CLOSE);\n\n      /* Log: flags after possible modification */\n      log_probe_hdr(\"after-flags-check\", response, hdr, value);\n    }\n  }\n  return MHD_YES;\n}"
}