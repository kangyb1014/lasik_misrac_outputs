{
  "user_message": "An agent A claimed that the following del_response_header_connection code violates the MISRA C 2023 rule 21.17.\n<misra_rule>\nMISRA C 2023 Rule 21.17 is Use of the string handling functions from <string.h> shall not result in accesses beyond the bounds of the objects referenced by their pointer parameters.\nThis rule strictly applies to the Standard Library functions in <string.h> such as memcpy, memmove, memset, memcmp, strcpy, strncpy, strcat, strncat, strlen, and strspn.\n</misra_rule>\n<target_code>\nHere is the original code of del_response_header_connection.\n```c\nstatic enum MHD_Result\ndel_response_header_connection (struct MHD_Response *response,\n                                const char *value)\n{\n  struct MHD_HTTP_Res_Header *hdr; /**< existing \"Connection\" header */\n\n  hdr = MHD_get_response_element_n_ (response, MHD_HEADER_KIND,\n                                     MHD_HTTP_HEADER_CONNECTION,\n                                     MHD_STATICSTR_LEN_ ( \\\n                                       MHD_HTTP_HEADER_CONNECTION));\n  if (NULL == hdr)\n    return MHD_NO;\n\n  if (! MHD_str_remove_tokens_caseless_ (hdr->value, &hdr->value_size, value,\n                                         strlen (value)))\n    return MHD_NO;\n  if (0 == hdr->value_size)\n  {\n    _MHD_remove_header (response, hdr);\n    free (hdr->value);\n    free (hdr->header);\n    free (hdr);\n    response->flags_auto &=\n      ~((enum MHD_ResponseAutoFlags) MHD_RAF_HAS_CONNECTION_HDR\n        | (enum MHD_ResponseAutoFlags) MHD_RAF_HAS_CONNECTION_CLOSE);\n  }\n  else\n  {\n    hdr->value[hdr->value_size] = 0; /* Null-terminate the result */\n    if (0 != (response->flags_auto\n              & ~((enum MHD_ResponseAutoFlags) MHD_RAF_HAS_CONNECTION_CLOSE)))\n    {\n      if (MHD_STATICSTR_LEN_ (\"close\") == hdr->value_size)\n      {\n        if (0 != memcmp (hdr->value, \"close\", MHD_STATICSTR_LEN_ (\"close\")))\n          response->flags_auto &=\n            ~((enum MHD_ResponseAutoFlags) MHD_RAF_HAS_CONNECTION_CLOSE);\n      }\n      else if (MHD_STATICSTR_LEN_ (\"close, \") < hdr->value_size)\n      {\n        if (0 != memcmp (hdr->value, \"close, \",\n                         MHD_STATICSTR_LEN_ (\"close, \")))\n          response->flags_auto &=\n            ~((enum MHD_ResponseAutoFlags) MHD_RAF_HAS_CONNECTION_CLOSE);\n      }\n      else\n        response->flags_auto &=\n          ~((enum MHD_ResponseAutoFlags) MHD_RAF_HAS_CONNECTION_CLOSE);\n    }\n  }\n  return MHD_YES;\n}\n```\n</target_code>\n<response format>\nProvide your answer with these fields.\n- explanation: your evaluation of the scenario provided by the agent A.\n- is_report_correct: whether the report is correct or not (true/false). True means there is a violation.\n</response format>\n<scenario>\nThe agent A provided the following violation scenario:\nPossible out-of-bounds write when the stored header buffer does not have space for a terminating NUL. If hdr->value points to a buffer whose allocated size equals hdr->value_size (i.e. no extra byte reserved for the '\\0'), then the statement hdr->value[hdr->value_size] = 0 writes one past the allocated object and is an out-of-bounds access. This can trigger violations of Rule 21.17 if subsequent uses of string.h functions (e.g. memcmp/strlen) operate on that buffer.\n</scenario>\n\n<execution_log>\nThe agent A also provided the following output log:\n---- del_response_header_connection probe: before-remove-tokens ----\nresponse=0x55d5d6525820, hdr=0x55d5d6525a20, value_param=0x55d5c658814d\nhdr->value=0x55d5d65258e0, hdr->value_size=13\nhdr->value dump (up to 13 bytes):\n61 2c 20 62 2c 20 63 2c 20 64 2c 20 65 \nascii: 'a, b, c, d, e'\nresponse->flags_auto=0x00000001\n---- end probe: before-remove-tokens ----\n\n---- del_response_header_connection probe: after-remove-tokens ----\nresponse=0x55d5d6525820, hdr=0x55d5d6525a20, value_param=0x55d5c658814d\nhdr->value=0x55d5d65258e0, hdr->value_size=0\nhdr->value is NULL or value_size is 0, no dump\nresponse->flags_auto=0x00000001\n---- end probe: after-remove-tokens ----\n\n---- del_response_header_connection probe: value_size-zero-before-remove ----\nresponse=0x55d5d6525820, hdr=0x55d5d6525a20, value_param=0x55d5c658814d\nhdr->value=0x55d5d65258e0, hdr->value_size=0\nhdr->value is NULL or value_size is 0, no dump\nresponse->flags_auto=0x00000001\n---- end probe: value_size-zero-before-remove ----\n\n---- del_response_header_connection probe: header-removed ----\nresponse=0x55d5d6525820, hdr=(nil), value_param=0x55d5c658814d\nhdr is NULL\n\n---- del_response_header_connection probe: before-remove-tokens ----\nresponse=0x55d5d6525820, hdr=0x55d5d6525c70, value_param=0x55d5c658818e\nhdr->value=0x55d5d6525c40, hdr->value_size=26\nhdr->value dump (up to 26 bytes):\n63 6c 6f 73 65 2c 20 69 2c 20 6b 2c 20 6c 2c 20 6d 2c 20 6e 2c 20 6f 2c 20 70 \nascii: 'close, i, k, l, m, n, o, p'\nresponse->flags_auto=0x00000003\n---- end probe: before-remove-tokens ----\n\n---- del_response_header_connection probe: after-remove-tokens ----\nresponse=0x55d5d6525820, hdr=0x55d5d6525c70, value_param=0x55d5c658818e\nhdr->value=0x55d5d6525c40, hdr->value_size=0\nhdr->value is NULL or value_size is 0, no dump\nresponse->flags_auto=0x00000003\n---- end probe: after-remove-tokens ----\n\n---- del_response_header_connection probe: value_size-zero-before-remove ----\nresponse=0x55d5d6525820, hdr=0x55d5d6525c70, value_param=0x55d5c658818e\nhdr->value=0x55d5d6525c40, hdr->value_size=0\nhdr->value is NULL or value_size is 0, no dump\nresponse->flags_auto=0x00000003\n---- end probe: value_size-zero-before-remove ----\n\n---- del_response_header_connection probe: header-removed ----\nresponse=0x55d5d6525820, hdr=(nil), value_param=0x55d5c658818e\nhdr is NULL\n\n---- del_response_header_connection probe: before-remove-tokens ----\nresponse=0x55d5d6525820, hdr=0x55d5d6525cb0, value_param=0x55d5c65882e1\nhdr->value=0x55d5d6525c70, hdr->value_size=32\nhdr->value dump (up to 32 bytes):\n63 6c 6f 73 65 2c 20 31 2c 20 32 2c 20 33 2c 20 34 2c 20 35 2c 20 36 2c 20 37 2c 20 38 2c 20 39 \nascii: 'close, 1, 2, 3, 4, 5, 6, 7, 8, 9'\nresponse->flags_auto=0x00000003\n---- end probe: before-remove-tokens ----\n\n---- del_response_header_connection probe: after-remove-tokens ----\nresponse=0x55d5d6525820, hdr=0x55d5d6525cb0, value_param=0x55d5c65882e1\nhdr->value=0x55d5d6525c70, hdr->value_size=17\nhdr->value dump (up to 17 bytes):\n63 6c 6f 73 65 2c 20 32 2c 20 34 2c 20 36 2c 20 38 \nascii: 'close, 2, 4, 6, 8'\nresponse->flags_auto=0x00000003\n---- end probe: after-remove-tokens ----\n\n---- del_response_header_connection probe: before-null-terminate ----\nresponse=0x55d5d6525820, hdr=0x55d5d6525cb0, value_param=0x55d5c65882e1\nhdr->value=0x55d5d6525c70, hdr->value_size=17\nhdr->value dump (up to 17 bytes):\n63 6c 6f 73 65 2c 20 32 2c 20 34 2c 20 36 2c 20 38 \nascii: 'close, 2, 4, 6, 8'\nresponse->flags_auto=0x00000003\n---- end probe: before-null-terminate ----\n\n---- del_response_header_connection probe: after-null-terminate ----\nresponse=0x55d5d6525820, hdr=0x55d5d6525cb0, value_param=0x55d5c65882e1\nhdr->value=0x55d5d6525c70, hdr->value_size=17\nhdr->value dump (up to 17 bytes):\n63 6c 6f 73 65 2c 20 32 2c 20 34 2c 20 36 2c 20 38 \nascii: 'close, 2, 4, 6, 8'\nresponse->flags_auto=0x00000003\n---- end probe: after-null-terminate ----\n\n---- del_response_header_connection probe: after-flags-check ----\nresponse=0x55d5d6525820, hdr=0x55d5d6525cb0, value_param=0x55d5c65882e1\nhdr->value=0x55d5d6525c70, hdr->value_size=17\nhdr->value dump (up to 17 bytes):\n63 6c \n</execution_log>\n\n<instruction>\nJudge whether the report is correct or not.\n</instruction>\n",
  "is_report_correct": true,
  "explanation": "The report is correct. The explicit write hdr->value[hdr->value_size] = 0 can be an out\u2011of\u2011bounds store if the allocated storage for hdr->value is exactly hdr->value_size bytes (i.e. no spare byte for a terminating NUL). The memcmp calls in this function are guarded so they themselves do not read past hdr->value_size, but the null\u2011termination write is an unconditional write past the last valid index unless the allocation invariant guarantees a trailing byte. If no such guarantee is documented/ensured, this is a real potential OOB and can cause later calls into <string.h> (e.g. strlen, strcmp) that assume a NUL\u2011terminated buffer to read beyond the object bounds, which is what MISRA C 2023 Rule 21.17 forbids. To be compliant the code must ensure the buffer has space for the terminating NUL (or avoid writing it)."
}