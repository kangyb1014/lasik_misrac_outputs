{
  "user_message": "An agent A claimed that the following new_connection_process_ code violates the MISRA C 2023 rule 8.13.\n<misra_rule>\nMISRA C 2023 Rule 8.13 is A pointer should point to a const-qualified type whenever possible.\n\n</misra_rule>\n<target_code>\nHere is the original code of new_connection_process_.\n```c\nstatic enum MHD_Result\nnew_connection_process_ (struct MHD_Daemon *daemon,\n                         struct MHD_Connection *connection)\n{\n  int eno = 0;\n\n  mhd_assert (connection->daemon == daemon);\n\n#ifdef MHD_USE_THREADS\n  /* Function manipulate connection and timeout DL-lists,\n   * must be called only within daemon thread. */\n  mhd_assert ( (! MHD_D_IS_USING_THREADS_ (daemon)) || \\\n               MHD_thread_handle_ID_is_current_thread_ (daemon->tid) );\n  mhd_assert (NULL == daemon->worker_pool);\n#endif /* MHD_USE_THREADS */\n\n  /* Allocate memory pool in the processing thread so\n   * intensively used memory area is allocated in \"good\"\n   * (for the thread) memory region. It is important with\n   * NUMA and/or complex cache hierarchy. */\n  connection->pool = MHD_pool_create (daemon->pool_size);\n  if (NULL == connection->pool)\n  { /* 'pool' creation failed */\n#ifdef HAVE_MESSAGES\n    MHD_DLOG (daemon,\n              _ (\"Error allocating memory: %s\\n\"),\n              MHD_strerror_ (errno));\n#endif\n#if defined(ENOMEM) && (ENOMEM + 0 != 0)\n    eno = ENOMEM;\n#endif\n    (void) 0; /* Mute possible compiler warning */\n  }\n  else\n  { /* 'pool' creation succeed */\n    MHD_mutex_lock_chk_ (&daemon->cleanup_connection_mutex);\n    /* Firm check under lock. */\n    if (daemon->connections >= daemon->connection_limit)\n    { /* Connections limit */\n      MHD_mutex_unlock_chk_ (&daemon->cleanup_connection_mutex);\n#ifdef HAVE_MESSAGES\n      MHD_DLOG (daemon,\n                _ (\"Server reached connection limit. \"\n                   \"Closing inbound connection.\\n\"));\n#endif\n#if defined(ENFILE) && (ENFILE + 0 != 0)\n      eno = ENFILE;\n#endif\n      (void) 0; /* Mute possible compiler warning */\n    }\n    else\n    { /* Have space for new connection */\n      daemon->connections++;\n      DLL_insert (daemon->connections_head,\n                  daemon->connections_tail,\n                  connection);\n      if (! MHD_D_IS_USING_THREAD_PER_CONN_ (daemon))\n      {\n        XDLL_insert (daemon->normal_timeout_head,\n                     daemon->normal_timeout_tail,\n                     connection);\n      }\n      MHD_mutex_unlock_chk_ (&daemon->cleanup_connection_mutex);\n\n      MHD_connection_set_initial_state_ (connection);\n\n      if (NULL != daemon->notify_connection)\n        daemon->notify_connection (daemon->notify_connection_cls,\n                                   connection,\n                                   &connection->socket_context,\n                                   MHD_CONNECTION_NOTIFY_STARTED);\n#ifdef MHD_USE_THREADS\n      if (MHD_D_IS_USING_THREAD_PER_CONN_ (daemon))\n      {\n        mhd_assert (! MHD_D_IS_USING_EPOLL_ (daemon));\n        if (! MHD_create_named_thread_ (&connection->tid,\n                                        \"MHD-connection\",\n                                        daemon->thread_stack_size,\n                                        &thread_main_handle_connection,\n                                        connection))\n        {\n          eno = errno;\n#ifdef HAVE_MESSAGES\n#ifdef EAGAIN\n          if (EAGAIN == eno)\n            MHD_DLOG (daemon,\n                      _ (\"Failed to create a new thread because it would \"\n                         \"have exceeded the system limit on the number of \"\n                         \"threads or no system resources available.\\n\"));\n          else\n#endif /* EAGAIN */\n          MHD_DLOG (daemon,\n                    _ (\"Failed to create a thread: %s\\n\"),\n                    MHD_strerror_ (eno));\n#endif /* HAVE_MESSAGES */\n        }\n        else               /* New thread has been created successfully */\n          return MHD_YES;  /* *** Function success exit point *** */\n      }\n      else\n#else  /* ! MHD_USE_THREADS */\n      if (1)\n#endif /* ! MHD_USE_THREADS */\n      { /* No 'thread-per-connection' */\n#ifdef MHD_USE_THREADS\n        connection->tid = daemon->tid;\n#endif /* MHD_USE_THREADS */\n#ifdef EPOLL_SUPPORT\n        if (MHD_D_IS_USING_EPOLL_ (daemon))\n        {\n          if (0 == (daemon->options & MHD_USE_TURBO))\n          {\n            struct epoll_event event;\n\n            event.events = EPOLLIN | EPOLLOUT | EPOLLPRI | EPOLLET | EPOLLRDHUP;\n            event.data.ptr = connection;\n            if (0 != epoll_ctl (daemon->epoll_fd,\n                                EPOLL_CTL_ADD,\n                                connection->socket_fd,\n                                &event))\n            {\n              eno = errno;\n#ifdef HAVE_MESSAGES\n              MHD_DLOG (daemon,\n                        _ (\"Call to epoll_ctl failed: %s\\n\"),\n                        MHD_socket_last_strerr_ ());\n#endif\n            }\n            else\n            { /* 'socket_fd' has been added to 'epool' */\n              connection->epoll_state |= MHD_EPOLL_STATE_IN_EPOLL_SET;\n\n              return MHD_YES;  /* *** Function success exit point *** */\n            }\n          }\n          else\n          {\n            connection->epoll_state |= MHD_EPOLL_STATE_READ_READY\n                                       | MHD_EPOLL_STATE_WRITE_READY\n                                       | MHD_EPOLL_STATE_IN_EREADY_EDLL;\n            EDLL_insert (daemon->eready_head,\n                         daemon->eready_tail,\n                         connection);\n\n            return MHD_YES;  /* *** Function success exit point *** */\n          }\n        }\n        else /* No 'epoll' */\n#endif /* EPOLL_SUPPORT */\n        return MHD_YES;    /* *** Function success exit point *** */\n      }\n\n      /* ** Below is a cleanup path ** */\n      if (NULL != daemon->notify_connection)\n        daemon->notify_connection (daemon->notify_connection_cls,\n                                   connection,\n                                   &connection->socket_context,\n                                   MHD_CONNECTION_NOTIFY_CLOSED);\n      MHD_mutex_lock_chk_ (&daemon->cleanup_connection_mutex);\n      if (! MHD_D_IS_USING_THREAD_PER_CONN_ (daemon))\n      {\n        XDLL_remove (daemon->normal_timeout_head,\n                     daemon->normal_timeout_tail,\n                     connection);\n      }\n      DLL_remove (daemon->connections_head,\n                  daemon->connections_tail,\n                  connection);\n      daemon->connections--;\n      MHD_mutex_unlock_chk_ (&daemon->cleanup_connection_mutex);\n    }\n    MHD_pool_destroy (connection->pool);\n  }\n  /* Free resources allocated before the call of this functions */\n#ifdef HTTPS_SUPPORT\n  if (NULL != connection->tls_session)\n    gnutls_deinit (connection->tls_session);\n#endif /* HTTPS_SUPPORT */\n  MHD_ip_limit_del (daemon,\n                    connection->addr,\n                    connection->addr_len);\n  if (NULL != connection->addr)\n    free (connection->addr);\n  MHD_socket_close_chk_ (connection->socket_fd);\n  free (connection);\n  if (0 != eno)\n    errno = eno;\n#ifdef EINVAL\n  else\n    errno = EINVAL;\n#endif /* EINVAL */\n  return MHD_NO;  /* *** Function failure exit point *** */\n}\n```\n</target_code>\n<response format>\nProvide your answer with these fields.\n- explanation: your evaluation of the scenario provided by the agent A.\n- is_report_correct: whether the report is correct or not (true/false). True means there is a violation.\n</response format>\n<scenario>\nThe agent A provided the following violation scenario:\nIf MHD_strerror_ is declared to return a non-const char * (e.g. wrapper around strerror), this is a violation: the returned pointer points to a string that is not meant to be modified and therefore should be const char *. Passing a non-const char * where the data is immutable breaks MISRA C 2023 Rule 8.13. If, however, MHD_strerror_ is declared to return const char *, there is no violation.\n</scenario>\n\n<execution_log>\nThe agent A also provided the following output log:\n[2025-08-26 09:46:12] [enter_new_connection_process] daemon=0x5563a307f8d0 connection=0x5563a30801e0\n  daemon->connections=0 connection_limit=1019\n  connection->socket_fd=5 pool=(nil) epoll_state=0x0\n[2025-08-26 09:46:12] [no_epoll_success] daemon=0x5563a307f8d0 connection=0x5563a30801e0\n  daemon->connections=1 connection_limit=1019\n  connection->socket_fd=5 pool=0x5563a3080850 epoll_state=0x0\n[2025-08-26 09:46:12] [enter_new_connection_process] daemon=0x5563a307f8d0 connection=0x5563a3080880\n  daemon->connections=0 connection_limit=1019\n  connection->socket_fd=5 pool=(nil) epoll_state=0x0\n[2025-08-26 09:46:12] [no_epoll_success] daemon=0x5563a307f8d0 connection=0x5563a3080880\n  daemon->connections=1 connection_limit=1019\n  connection->socket_fd=5 pool=0x5563a3080850 epoll_state=0x0\n[2025-08-26 09:46:12] [enter_new_connection_process] daemon=0x5563a307f8d0 connection=0x5563a3080ad0\n  daemon->connections=0 connection_limit=1019\n  connection->socket_fd=5 pool=(nil) epoll_state=0x0\n[2025-08-26 09:46:12] [no_epoll_success] daemon=0x5563a307f8d0 connection=0x5563a3080ad0\n  daemon->connections=1 connection_limit=1019\n  connection->socket_fd=5 pool=0x5563a3080850 epoll_state=0x0\n[2025-08-26 09:46:12] [enter_new_connection_process] daemon=0x5563a307f8d0 connection=0x5563a3080d20\n  daemon->connections=0 connection_limit=1019\n  connection->socket_fd=5 pool=(nil) epoll_state=0x0\n[2025-08-26 09:46:12] [no_epoll_success] daemon=0x5563a307f8d0 connection=0x5563a3080d20\n  daemon->connections=1 connection_limit=1019\n  connection->socket_fd=5 pool=0x5563a3080850 epoll_state=0x0\n[2025-08-26 09:46:12] [enter_new_connection_process] daemon=0x5563a307f8d0 connection=0x5563a3080f70\n  daemon->connections=0 connection_limit=1019\n  connection->socket_fd=5 pool=(nil) epoll_state=0x0\n[2025-08-26 09:46:12] [no_epoll_success] daemon=0x5563a307f8d0 connection=0x5563a3080f70\n  daemon->connections=1 connection_limit=1019\n  connection->socket_fd=5 pool=0x5563a3080850 epoll_state=0x0\n[2025-08-26 09:46:12] [enter_new_connection_process] daemon=0x5563a307f8d0 connection=0x5563a30811c0\n  daemon->connections=0 connection_limit=1019\n  connection->socket_fd=5 pool=(nil) epoll_state=0x0\n[2025-08-26 09:46:12] [no_epoll_success] daemon=0x5563a307f8d0 connection=0x5563a30811c0\n  daemon->connections=1 connection_limit=1019\n  connection->socket_fd=5 pool=0x5563a3080850 epoll_state=0x0\n[2025-08-26 09:46:12] [enter_new_connection_process] daemon=0x5563a307f8d0 connection=0x5563a3081410\n  daemon->connections=0 connection_limit=1019\n  connection->socket_fd=5 pool=(nil) epoll_state=0x0\n[2025-08-26 09:46:12] [no_epoll_success] daemon=0x5563a307f8d0 connection=0x5563a3081410\n  daemon->connections=1 connection_limit=1019\n  connection->socket_fd=5 pool=0x5563a3080850 epoll_state=0x0\n[2025-08-26 09:46:12] [enter_new_connection_process] daemon=0x5563a307f8d0 connection=0x5563a3082870\n  daemon->connections=0 connection_limit=1019\n  connection->socket_fd=5 pool=(nil) epoll_state=0x0\n[2025-08-26 09:46:12] [no_epoll_success] daemon=0x5563a307f8d0 connection=0x5563a3082870\n  daemon->connections=1 connection_limit=1019\n  connection->socket_fd=5 pool=0x5563a3080850 epoll_state=0x0\n[2025-08-26 09:46:12] [enter_new_connection_process] daemon=0x5563a307f8d0 connection=0x5563a3082870\n  daemon->connections=0 connection_limit=1019\n  connection->socket_fd=5 pool=(nil) epoll_state=0x0\n[2025-08-26 09:46:12] [no_epoll_success] daemon=0x5563a307f8d0 connection=0x5563a3082870\n  daemon->connections=1 connection_limit=1019\n  connection->socket_fd=5 pool=0x5563a3080850 epoll_state=0x0\n[2025-08-26 09:46:12] [enter_new_connection_process] daemon=0x5563a307f8d0 connection=0x5563a3082870\n  daemon->connections=0 connection_limit=1019\n  connection->socket_fd=5 pool=(nil) epoll_state=0x0\n[2025-08-26 09:46:12] [no_epoll_success] daemon=0x5563a307f8d0 connection=0x5563a3082870\n  daemon->connections=1 connection_limit=1019\n  connection->socket_fd=5 pool=0x5563a3080850 epoll_state=0x0\n[2025-08-26 09:46:12] [enter_new_connection_process] daemon=0x5563a307f8d0 connection=0x5563a3082870\n  daemon->connections=0 c\n</execution_log>\n\n<instruction>\nJudge whether the report is correct or not.\n</instruction>\n",
  "is_report_correct": false,
  "explanation": "Not correct. MISRA C 2023 Rule 8.13 mandates that pointer types be const-qualified where the pointed-to object is not intended to be modified \u2014 this is a requirement on declarations (the types that functions return or variables are declared with), not on every call site that merely uses such a pointer. In new_connection_process_ the code only calls MHD_strerror_() and immediately passes its return value to a logging routine; it does not declare a pointer-to-char variable that should have been const-qualified. If MHD_strerror_ is declared to return a non-const char * while the returned string is immutable, then the violation is in the declaration of MHD_strerror_ (or the wrapper around strerror), not in this caller. Conversely, if MHD_strerror_ is declared to return const char *, there is no issue. Therefore agent A\u2019s attribution of a Rule 8.13 violation to new_connection_process_ is incorrect (the actual problem would be in MHD_strerror_\u2019s declaration)."
}