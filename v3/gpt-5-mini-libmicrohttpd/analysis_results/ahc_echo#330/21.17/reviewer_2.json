{
  "user_message": "An agent A claimed that the following ahc_echo code violates the MISRA C 2023 rule 21.17.\n<misra_rule>\nMISRA C 2023 Rule 21.17 is Use of the string handling functions from <string.h> shall not result in accesses beyond the bounds of the objects referenced by their pointer parameters.\nThis rule strictly applies to the Standard Library functions in <string.h> such as memcpy, memmove, memset, memcmp, strcpy, strncpy, strcat, strncat, strlen, and strspn.\n</misra_rule>\n<target_code>\nHere is the original code of ahc_echo.\n```c\nstatic enum MHD_Result\nahc_echo (void *cls,\n          struct MHD_Connection *connection,\n          const char *url,\n          const char *method,\n          const char *version,\n          const char *upload_data, size_t *upload_data_size, void **req_cls)\n{\n  static int aptr;\n  struct handler_param *param = (struct handler_param *) cls;\n  struct MHD_Response *response;\n  enum MHD_Result ret;\n  (void) cls;               /* Unused. Silent compiler warning. */\n  (void) url;               /* Unused. Silent compiler warning. */\n  (void) version;           /* Unused. Silent compiler warning. */\n  (void) upload_data;       /* Unused. Silent compiler warning. */\n  (void) upload_data_size;  /* Unused. Silent compiler warning. */\n\n  if ((0 != strcmp (method, \"GET\")) && (0 != strcmp (method, \"POST\")))\n    return MHD_NO;              /* unexpected method */\n\n  if (&aptr != *req_cls)\n  {\n    *req_cls = &aptr;\n\n    /* always to busy for POST requests */\n    if (0 == strcmp (method, \"POST\"))\n    {\n      response =\n        MHD_create_response_from_buffer_static (strlen (BUSYPAGE),\n                                                (const void *) BUSYPAGE);\n      ret =\n        MHD_queue_response (connection, MHD_HTTP_SERVICE_UNAVAILABLE,\n                            response);\n      MHD_destroy_response (response);\n      return ret;\n    }\n  }\n\n  *req_cls = NULL;                  /* reset when done */\n  response =\n    MHD_create_response_from_buffer_static (strlen (param->response_page),\n                                            (const void *)\n                                            param->response_page);\n  ret = MHD_queue_response (connection, MHD_HTTP_OK, response);\n  MHD_destroy_response (response);\n  return ret;\n}\n```\n</target_code>\n<response format>\nProvide your answer with these fields.\n- explanation: your evaluation of the scenario provided by the agent A.\n- is_report_correct: whether the report is correct or not (true/false). True means there is a violation.\n</response format>\n<scenario>\nThe agent A provided the following violation scenario:\nThe call to strcmp(method, \"GET\") / strcmp(method, \"POST\") can read beyond the bounds of the object referenced by method. For example, if method == NULL the call dereferences a null pointer; or if method points to a buffer that is not NUL-terminated within its allocated size, strcmp will keep reading past the buffer until it finds a NUL, causing out-of-bounds access.\n</scenario>\n\n<instruction>\nJudge whether the report is correct or not.\n</instruction>\n",
  "is_report_correct": true,
  "explanation": "The agent A report is correct in the sense that the code uses strcmp(method, \"GET\") / strcmp(method, \"POST\") without any local check that 'method' is a non-NULL pointer to a NUL-terminated buffer. strcmp reads bytes until it finds a NUL byte, so if 'method' were NULL this would dereference a null pointer, or if 'method' pointed to a buffer that is not NUL-terminated within its allocation strcmp could read beyond the object bounds \u2014 both situations would violate MISRA C 2023 Rule 21.17. That rule requires that uses of the string.h functions must not result in accesses beyond the bounds of the objects referenced by their pointer parameters.\n\nWhether this is an actual violation in the concrete system depends on the calling contract: if the HTTP library (or other caller) formally guarantees that it will always pass a valid, NUL-terminated, non-NULL string for 'method', then the use is safe and does not violate the rule. In the absence of such a documented and verified guarantee, the code is nonconforming because it does not protect against out-of-bounds or NULL-pointer access. To remediate, either (a) document and justify the external guarantee, or (b) add defensive checks (e.g. verify method != NULL and that it is NUL-terminated within an expected bound, or use safer bounded comparisons after confirming buffer length) before calling strcmp."
}