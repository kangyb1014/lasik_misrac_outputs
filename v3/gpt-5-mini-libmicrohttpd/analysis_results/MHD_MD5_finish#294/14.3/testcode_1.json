{
  "user_message": "<misra_rule>\nMISRA C 2023 Rule 14.3 is: Controlling expressions shall not be invariant.\nHere are exceptions to this rule:\n1. Invariants that are used to create infinite loops are permitted.\n2. A do-while loop with an essentially Boolean controlling expression that evaluates to false and satisfies the constraints and semantics for an integer constant expression is permitted.\n</misra_rule>\n\nAnother agent reported that the target code violated the Rule 14.3.\nHere is the comment from the agent.\n<violation scenario>\nThe controlling expression 'if (1)' is a constant invariant. This is not an infinite loop nor the permitted do-while constant-false case; it is used to select an unconditional branch (via conditional compilation). Therefore Rule 14.3 is violated.\n</violation scenario>\n\nYour job is to insert logging code to capture the control flow and state information of the program.\nInsert logging code so that other agents can reproduce and get evidence for the violation scenario.\n<response format>\n- test_code: a modified MHD_MD5_finish code that contains useful probe functions that print useful logs to a file \"/tmp/logs/2945.txt\". The logs should contain the control path and state information of the violation scenario. If test code is not required to validate the scenario, you can leave this blank.\nHere are the constraints for the test code:\n- The test code MUST preserve the original logic of MHD_MD5_finish as much as possible.\nYou CAN just insert probe functions to the original code.\n- DO NOT introduce new violations to demonstrate your scenario.\n- The test code MUST be compilable and executable.\n- The test code MUST include line breaks.\n- You MUST NOT define the main function.\n- You MUST NOT define macros.\n</response format>\n<target_code>\nHere is the code of MHD_MD5_finish:\n```c\nvoid\nMHD_MD5_finish (struct Md5Ctx *ctx,\n                uint8_t digest[MD5_DIGEST_SIZE])\n{\n  uint64_t num_bits;   /**< Number of processed bits */\n  unsigned int bytes_have; /**< Number of bytes in the context buffer */\n\n  /* Memorise the number of processed bits.\n     The padding and other data added here during the postprocessing must\n     not change the amount of hashed data. */\n  num_bits = ctx->count << 3;\n\n  /* Note: (count & (MD5_BLOCK_SIZE-1))\n           equals (count % MD5_BLOCK_SIZE) for this block size. */\n  bytes_have = (unsigned int) (ctx->count & (MD5_BLOCK_SIZE - 1));\n\n  /* Input data must be padded with a single bit \"1\", then with zeros and\n     the finally the length of data in bits must be added as the final bytes\n     of the last block.\n     See RFC 1321, Clauses 3.1 and 3.2 (steps 1 and 2). */\n  /* Data is always processed in form of bytes (not by individual bits),\n     therefore position of the first padding bit in byte is always\n     predefined (0x80). */\n  /* Buffer always have space for one byte at least (as full buffers are\n     processed immediately). */\n  ((uint8_t *) ctx->buffer)[bytes_have++] = 0x80;\n\n  if (MD5_BLOCK_SIZE - bytes_have < MD5_SIZE_OF_LEN_ADD)\n  {   /* No space in the current block to put the total length of message.\n         Pad the current block with zeros and process it. */\n    if (bytes_have < MD5_BLOCK_SIZE)\n      memset (((uint8_t *) ctx->buffer) + bytes_have, 0,\n              MD5_BLOCK_SIZE - bytes_have);\n    /* Process the full block. */\n    md5_transform (ctx->H, ctx->buffer);\n    /* Start the new block. */\n    bytes_have = 0;\n  }\n\n  /* Pad the rest of the buffer with zeros. */\n  memset (((uint8_t *) ctx->buffer) + bytes_have, 0,\n          MD5_BLOCK_SIZE - MD5_SIZE_OF_LEN_ADD - bytes_have);\n  /* Put the number of bits in processed data as little-endian value.\n     See RFC 1321, clauses 2 and 3.2 (step 2). */\n  _MHD_PUT_64BIT_LE_SAFE (ctx->buffer + MD5_BLOCK_SIZE_WORDS - 2,\n                          num_bits);\n  /* Process the full final block. */\n  md5_transform (ctx->H, ctx->buffer);\n\n  /* Put in LE mode the hash as the final digest.\n     See RFC 1321, clauses 2 and 3.5 (step 5). */\n#ifndef _MHD_PUT_32BIT_LE_UNALIGNED\n  if (1\n#ifndef MHD_FAVOR_SMALL_CODE\n      && (0 != ((uintptr_t) digest) % _MHD_UINT32_ALIGN)\n#endif /* MHD_FAVOR_SMALL_CODE */\n      )\n  {\n    /* If storing of the final result requires aligned address and\n       the destination address is not aligned or compact code is used,\n       store the final digest in aligned temporary buffer first, then\n       copy it to the destination. */\n    uint32_t alig_dgst[MD5_DIGEST_SIZE_WORDS];\n    _MHD_PUT_32BIT_LE (alig_dgst + 0, ctx->H[0]);\n    _MHD_PUT_32BIT_LE (alig_dgst + 1, ctx->H[1]);\n    _MHD_PUT_32BIT_LE (alig_dgst + 2, ctx->H[2]);\n    _MHD_PUT_32BIT_LE (alig_dgst + 3, ctx->H[3]);\n    /* Copy result to the unaligned destination address. */\n    memcpy (digest, alig_dgst, MD5_DIGEST_SIZE);\n  }\n#ifndef MHD_FAVOR_SMALL_CODE\n  else /* Combined with the next 'if' */\n#endif /* MHD_FAVOR_SMALL_CODE */\n#endif /* ! _MHD_PUT_32BIT_LE_UNALIGNED */\n#if ! defined(MHD_FAVOR_SMALL_CODE) || defined(_MHD_PUT_32BIT_LE_UNALIGNED)\n  if (1)\n  {\n    /* Use cast to (void*) here to mute compiler alignment warnings.\n     * Compilers are not smart enough to see that alignment has been checked. */\n    _MHD_PUT_32BIT_LE ((void *) (digest + 0 * MD5_BYTES_IN_WORD), ctx->H[0]);\n    _MHD_PUT_32BIT_LE ((void *) (digest + 1 * MD5_BYTES_IN_WORD), ctx->H[1]);\n    _MHD_PUT_32BIT_LE ((void *) (digest + 2 * MD5_BYTES_IN_WORD), ctx->H[2]);\n    _MHD_PUT_32BIT_LE ((void *) (digest + 3 * MD5_BYTES_IN_WORD), ctx->H[3]);\n  }\n#endif /* ! MHD_FAVOR_SMALL_CODE || _MHD_PUT_32BIT_LE_UNALIGNED */\n\n  /* Erase potentially sensitive data. */\n  memset (ctx, 0, sizeof(struct Md5Ctx));\n}\n```\n</target_code>\nPlease provide the modified MHD_MD5_finish code.\n",
  "test_code": "#include <stdio.h>\n#include <stdint.h>\n#include <string.h>\n#include <stdlib.h>\n#include <inttypes.h>\n\n/* Minimal re-creation of needed types and constants so this file is\n   self-contained and compilable for testing the control-flow logging. */\nstatic const size_t MD5_DIGEST_SIZE = 16U;\nstatic const size_t MD5_BLOCK_SIZE = 64U;\nstatic const size_t MD5_SIZE_OF_LEN_ADD = 8U;\nstatic const size_t MD5_BLOCK_SIZE_WORDS = 64U; /* used as byte offset in original code */\nstatic const size_t MD5_DIGEST_SIZE_WORDS = 4U;\nstatic const size_t MD5_BYTES_IN_WORD = 4U;\n\nstruct Md5Ctx\n{\n  uint64_t count; /* number of processed bytes */\n  uint32_t H[4];\n  uint8_t buffer[MD5_BLOCK_SIZE];\n};\n\n/* Stubs for transformations and put functions. These preserve the\n   semantics needed for the finish function while allowing the test code\n   to be compiled and executed. */\nstatic void md5_transform (uint32_t H[4], const void *buffer)\n{\n  /* Minimal non-destructive stub: mix buffer bytes into H so logs can\n     show some change if needed. This preserves the idea of processing\n     the block but is not a real MD5 transform. */\n  const uint8_t *b = (const uint8_t *) buffer;\n  uint32_t mix = 0U;\n  for (size_t i = 0U; i < 8U && i < MD5_BLOCK_SIZE; ++i)\n  {\n    mix = (mix << 5) ^ (uint32_t) b[i];\n  }\n  H[0] ^= mix;\n  H[1] += mix;\n  H[2] -= mix;\n  H[3] = (H[3] << 1) | (H[3] >> 31);\n}\n\nstatic void _MHD_PUT_64BIT_LE_SAFE (void *dst, uint64_t v)\n{\n  uint8_t *d = (uint8_t *) dst;\n  for (int i = 0; i < 8; ++i)\n  {\n    d[i] = (uint8_t) (v & 0xFFU);\n    v >>= 8;\n  }\n}\n\nstatic void _MHD_PUT_32BIT_LE (void *dst, uint32_t v)\n{\n  uint8_t *d = (uint8_t *) dst;\n  for (int i = 0; i < 4; ++i)\n  {\n    d[i] = (uint8_t) (v & 0xFFU);\n    v >>= 8;\n  }\n}\n\n/* Probe helper: append a textual log line to the test file. */\nstatic void probe_log(const char *fmt, ...)\n{\n  FILE *f = fopen(\"/tmp/logs/2945.txt\", \"a\");\n  if (f == NULL)\n    return;\n  va_list ap;\n  va_start(ap, fmt);\n  vfprintf(f, fmt, ap);\n  va_end(ap);\n  fputc('\\n', f);\n  fclose(f);\n}\n\n/* Modified MHD_MD5_finish with inserted probes that log the control flow\n   and key state information to /tmp/logs/2945.txt. The original logic\n   is preserved as closely as possible given the self-contained test\n   environment. */\nvoid\nMHD_MD5_finish (struct Md5Ctx *ctx,\n                uint8_t digest[16])\n{\n  uint64_t num_bits;   /**< Number of processed bits */\n  unsigned int bytes_have; /**< Number of bytes in the context buffer */\n\n  /* Memorise the number of processed bits. */\n  num_bits = ctx->count << 3;\n  probe_log(\"enter MHD_MD5_finish: ctx=%p, count=%\" PRIu64 \", num_bits=%\" PRIu64,\n            (void *) ctx, ctx->count, num_bits);\n\n  /* Note: (count & (MD5_BLOCK_SIZE-1)) equals (count % MD5_BLOCK_SIZE)\n     for this block size. */\n  bytes_have = (unsigned int) (ctx->count & (MD5_BLOCK_SIZE - 1));\n  probe_log(\"bytes_have (before padding) = %u\", bytes_have);\n\n  /* Add the 0x80 padding byte. */\n  ((uint8_t *) ctx->buffer)[bytes_have++] = 0x80;\n  probe_log(\"added 0x80 at buffer[%u], bytes_have -> %u\", (unsigned) (bytes_have - 1), bytes_have);\n\n  if (MD5_BLOCK_SIZE - bytes_have < MD5_SIZE_OF_LEN_ADD)\n  {   /* No space in the current block to put the total length of message. */\n    probe_log(\"No space in current block for length: MD5_BLOCK_SIZE - bytes_have = %zu\",\n              (size_t)(MD5_BLOCK_SIZE - bytes_have));\n    if (bytes_have < MD5_BLOCK_SIZE)\n    {\n      memset (((uint8_t *) ctx->buffer) + bytes_have, 0,\n              MD5_BLOCK_SIZE - bytes_have);\n      probe_log(\"padded current block with zeros from %u to %u\", bytes_have, (unsigned)MD5_BLOCK_SIZE);\n    }\n    /* Process the full block. */\n    md5_transform (ctx->H, ctx->buffer);\n    probe_log(\"md5_transform called on full block (wrap). H = [%08\" PRIx32 \", %08\" PRIx32 \", %08\" PRIx32 \", %08\" PRIx32 \"]\",\n              ctx->H[0], ctx->H[1], ctx->H[2], ctx->H[3]);\n    /* Start the new block. */\n    bytes_have = 0;\n    probe_log(\"started new block, bytes_have = %u\", bytes_have);\n  }\n\n  /* Pad the rest of the buffer with zeros. */\n  memset (((uint8_t *) ctx->buffer) + bytes_have, 0,\n          MD5_BLOCK_SIZE - MD5_SIZE_OF_LEN_ADD - bytes_have);\n  probe_log(\"zero-padded buffer from %u up to %u\", bytes_have, (unsigned)(MD5_BLOCK_SIZE - MD5_SIZE_OF_LEN_ADD));\n\n  /* Put the number of bits in processed data as little-endian value. */\n  _MHD_PUT_64BIT_LE_SAFE (ctx->buffer + MD5_BLOCK_SIZE_WORDS - 2,\n                          num_bits);\n  probe_log(\"wrote num_bits (%\" PRIu64 \") at buffer offset %zu\", num_bits, (size_t)(MD5_BLOCK_SIZE_WORDS - 2));\n\n  /* Process the full final block. */\n  md5_transform (ctx->H, ctx->buffer);\n  probe_log(\"md5_transform called on final block. H = [%08\" PRIx32 \", %08\" PRIx32 \", %08\" PRIx32 \", %08\" PRIx32 \"]\",\n            ctx->H[0], ctx->H[1], ctx->H[2], ctx->H[3]);\n\n  /* Put in LE mode the hash as the final digest. */\n  /* The original implementation contains conditional compilation and a\n     controlling expression that includes literal 'if (1)'. We keep the\n     literal 'if (1)'s to reproduce and log the invariant controlling\n     expressions while preserving behavior. */\n\n  /* First variant: case where storing requires aligned temporary buffer. */\n  /* Note: Keep the literal '1' in the controlling expression as in the\n     original code so that tools can see the invariant controlling\n     expression. */\n  if (1\n      && (0 != ((uintptr_t) digest) % (uintptr_t) sizeof(uint32_t)))\n  {\n    probe_log(\"entered first 'if (1 && alignment)' branch: digest=%p, alignment mismatch=%zu\",\n              (void *) digest, (size_t) ((uintptr_t) digest % (uintptr_t) sizeof(uint32_t)));\n\n    uint32_t alig_dgst[MD5_DIGEST_SIZE_WORDS];\n    _MHD_PUT_32BIT_LE (alig_dgst + 0, ctx->H[0]);\n    _MHD_PUT_32BIT_LE (alig_dgst + 1, ctx->H[1]);\n    _MHD_PUT_32BIT_LE (alig_dgst + 2, ctx->H[2]);\n    _MHD_PUT_32BIT_LE (alig_dgst + 3, ctx->H[3]);\n    /* Copy result to the unaligned destination address. */\n    memcpy (digest, alig_dgst, MD5_DIGEST_SIZE);\n    probe_log(\"stored digest via aligned temporary buffer and memcpy\");\n  }\n  else\n  {\n    /* This 'else' may be combined with the next 'if' in some builds. */\n    probe_log(\"skipped first 'if (1 && alignment)' branch; will attempt direct store\");\n  }\n\n  /* Second variant: direct store path. The original code contains an\n     unconditional 'if (1)' to indicate an always-true controlling\n     expression in some builds. We retain that literal to show the\n     invariant in logs. */\n  if (1)\n  {\n    probe_log(\"entered second 'if (1)' direct-store branch; digest=%p\", (void *) digest);\n    /* Use cast to (void*) here to mute compiler alignment warnings. */\n    _MHD_PUT_32BIT_LE ((void *) (digest + 0 * MD5_BYTES_IN_WORD), ctx->H[0]);\n    _MHD_PUT_32BIT_LE ((void *) (digest + 1 * MD5_BYTES_IN_WORD), ctx->H[1]);\n    _MHD_PUT_32BIT_LE ((void *) (digest + 2 * MD5_BYTES_IN_WORD), ctx->H[2]);\n    _MHD_PUT_32BIT_LE ((void *) (digest + 3 * MD5_BYTES_IN_WORD), ctx->H[3]);\n    probe_log(\"direct-store completed. digest addr=%p, first 4 bytes = 0x%02x\",\n              (void *) digest, digest[0]);\n  }\n\n  /* Erase potentially sensitive data. */\n  memset (ctx, 0, sizeof(struct Md5Ctx));\n  probe_log(\"ctx zeroed and exit MHD_MD5_finish\");\n}\n"
}