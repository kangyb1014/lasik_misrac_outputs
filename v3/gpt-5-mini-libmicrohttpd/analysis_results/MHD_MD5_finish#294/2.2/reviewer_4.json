{
  "user_message": "An agent A claimed that the following MHD_MD5_finish code violates the MISRA C 2023 rule 2.2.\n<misra_rule>\nMISRA C 2023 Rule 2.2 is A project shall not contain dead code.\nAny operation that is executed but whose removal would not affect program behaviour constitutes dead code. Notes:\n1. The behaviour of an embedded sytem is often determined not just by the nature of its actions, but also by the time at which they occur.\n2. unreachable code is not dead code, as it cannot be executed.\n3.Initialization is not the same as an assignment operation and is therfore not a candidate for dead code.\n</misra_rule>\n<target_code>\nHere is the original code of MHD_MD5_finish.\n```c\nvoid\nMHD_MD5_finish (struct Md5Ctx *ctx,\n                uint8_t digest[MD5_DIGEST_SIZE])\n{\n  uint64_t num_bits;   /**< Number of processed bits */\n  unsigned int bytes_have; /**< Number of bytes in the context buffer */\n\n  /* Memorise the number of processed bits.\n     The padding and other data added here during the postprocessing must\n     not change the amount of hashed data. */\n  num_bits = ctx->count << 3;\n\n  /* Note: (count & (MD5_BLOCK_SIZE-1))\n           equals (count % MD5_BLOCK_SIZE) for this block size. */\n  bytes_have = (unsigned int) (ctx->count & (MD5_BLOCK_SIZE - 1));\n\n  /* Input data must be padded with a single bit \"1\", then with zeros and\n     the finally the length of data in bits must be added as the final bytes\n     of the last block.\n     See RFC 1321, Clauses 3.1 and 3.2 (steps 1 and 2). */\n  /* Data is always processed in form of bytes (not by individual bits),\n     therefore position of the first padding bit in byte is always\n     predefined (0x80). */\n  /* Buffer always have space for one byte at least (as full buffers are\n     processed immediately). */\n  ((uint8_t *) ctx->buffer)[bytes_have++] = 0x80;\n\n  if (MD5_BLOCK_SIZE - bytes_have < MD5_SIZE_OF_LEN_ADD)\n  {   /* No space in the current block to put the total length of message.\n         Pad the current block with zeros and process it. */\n    if (bytes_have < MD5_BLOCK_SIZE)\n      memset (((uint8_t *) ctx->buffer) + bytes_have, 0,\n              MD5_BLOCK_SIZE - bytes_have);\n    /* Process the full block. */\n    md5_transform (ctx->H, ctx->buffer);\n    /* Start the new block. */\n    bytes_have = 0;\n  }\n\n  /* Pad the rest of the buffer with zeros. */\n  memset (((uint8_t *) ctx->buffer) + bytes_have, 0,\n          MD5_BLOCK_SIZE - MD5_SIZE_OF_LEN_ADD - bytes_have);\n  /* Put the number of bits in processed data as little-endian value.\n     See RFC 1321, clauses 2 and 3.2 (step 2). */\n  _MHD_PUT_64BIT_LE_SAFE (ctx->buffer + MD5_BLOCK_SIZE_WORDS - 2,\n                          num_bits);\n  /* Process the full final block. */\n  md5_transform (ctx->H, ctx->buffer);\n\n  /* Put in LE mode the hash as the final digest.\n     See RFC 1321, clauses 2 and 3.5 (step 5). */\n#ifndef _MHD_PUT_32BIT_LE_UNALIGNED\n  if (1\n#ifndef MHD_FAVOR_SMALL_CODE\n      && (0 != ((uintptr_t) digest) % _MHD_UINT32_ALIGN)\n#endif /* MHD_FAVOR_SMALL_CODE */\n      )\n  {\n    /* If storing of the final result requires aligned address and\n       the destination address is not aligned or compact code is used,\n       store the final digest in aligned temporary buffer first, then\n       copy it to the destination. */\n    uint32_t alig_dgst[MD5_DIGEST_SIZE_WORDS];\n    _MHD_PUT_32BIT_LE (alig_dgst + 0, ctx->H[0]);\n    _MHD_PUT_32BIT_LE (alig_dgst + 1, ctx->H[1]);\n    _MHD_PUT_32BIT_LE (alig_dgst + 2, ctx->H[2]);\n    _MHD_PUT_32BIT_LE (alig_dgst + 3, ctx->H[3]);\n    /* Copy result to the unaligned destination address. */\n    memcpy (digest, alig_dgst, MD5_DIGEST_SIZE);\n  }\n#ifndef MHD_FAVOR_SMALL_CODE\n  else /* Combined with the next 'if' */\n#endif /* MHD_FAVOR_SMALL_CODE */\n#endif /* ! _MHD_PUT_32BIT_LE_UNALIGNED */\n#if ! defined(MHD_FAVOR_SMALL_CODE) || defined(_MHD_PUT_32BIT_LE_UNALIGNED)\n  if (1)\n  {\n    /* Use cast to (void*) here to mute compiler alignment warnings.\n     * Compilers are not smart enough to see that alignment has been checked. */\n    _MHD_PUT_32BIT_LE ((void *) (digest + 0 * MD5_BYTES_IN_WORD), ctx->H[0]);\n    _MHD_PUT_32BIT_LE ((void *) (digest + 1 * MD5_BYTES_IN_WORD), ctx->H[1]);\n    _MHD_PUT_32BIT_LE ((void *) (digest + 2 * MD5_BYTES_IN_WORD), ctx->H[2]);\n    _MHD_PUT_32BIT_LE ((void *) (digest + 3 * MD5_BYTES_IN_WORD), ctx->H[3]);\n  }\n#endif /* ! MHD_FAVOR_SMALL_CODE || _MHD_PUT_32BIT_LE_UNALIGNED */\n\n  /* Erase potentially sensitive data. */\n  memset (ctx, 0, sizeof(struct Md5Ctx));\n}\n```\n</target_code>\n<response format>\nProvide your answer with these fields.\n- explanation: your evaluation of the scenario provided by the agent A.\n- is_report_correct: whether the report is correct or not (true/false). True means there is a violation.\n</response format>\n<scenario>\nThe agent A provided the following violation scenario:\nThe conditional 'if (1)' wrapping the block is a constant-true test. The condition is evaluated and the branch is always taken, so the presence of the 'if (1)' statement (its test and branching) is executed but removing it would not affect program behaviour. Thus the conditional is dead code under MISRA C 2023 Rule 2.2. (The body statements are not dead \u2014 they have effect \u2014 but the surrounding 'if (1)' construct is redundant and constitutes dead code.)\n</scenario>\n\n<execution_log>\nThe agent A also provided the following output log:\nENTER MHD_MD5_finish: ctx=0x7ffddf9917b0 count=28\nnum_bits computed=224\nbytes_have initial=28\nafter appending 0x80, bytes_have=29\nno need to process current block first; bytes_have=29\npadding rest of buffer with zeros: start=29 len=27\nwrote num_bits (LE) into buffer; calling md5_transform for final block\nentered always-true branch for direct LE-put into digest (this is the branch reported in the violation scenario)\nwrote digest directly via _MHD_PUT_32BIT_LE\nabout to erase ctx at 0x7ffddf9917b0 (sizeof=88)\nEXIT MHD_MD5_finish\n\nENTER MHD_MD5_finish: ctx=0x7ffddf9917b0 count=14\nnum_bits computed=112\nbytes_have initial=14\nafter appending 0x80, bytes_have=15\nno need to process current block first; bytes_have=15\npadding rest of buffer with zeros: start=15 len=41\nwrote num_bits (LE) into buffer; calling md5_transform for final block\nentered always-true branch for direct LE-put into digest (this is the branch reported in the violation scenario)\nwrote digest directly via _MHD_PUT_32BIT_LE\nabout to erase ctx at 0x7ffddf9917b0 (sizeof=88)\nEXIT MHD_MD5_finish\n\nENTER MHD_MD5_finish: ctx=0x7ffddf9917b0 count=26\nnum_bits computed=208\nbytes_have initial=26\nafter appending 0x80, bytes_have=27\nno need to process current block first; bytes_have=27\npadding rest of buffer with zeros: start=27 len=29\nwrote num_bits (LE) into buffer; calling md5_transform for final block\nentered always-true branch for direct LE-put into digest (this is the branch reported in the violation scenario)\nwrote digest directly via _MHD_PUT_32BIT_LE\nabout to erase ctx at 0x7ffddf9917b0 (sizeof=88)\nEXIT MHD_MD5_finish\n\nENTER MHD_MD5_finish: ctx=0x7ffddf9917b0 count=26\nnum_bits computed=208\nbytes_have initial=26\nafter appending 0x80, bytes_have=27\nno need to process current block first; bytes_have=27\npadding rest of buffer with zeros: start=27 len=29\nwrote num_bits (LE) into buffer; calling md5_transform for final block\nentered always-true branch for direct LE-put into digest (this is the branch reported in the violation scenario)\nwrote digest directly via _MHD_PUT_32BIT_LE\nabout to erase ctx at 0x7ffddf9917b0 (sizeof=88)\nEXIT MHD_MD5_finish\n\nENTER MHD_MD5_finish: ctx=0x7ffddf9917b0 count=104\nnum_bits computed=832\nbytes_have initial=40\nafter appending 0x80, bytes_have=41\nno need to process current block first; bytes_have=41\npadding rest of buffer with zeros: start=41 len=15\nwrote num_bits (LE) into buffer; calling md5_transform for final block\nentered always-true branch for direct LE-put into digest (this is the branch reported in the violation scenario)\nwrote digest directly via _MHD_PUT_32BIT_LE\nabout to erase ctx at 0x7ffddf9917b0 (sizeof=88)\nEXIT MHD_MD5_finish\n\nENTER MHD_MD5_finish: ctx=0x7ffddf9917b0 count=378\nnum_bits computed=3024\nbytes_have initial=58\nafter appending 0x80, bytes_have=59\npadding into current block: MD5_BLOCK_SIZE=64 bytes_have=59 MD5_SIZE_OF_LEN_ADD=8\ncalling md5_transform for full block (first)\nstarted new block, bytes_have=0\npadding rest of buffer with zeros: start=0 len=56\nwrote num_bits (LE) into buffer; calling md5_transform for final block\nentered always-true branch for direct LE-put into digest (this is the branch reported in the violation scenario)\nwrote digest directly via _MHD_PUT_32BIT_LE\nabout to erase ctx at 0x7ffddf9917b0 (sizeof=88)\nEXIT MHD_MD5_finish\n\nENTER MHD_MD5_finish: ctx=0x7ffddf9917b0 count=0\nnum_bits computed=0\nbytes_have initial=0\nafter appending 0x80, bytes_have=1\nno need to process current block first; bytes_have=1\npadding rest of buffer with zeros: start=1 len=55\nwrote num_bits (LE) into buffer; calling md5_transform for final block\nentered always-true branch for direct LE-put into digest (this is the branch reported in the violation scenario)\nwrote digest directly via _MHD_PUT_32BIT_LE\nabout to erase ctx at 0x7ffddf9917b0 (sizeof=88)\nEXIT MHD_MD5_finish\n\nENTER MHD_MD5_finish: ctx=0x7ffddf9917b0 count=1\nnum_bits computed=8\nbytes_have initial=1\nafter appending 0x80, bytes_have=2\nno need to process current block first; bytes_have=2\npadding rest of buffer with zeros: start=2 len=54\nwrote num_bits (LE) into buffer; call\n</execution_log>\n\n<instruction>\nJudge whether the report is correct or not.\n</instruction>\n",
  "is_report_correct": true,
  "explanation": "The report is correct. The construct if (1) in the translation unit is an executed operation (the constant test is evaluated and the branch logic executed) whose removal would not change program behaviour \u2014 it is therefore dead code according to MISRA C 2023 Rule 2.2. The surrounding preprocessor logic explains why an always-true test appears (the code is arranged so different macro configurations produce an if/else pairing), but in any configuration that yields a literal if (1) the condition and branching itself are redundant and meet the rule\u2019s definition of dead code (note 2 excludes unreachable code, which is not the case here)."
}