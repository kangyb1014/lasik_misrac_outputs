{
  "user_message": "An agent A claimed that the following parse_http_std_method code violates the MISRA C 2023 rule 21.17.\n<misra_rule>\nMISRA C 2023 Rule 21.17 is Use of the string handling functions from <string.h> shall not result in accesses beyond the bounds of the objects referenced by their pointer parameters.\nThis rule strictly applies to the Standard Library functions in <string.h> such as memcpy, memmove, memset, memcmp, strcpy, strncpy, strcat, strncat, strlen, and strspn.\n</misra_rule>\n<target_code>\nHere is the original code of parse_http_std_method.\n```c\nstatic void\nparse_http_std_method (struct MHD_Connection *connection,\n                       const char *method,\n                       size_t len)\n{\n  const char *const m = method; /**< short alias */\n  mhd_assert (NULL != m);\n  mhd_assert (0 != len);\n\n  if ((MHD_STATICSTR_LEN_ (MHD_HTTP_METHOD_GET) == len) &&\n      (0 == memcmp (m, MHD_HTTP_METHOD_GET, len)))\n    connection->rq.http_mthd = MHD_HTTP_MTHD_GET;\n  else if ((MHD_STATICSTR_LEN_ (MHD_HTTP_METHOD_HEAD) == len) &&\n           (0 == memcmp (m, MHD_HTTP_METHOD_HEAD, len)))\n    connection->rq.http_mthd = MHD_HTTP_MTHD_HEAD;\n  else if ((MHD_STATICSTR_LEN_ (MHD_HTTP_METHOD_POST) == len) &&\n           (0 == memcmp (m, MHD_HTTP_METHOD_POST, len)))\n    connection->rq.http_mthd = MHD_HTTP_MTHD_POST;\n  else if ((MHD_STATICSTR_LEN_ (MHD_HTTP_METHOD_PUT) == len) &&\n           (0 == memcmp (m, MHD_HTTP_METHOD_PUT, len)))\n    connection->rq.http_mthd = MHD_HTTP_MTHD_PUT;\n  else if ((MHD_STATICSTR_LEN_ (MHD_HTTP_METHOD_DELETE) == len) &&\n           (0 == memcmp (m, MHD_HTTP_METHOD_DELETE, len)))\n    connection->rq.http_mthd = MHD_HTTP_MTHD_DELETE;\n  else if ((MHD_STATICSTR_LEN_ (MHD_HTTP_METHOD_CONNECT) == len) &&\n           (0 == memcmp (m, MHD_HTTP_METHOD_CONNECT, len)))\n    connection->rq.http_mthd = MHD_HTTP_MTHD_CONNECT;\n  else if ((MHD_STATICSTR_LEN_ (MHD_HTTP_METHOD_OPTIONS) == len) &&\n           (0 == memcmp (m, MHD_HTTP_METHOD_OPTIONS, len)))\n    connection->rq.http_mthd = MHD_HTTP_MTHD_OPTIONS;\n  else if ((MHD_STATICSTR_LEN_ (MHD_HTTP_METHOD_TRACE) == len) &&\n           (0 == memcmp (m, MHD_HTTP_METHOD_TRACE, len)))\n    connection->rq.http_mthd = MHD_HTTP_MTHD_TRACE;\n  else\n    connection->rq.http_mthd = MHD_HTTP_MTHD_OTHER;\n}\n```\n</target_code>\n<response format>\nProvide your answer with these fields.\n- explanation: your evaluation of the scenario provided by the agent A.\n- is_report_correct: whether the report is correct or not (true/false). True means there is a violation.\n</response format>\n<scenario>\nThe agent A provided the following violation scenario:\nmemcmp(m, MHD_HTTP_METHOD_DELETE, len) will read len bytes from both operands. While MHD_STATICSTR_LEN_(MHD_HTTP_METHOD_DELETE) ensures the string literal is at least len bytes, there is no guarantee in this function that the buffer pointed to by method (m) contains len bytes. If the caller provides a smaller buffer (or len is larger than the available bytes at m), memcmp will access beyond the bounds of m, violating Rule 21.17.\n</scenario>\n\n<instruction>\nJudge whether the report is correct or not.\n</instruction>\n",
  "is_report_correct": true,
  "explanation": "The report is correct. memcmp(m, CONST, len) will read len bytes from both operands; the code ensures the constant operand is at least len bytes via MHD_STATICSTR_LEN_, but there is no runtime check that the buffer pointed to by method (m) actually contains len bytes. The only checks in the function are mhd_assert calls, which are typically disabled in production and do not satisfy MISRA\u2019s requirement that use of <string.h> functions must not permit out-of-bounds accesses. Therefore, unless there is an external, statically provable contract that guarantees the caller supplies a buffer of at least len bytes, this use can result in an out-of-bounds read and thereby violates MISRA C 2023 Rule 21.17."
}