{
  "user_message": "<misra_rule>\nMISRA C 2023 Rule 21.17 is: Use of the string handling functions from <string.h> shall not result in accesses beyond the bounds of the objects referenced by their pointer parameters.\nThis rule strictly applies to the Standard Library functions in <string.h> such as memcpy, memmove, memset, memcmp, strcpy, strncpy, strcat, strncat, strlen, and strspn.\n</misra_rule>\n\nAnother agent reported that the target code violated the Rule 21.17.\nHere is the comment from the agent.\n<violation scenario>\nIf the loop exits because i == str_len (i.e. the parameter value runs to the end of the input with no delimiter), the subsequent test if (';' == str[i]) dereferences str at index str_len, which is past the last valid element. Example: str_len == 5 and characters at indices 0..4 are non-delimiters \u2014 the while loop increments i to 5, then the if (';' == str[i]) reads str[5] (out-of-bounds).\n</violation scenario>\n\nYour job is to insert logging code to capture the control flow and state information of the program.\nInsert logging code so that other agents can reproduce and get evidence for the violation scenario.\n<response format>\n- test_code: a modified parse_dauth_params code that contains useful probe functions that print useful logs to a file \"/tmp/logs/2459.txt\". The logs should contain the control path and state information of the violation scenario. If test code is not required to validate the scenario, you can leave this blank.\nHere are the constraints for the test code:\n- The test code MUST preserve the original logic of parse_dauth_params as much as possible.\nYou CAN just insert probe functions to the original code.\n- DO NOT introduce new violations to demonstrate your scenario.\n- The test code MUST be compilable and executable.\n- The test code MUST include line breaks.\n- You MUST NOT define the main function.\n- You MUST NOT define macros.\n</response format>\n<target_code>\nHere is the code of parse_dauth_params:\n```c\nstatic bool\nparse_dauth_params (const char *str,\n                    const size_t str_len,\n                    struct MHD_RqDAuth *pdauth)\n{\n  /* The tokens */\n  static const struct _MHD_cstr_w_len nonce_tk = _MHD_S_STR_W_LEN (\"nonce\");\n  static const struct _MHD_cstr_w_len opaque_tk = _MHD_S_STR_W_LEN (\"opaque\");\n  static const struct _MHD_cstr_w_len algorithm_tk =\n    _MHD_S_STR_W_LEN (\"algorithm\");\n  static const struct _MHD_cstr_w_len response_tk =\n    _MHD_S_STR_W_LEN (\"response\");\n  static const struct _MHD_cstr_w_len username_tk =\n    _MHD_S_STR_W_LEN (\"username\");\n  static const struct _MHD_cstr_w_len username_ext_tk =\n    _MHD_S_STR_W_LEN (\"username*\");\n  static const struct _MHD_cstr_w_len realm_tk = _MHD_S_STR_W_LEN (\"realm\");\n  static const struct _MHD_cstr_w_len uri_tk = _MHD_S_STR_W_LEN (\"uri\");\n  static const struct _MHD_cstr_w_len qop_tk = _MHD_S_STR_W_LEN (\"qop\");\n  static const struct _MHD_cstr_w_len cnonce_tk = _MHD_S_STR_W_LEN (\"cnonce\");\n  static const struct _MHD_cstr_w_len nc_tk = _MHD_S_STR_W_LEN (\"nc\");\n  static const struct _MHD_cstr_w_len userhash_tk =\n    _MHD_S_STR_W_LEN (\"userhash\");\n  /* The locally processed parameters */\n  struct MHD_RqDAuthParam userhash;\n  struct MHD_RqDAuthParam algorithm;\n  /* Indexes */\n  size_t i;\n  size_t p;\n  /* The list of the tokens.\n     The order of the elements matches the next array. */\n  static const struct _MHD_cstr_w_len *const tk_names[] = {\n    &nonce_tk,          /* 0 */\n    &opaque_tk,         /* 1 */\n    &algorithm_tk,      /* 2 */\n    &response_tk,       /* 3 */\n    &username_tk,       /* 4 */\n    &username_ext_tk,   /* 5 */\n    &realm_tk,          /* 6 */\n    &uri_tk,            /* 7 */\n    &qop_tk,            /* 8 */\n    &cnonce_tk,         /* 9 */\n    &nc_tk,             /* 10 */\n    &userhash_tk        /* 11 */\n  };\n  /* The list of the parameters.\n     The order of the elements matches the previous array. */\n  struct MHD_RqDAuthParam *params[sizeof(tk_names) / sizeof(tk_names[0])];\n\n  params[0 ] = &(pdauth->nonce);           /* 0 */\n  params[1 ] = &(pdauth->opaque);          /* 1 */\n  params[2 ] = &algorithm;                 /* 2 */\n  params[3 ] = &(pdauth->response);        /* 3 */\n  params[4 ] = &(pdauth->username);        /* 4 */\n  params[5 ] = &(pdauth->username_ext);    /* 5 */\n  params[6 ] = &(pdauth->realm);           /* 6 */\n  params[7 ] = &(pdauth->uri);             /* 7 */\n  params[8 ] = &(pdauth->qop_raw);         /* 8 */\n  params[9 ] = &(pdauth->cnonce);          /* 9 */\n  params[10] = &(pdauth->nc);              /* 10 */\n  params[11] = &userhash;                  /* 11 */\n\n  mhd_assert ((sizeof(tk_names) / sizeof(tk_names[0])) == \\\n              (sizeof(params) / sizeof(params[0])));\n  memset (&userhash, 0, sizeof(userhash));\n  memset (&algorithm, 0, sizeof(algorithm));\n  i = 0;\n\n  /* Skip all whitespaces at start */\n  while (i < str_len && (' ' == str[i] || '\\t' == str[i]))\n    i++;\n\n  while (str_len > i)\n  {\n    size_t left;\n    mhd_assert (' ' != str[i]);\n    mhd_assert ('\\t' != str[i]);\n\n    left = str_len - i;\n    if ('=' == str[i])\n      return false; /* The equal sign is not allowed as the first character */\n    for (p = 0; p < (sizeof(tk_names) / sizeof(tk_names[0])); ++p)\n    {\n      const struct _MHD_cstr_w_len *const tk_name = tk_names[p];\n      struct MHD_RqDAuthParam *const param = params[p];\n      if ( (tk_name->len <= left) &&\n           MHD_str_equal_caseless_bin_n_ (str + i, tk_name->str,\n                                          tk_name->len) &&\n           ((tk_name->len == left) ||\n            ('=' == str[i + tk_name->len]) ||\n            (' ' == str[i + tk_name->len]) ||\n            ('\\t' == str[i + tk_name->len]) ||\n            (',' == str[i + tk_name->len]) ||\n            (';' == str[i + tk_name->len])) )\n      {\n        size_t value_start;\n        size_t value_len;\n        bool quoted; /* Only mark as \"quoted\" if backslash-escape used */\n\n        if (tk_name->len == left)\n          return false; /* No equal sign after parameter name, broken data */\n\n        quoted = false;\n        i += tk_name->len;\n        /* Skip all whitespaces before '=' */\n        while (str_len > i && (' ' == str[i] || '\\t' == str[i]))\n          i++;\n        if ((i == str_len) || ('=' != str[i]))\n          return false; /* No equal sign, broken data */\n        i++;\n        /* Skip all whitespaces after '=' */\n        while (str_len > i && (' ' == str[i] || '\\t' == str[i]))\n          i++;\n        if ((str_len > i) && ('\"' == str[i]))\n        { /* Value is in quotation marks */\n          i++; /* Advance after the opening quote */\n          value_start = i;\n          while (str_len > i && '\"' != str[i])\n          {\n            if ('\\\\' == str[i])\n            {\n              i++;\n              quoted = true; /* Have escaped chars */\n            }\n            if (0 == str[i])\n              return false; /* Binary zero in parameter value */\n            i++;\n          }\n          if (str_len <= i)\n            return false; /* No closing quote */\n          mhd_assert ('\"' == str[i]);\n          value_len = i - value_start;\n          i++; /* Advance after the closing quote */\n        }\n        else\n        {\n          value_start = i;\n          while (str_len > i && ',' != str[i] &&\n                 ' ' != str[i] && '\\t' != str[i] && ';' != str[i])\n          {\n            if (0 == str[i])\n              return false;  /* Binary zero in parameter value */\n            i++;\n          }\n          if (';' == str[i])\n            return false;  /* Semicolon in parameter value */\n          value_len = i - value_start;\n        }\n        /* Skip all whitespaces after parameter value */\n        while (str_len > i && (' ' == str[i] || '\\t' == str[i]))\n          i++;\n        if ((str_len > i) && (',' != str[i]))\n          return false; /* Garbage after parameter value */\n\n        /* Have valid parameter name and value */\n        mhd_assert (! quoted || 0 != value_len);\n        param->value.str = str + value_start;\n        param->value.len = value_len;\n        param->quoted = quoted;\n\n        break; /* Found matching parameter name */\n      }\n    }\n    if (p == (sizeof(tk_names) / sizeof(tk_names[0])))\n    {\n      /* No matching parameter name */\n      while (str_len > i && ',' != str[i])\n      {\n        if ((0 == str[i]) || (';' == str[i]))\n          return false; /* Not allowed characters */\n        if ('\"' == str[i])\n        { /* Skip quoted part */\n          i++; /* Advance after the opening quote */\n          while (str_len > i && '\"' != str[i])\n          {\n            if (0 == str[i])\n              return false;  /* Binary zero is not allowed */\n            if ('\\\\' == str[i])\n              i++;           /* Skip escaped char */\n            i++;\n          }\n          if (str_len <= i)\n            return false; /* No closing quote */\n          mhd_assert ('\"' == str[i]);\n        }\n        i++;\n      }\n    }\n    mhd_assert (str_len == i || ',' == str[i]);\n    if (str_len > i)\n      i++; /* Advance after ',' */\n    /* Skip all whitespaces before next parameter name */\n    while (i < str_len && (' ' == str[i] || '\\t' == str[i]))\n      i++;\n  }\n\n  /* Postprocess values */\n\n  if (NULL != userhash.value.str)\n  {\n    if (userhash.quoted)\n      pdauth->userhash =\n        MHD_str_equal_caseless_quoted_s_bin_n (userhash.value.str, \\\n                                               userhash.value.len, \\\n                                               \"true\");\n    else\n      pdauth->userhash =\n        MHD_str_equal_caseless_s_bin_n_ (\"true\", userhash.value.str, \\\n                                         userhash.value.len);\n\n  }\n  else\n    pdauth->userhash = false;\n\n  pdauth->algo3 = get_rq_dauth_algo (&algorithm);\n  pdauth->qop = get_rq_dauth_qop (&pdauth->qop_raw);\n\n  return true;\n}\n```\n</target_code>\nPlease provide the modified parse_dauth_params code.\n",
  "test_code": "#include <stdio.h>\n#include <stdarg.h>\n#include <stddef.h>\n#include <stdint.h>\n\n/* Helper logging/probe utilities. These functions append diagnostic\n   information to /tmp/logs/2459.txt. They are careful not to read\n   str[i] when i >= str_len to avoid introducing new out-of-bounds\n   accesses. */\nstatic void\nmhd_log_printf (const char *fmt, ...)\n{\n  FILE *f = fopen(\"/tmp/logs/2459.txt\", \"a\");\n  if (NULL == f)\n    return;\n  va_list ap;\n  va_start (ap, fmt);\n  vfprintf (f, fmt, ap);\n  fprintf (f, \"\\n\");\n  va_end (ap);\n  fclose (f);\n}\n\nstatic void\nmhd_log_state (const char *tag,\n               const char *str,\n               size_t str_len,\n               size_t i,\n               size_t p,\n               size_t extra1,\n               size_t extra2,\n               const char *note)\n{\n  int ch = -1;\n  if (str != NULL && i < str_len)\n    ch = (unsigned char) str[i];\n  mhd_log_printf (\"[%s] note=%s i=%zu str_len=%zu p=%zu extra1=%zu extra2=%zu char_at_i=%d\",\n                  tag, note ? note : \"(null)\", i, str_len, p, extra1, extra2, ch);\n}\n\n/* Modified parse_dauth_params with logging probes inserted. The original\n   logic is preserved as much as possible; logging never reads out-of-bounds. */\nstatic bool\nparse_dauth_params (const char *str,\n                    const size_t str_len,\n                    struct MHD_RqDAuth *pdauth)\n{\n  /* The tokens */\n  static const struct _MHD_cstr_w_len nonce_tk = _MHD_S_STR_W_LEN (\"nonce\");\n  static const struct _MHD_cstr_w_len opaque_tk = _MHD_S_STR_W_LEN (\"opaque\");\n  static const struct _MHD_cstr_w_len algorithm_tk =\n    _MHD_S_STR_W_LEN (\"algorithm\");\n  static const struct _MHD_cstr_w_len response_tk =\n    _MHD_S_STR_W_LEN (\"response\");\n  static const struct _MHD_cstr_w_len username_tk =\n    _MHD_S_STR_W_LEN (\"username\");\n  static const struct _MHD_cstr_w_len username_ext_tk =\n    _MHD_S_STR_W_LEN (\"username*\");\n  static const struct _MHD_cstr_w_len realm_tk = _MHD_S_STR_W_LEN (\"realm\");\n  static const struct _MHD_cstr_w_len uri_tk = _MHD_S_STR_W_LEN (\"uri\");\n  static const struct _MHD_cstr_w_len qop_tk = _MHD_S_STR_W_LEN (\"qop\");\n  static const struct _MHD_cstr_w_len cnonce_tk = _MHD_S_STR_W_LEN (\"cnonce\");\n  static const struct _MHD_cstr_w_len nc_tk = _MHD_S_STR_W_LEN (\"nc\");\n  static const struct _MHD_cstr_w_len userhash_tk =\n    _MHD_S_STR_W_LEN (\"userhash\");\n  /* The locally processed parameters */\n  struct MHD_RqDAuthParam userhash;\n  struct MHD_RqDAuthParam algorithm;\n  /* Indexes */\n  size_t i;\n  size_t p;\n  /* The list of the tokens.\n     The order of the elements matches the next array. */\n  static const struct _MHD_cstr_w_len *const tk_names[] = {\n    &nonce_tk,          /* 0 */\n    &opaque_tk,         /* 1 */\n    &algorithm_tk,      /* 2 */\n    &response_tk,       /* 3 */\n    &username_tk,       /* 4 */\n    &username_ext_tk,   /* 5 */\n    &realm_tk,          /* 6 */\n    &uri_tk,            /* 7 */\n    &qop_tk,            /* 8 */\n    &cnonce_tk,         /* 9 */\n    &nc_tk,             /* 10 */\n    &userhash_tk        /* 11 */\n  };\n  /* The list of the parameters.\n     The order of the elements matches the previous array. */\n  struct MHD_RqDAuthParam *params[sizeof(tk_names) / sizeof(tk_names[0])];\n\n  params[0 ] = &(pdauth->nonce);           /* 0 */\n  params[1 ] = &(pdauth->opaque);          /* 1 */\n  params[2 ] = &algorithm;                 /* 2 */\n  params[3 ] = &(pdauth->response);        /* 3 */\n  params[4 ] = &(pdauth->username);        /* 4 */\n  params[5 ] = &(pdauth->username_ext);    /* 5 */\n  params[6 ] = &(pdauth->realm);           /* 6 */\n  params[7 ] = &(pdauth->uri);             /* 7 */\n  params[8 ] = &(pdauth->qop_raw);         /* 8 */\n  params[9 ] = &(pdauth->cnonce);          /* 9 */\n  params[10] = &(pdauth->nc);              /* 10 */\n  params[11] = &userhash;                  /* 11 */\n\n  mhd_assert ((sizeof(tk_names) / sizeof(tk_names[0])) == \\\n              (sizeof(params) / sizeof(params[0])));\n  memset (&userhash, 0, sizeof(userhash));\n  memset (&algorithm, 0, sizeof(algorithm));\n  i = 0;\n\n  mhd_log_state(\"enter\", str, str_len, i, (size_t)-1, 0, 0, \"function entry\");\n\n  /* Skip all whitespaces at start */\n  while (i < str_len && (' ' == str[i] || '\\t' == str[i]))\n    i++;\n\n  mhd_log_state(\"after_leading_ws\", str, str_len, i, (size_t)-1, 0, 0, \"skipped leading whitespace\");\n\n  while (str_len > i)\n  {\n    size_t left;\n    mhd_assert (' ' != str[i]);\n    mhd_assert ('\\t' != str[i]);\n\n    left = str_len - i;\n    if ('=' == str[i])\n    {\n      mhd_log_state(\"early_equal\", str, str_len, i, (size_t)-1, 0, 0, \"found '=' as first char in token\");\n      return false; /* The equal sign is not allowed as the first character */\n    }\n    for (p = 0; p < (sizeof(tk_names) / sizeof(tk_names[0])); ++p)\n    {\n      const struct _MHD_cstr_w_len *const tk_name = tk_names[p];\n      struct MHD_RqDAuthParam *const param = params[p];\n      mhd_log_state(\"token_check\", str, str_len, i, p, tk_name->len, left, \"checking token\");\n      if ( (tk_name->len <= left) &&\n           MHD_str_equal_caseless_bin_n_ (str + i, tk_name->str,\n                                          tk_name->len) &&\n           ((tk_name->len == left) ||\n            ('=' == str[i + tk_name->len]) ||\n            (' ' == str[i + tk_name->len]) ||\n            ('\\t' == str[i + tk_name->len]) ||\n            (',' == str[i + tk_name->len]) ||\n            (';' == str[i + tk_name->len])) )\n      {\n        size_t value_start;\n        size_t value_len;\n        bool quoted; /* Only mark as \"quoted\" if backslash-escape used */\n\n        mhd_log_state(\"token_matched\", str, str_len, i, p, tk_name->len, left, \"matched token name\");\n\n        if (tk_name->len == left)\n        {\n          mhd_log_state(\"no_equal_after\", str, str_len, i, p, tk_name->len, left, \"no '=' after name\");\n          return false; /* No equal sign after parameter name, broken data */\n        }\n\n        quoted = false;\n        i += tk_name->len;\n        /* Skip all whitespaces before '=' */\n        while (str_len > i && (' ' == str[i] || '\\t' == str[i]))\n          i++;\n        if ((i == str_len) || ('=' != str[i]))\n        {\n          mhd_log_state(\"no_equal_found\", str, str_len, i, p, 0, 0, \"no '=' after token and ws\");\n          return false; /* No equal sign, broken data */\n        }\n        i++;\n        /* Skip all whitespaces after '=' */\n        while (str_len > i && (' ' == str[i] || '\\t' == str[i]))\n          i++;\n        if ((str_len > i) && ('\"' == str[i]))\n        { /* Value is in quotation marks */\n          i++; /* Advance after the opening quote */\n          value_start = i;\n          mhd_log_state(\"quoted_value_start\", str, str_len, i, p, value_start, 0, \"start quoted value scanning\");\n          while (str_len > i && '\"' != str[i])\n          {\n            if ('\\\\' == str[i])\n            {\n              i++;\n              quoted = true; /* Have escaped chars */\n            }\n            if (0 == str[i])\n            {\n              mhd_log_state(\"binary_zero_in_value\", str, str_len, i, p, value_start, 0, \"binary zero in quoted value\");\n              return false; /* Binary zero in parameter value */\n            }\n            i++;\n          }\n          if (str_len <= i)\n          {\n            mhd_log_state(\"no_closing_quote\", str, str_len, i, p, value_start, 0, \"quoted value not closed\");\n            return false; /* No closing quote */\n          }\n          mhd_assert ('\"' == str[i]);\n          value_len = i - value_start;\n          i++; /* Advance after the closing quote */\n          mhd_log_state(\"quoted_value_end\", str, str_len, i, p, value_start, value_len, \"finished quoted value\");\n        }\n        else\n        {\n          value_start = i;\n          mhd_log_state(\"unquoted_value_start\", str, str_len, i, p, value_start, 0, \"start unquoted value scanning\");\n          while (str_len > i && ',' != str[i] &&\n                 ' ' != str[i] && '\\t' != str[i] && ';' != str[i])\n          {\n            if (0 == str[i])\n            {\n              mhd_log_state(\"binary_zero_in_unquoted\", str, str_len, i, p, value_start, 0, \"binary zero in unquoted value\");\n              return false;  /* Binary zero in parameter value */\n            }\n            i++;\n          }\n          /* IMPORTANT PROBE: log position where loop stopped before checking ';' */\n          mhd_log_state(\"after_unquoted_scan\", str, str_len, i, p, value_start, (size_t)(i - value_start), \"stopped scanning unquoted value\");\n\n          if (';' == str[i])\n          {\n            /* Log that ';' was observed at i (only safe if i < str_len). */\n            mhd_log_state(\"semicolon_in_value\", str, str_len, i, p, value_start, (size_t)(i - value_start), \"found ';' in unquoted value -> error\");\n            return false;  /* Semicolon in parameter value */\n          }\n          value_len = i - value_start;\n        }\n        /* Skip all whitespaces after parameter value */\n        while (str_len > i && (' ' == str[i] || '\\t' == str[i]))\n          i++;\n        if ((str_len > i) && (',' != str[i]))\n        {\n          mhd_log_state(\"garbage_after_value\", str, str_len, i, p, 0, 0, \"garbage after parameter value\");\n          return false; /* Garbage after parameter value */\n        }\n\n        /* Have valid parameter name and value */\n        mhd_assert (! quoted || 0 != value_len);\n        param->value.str = str + value_start;\n        param->value.len = value_len;\n        param->quoted = quoted;\n\n        mhd_log_state(\"param_stored\", str, str_len, i, p, value_start, value_len, \"stored parameter\");\n\n        break; /* Found matching parameter name */\n      }\n    }\n    if (p == (sizeof(tk_names) / sizeof(tk_names[0])))\n    {\n      /* No matching parameter name */\n      mhd_log_state(\"no_token_match_enter\", str, str_len, i, (size_t)-1, 0, 0, \"scanning unknown token until ','\");\n      while (str_len > i && ',' != str[i])\n      {\n        if ((0 == str[i]) || (';' == str[i]))\n        {\n          mhd_log_state(\"invalid_char_in_unknown\", str, str_len, i, (size_t)-1, 0, 0, \"invalid char while scanning unknown token\");\n          return false; /* Not allowed characters */\n        }\n        if ('\"' == str[i])\n        { /* Skip quoted part */\n          i++; /* Advance after the opening quote */\n          while (str_len > i && '\"' != str[i])\n          {\n            if (0 == str[i])\n            {\n              mhd_log_state(\"binary_zero_in_unknown_quoted\", str, str_len, i, (size_t)-1, 0, 0, \"binary zero in unknown quoted part\");\n              return false;  /* Binary zero is not allowed */\n            }\n            if ('\\\\' == str[i])\n              i++;           /* Skip escaped char */\n            i++;\n          }\n          if (str_len <= i)\n          {\n            mhd_log_state(\"no_closing_quote_in_unknown\", str, str_len, i, (size_t)-1, 0, 0, \"no closing quote in unknown token\");\n            return false; /* No closing quote */\n          }\n          mhd_assert ('\"' == str[i]);\n        }\n        i++;\n      }\n      mhd_log_state(\"no_token_match_exit\", str, str_len, i, (size_t)-1, 0, 0, \"finished scanning unknown token\");\n    }\n    mhd_assert (str_len == i || ',' == str[i]);\n    if (str_len > i)\n    {\n      mhd_log_state(\"comma_advance\", str, str_len, i, (size_t)-1, 0, 0, \"advancing past comma\");\n      i++; /* Advance after ',' */\n    }\n    /* Skip all whitespaces before next parameter name */\n    while (i < str_len && (' ' == str[i] || '\\t' == str[i]))\n      i++;\n    mhd_log_state(\"iteration_end\", str, str_len, i, (size_t)-1, 0, 0, \"end of outer while iteration\");\n  }\n\n  mhd_log_state(\"post_loop\", str, str_len, i, (size_t)-1, 0, 0, \"entered postprocess values\");\n\n  /* Postprocess values */\n\n  if (NULL != userhash.value.str)\n  {\n    if (userhash.quoted)\n      pdauth->userhash =\n        MHD_str_equal_caseless_quoted_s_bin_n (userhash.value.str, \\\n                                               userhash.value.len, \\\n                                               \"true\");\n    else\n      pdauth->userhash =\n        MHD_str_equal_caseless_s_bin_n_ (\"true\", userhash.value.str, \\\n                                         userhash.value.len);\n\n    mhd_log_state(\"userhash_set\", str, str_len, i, (size_t)-1, (size_t)userhash.value.len, (size_t)(userhash.quoted ? 1 : 0), \"userhash postprocessed\");\n  }\n  else\n  {\n    pdauth->userhash = false;\n    mhd_log_state(\"userhash_unset\", str, str_len, i, (size_t)-1, 0, 0, \"userhash not present\");\n  }\n\n  pdauth->algo3 = get_rq_dauth_algo (&algorithm);\n  pdauth->qop = get_rq_dauth_qop (&pdauth->qop_raw);\n\n  mhd_log_state(\"function_exit\", str, str_len, i, (size_t)-1, 0, 0, \"returning true\");\n\n  return true;\n}\n"
}