{
  "user_message": "<misra_rule>\nMISRA C 2023 Rule 2.2 is: A project shall not contain dead code.\nAny operation that is executed but whose removal would not affect program behaviour constitutes dead code. Notes:\n1. The behaviour of an embedded sytem is often determined not just by the nature of its actions, but also by the time at which they occur.\n2. unreachable code is not dead code, as it cannot be executed.\n3.Initialization is not the same as an assignment operation and is therfore not a candidate for dead code.\n</misra_rule>\n\nAnother agent reported that the target code violated the Rule 2.2.\nHere is the comment from the agent.\n<violation scenario>\nIf the mhd_assert macro is defined as a no-op in normal/release builds (for example expanding to ((void)0) when assertions are disabled), the statement mhd_assert (' ' != str[i]); performs no observable action (at most reads str[i], which has no side\u2011effects for a non-volatile const char*). Removing that statement would not change program behaviour, so it constitutes dead code and therefore violates MISRA C 2023 Rule 2.2. (If, however, mhd_assert invokes runtime behaviour such as logging or aborting on failure, then the statement is not dead code.)\n</violation scenario>\n\nYour job is to insert logging code to capture the control flow and state information of the program.\nInsert logging code so that other agents can reproduce and get evidence for the violation scenario.\n<response format>\n- test_code: a modified parse_dauth_params code that contains useful probe functions that print useful logs to a file \"/tmp/logs/2452.txt\". The logs should contain the control path and state information of the violation scenario. If test code is not required to validate the scenario, you can leave this blank.\nHere are the constraints for the test code:\n- The test code MUST preserve the original logic of parse_dauth_params as much as possible.\nYou CAN just insert probe functions to the original code.\n- DO NOT introduce new violations to demonstrate your scenario.\n- The test code MUST be compilable and executable.\n- The test code MUST include line breaks.\n- You MUST NOT define the main function.\n- You MUST NOT define macros.\n</response format>\n<target_code>\nHere is the code of parse_dauth_params:\n```c\nstatic bool\nparse_dauth_params (const char *str,\n                    const size_t str_len,\n                    struct MHD_RqDAuth *pdauth)\n{\n  /* The tokens */\n  static const struct _MHD_cstr_w_len nonce_tk = _MHD_S_STR_W_LEN (\"nonce\");\n  static const struct _MHD_cstr_w_len opaque_tk = _MHD_S_STR_W_LEN (\"opaque\");\n  static const struct _MHD_cstr_w_len algorithm_tk =\n    _MHD_S_STR_W_LEN (\"algorithm\");\n  static const struct _MHD_cstr_w_len response_tk =\n    _MHD_S_STR_W_LEN (\"response\");\n  static const struct _MHD_cstr_w_len username_tk =\n    _MHD_S_STR_W_LEN (\"username\");\n  static const struct _MHD_cstr_w_len username_ext_tk =\n    _MHD_S_STR_W_LEN (\"username*\");\n  static const struct _MHD_cstr_w_len realm_tk = _MHD_S_STR_W_LEN (\"realm\");\n  static const struct _MHD_cstr_w_len uri_tk = _MHD_S_STR_W_LEN (\"uri\");\n  static const struct _MHD_cstr_w_len qop_tk = _MHD_S_STR_W_LEN (\"qop\");\n  static const struct _MHD_cstr_w_len cnonce_tk = _MHD_S_STR_W_LEN (\"cnonce\");\n  static const struct _MHD_cstr_w_len nc_tk = _MHD_S_STR_W_LEN (\"nc\");\n  static const struct _MHD_cstr_w_len userhash_tk =\n    _MHD_S_STR_W_LEN (\"userhash\");\n  /* The locally processed parameters */\n  struct MHD_RqDAuthParam userhash;\n  struct MHD_RqDAuthParam algorithm;\n  /* Indexes */\n  size_t i;\n  size_t p;\n  /* The list of the tokens.\n     The order of the elements matches the next array. */\n  static const struct _MHD_cstr_w_len *const tk_names[] = {\n    &nonce_tk,          /* 0 */\n    &opaque_tk,         /* 1 */\n    &algorithm_tk,      /* 2 */\n    &response_tk,       /* 3 */\n    &username_tk,       /* 4 */\n    &username_ext_tk,   /* 5 */\n    &realm_tk,          /* 6 */\n    &uri_tk,            /* 7 */\n    &qop_tk,            /* 8 */\n    &cnonce_tk,         /* 9 */\n    &nc_tk,             /* 10 */\n    &userhash_tk        /* 11 */\n  };\n  /* The list of the parameters.\n     The order of the elements matches the previous array. */\n  struct MHD_RqDAuthParam *params[sizeof(tk_names) / sizeof(tk_names[0])];\n\n  params[0 ] = &(pdauth->nonce);           /* 0 */\n  params[1 ] = &(pdauth->opaque);          /* 1 */\n  params[2 ] = &algorithm;                 /* 2 */\n  params[3 ] = &(pdauth->response);        /* 3 */\n  params[4 ] = &(pdauth->username);        /* 4 */\n  params[5 ] = &(pdauth->username_ext);    /* 5 */\n  params[6 ] = &(pdauth->realm);           /* 6 */\n  params[7 ] = &(pdauth->uri);             /* 7 */\n  params[8 ] = &(pdauth->qop_raw);         /* 8 */\n  params[9 ] = &(pdauth->cnonce);          /* 9 */\n  params[10] = &(pdauth->nc);              /* 10 */\n  params[11] = &userhash;                  /* 11 */\n\n  mhd_assert ((sizeof(tk_names) / sizeof(tk_names[0])) == \\\n              (sizeof(params) / sizeof(params[0])));\n  memset (&userhash, 0, sizeof(userhash));\n  memset (&algorithm, 0, sizeof(algorithm));\n  i = 0;\n\n  /* Skip all whitespaces at start */\n  while (i < str_len && (' ' == str[i] || '\\t' == str[i]))\n    i++;\n\n  while (str_len > i)\n  {\n    size_t left;\n    mhd_assert (' ' != str[i]);\n    mhd_assert ('\\t' != str[i]);\n\n    left = str_len - i;\n    if ('=' == str[i])\n      return false; /* The equal sign is not allowed as the first character */\n    for (p = 0; p < (sizeof(tk_names) / sizeof(tk_names[0])); ++p)\n    {\n      const struct _MHD_cstr_w_len *const tk_name = tk_names[p];\n      struct MHD_RqDAuthParam *const param = params[p];\n      if ( (tk_name->len <= left) &&\n           MHD_str_equal_caseless_bin_n_ (str + i, tk_name->str,\n                                          tk_name->len) &&\n           ((tk_name->len == left) ||\n            ('=' == str[i + tk_name->len]) ||\n            (' ' == str[i + tk_name->len]) ||\n            ('\\t' == str[i + tk_name->len]) ||\n            (',' == str[i + tk_name->len]) ||\n            (';' == str[i + tk_name->len])) )\n      {\n        size_t value_start;\n        size_t value_len;\n        bool quoted; /* Only mark as \"quoted\" if backslash-escape used */\n\n        if (tk_name->len == left)\n          return false; /* No equal sign after parameter name, broken data */\n\n        quoted = false;\n        i += tk_name->len;\n        /* Skip all whitespaces before '=' */\n        while (str_len > i && (' ' == str[i] || '\\t' == str[i]))\n          i++;\n        if ((i == str_len) || ('=' != str[i]))\n          return false; /* No equal sign, broken data */\n        i++;\n        /* Skip all whitespaces after '=' */\n        while (str_len > i && (' ' == str[i] || '\\t' == str[i]))\n          i++;\n        if ((str_len > i) && ('\"' == str[i]))\n        { /* Value is in quotation marks */\n          i++; /* Advance after the opening quote */\n          value_start = i;\n          while (str_len > i && '\"' != str[i])\n          {\n            if ('\\\\' == str[i])\n            {\n              i++;\n              quoted = true; /* Have escaped chars */\n            }\n            if (0 == str[i])\n              return false; /* Binary zero in parameter value */\n            i++;\n          }\n          if (str_len <= i)\n            return false; /* No closing quote */\n          mhd_assert ('\"' == str[i]);\n          value_len = i - value_start;\n          i++; /* Advance after the closing quote */\n        }\n        else\n        {\n          value_start = i;\n          while (str_len > i && ',' != str[i] &&\n                 ' ' != str[i] && '\\t' != str[i] && ';' != str[i])\n          {\n            if (0 == str[i])\n              return false;  /* Binary zero in parameter value */\n            i++;\n          }\n          if (';' == str[i])\n            return false;  /* Semicolon in parameter value */\n          value_len = i - value_start;\n        }\n        /* Skip all whitespaces after parameter value */\n        while (str_len > i && (' ' == str[i] || '\\t' == str[i]))\n          i++;\n        if ((str_len > i) && (',' != str[i]))\n          return false; /* Garbage after parameter value */\n\n        /* Have valid parameter name and value */\n        mhd_assert (! quoted || 0 != value_len);\n        param->value.str = str + value_start;\n        param->value.len = value_len;\n        param->quoted = quoted;\n\n        break; /* Found matching parameter name */\n      }\n    }\n    if (p == (sizeof(tk_names) / sizeof(tk_names[0])))\n    {\n      /* No matching parameter name */\n      while (str_len > i && ',' != str[i])\n      {\n        if ((0 == str[i]) || (';' == str[i]))\n          return false; /* Not allowed characters */\n        if ('\"' == str[i])\n        { /* Skip quoted part */\n          i++; /* Advance after the opening quote */\n          while (str_len > i && '\"' != str[i])\n          {\n            if (0 == str[i])\n              return false;  /* Binary zero is not allowed */\n            if ('\\\\' == str[i])\n              i++;           /* Skip escaped char */\n            i++;\n          }\n          if (str_len <= i)\n            return false; /* No closing quote */\n          mhd_assert ('\"' == str[i]);\n        }\n        i++;\n      }\n    }\n    mhd_assert (str_len == i || ',' == str[i]);\n    if (str_len > i)\n      i++; /* Advance after ',' */\n    /* Skip all whitespaces before next parameter name */\n    while (i < str_len && (' ' == str[i] || '\\t' == str[i]))\n      i++;\n  }\n\n  /* Postprocess values */\n\n  if (NULL != userhash.value.str)\n  {\n    if (userhash.quoted)\n      pdauth->userhash =\n        MHD_str_equal_caseless_quoted_s_bin_n (userhash.value.str, \\\n                                               userhash.value.len, \\\n                                               \"true\");\n    else\n      pdauth->userhash =\n        MHD_str_equal_caseless_s_bin_n_ (\"true\", userhash.value.str, \\\n                                         userhash.value.len);\n\n  }\n  else\n    pdauth->userhash = false;\n\n  pdauth->algo3 = get_rq_dauth_algo (&algorithm);\n  pdauth->qop = get_rq_dauth_qop (&pdauth->qop_raw);\n\n  return true;\n}\n```\n</target_code>\nPlease provide the modified parse_dauth_params code.\n",
  "test_code": "#include <stdio.h>\n#include <stdarg.h>\n#include <stddef.h>\n#include <stdbool.h>\n#include <string.h>\n\n/* Probe logging helper: append small diagnostic lines to the log file. */\nstatic void probe_log(const char *fmt, ...)\n{\n  FILE *f = fopen(\"/tmp/logs/2452.txt\", \"a\");\n  if (f == NULL)\n    return; /* If logging not available, do nothing to preserve original behaviour. */\n  va_list ap;\n  va_start(ap, fmt);\n  vfprintf(f, fmt, ap);\n  fputc('\\n', f);\n  va_end(ap);\n  fclose(f);\n}\n\nstatic bool\nparse_dauth_params (const char *str,\n                    const size_t str_len,\n                    struct MHD_RqDAuth *pdauth)\n{\n  /* The tokens */\n  static const struct _MHD_cstr_w_len nonce_tk = _MHD_S_STR_W_LEN (\"nonce\");\n  static const struct _MHD_cstr_w_len opaque_tk = _MHD_S_STR_W_LEN (\"opaque\");\n  static const struct _MHD_cstr_w_len algorithm_tk =\n    _MHD_S_STR_W_LEN (\"algorithm\");\n  static const struct _MHD_cstr_w_len response_tk =\n    _MHD_S_STR_W_LEN (\"response\");\n  static const struct _MHD_cstr_w_len username_tk =\n    _MHD_S_STR_W_LEN (\"username\");\n  static const struct _MHD_cstr_w_len username_ext_tk =\n    _MHD_S_STR_W_LEN (\"username*\");\n  static const struct _MHD_cstr_w_len realm_tk = _MHD_S_STR_W_LEN (\"realm\");\n  static const struct _MHD_cstr_w_len uri_tk = _MHD_S_STR_W_LEN (\"uri\");\n  static const struct _MHD_cstr_w_len qop_tk = _MHD_S_STR_W_LEN (\"qop\");\n  static const struct _MHD_cstr_w_len cnonce_tk = _MHD_S_STR_W_LEN (\"cnonce\");\n  static const struct _MHD_cstr_w_len nc_tk = _MHD_S_STR_W_LEN (\"nc\");\n  static const struct _MHD_cstr_w_len userhash_tk =\n    _MHD_S_STR_W_LEN (\"userhash\");\n  /* The locally processed parameters */\n  struct MHD_RqDAuthParam userhash;\n  struct MHD_RqDAuthParam algorithm;\n  /* Indexes */\n  size_t i;\n  size_t p;\n  /* The list of the tokens.\n     The order of the elements matches the next array. */\n  static const struct _MHD_cstr_w_len *const tk_names[] = {\n    &nonce_tk,          /* 0 */\n    &opaque_tk,         /* 1 */\n    &algorithm_tk,      /* 2 */\n    &response_tk,       /* 3 */\n    &username_tk,       /* 4 */\n    &username_ext_tk,   /* 5 */\n    &realm_tk,          /* 6 */\n    &uri_tk,            /* 7 */\n    &qop_tk,            /* 8 */\n    &cnonce_tk,         /* 9 */\n    &nc_tk,             /* 10 */\n    &userhash_tk        /* 11 */\n  };\n  /* The list of the parameters.\n     The order of the elements matches the previous array. */\n  struct MHD_RqDAuthParam *params[sizeof(tk_names) / sizeof(tk_names[0])];\n\n  params[0 ] = &(pdauth->nonce);           /* 0 */\n  params[1 ] = &(pdauth->opaque);          /* 1 */\n  params[2 ] = &algorithm;                 /* 2 */\n  params[3 ] = &(pdauth->response);        /* 3 */\n  params[4 ] = &(pdauth->username);        /* 4 */\n  params[5 ] = &(pdauth->username_ext);    /* 5 */\n  params[6 ] = &(pdauth->realm);           /* 6 */\n  params[7 ] = &(pdauth->uri);             /* 7 */\n  params[8 ] = &(pdauth->qop_raw);         /* 8 */\n  params[9 ] = &(pdauth->cnonce);          /* 9 */\n  params[10] = &(pdauth->nc);              /* 10 */\n  params[11] = &userhash;                  /* 11 */\n\n  mhd_assert ((sizeof(tk_names) / sizeof(tk_names[0])) == \\\n              (sizeof(params) / sizeof(params[0])));\n  memset (&userhash, 0, sizeof(userhash));\n  memset (&algorithm, 0, sizeof(algorithm));\n  i = 0;\n\n  /* Skip all whitespaces at start */\n  while (i < str_len && (' ' == str[i] || '\\t' == str[i]))\n    i++;\n\n  probe_log(\"parse_dauth_params: after initial whitespace skip: i=%zu str_len=%zu next_char=%02x\",\n            i, str_len, (unsigned)(i < str_len ? (unsigned char)str[i] : 0));\n\n  while (str_len > i)\n  {\n    size_t left;\n    /* Log the position and next character before the asserts. */\n    probe_log(\"loop_start: i=%zu left=%zu next_char=%02x\", i, (size_t)(str_len - i),\n              (unsigned)(i < str_len ? (unsigned char)str[i] : 0));\n\n    /* These assertions are the subject of the reported violation scenario.\n       Log the value observed so other agents can reproduce whether the\n       assertion is effectively a no-op (e.g. in release builds). */\n    probe_log(\"about_to_assert_space: char_at_i=%02x\", (unsigned)(i < str_len ? (unsigned char)str[i] : 0));\n    mhd_assert (' ' != str[i]);\n    probe_log(\"after_assert_space: char_at_i=%02x\", (unsigned)(i < str_len ? (unsigned char)str[i] : 0));\n\n    probe_log(\"about_to_assert_tab: char_at_i=%02x\", (unsigned)(i < str_len ? (unsigned char)str[i] : 0));\n    mhd_assert ('\\t' != str[i]);\n    probe_log(\"after_assert_tab: char_at_i=%02x\", (unsigned)(i < str_len ? (unsigned char)str[i] : 0));\n\n    left = str_len - i;\n    if ('=' == str[i])\n      return false; /* The equal sign is not allowed as the first character */\n    for (p = 0; p < (sizeof(tk_names) / sizeof(tk_names[0])); ++p)\n    {\n      const struct _MHD_cstr_w_len *const tk_name = tk_names[p];\n      struct MHD_RqDAuthParam *const param = params[p];\n      if ( (tk_name->len <= left) &&\n           MHD_str_equal_caseless_bin_n_ (str + i, tk_name->str,\n                                          tk_name->len) &&\n           ((tk_name->len == left) ||\n            ('=' == str[i + tk_name->len]) ||\n            (' ' == str[i + tk_name->len]) ||\n            ('\\t' == str[i + tk_name->len]) ||\n            (',' == str[i + tk_name->len]) ||\n            (';' == str[i + tk_name->len])) )\n      {\n        size_t value_start;\n        size_t value_len;\n        bool quoted; /* Only mark as \"quoted\" if backslash-escape used */\n\n        if (tk_name->len == left)\n          return false; /* No equal sign after parameter name, broken data */\n\n        quoted = false;\n        i += tk_name->len;\n        /* Skip all whitespaces before '=' */\n        while (str_len > i && (' ' == str[i] || '\\t' == str[i]))\n          i++;\n        if ((i == str_len) || ('=' != str[i]))\n          return false; /* No equal sign, broken data */\n        i++;\n        /* Skip all whitespaces after '=' */\n        while (str_len > i && (' ' == str[i] || '\\t' == str[i]))\n          i++;\n        if ((str_len > i) && ('\"' == str[i]))\n        { /* Value is in quotation marks */\n          i++; /* Advance after the opening quote */\n          value_start = i;\n          while (str_len > i && '\"' != str[i])\n          {\n            if ('\\\\' == str[i])\n            {\n              i++;\n              quoted = true; /* Have escaped chars */\n            }\n            if (0 == str[i])\n              return false; /* Binary zero in parameter value */\n            i++;\n          }\n          if (str_len <= i)\n            return false; /* No closing quote */\n          /* Log that we are just about to assert the closing quote. */\n          probe_log(\"about_to_assert_closing_quote: i=%zu char=%02x\", i,\n                    (unsigned)(i < str_len ? (unsigned char)str[i] : 0));\n          mhd_assert ('\"' == str[i]);\n          probe_log(\"after_assert_closing_quote: i=%zu char=%02x\", i,\n                    (unsigned)(i < str_len ? (unsigned char)str[i] : 0));\n          value_len = i - value_start;\n          i++; /* Advance after the closing quote */\n        }\n        else\n        {\n          value_start = i;\n          while (str_len > i && ',' != str[i] &&\n                 ' ' != str[i] && '\\t' != str[i] && ';' != str[i])\n          {\n            if (0 == str[i])\n              return false;  /* Binary zero in parameter value */\n            i++;\n          }\n          if (';' == str[i])\n            return false;  /* Semicolon in parameter value */\n          value_len = i - value_start;\n        }\n        /* Skip all whitespaces after parameter value */\n        while (str_len > i && (' ' == str[i] || '\\t' == str[i]))\n          i++;\n        if ((str_len > i) && (',' != str[i]))\n          return false; /* Garbage after parameter value */\n\n        /* Have valid parameter name and value */\n        /* Log parameter parse result for diagnostics. */\n        probe_log(\"param_parsed: token_index=%zu token_len=%zu value_start=%zu value_len=%zu quoted=%d next_char=%02x\",\n                  p, (size_t)tk_name->len, value_start, value_len, (int)quoted,\n                  (unsigned)(i < str_len ? (unsigned char)str[i] : 0));\n\n        mhd_assert (! quoted || 0 != value_len);\n\n        param->value.str = str + value_start;\n        param->value.len = value_len;\n        param->quoted = quoted;\n\n        break; /* Found matching parameter name */\n      }\n    }\n    if (p == (sizeof(tk_names) / sizeof(tk_names[0])))\n    {\n      /* No matching parameter name */\n      while (str_len > i && ',' != str[i])\n      {\n        if ((0 == str[i]) || (';' == str[i]))\n          return false; /* Not allowed characters */\n        if ('\"' == str[i])\n        { /* Skip quoted part */\n          i++; /* Advance after the opening quote */\n          while (str_len > i && '\"' != str[i])\n          {\n            if (0 == str[i])\n              return false;  /* Binary zero is not allowed */\n            if ('\\\\' == str[i])\n              i++;           /* Skip escaped char */\n            i++;\n          }\n          if (str_len <= i)\n            return false; /* No closing quote */\n          probe_log(\"about_to_assert_closing_quote_unmatched: i=%zu char=%02x\", i,\n                    (unsigned)(i < str_len ? (unsigned char)str[i] : 0));\n          mhd_assert ('\"' == str[i]);\n          probe_log(\"after_assert_closing_quote_unmatched: i=%zu char=%02x\", i,\n                    (unsigned)(i < str_len ? (unsigned char)str[i] : 0));\n        }\n        i++;\n      }\n    }\n    probe_log(\"about_to_assert_comma_or_end: i=%zu char=%02x\", i,\n              (unsigned)(i < str_len ? (unsigned char)str[i] : 0));\n    mhd_assert (str_len == i || ',' == str[i]);\n    probe_log(\"after_assert_comma_or_end: i=%zu char=%02x\", i,\n              (unsigned)(i < str_len ? (unsigned char)str[i] : 0));\n    if (str_len > i)\n      i++; /* Advance after ',' */\n    /* Skip all whitespaces before next parameter name */\n    while (i < str_len && (' ' == str[i] || '\\t' == str[i]))\n      i++;\n  }\n\n  /* Postprocess values */\n\n  if (NULL != userhash.value.str)\n  {\n    if (userhash.quoted)\n      pdauth->userhash =\n        MHD_str_equal_caseless_quoted_s_bin_n (userhash.value.str, \\\n                                               userhash.value.len, \\\n                                               \"true\");\n    else\n      pdauth->userhash =\n        MHD_str_equal_caseless_s_bin_n_ (\"true\", userhash.value.str, \\\n                                         userhash.value.len);\n\n  }\n  else\n    pdauth->userhash = false;\n\n  pdauth->algo3 = get_rq_dauth_algo (&algorithm);\n  pdauth->qop = get_rq_dauth_qop (&pdauth->qop_raw);\n\n  probe_log(\"parse_dauth_params: exit true: final_algo3=%d qop=%d userhash=%d\", (int)pdauth->algo3, (int)pdauth->qop, (int)pdauth->userhash);\n\n  return true;\n}\n"
}