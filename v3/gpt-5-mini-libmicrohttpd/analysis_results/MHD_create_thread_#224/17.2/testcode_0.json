{
  "user_message": "<misra_rule>\nMISRA C 2023 Rule 17.2 is: Functions shall not call themselves, either directly or indirectly.\n\n</misra_rule>\n\nAnother agent reported that the target code violated the Rule 17.2.\nHere is the comment from the agent.\n<violation scenario>\nIf the start_routine argument points to MHD_create_thread_ itself (or to any function that eventually calls MHD_create_thread_), then the call to pthread_create will result in the start_routine being invoked and thus MHD_create_thread_ will indirectly cause itself to be called. This creates an indirect recursion (MHD_create_thread_ -> pthread_create -> start_routine -> ... -> MHD_create_thread_), violating MISRA C 2023 Rule 17.2.\n</violation scenario>\n\nYour job is to insert logging code to capture the control flow and state information of the program.\nInsert logging code so that other agents can reproduce and get evidence for the violation scenario.\n<response format>\n- test_code: a modified MHD_create_thread_ code that contains useful probe functions that print useful logs to a file \"/tmp/logs/2246.txt\". The logs should contain the control path and state information of the violation scenario. If test code is not required to validate the scenario, you can leave this blank.\nHere are the constraints for the test code:\n- The test code MUST preserve the original logic of MHD_create_thread_ as much as possible.\nYou CAN just insert probe functions to the original code.\n- DO NOT introduce new violations to demonstrate your scenario.\n- The test code MUST be compilable and executable.\n- The test code MUST include line breaks.\n- You MUST NOT define the main function.\n- You MUST NOT define macros.\n</response format>\n<target_code>\nHere is the code of MHD_create_thread_:\n```c\nint\nMHD_create_thread_ (MHD_thread_handle_ID_ *handle_id,\n                    size_t stack_size,\n                    MHD_THREAD_START_ROUTINE_ start_routine,\n                    void *arg)\n{\n#if defined(MHD_USE_POSIX_THREADS)\n  int res;\n#if defined(MHD_thread_handle_ID_get_native_handle_ptr_)\n  pthread_t *const new_tid_ptr =\n    MHD_thread_handle_ID_get_native_handle_ptr_ (handle_id);\n#else  /* ! MHD_thread_handle_ID_get_native_handle_ptr_ */\n  pthread_t new_tid;\n  pthread_t *const new_tid_ptr = &new_tid;\n#endif /* ! MHD_thread_handle_ID_get_native_handle_ptr_ */\n\n  mhd_assert (! MHD_thread_handle_ID_is_valid_handle_ (*handle_id));\n\n  if (0 != stack_size)\n  {\n    pthread_attr_t attr;\n    res = pthread_attr_init (&attr);\n    if (0 == res)\n    {\n      res = pthread_attr_setstacksize (&attr,\n                                       stack_size);\n      if (0 == res)\n        res = pthread_create (new_tid_ptr,\n                              &attr,\n                              start_routine,\n                              arg);\n      pthread_attr_destroy (&attr);\n    }\n  }\n  else\n    res = pthread_create (new_tid_ptr,\n                          NULL,\n                          start_routine,\n                          arg);\n\n  if (0 != res)\n  {\n    errno = res;\n    MHD_thread_handle_ID_set_invalid_ (handle_id);\n  }\n#if ! defined(MHD_thread_handle_ID_get_native_handle_ptr_)\n  else\n    MHD_thread_handle_ID_set_native_handle_ (handle_id, new_tid);\n#endif /* ! MHD_thread_handle_ID_set_current_thread_ID_ */\n\n  return ! res;\n#elif defined(MHD_USE_W32_THREADS)\n  uintptr_t thr_handle;\n#if SIZEOF_SIZE_T != SIZEOF_UNSIGNED_INT\n\n  mhd_assert (! MHD_thread_handle_ID_is_valid_handle_ (*handle_id));\n\n  if (stack_size > UINT_MAX)\n  {\n    errno = EINVAL;\n    return 0;\n  }\n#endif /* SIZEOF_SIZE_T != SIZEOF_UNSIGNED_INT */\n  thr_handle = (uintptr_t) _beginthreadex (NULL,\n                                           (unsigned int) stack_size,\n                                           start_routine,\n                                           arg,\n                                           0,\n                                           NULL);\n  if ((MHD_thread_handle_native_) 0 == (MHD_thread_handle_native_) thr_handle)\n    return 0;\n\n  MHD_thread_handle_ID_set_native_handle_ (handle_id, \\\n                                           (MHD_thread_handle_native_) \\\n                                           thr_handle);\n\n  return ! 0;\n#endif\n}\n```\n</target_code>\nPlease provide the modified MHD_create_thread_ code.\n",
  "test_code": "#include <stdio.h>\n#include <stdarg.h>\n#include <stdlib.h>\n#include <stdint.h>\n#include <errno.h>\n#include <pthread.h>\n#include <unistd.h>\n\n/* Probe/logging helpers */\nstatic void mhd_log_probe(const char *fmt, ...)\n{\n  FILE *f = fopen(\"/tmp/logs/2246.txt\", \"a\");\n  if (NULL == f)\n    return;\n\n  /* timestamp + pid + thread id to help correlate events */\n  pid_t pid = getpid();\n  uintptr_t tid = (uintptr_t) pthread_self();\n\n  fprintf(f, \"[%ld][tid=%lu] \", (long) pid, (unsigned long) tid);\n\n  va_list ap;\n  va_start(ap, fmt);\n  vfprintf(f, fmt, ap);\n  va_end(ap);\n\n  fprintf(f, \"\\n\");\n  fclose(f);\n}\n\n/* Wrapper used to intercept thread start and record when the thread begins\n   and what start routine it will call. We allocate a small struct to hold\n   the original start pointer + argument. This preserves original semantics\n   except for adding the logging calls. If allocation fails we fall back to\n   calling pthread_create with the original start_routine. */\nstruct mhd_start_wrapper_info\n{\n  void *(*real_start)(void *);\n  void *real_arg;\n};\n\nstatic void *mhd_thread_start_wrapper(void *wrapper_arg)\n{\n  struct mhd_start_wrapper_info *wi = (struct mhd_start_wrapper_info *) wrapper_arg;\n  if (wi == NULL)\n  {\n    mhd_log_probe(\"thread wrapper: received NULL wrapper_arg\");\n    return NULL;\n  }\n\n  mhd_log_probe(\"thread wrapper start: real_start=%p real_arg=%p\", (void *) wi->real_start, wi->real_arg);\n\n  /* Call the real start routine and capture its return value to log. */\n  void *ret = wi->real_start(wi->real_arg);\n\n  mhd_log_probe(\"thread wrapper end: real_start=%p returned=%p\", (void *) wi->real_start, ret);\n\n  /* Free the wrapper info allocated in the creating thread. */\n  free(wi);\n  return ret;\n}\n\nint\nMHD_create_thread_ (MHD_thread_handle_ID_ *handle_id,\n                    size_t stack_size,\n                    MHD_THREAD_START_ROUTINE_ start_routine,\n                    void *arg)\n{\n#if defined(MHD_USE_POSIX_THREADS)\n  int res;\n#if defined(MHD_thread_handle_ID_get_native_handle_ptr_)\n  pthread_t *const new_tid_ptr =\n    MHD_thread_handle_ID_get_native_handle_ptr_ (handle_id);\n#else  /* ! MHD_thread_handle_ID_get_native_handle_ptr_ */\n  pthread_t new_tid;\n  pthread_t *const new_tid_ptr = &new_tid;\n#endif /* ! MHD_thread_handle_ID_get_native_handle_ptr_ */\n\n  /* Log entry and parameters */\n  mhd_log_probe(\"MHD_create_thread_ entry: handle_id=%p stack_size=%zu start_routine=%p arg=%p\",\n                (void *) handle_id, stack_size, (void *) start_routine, arg);\n\n  mhd_assert (! MHD_thread_handle_ID_is_valid_handle_ (*handle_id));\n\n  if (0 != stack_size)\n  {\n    pthread_attr_t attr;\n    mhd_log_probe(\"initializing pthread_attr for stack_size=%zu\", stack_size);\n    res = pthread_attr_init (&attr);\n    if (0 == res)\n    {\n      res = pthread_attr_setstacksize (&attr,\n                                       stack_size);\n      mhd_log_probe(\"pthread_attr_setstacksize returned %d\", res);\n      if (0 == res)\n      {\n        /* Try to allocate wrapper info to intercept thread entry. If allocation\n           fails, fall back to calling pthread_create with the original\n           start_routine (preserves original behavior). */\n        struct mhd_start_wrapper_info *wi = (struct mhd_start_wrapper_info *) malloc(sizeof(*wi));\n        if (wi != NULL)\n        {\n          wi->real_start = (void *(*)(void *)) start_routine;\n          wi->real_arg = arg;\n\n          mhd_log_probe(\"calling pthread_create (with wrapper): new_tid_ptr=%p attr=%p wrapper=%p original_start=%p original_arg=%p\",\n                        (void *) new_tid_ptr, (void *) &attr, (void *) mhd_thread_start_wrapper,\n                        (void *) start_routine, arg);\n\n          res = pthread_create (new_tid_ptr,\n                                &attr,\n                                mhd_thread_start_wrapper,\n                                wi);\n\n          if (0 != res)\n          {\n            /* creation failed, free the wrapper info to avoid leak */\n            free(wi);\n          }\n        }\n        else\n        {\n          mhd_log_probe(\"malloc for wrapper_info failed, calling pthread_create without wrapper\");\n          res = pthread_create (new_tid_ptr,\n                                &attr,\n                                start_routine,\n                                arg);\n        }\n      }\n      pthread_attr_destroy (&attr);\n    }\n    else\n    {\n      mhd_log_probe(\"pthread_attr_init failed: %d\", res);\n    }\n  }\n  else\n  {\n    /* No stack attr path. Try to use wrapper as above. */\n    struct mhd_start_wrapper_info *wi = (struct mhd_start_wrapper_info *) malloc(sizeof(*wi));\n    if (wi != NULL)\n    {\n      wi->real_start = (void *(*)(void *)) start_routine;\n      wi->real_arg = arg;\n\n      mhd_log_probe(\"calling pthread_create (no attr) with wrapper: new_tid_ptr=%p wrapper=%p original_start=%p original_arg=%p\",\n                    (void *) new_tid_ptr, (void *) mhd_thread_start_wrapper,\n                    (void *) start_routine, arg);\n\n      res = pthread_create (new_tid_ptr,\n                            NULL,\n                            mhd_thread_start_wrapper,\n                            wi);\n\n      if (0 != res)\n      {\n        free(wi);\n      }\n    }\n    else\n    {\n      mhd_log_probe(\"malloc for wrapper_info failed (no attr), calling pthread_create without wrapper\");\n      res = pthread_create (new_tid_ptr,\n                            NULL,\n                            start_routine,\n                            arg);\n    }\n  }\n\n  if (0 != res)\n  {\n    errno = res;\n    mhd_log_probe(\"pthread_create failed: %d (errno set to %d)\", res, errno);\n    MHD_thread_handle_ID_set_invalid_ (handle_id);\n  }\n#if ! defined(MHD_thread_handle_ID_get_native_handle_ptr_)\n  else\n    MHD_thread_handle_ID_set_native_handle_ (handle_id, new_tid);\n#endif /* ! MHD_thread_handle_ID_set_current_thread_ID_ */\n\n  mhd_log_probe(\"MHD_create_thread_ exit: return=%d\", !res);\n  return ! res;\n#elif defined(MHD_USE_W32_THREADS)\n  uintptr_t thr_handle;\n#if SIZEOF_SIZE_T != SIZEOF_UNSIGNED_INT\n\n  mhd_assert (! MHD_thread_handle_ID_is_valid_handle_ (*handle_id));\n\n  if (stack_size > UINT_MAX)\n  {\n    errno = EINVAL;\n    return 0;\n  }\n#endif /* SIZEOF_SIZE_T != SIZEOF_UNSIGNED_INT */\n\n  mhd_log_probe(\"creating W32 thread: start_routine=%p arg=%p stack_size=%zu\", (void *) start_routine, arg, stack_size);\n\n  thr_handle = (uintptr_t) _beginthreadex (NULL,\n                                           (unsigned int) stack_size,\n                                           start_routine,\n                                           arg,\n                                           0,\n                                           NULL);\n  if ((MHD_thread_handle_native_) 0 == (MHD_thread_handle_native_) thr_handle)\n  {\n    mhd_log_probe(\"_beginthreadex failed, thr_handle==0\");\n    return 0;\n  }\n\n  MHD_thread_handle_ID_set_native_handle_ (handle_id, \\\n                                           (MHD_thread_handle_native_) \\\n                                           thr_handle);\n\n  mhd_log_probe(\"W32 thread created: thr_handle=%p\", (void *) (uintptr_t) thr_handle);\n\n  return ! 0;\n#endif\n}\n"
}