{
  "user_message": "An agent A claimed that the following compress_buf code violates the MISRA C 2023 rule 21.17.\n<misra_rule>\nMISRA C 2023 Rule 21.17 is Use of the string handling functions from <string.h> shall not result in accesses beyond the bounds of the objects referenced by their pointer parameters.\nThis rule strictly applies to the Standard Library functions in <string.h> such as memcpy, memmove, memset, memcmp, strcpy, strncpy, strcat, strncat, strlen, and strspn.\n</misra_rule>\n<target_code>\nHere is the original code of compress_buf.\n```c\nstatic enum MHD_Result\ncompress_buf (z_stream *strm, const void *src, size_t src_size, size_t *offset,\n              void **dest, size_t *dest_size,\n              void *tmp)\n{\n  unsigned int have;\n  enum MHD_Result ret;\n  int flush;\n  void *tmp_dest;\n  *dest = NULL;\n  *dest_size = 0;\n  do\n  {\n    if (src_size > CHUNK)\n    {\n      strm->avail_in = CHUNK;\n      src_size -= CHUNK;\n      flush = Z_NO_FLUSH;\n    }\n    else\n    {\n      strm->avail_in = (uInt) src_size;\n      flush = Z_SYNC_FLUSH;\n    }\n    *offset += strm->avail_in;\n    strm->next_in = (const Bytef *) src;\n    do\n    {\n      strm->avail_out = CHUNK;\n      strm->next_out = tmp;\n      ret = (Z_OK == deflate (strm, flush)) ? MHD_YES : MHD_NO;\n      have = CHUNK - strm->avail_out;\n      *dest_size += have;\n      tmp_dest = realloc (*dest, *dest_size);\n      if (NULL == tmp_dest)\n      {\n        free (*dest);\n        *dest = NULL;\n        return MHD_NO;\n      }\n      *dest = tmp_dest;\n      memcpy (((uint8_t *) (*dest)) + ((*dest_size) - have), tmp, have);\n    }\n    while (0 == strm->avail_out);\n  }\n  while (flush != Z_SYNC_FLUSH);\n  return ret;\n}\n```\n</target_code>\n<response format>\nProvide your answer with these fields.\n- explanation: your evaluation of the scenario provided by the agent A.\n- is_report_correct: whether the report is correct or not (true/false). True means there is a violation.\n</response format>\n<scenario>\nThe agent A provided the following violation scenario:\nThe memcpy can read or write beyond the bounds if assumptions about sizes are violated. Specific violation scenarios:\n1) If the source temp buffer tmp is smaller than the number of bytes copied (have). In the loop have is computed from the compressor (have = CHUNK - strm->avail_out). If the caller passed a tmp buffer smaller than have (e.g. tmp not CHUNK bytes), memcpy(((uint8_t *)(*dest)) + (*dest_size - have), tmp, have) will read beyond tmp.\n2) If the size arithmetic *dest_size += have overflows (e.g. *dest_size was close to SIZE_MAX), the resulting value passed to realloc may be much smaller than the true required size and memcpy will write past the allocated block.\nBecause the fragment does not itself guarantee tmp\u2019s length nor check for addition overflow, it can violate MISRA C 2023 Rule 21.17.\n</scenario>\n\n<instruction>\nJudge whether the report is correct or not.\n</instruction>\n",
  "is_report_correct": true,
  "explanation": "Agent A is correct. The memcpy call can result in out-of-bounds accesses under realistic failure/usage scenarios and the function does not guard against them, so it violates MISRA C 2023 Rule 21.17.\n\nTwo concrete issues shown by the agent A scenario:\n1) tmp length assumption: The code sets strm->avail_out = CHUNK and strm->next_out = tmp, and later uses have = CHUNK - strm->avail_out and memcpy(tmp ->dest, tmp, have). That sequence implicitly assumes the caller supplied tmp with at least CHUNK bytes (so that deflate can write up to CHUNK and memcpy can read have bytes). The function does not check or document the length of tmp itself; if tmp is smaller than have, memcpy will read beyond the source buffer.\n2) size overflow / realloc sizing: The code does *dest_size += have and immediately calls realloc(*dest, *dest_size). If the addition overflows (e.g. *dest_size was close to SIZE_MAX), the wrapped value passed to realloc can be smaller than the true required size, and the subsequent memcpy(((uint8_t *)(*dest)) + ((*dest_size) - have), tmp, have) may write past the allocated destination buffer. No checks for addition overflow or allocation size are performed.\n\nBoth scenarios are exactly the kinds of out-of-bounds accesses Rule 21.17 forbids for uses of memcpy. To remediate, the function must ensure (or be given and checked) the source buffer length for tmp and must check for addition overflow (e.g. ensure SIZE_MAX - *dest_size >= have before adding and reallocating) and verify realloc succeeded with adequate size before calling memcpy."
}