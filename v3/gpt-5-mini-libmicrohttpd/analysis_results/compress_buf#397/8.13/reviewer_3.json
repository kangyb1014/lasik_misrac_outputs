{
  "user_message": "An agent A claimed that the following compress_buf code violates the MISRA C 2023 rule 8.13.\n<misra_rule>\nMISRA C 2023 Rule 8.13 is A pointer should point to a const-qualified type whenever possible.\n\n</misra_rule>\n<target_code>\nHere is the original code of compress_buf.\n```c\nstatic enum MHD_Result\ncompress_buf (z_stream *strm, const void *src, size_t src_size, size_t *offset,\n              void **dest, size_t *dest_size,\n              void *tmp)\n{\n  unsigned int have;\n  enum MHD_Result ret;\n  int flush;\n  void *tmp_dest;\n  *dest = NULL;\n  *dest_size = 0;\n  do\n  {\n    if (src_size > CHUNK)\n    {\n      strm->avail_in = CHUNK;\n      src_size -= CHUNK;\n      flush = Z_NO_FLUSH;\n    }\n    else\n    {\n      strm->avail_in = (uInt) src_size;\n      flush = Z_SYNC_FLUSH;\n    }\n    *offset += strm->avail_in;\n    strm->next_in = (const Bytef *) src;\n    do\n    {\n      strm->avail_out = CHUNK;\n      strm->next_out = tmp;\n      ret = (Z_OK == deflate (strm, flush)) ? MHD_YES : MHD_NO;\n      have = CHUNK - strm->avail_out;\n      *dest_size += have;\n      tmp_dest = realloc (*dest, *dest_size);\n      if (NULL == tmp_dest)\n      {\n        free (*dest);\n        *dest = NULL;\n        return MHD_NO;\n      }\n      *dest = tmp_dest;\n      memcpy (((uint8_t *) (*dest)) + ((*dest_size) - have), tmp, have);\n    }\n    while (0 == strm->avail_out);\n  }\n  while (flush != Z_SYNC_FLUSH);\n  return ret;\n}\n```\n</target_code>\n<response format>\nProvide your answer with these fields.\n- explanation: your evaluation of the scenario provided by the agent A.\n- is_report_correct: whether the report is correct or not (true/false). True means there is a violation.\n</response format>\n<scenario>\nThe agent A provided the following violation scenario:\nViolation: strm->next_in is a non-const pointer (Bytef *). The code assigns a const-qualified source (const void *src cast to const Bytef *) into that non-const member, effectively discarding the const qualifier. This contradicts MISRA C 2023 Rule 8.13 which requires pointers to point to const-qualified types when possible.\n</scenario>\n\n<instruction>\nJudge whether the report is correct or not.\n</instruction>\n",
  "is_report_correct": true,
  "explanation": "Agent A is correct. The zlib stream member next_in is declared as a non-const pointer (Bytef *). In the code the source buffer is const (const void *src) and is cast to const Bytef * and then assigned to strm->next_in, which results in discarding the const qualifier when stored in the non-const member. MISRA C 2023 Rule 8.13 requires pointers to point to const-qualified types whenever possible (i.e. if the data is not modified through the pointer it should be pointed-to via a const-qualified pointer). Assigning a const-qualified pointer into a non-const pointer violates that intent. Note: this is often encountered when interfacing with external APIs (zlib uses a non-const next_in), in which case a documented deviation or a const-correct wrapper is the usual remedial approach, but absent such justification the code does violate Rule 8.13."
}