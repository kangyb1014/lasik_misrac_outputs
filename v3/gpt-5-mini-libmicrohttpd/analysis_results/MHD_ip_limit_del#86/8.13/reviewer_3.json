{
  "user_message": "An agent A claimed that the following MHD_ip_limit_del code violates the MISRA C 2023 rule 8.13.\n<misra_rule>\nMISRA C 2023 Rule 8.13 is A pointer should point to a const-qualified type whenever possible.\n\n</misra_rule>\n<target_code>\nHere is the original code of MHD_ip_limit_del.\n```c\nstatic void\nMHD_ip_limit_del (struct MHD_Daemon *daemon,\n                  const struct sockaddr_storage *addr,\n                  socklen_t addrlen)\n{\n  struct MHD_IPCount search_key;\n  struct MHD_IPCount *found_key;\n  void **nodep;\n\n  daemon = MHD_get_master (daemon);\n  /* Ignore if no connection limit assigned */\n  if (0 == daemon->per_ip_connection_limit)\n    return;\n  /* Initialize search key */\n  if (MHD_NO == MHD_ip_addr_to_key (addr,\n                                    addrlen,\n                                    &search_key))\n    return;\n\n  MHD_ip_count_lock (daemon);\n\n  /* Search for the IP address */\n  if (NULL == (nodep = tfind (&search_key,\n                              &daemon->per_ip_connection_count,\n                              &MHD_ip_addr_compare)))\n  {\n    /* Something's wrong if we couldn't find an IP address\n     * that was previously added */\n    MHD_PANIC (_ (\"Failed to find previously-added IP address.\\n\"));\n  }\n  found_key = (struct MHD_IPCount *) *nodep;\n  /* Validate existing count for IP address */\n  if (0 == found_key->count)\n  {\n    MHD_PANIC (_ (\"Previously-added IP address had counter of zero.\\n\"));\n  }\n  /* Remove the node entirely if count reduces to 0 */\n  if (0 == --found_key->count)\n  {\n    tdelete (found_key,\n             &daemon->per_ip_connection_count,\n             &MHD_ip_addr_compare);\n    MHD_ip_count_unlock (daemon);\n    free (found_key);\n  }\n  else\n    MHD_ip_count_unlock (daemon);\n}\n```\n</target_code>\n<response format>\nProvide your answer with these fields.\n- explanation: your evaluation of the scenario provided by the agent A.\n- is_report_correct: whether the report is correct or not (true/false). True means there is a violation.\n</response format>\n<scenario>\nThe agent A provided the following violation scenario:\nThe local variable nodep is declared as \"void **nodep\" but it is only used to read the stored pointer returned by tfind (it is assigned from tfind and dereferenced only to read *nodep). Since *nodep is not modified through nodep, the pointed-to type could be const-qualified (e.g. declare as \"void * const *nodep\"). Therefore this use violates MISRA C 2023 Rule 8.13.\n</scenario>\n\n<execution_log>\nThe agent A also provided the following output log:\n[2025-08-26 08:12:14] enter MHD_ip_limit_del: daemon_in=0x55d612d848d0 addr=0x55d612d85430 addrlen=16\n[2025-08-26 08:12:14] after MHD_get_master: daemon=0x55d612d848d0 per_ip_connection_limit=0\n[2025-08-26 08:12:14] no per-ip limit (0) -> return\n[2025-08-26 08:12:14] enter MHD_ip_limit_del: daemon_in=0x55d612d848d0 addr=0x55d612d85430 addrlen=16\n[2025-08-26 08:12:14] after MHD_get_master: daemon=0x55d612d848d0 per_ip_connection_limit=0\n[2025-08-26 08:12:14] no per-ip limit (0) -> return\n[2025-08-26 08:12:14] enter MHD_ip_limit_del: daemon_in=0x55d612d848d0 addr=0x55d612d85430 addrlen=16\n[2025-08-26 08:12:14] after MHD_get_master: daemon=0x55d612d848d0 per_ip_connection_limit=0\n[2025-08-26 08:12:14] no per-ip limit (0) -> return\n[2025-08-26 08:12:14] enter MHD_ip_limit_del: daemon_in=0x55d612d848d0 addr=0x55d612d85430 addrlen=16\n[2025-08-26 08:12:14] after MHD_get_master: daemon=0x55d612d848d0 per_ip_connection_limit=0\n[2025-08-26 08:12:14] no per-ip limit (0) -> return\n[2025-08-26 08:12:14] enter MHD_ip_limit_del: daemon_in=0x55d612d848d0 addr=0x55d612d85430 addrlen=16\n[2025-08-26 08:12:14] after MHD_get_master: daemon=0x55d612d848d0 per_ip_connection_limit=0\n[2025-08-26 08:12:14] no per-ip limit (0) -> return\n[2025-08-26 08:12:14] enter MHD_ip_limit_del: daemon_in=0x55d612d848d0 addr=0x55d612d85430 addrlen=16\n[2025-08-26 08:12:14] after MHD_get_master: daemon=0x55d612d848d0 per_ip_connection_limit=0\n[2025-08-26 08:12:14] no per-ip limit (0) -> return\n[2025-08-26 08:12:14] enter MHD_ip_limit_del: daemon_in=0x55d612d848d0 addr=0x55d612d85430 addrlen=16\n[2025-08-26 08:12:14] after MHD_get_master: daemon=0x55d612d848d0 per_ip_connection_limit=0\n[2025-08-26 08:12:14] no per-ip limit (0) -> return\n[2025-08-26 08:12:14] enter MHD_ip_limit_del: daemon_in=0x55d612d848d0 addr=0x55d612d85430 addrlen=16\n[2025-08-26 08:12:14] after MHD_get_master: daemon=0x55d612d848d0 per_ip_connection_limit=0\n[2025-08-26 08:12:14] no per-ip limit (0) -> return\n[2025-08-26 08:12:14] enter MHD_ip_limit_del: daemon_in=0x55d612d848d0 addr=0x55d612d85430 addrlen=16\n[2025-08-26 08:12:14] after MHD_get_master: daemon=0x55d612d848d0 per_ip_connection_limit=0\n[2025-08-26 08:12:14] no per-ip limit (0) -> return\n[2025-08-26 08:12:14] enter MHD_ip_limit_del: daemon_in=0x55d612d848d0 addr=0x55d612d85430 addrlen=16\n[2025-08-26 08:12:14] after MHD_get_master: daemon=0x55d612d848d0 per_ip_connection_limit=0\n[2025-08-26 08:12:14] no per-ip limit (0) -> return\n[2025-08-26 08:12:14] enter MHD_ip_limit_del: daemon_in=0x55d612d848d0 addr=0x55d612d85430 addrlen=16\n[2025-08-26 08:12:14] after MHD_get_master: daemon=0x55d612d848d0 per_ip_connection_limit=0\n[2025-08-26 08:12:14] no per-ip limit (0) -> return\n[2025-08-26 08:12:14] enter MHD_ip_limit_del: daemon_in=0x55d612d848d0 addr=0x55d612d85430 addrlen=16\n[2025-08-26 08:12:14] after MHD_get_master: daemon=0x55d612d848d0 per_ip_connection_limit=0\n[2025-08-26 08:12:14] no per-ip limit (0) -> return\n[2025-08-26 08:12:14] enter MHD_ip_limit_del: daemon_in=0x55d612d848d0 addr=0x55d612d85430 addrlen=16\n[2025-08-26 08:12:14] after MHD_get_master: daemon=0x55d612d848d0 per_ip_connection_limit=0\n[2025-08-26 08:12:14] no per-ip limit (0) -> return\n[2025-08-26 08:12:14] enter MHD_ip_limit_del: daemon_in=0x55d612d848d0 addr=0x55d612d85430 addrlen=16\n[2025-08-26 08:12:14] after MHD_get_master: daemon=0x55d612d848d0 per_ip_connection_limit=0\n[2025-08-26 08:12:14] no per-ip limit (0) -> return\n[2025-08-26 08:12:14] enter MHD_ip_limit_del: daemon_in=0x55d612d848d0 addr=0x55d612d85430 addrlen=16\n[2025-08-26 08:12:14] after MHD_get_master: daemon=0x55d612d848d0 per_ip_connection_limit=0\n[2025-08-26 08:12:14] no per-ip limit (0) -> return\n[2025-08-26 08:12:14] enter MHD_ip_limit_del: daemon_in=0x55d612d848d0 addr=0x55d612d85430 addrlen=16\n[2025-08-26 08:12:14] after MHD_get_master: daemon=0x55d612d848d0 per_ip_connection_limit=0\n[2025-08-26 08:12:14] no per-ip limit (0) -> return\n[2025-08-26 08:12:14] enter MHD_ip_limit_del: daemon_in=0x55d612d848d0 addr=0x55d612d85430 addrlen=16\n[2025-08-26 08:12:14] after MHD_get_master: daemon=0x55d61\n</execution_log>\n\n<instruction>\nJudge whether the report is correct or not.\n</instruction>\n",
  "is_report_correct": true,
  "explanation": "Correct. MISRA C:2023 R8.13 requires that pointers should point to const-qualified types when modification through that pointer is not required. In MHD_ip_limit_del the local variable nodep is declared as void ** but it is only used to read the pointer stored in the tree (it is assigned from tfind and then dereferenced to obtain *nodep, which is not modified). That means the object pointed-to by nodep (i.e. the stored pointer) is not changed via nodep and therefore the pointed-to type could and should be const-qualified (for example: void * const *nodep, or another appropriate const variant depending on intended constness of the pointed data). Declaring nodep as a pointer to a const-qualified type would satisfy R8.13. (If the external tfind prototype prevents a direct change without an explicit cast, that is an interoperability issue, but it does not negate that the existing declaration fails to follow R8.13.)"
}