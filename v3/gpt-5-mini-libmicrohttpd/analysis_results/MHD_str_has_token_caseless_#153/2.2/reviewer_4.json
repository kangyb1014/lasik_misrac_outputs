{
  "user_message": "An agent A claimed that the following MHD_str_has_token_caseless_ code violates the MISRA C 2023 rule 2.2.\n<misra_rule>\nMISRA C 2023 Rule 2.2 is A project shall not contain dead code.\nAny operation that is executed but whose removal would not affect program behaviour constitutes dead code. Notes:\n1. The behaviour of an embedded sytem is often determined not just by the nature of its actions, but also by the time at which they occur.\n2. unreachable code is not dead code, as it cannot be executed.\n3.Initialization is not the same as an assignment operation and is therfore not a candidate for dead code.\n</misra_rule>\n<target_code>\nHere is the original code of MHD_str_has_token_caseless_.\n```c\nbool\nMHD_str_has_token_caseless_ (const char *str,\n                             const char *const token,\n                             size_t token_len)\n{\n  if (0 == token_len)\n    return false;\n\n  while (0 != *str)\n  {\n    size_t i;\n    /* Skip all whitespaces and empty tokens. */\n    while (' ' == *str || '\\t' == *str || ',' == *str)\n      str++;\n\n    /* Check for token match. */\n    i = 0;\n    while (1)\n    {\n      const char sc = *(str++);\n      const char tc = token[i++];\n\n      if (0 == sc)\n        return false;\n      if (! charsequalcaseless (sc, tc))\n        break;\n      if (i >= token_len)\n      {\n        /* Check whether substring match token fully or\n         * has additional unmatched chars at tail. */\n        while (' ' == *str || '\\t' == *str)\n          str++;\n        /* End of (sub)string? */\n        if ((0 == *str) || (',' == *str) )\n          return true;\n        /* Unmatched chars at end of substring. */\n        break;\n      }\n    }\n    /* Find next substring. */\n    while (0 != *str && ',' != *str)\n      str++;\n  }\n  return false;\n}\n```\n</target_code>\n<response format>\nProvide your answer with these fields.\n- explanation: your evaluation of the scenario provided by the agent A.\n- is_report_correct: whether the report is correct or not (true/false). True means there is a violation.\n</response format>\n<scenario>\nThe agent A provided the following violation scenario:\nThe assignment const char tc = token[i++]; (and the increment of i) is executed even when sc == 0 and the function immediately returns. In that branch the read of token[i] and the increment of i have no observable effect on program behaviour (the function returns), so those operations are executed but could be removed without changing behaviour. Therefore the code contains dead code (violates MISRA C 2023 Rule 2.2).\n</scenario>\n\n<execution_log>\nThe agent A also provided the following output log:\nREAD_SC_TC: token_len=6, i_before=0, i_after=1, sc=115('s'), tc=115('s'), str=0x562f3252c198, token=0x562f3252c197\nREAD_SC_TC: token_len=6, i_before=1, i_after=2, sc=116('t'), tc=116('t'), str=0x562f3252c199, token=0x562f3252c197\nREAD_SC_TC: token_len=6, i_before=2, i_after=3, sc=114('r'), tc=114('r'), str=0x562f3252c19a, token=0x562f3252c197\nREAD_SC_TC: token_len=6, i_before=3, i_after=4, sc=105('i'), tc=105('i'), str=0x562f3252c19b, token=0x562f3252c197\nREAD_SC_TC: token_len=6, i_before=4, i_after=5, sc=110('n'), tc=110('n'), str=0x562f3252c19c, token=0x562f3252c197\nREAD_SC_TC: token_len=6, i_before=5, i_after=6, sc=103('g'), tc=103('g'), str=0x562f3252c19d, token=0x562f3252c197\nMATCH_FOUND: token_len=6, i_before=6, i_after=6, sc=103('g'), tc=103('g'), str=0x562f3252c19d, token=0x562f3252c197\nREAD_SC_TC: token_len=6, i_before=0, i_after=1, sc=83('S'), tc=115('s'), str=0x562f3252c005, token=0x562f3252c197\nREAD_SC_TC: token_len=6, i_before=1, i_after=2, sc=116('t'), tc=116('t'), str=0x562f3252c006, token=0x562f3252c197\nREAD_SC_TC: token_len=6, i_before=2, i_after=3, sc=114('r'), tc=114('r'), str=0x562f3252c007, token=0x562f3252c197\nREAD_SC_TC: token_len=6, i_before=3, i_after=4, sc=105('i'), tc=105('i'), str=0x562f3252c008, token=0x562f3252c197\nREAD_SC_TC: token_len=6, i_before=4, i_after=5, sc=110('n'), tc=110('n'), str=0x562f3252c009, token=0x562f3252c197\nREAD_SC_TC: token_len=6, i_before=5, i_after=6, sc=103('g'), tc=103('g'), str=0x562f3252c00a, token=0x562f3252c197\nMATCH_FOUND: token_len=6, i_before=6, i_after=6, sc=103('g'), tc=103('g'), str=0x562f3252c00a, token=0x562f3252c197\nREAD_SC_TC: token_len=6, i_before=0, i_after=1, sc=115('s'), tc=83('S'), str=0x562f3252c198, token=0x562f3252c004\nREAD_SC_TC: token_len=6, i_before=1, i_after=2, sc=116('t'), tc=116('t'), str=0x562f3252c199, token=0x562f3252c004\nREAD_SC_TC: token_len=6, i_before=2, i_after=3, sc=114('r'), tc=114('r'), str=0x562f3252c19a, token=0x562f3252c004\nREAD_SC_TC: token_len=6, i_before=3, i_after=4, sc=105('i'), tc=105('i'), str=0x562f3252c19b, token=0x562f3252c004\nREAD_SC_TC: token_len=6, i_before=4, i_after=5, sc=110('n'), tc=110('n'), str=0x562f3252c19c, token=0x562f3252c004\nREAD_SC_TC: token_len=6, i_before=5, i_after=6, sc=103('g'), tc=103('g'), str=0x562f3252c19d, token=0x562f3252c004\nMATCH_FOUND: token_len=6, i_before=6, i_after=6, sc=103('g'), tc=103('g'), str=0x562f3252c19d, token=0x562f3252c004\nREAD_SC_TC: token_len=6, i_before=0, i_after=1, sc=115('s'), tc=83('S'), str=0x562f3252c00e, token=0x562f3252c004\nREAD_SC_TC: token_len=6, i_before=1, i_after=2, sc=116('t'), tc=116('t'), str=0x562f3252c00f, token=0x562f3252c004\nREAD_SC_TC: token_len=6, i_before=2, i_after=3, sc=114('r'), tc=114('r'), str=0x562f3252c010, token=0x562f3252c004\nREAD_SC_TC: token_len=6, i_before=3, i_after=4, sc=105('i'), tc=105('i'), str=0x562f3252c011, token=0x562f3252c004\nREAD_SC_TC: token_len=6, i_before=4, i_after=5, sc=110('n'), tc=110('n'), str=0x562f3252c012, token=0x562f3252c004\nREAD_SC_TC: token_len=6, i_before=5, i_after=6, sc=71('G'), tc=103('g'), str=0x562f3252c013, token=0x562f3252c004\nMATCH_FOUND: token_len=6, i_before=6, i_after=6, sc=71('G'), tc=103('g'), str=0x562f3252c013, token=0x562f3252c004\nREAD_SC_TC: token_len=6, i_before=0, i_after=1, sc=115('s'), tc=83('S'), str=0x562f3252c00e, token=0x562f3252c004\nREAD_SC_TC: token_len=6, i_before=1, i_after=2, sc=116('t'), tc=116('t'), str=0x562f3252c00f, token=0x562f3252c004\nREAD_SC_TC: token_len=6, i_before=2, i_after=3, sc=114('r'), tc=114('r'), str=0x562f3252c010, token=0x562f3252c004\nREAD_SC_TC: token_len=6, i_before=3, i_after=4, sc=105('i'), tc=105('i'), str=0x562f3252c011, token=0x562f3252c004\nREAD_SC_TC: token_len=6, i_before=4, i_after=5, sc=110('n'), tc=110('n'), str=0x562f3252c012, token=0x562f3252c004\nREAD_SC_TC: token_len=6, i_before=5, i_after=6, sc=71('G'), tc=103('g'), str=0x562f3252c013, token=0x562f3252c004\nMATCH_FOUND: token_len=6, i_before=6, i_after=6, sc=71('G'), tc=103('g'), str=0x562f3252c013, token=0x562f3252c004\nREAD_SC_TC: token_len=6, i_before=0, i_after=1, sc=115('s'), tc=83('S'), s\n</execution_log>\n\n<instruction>\nJudge whether the report is correct or not.\n</instruction>\n",
  "is_report_correct": false,
  "explanation": "The report is not correct. The assignment/increment (const char tc = token[i++];) is not dead code under MISRA 2.2. Although in the specific instant where sc == 0 the function immediately returns and the local read and increment have no observable effect on the caller\u2019s state, removing that operation could change program behaviour in ways that MISRA considers relevant: it would change memory access ordering/timing and could avoid or introduce side effects (for example if the token buffer adjoins unmapped memory or a memory-mapped device, or if timing is significant in the embedded system). Moreover, the operation is required for the correct function of other loop iterations \u2014 it is not syntactically or semantically unreachable or inert in the general case. MISRA Note 1 (timing matters) and the possibility of observable side effects from the memory access mean the operation cannot be classified as dead code simply because one execution path returns immediately afterwards. If you want to avoid the extra read in the termination case you can reorder the checks (read sc, test sc==0, then read tc), but that is a maintenance/efficiency change, not a MISRA 2.2 violation."
}