{
  "user_message": "An agent A claimed that the following MHD_parse_arguments_ code violates the MISRA C 2023 rule 17.8.\n<misra_rule>\nMISRA C 2023 Rule 17.8 is A function parameter should not be modified.\nNote that the object referred to by a pointer parameter may be modified, but the pointer itself shall not be modified.\n</misra_rule>\n<target_code>\nHere is the original code of MHD_parse_arguments_.\n```c\nenum MHD_Result\nMHD_parse_arguments_ (struct MHD_Connection *connection,\n                      enum MHD_ValueKind kind,\n                      char *args,\n                      MHD_ArgumentIterator_ cb,\n                      void *cls)\n{\n  struct MHD_Daemon *daemon = connection->daemon;\n  char *equals;\n  char *amper;\n\n  while ( (NULL != args) &&\n          ('\\0' != args[0]) )\n  {\n    size_t key_len;\n    size_t value_len;\n    equals = strchr (args, '=');\n    amper = strchr (args, '&');\n    if (NULL == amper)\n    {\n      /* last argument */\n      if (NULL == equals)\n      {\n        /* last argument, without '=' */\n        MHD_unescape_plus (args);\n        key_len = daemon->unescape_callback (daemon->unescape_callback_cls,\n                                             connection,\n                                             args);\n        if (MHD_NO == cb (cls,\n                          args,\n                          key_len,\n                          NULL,\n                          0,\n                          kind))\n          return MHD_NO;\n        break;\n      }\n      /* got 'foo=bar' */\n      equals[0] = '\\0';\n      equals++;\n      MHD_unescape_plus (args);\n      key_len = daemon->unescape_callback (daemon->unescape_callback_cls,\n                                           connection,\n                                           args);\n      MHD_unescape_plus (equals);\n      value_len = daemon->unescape_callback (daemon->unescape_callback_cls,\n                                             connection,\n                                             equals);\n      if (MHD_NO == cb (cls,\n                        args,\n                        key_len,\n                        equals,\n                        value_len,\n                        kind))\n        return MHD_NO;\n      break;\n    }\n    /* amper is non-NULL here */\n    amper[0] = '\\0';\n    amper++;\n    if ( (NULL == equals) ||\n         (equals >= amper) )\n    {\n      /* got 'foo&bar' or 'foo&bar=val', add key 'foo' with NULL for value */\n      MHD_unescape_plus (args);\n      key_len = daemon->unescape_callback (daemon->unescape_callback_cls,\n                                           connection,\n                                           args);\n      if (MHD_NO == cb (cls,\n                        args,\n                        key_len,\n                        NULL,\n                        0,\n                        kind))\n        return MHD_NO;\n      /* continue with 'bar' */\n      args = amper;\n      continue;\n    }\n    /* equals and amper are non-NULL here, and equals < amper,\n so we got regular 'foo=value&bar...'-kind of argument */\n    equals[0] = '\\0';\n    equals++;\n    MHD_unescape_plus (args);\n    key_len = daemon->unescape_callback (daemon->unescape_callback_cls,\n                                         connection,\n                                         args);\n    MHD_unescape_plus (equals);\n    value_len = daemon->unescape_callback (daemon->unescape_callback_cls,\n                                           connection,\n                                           equals);\n    if (MHD_NO == cb (cls,\n                      args,\n                      key_len,\n                      equals,\n                      value_len,\n                      kind))\n      return MHD_NO;\n    args = amper;\n  }\n  return MHD_YES;\n}\n```\n</target_code>\n<response format>\nProvide your answer with these fields.\n- explanation: your evaluation of the scenario provided by the agent A.\n- is_report_correct: whether the report is correct or not (true/false). True means there is a violation.\n</response format>\n<scenario>\nThe agent A provided the following violation scenario:\nThe function parameter 'args' (type 'char *') is reassigned with 'args = amper;', i.e. the pointer parameter itself is modified. MISRA C 2023 Rule 17.8 prohibits modifying pointer parameters (the pointed-to object may be modified, but not the pointer), so this assignment constitutes a violation. Note: modifications like 'equals[0] = '\\0'' or 'amper[0] = '\\0'' (modifying the pointed-to characters) are allowed, but the 'args' pointer must not be changed.\n</scenario>\n\n<instruction>\nJudge whether the report is correct or not.\n</instruction>\n",
  "is_report_correct": true,
  "explanation": "Agent A is correct. MISRA C 2023 Rule 17.8 states that a function parameter shall not be modified; when the parameter is a pointer, the object it points to may be modified but the pointer itself shall not be assigned to. In the reported function the pointer parameter args is reassigned (args = amper;), which directly modifies the parameter itself and therefore violates Rule 17.8. (Other modifications in the function such as equals[0] = '\\0' or amper[0] = '\\0' only modify the pointed-to objects and are allowed.) A compliant fix is to iterate using a local pointer (for example, char *p = args;) and update p instead of reassigning the parameter."
}