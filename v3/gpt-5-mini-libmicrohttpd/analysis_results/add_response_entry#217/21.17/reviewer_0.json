{
  "user_message": "An agent A claimed that the following add_response_entry code violates the MISRA C 2023 rule 21.17.\n<misra_rule>\nMISRA C 2023 Rule 21.17 is Use of the string handling functions from <string.h> shall not result in accesses beyond the bounds of the objects referenced by their pointer parameters.\nThis rule strictly applies to the Standard Library functions in <string.h> such as memcpy, memmove, memset, memcmp, strcpy, strncpy, strcat, strncat, strlen, and strspn.\n</misra_rule>\n<target_code>\nHere is the original code of add_response_entry.\n```c\nstatic enum MHD_Result\nadd_response_entry (struct MHD_Response *response,\n                    enum MHD_ValueKind kind,\n                    const char *header,\n                    const char *content)\n{\n  size_t header_len;\n  size_t content_len;\n\n  if (NULL == content)\n    return MHD_NO;\n\n  header_len = strlen (header);\n  content_len = strlen (content);\n  return add_response_entry_n (response, kind, header,\n                               header_len, content,\n                               content_len) ? MHD_YES : MHD_NO;\n}\n```\n</target_code>\n<response format>\nProvide your answer with these fields.\n- explanation: your evaluation of the scenario provided by the agent A.\n- is_report_correct: whether the report is correct or not (true/false). True means there is a violation.\n</response format>\n<scenario>\nThe agent A provided the following violation scenario:\nThe function does not validate 'header' before calling strlen(header). If the caller passes header == NULL (or a pointer to a non\u2011NUL\u2011terminated buffer), strlen(header) will read out of bounds (dereferencing NULL or scanning past the object), violating MISRA C 2023 Rule 21.17.\n</scenario>\n\n<execution_log>\nThe agent A also provided the following output log:\nenter: header=0x55896121a01f, content=0x55896121a02d\nbefore_strlen: header=0x55896121a01f, content=0x55896121a02d\nbefore_add_response_entry_n: header=0x55896121a01f, content=0x55896121a02d\nenter: header=0x55896121a01f, content=0x55896121a04d\nbefore_strlen: header=0x55896121a01f, content=0x55896121a04d\nbefore_add_response_entry_n: header=0x55896121a01f, content=0x55896121a04d\nenter: header=0x55896121a01f, content=0x55896121a087\nbefore_strlen: header=0x55896121a01f, content=0x55896121a087\nbefore_add_response_entry_n: header=0x55896121a01f, content=0x55896121a087\nenter: header=0x55896121aa16, content=0x55896121aa1b\nbefore_strlen: header=0x55896121aa16, content=0x55896121aa1b\nbefore_add_response_entry_n: header=0x55896121aa16, content=0x55896121aa1b\nenter: header=0x55896121aa16, content=0x55896121aa79\nbefore_strlen: header=0x55896121aa16, content=0x55896121aa79\nbefore_add_response_entry_n: header=0x55896121aa16, content=0x55896121aa79\nenter: header=0x55896121aaf5, content=0x55896121ab07\nbefore_strlen: header=0x55896121aaf5, content=0x55896121ab07\nbefore_add_response_entry_n: header=0x55896121aaf5, content=0x55896121ab07\n\n</execution_log>\n\n<instruction>\nJudge whether the report is correct or not.\n</instruction>\n",
  "is_report_correct": true,
  "explanation": "MISRA C:2023 Rule 21.17 forbids using <string.h> functions in a way that can access beyond the bounds of the objects referenced by their pointer parameters. In add_response_entry the code checks content for NULL but does not validate header before calling strlen(header). If a caller passes header == NULL (or a pointer to a non\u2013NUL\u2013terminated buffer), strlen(header) will dereference NULL or scan past the object\u2019s bounds, which is a potential out\u2011of\u2011bounds access and therefore a breach of Rule 21.17. The provided execution log only shows non\u2011NULL header values and so does not refute the issue; the code itself contains no guarding or documented precondition to guarantee header cannot be NULL. Therefore the report is correct. A suitable fix is to validate header (e.g. if (header == NULL) return MHD_NO;) or document and enforce a non\u2011NULL/NUL\u2011terminated precondition via the function API/annotations."
}