{
  "user_message": "An agent A claimed that the following setup_epoll_fd code violates the MISRA C 2023 rule 8.13.\n<misra_rule>\nMISRA C 2023 Rule 8.13 is A pointer should point to a const-qualified type whenever possible.\n\n</misra_rule>\n<target_code>\nHere is the original code of setup_epoll_fd.\n```c\nstatic int\nsetup_epoll_fd (struct MHD_Daemon *daemon)\n{\n  int fd;\n\n#ifndef HAVE_MESSAGES\n  (void) daemon; /* Mute compiler warning. */\n#endif /* ! HAVE_MESSAGES */\n\n#ifdef USE_EPOLL_CREATE1\n  fd = epoll_create1 (EPOLL_CLOEXEC);\n#else  /* ! USE_EPOLL_CREATE1 */\n  fd = epoll_create (MAX_EVENTS);\n#endif /* ! USE_EPOLL_CREATE1 */\n  if (MHD_INVALID_SOCKET == fd)\n  {\n#ifdef HAVE_MESSAGES\n    MHD_DLOG (daemon,\n              _ (\"Call to epoll_create1 failed: %s\\n\"),\n              MHD_socket_last_strerr_ ());\n#endif\n    return MHD_INVALID_SOCKET;\n  }\n#if ! defined(USE_EPOLL_CREATE1)\n  if (! MHD_socket_noninheritable_ (fd))\n  {\n#ifdef HAVE_MESSAGES\n    MHD_DLOG (daemon,\n              _ (\"Failed to set noninheritable mode on epoll FD.\\n\"));\n#endif\n  }\n#endif /* ! USE_EPOLL_CREATE1 */\n  return fd;\n}\n```\n</target_code>\n<response format>\nProvide your answer with these fields.\n- explanation: your evaluation of the scenario provided by the agent A.\n- is_report_correct: whether the report is correct or not (true/false). True means there is a violation.\n</response format>\n<scenario>\nThe agent A provided the following violation scenario:\nThe function parameter 'daemon' is declared as 'struct MHD_Daemon *daemon' but the function does not modify the pointed-to object (it is only used for logging or not used at all \u2014 e.g. (void) daemon;). Therefore it should be declared 'const struct MHD_Daemon *daemon' to satisfy Rule 8.13.\n</scenario>\n\n<execution_log>\nThe agent A also provided the following output log:\n2025-08-26 08:22:35 - setup_epoll_fd: entry - HAVE_MESSAGES defined; daemon=0x556895775a40\n2025-08-26 08:22:35 - Calling epoll_create1 (EPOLL_CLOEXEC)\n2025-08-26 08:22:35 - epoll create returned fd=4\n2025-08-26 08:22:35 - setup_epoll_fd: returning fd=4\n2025-08-26 08:22:35 - setup_epoll_fd: entry - HAVE_MESSAGES defined; daemon=0x5568957763f0\n2025-08-26 08:22:35 - Calling epoll_create1 (EPOLL_CLOEXEC)\n2025-08-26 08:22:35 - epoll create returned fd=4\n2025-08-26 08:22:35 - setup_epoll_fd: returning fd=4\n2025-08-26 08:22:35 - setup_epoll_fd: entry - HAVE_MESSAGES defined; daemon=0x556895776698\n2025-08-26 08:22:35 - Calling epoll_create1 (EPOLL_CLOEXEC)\n2025-08-26 08:22:35 - epoll create returned fd=5\n2025-08-26 08:22:35 - setup_epoll_fd: returning fd=5\n\n</execution_log>\n\n<instruction>\nJudge whether the report is correct or not.\n</instruction>\n",
  "is_report_correct": false,
  "explanation": "Not enough evidence to conclude a definite MISRA 8.13 violation. Rule 8.13 encourages qualifying pointer targets with const when the pointed-to object is not modified, but it is not an absolute command if doing so would be incompatible with other code. In this function the parameter is not modified, but it is passed to MHD_DLOG (when HAVE_MESSAGES is defined). If MHD_DLOG (or other callees) expect a non-const struct MHD_Daemon * then changing the parameter here to const would either force casts at call sites or require changing those APIs as well. Without the declarations of MHD_DLOG and related APIs, we cannot say the const qualification is \u201cpossible\u201d; therefore the claim that the code violates Rule 8.13 is not proven. If the MHD_DLOG prototype already accepts a pointer to const, then the parameter should indeed be const and the report would be correct; otherwise it would be incorrect. Given only the code shown, the agent\u2019s blanket claim is not justified."
}