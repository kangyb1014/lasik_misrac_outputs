{
  "user_message": "An agent A claimed that the following MHD_get_timeout code violates the MISRA C 2023 rule 8.13.\n<misra_rule>\nMISRA C 2023 Rule 8.13 is A pointer should point to a const-qualified type whenever possible.\n\n</misra_rule>\n<target_code>\nHere is the original code of MHD_get_timeout.\n```c\n_MHD_EXTERN enum MHD_Result\nMHD_get_timeout (struct MHD_Daemon *daemon,\n                 MHD_UNSIGNED_LONG_LONG *timeout)\n{\n  uint64_t t64;\n  if (MHD_NO == MHD_get_timeout64 (daemon, &t64))\n    return MHD_NO;\n\n#if SIZEOF_UINT64_T > SIZEOF_UNSIGNED_LONG_LONG\n  if (ULLONG_MAX <= t64)\n    *timeout = ULLONG_MAX;\n  else\n#endif /* SIZEOF_UINT64_T > SIZEOF_UNSIGNED_LONG_LONG */\n  *timeout = (MHD_UNSIGNED_LONG_LONG) t64;\n  return MHD_YES;\n}\n```\n</target_code>\n<response format>\nProvide your answer with these fields.\n- explanation: your evaluation of the scenario provided by the agent A.\n- is_report_correct: whether the report is correct or not (true/false). True means there is a violation.\n</response format>\n<scenario>\nThe agent A provided the following violation scenario:\nThe function parameter is declared as 'struct MHD_Daemon *daemon' but within MHD_get_timeout the daemon pointer is only passed to MHD_get_timeout64 and is not modified locally. According to MISRA C 2023 Rule 8.13 the pointer should point to a const-qualified type whenever possible. Therefore the parameter should be declared 'const struct MHD_Daemon *daemon' (and the called API adjusted accordingly). This is a violation unless MHD_get_timeout64 or other called APIs require a non-const pointer (in which case the non-const declaration is forced by the API).\n</scenario>\n\n<instruction>\nJudge whether the report is correct or not.\n</instruction>\n",
  "is_report_correct": false,
  "explanation": "MISRA C:2023 Rule 8.13 recommends that pointer parameters should point to const-qualified types when they are not used to modify the pointed-to object. In the shown MHD_get_timeout implementation the daemon parameter is not modified locally, so at first glance it could be const. However MHD_get_timeout simply forwards the pointer to MHD_get_timeout64; if that API is declared to take a non-const struct MHD_Daemon * then MHD_get_timeout cannot sensibly change its own parameter to const without changing the called API (or using a cast), so the non-const declaration may be forced by the existing API. The report from agent A therefore cannot be judged correct from the snippet alone \u2014 a violation only exists if MHD_get_timeout64 (and any other callees) accept a const-qualified pointer and MHD_get_timeout nevertheless fails to use const. If the callee requires a non-const pointer, there is no breach of the rule in this function. In short: the claim is incomplete and cannot be confirmed without checking the prototype(s) of MHD_get_timeout64 (and related APIs)."
}