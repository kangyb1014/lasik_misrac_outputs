{
  "user_message": "<misra_rule>\nMISRA C 2023 Rule 8.13 is: A pointer should point to a const-qualified type whenever possible.\n\n</misra_rule>\n\nAnother agent reported that the target code violated the Rule 8.13.\nHere is the comment from the agent.\n<violation scenario>\nIf c->rq.version is declared as a non-const pointer (e.g. char *version;) then this assignment makes a non-const pointer point into a buffer whose contents are not intended to be modified via that pointer. According to MISRA C 2023 Rule 8.13 the pointer should be const-qualified whenever possible (i.e. use const char *version). In that situation the rule is violated. If, instead, c->rq.version is already declared as const char * (or equivalent const-qualified type), no rule violation occurs.\n</violation scenario>\n\nYour job is to insert logging code to capture the control flow and state information of the program.\nInsert logging code so that other agents can reproduce and get evidence for the violation scenario.\n<response format>\n- test_code: a modified get_request_line_inner code that contains useful probe functions that print useful logs to a file \"/tmp/logs/423.txt\". The logs should contain the control path and state information of the violation scenario. If test code is not required to validate the scenario, you can leave this blank.\nHere are the constraints for the test code:\n- The test code MUST preserve the original logic of get_request_line_inner as much as possible.\nYou CAN just insert probe functions to the original code.\n- DO NOT introduce new violations to demonstrate your scenario.\n- The test code MUST be compilable and executable.\n- The test code MUST include line breaks.\n- You MUST NOT define the main function.\n- You MUST NOT define macros.\n</response format>\n<target_code>\nHere is the code of get_request_line_inner:\n```c\nstatic bool\nget_request_line_inner (struct MHD_Connection *c)\n{\n  size_t p; /**< The current processing position */\n  const int discp_lvl = c->daemon->client_discipline;\n  /* Allow to skip one or more empty lines before the request line.\n     RFC 9112, section 2.2 */\n  const bool skip_empty_lines = (1 >= discp_lvl);\n  /* Allow to skip more then one empty line before the request line.\n     RFC 9112, section 2.2 */\n  const bool skip_several_empty_lines = (skip_empty_lines && (0 >= discp_lvl));\n  /* Allow to skip number of unlimited empty lines before the request line.\n     RFC 9112, section 2.2 */\n  const bool skip_unlimited_empty_lines =\n    (skip_empty_lines && (-3 >= discp_lvl));\n  /* Treat bare LF as the end of the line.\n     RFC 9112, section 2.2 */\n  const bool bare_lf_as_crlf = MHD_ALLOW_BARE_LF_AS_CRLF_ (discp_lvl);\n  /* Treat tab as whitespace delimiter.\n     RFC 9112, section 3 */\n  const bool tab_as_wsp = (0 >= discp_lvl);\n  /* Treat VT (vertical tab) and FF (form feed) as whitespace delimiters.\n     RFC 9112, section 3 */\n  const bool other_wsp_as_wsp = (-1 >= discp_lvl);\n  /* Treat continuous whitespace block as a single space.\n     RFC 9112, section 3 */\n  const bool wsp_blocks = (-1 >= discp_lvl);\n  /* Parse whitespace in URI, special parsing of the request line.\n     RFC 9112, section 3.2 */\n  const bool wsp_in_uri = (0 >= discp_lvl);\n  /* Keep whitespace in URI, give app URI with whitespace instead of\n     automatic redirect to fixed URI.\n     Violates RFC 9112, section 3.2 */\n  const bool wsp_in_uri_keep = (-2 >= discp_lvl);\n  /* Keep bare CR character as is.\n     Violates RFC 9112, section 2.2 */\n  const bool bare_cr_keep = (wsp_in_uri_keep && (-3 >= discp_lvl));\n  /* Treat bare CR as space; replace it with space before processing.\n     RFC 9112, section 2.2 */\n  const bool bare_cr_as_sp = ((! bare_cr_keep) && (-1 >= discp_lvl));\n\n  mhd_assert (MHD_CONNECTION_INIT == c->state || \\\n              MHD_CONNECTION_REQ_LINE_RECEIVING == c->state);\n  mhd_assert (NULL == c->rq.method || \\\n              MHD_CONNECTION_REQ_LINE_RECEIVING == c->state);\n  mhd_assert (MHD_HTTP_MTHD_NO_METHOD == c->rq.http_mthd || \\\n              MHD_CONNECTION_REQ_LINE_RECEIVING == c->state);\n  mhd_assert (MHD_HTTP_MTHD_NO_METHOD == c->rq.http_mthd || \\\n              0 != c->rq.hdrs.rq_line.proc_pos);\n\n  if (0 == c->read_buffer_offset)\n  {\n    mhd_assert (MHD_CONNECTION_INIT == c->state);\n    return false; /* No data to process */\n  }\n  p = c->rq.hdrs.rq_line.proc_pos;\n  mhd_assert (p <= c->read_buffer_offset);\n\n  /* Skip empty lines, if any (and if allowed) */\n  /* See RFC 9112, section 2.2 */\n  if ((0 == p)\n      && (skip_empty_lines))\n  {\n    /* Skip empty lines before the request line.\n       See RFC 9112, section 2.2 */\n    bool is_empty_line;\n    mhd_assert (MHD_CONNECTION_INIT == c->state);\n    mhd_assert (NULL == c->rq.method);\n    mhd_assert (NULL == c->rq.url);\n    mhd_assert (0 == c->rq.url_len);\n    mhd_assert (NULL == c->rq.hdrs.rq_line.rq_tgt);\n    mhd_assert (0 == c->rq.req_target_len);\n    mhd_assert (NULL == c->rq.version);\n    do\n    {\n      is_empty_line = false;\n      if ('\\r' == c->read_buffer[0])\n      {\n        if (1 == c->read_buffer_offset)\n          return false; /* Not enough data yet */\n        if ('\\n' == c->read_buffer[1])\n        {\n          is_empty_line = true;\n          c->read_buffer += 2;\n          c->read_buffer_size -= 2;\n          c->read_buffer_offset -= 2;\n          c->rq.hdrs.rq_line.skipped_empty_lines++;\n        }\n      }\n      else if (('\\n' == c->read_buffer[0]) &&\n               (bare_lf_as_crlf))\n      {\n        is_empty_line = true;\n        c->read_buffer += 1;\n        c->read_buffer_size -= 1;\n        c->read_buffer_offset -= 1;\n        c->rq.hdrs.rq_line.skipped_empty_lines++;\n      }\n      if (is_empty_line)\n      {\n        if ((! skip_unlimited_empty_lines) &&\n            (((unsigned int) ((skip_several_empty_lines) ?\n                              MHD_MAX_EMPTY_LINES_SKIP : 1)) <\n             c->rq.hdrs.rq_line.skipped_empty_lines))\n        {\n          connection_close_error (c,\n                                  _ (\"Too many meaningless extra empty lines \" \\\n                                     \"received before the request\"));\n          return true; /* Process connection closure */\n        }\n        if (0 == c->read_buffer_offset)\n          return false;  /* No more data to process */\n      }\n    } while (is_empty_line);\n  }\n  /* All empty lines are skipped */\n\n  c->state = MHD_CONNECTION_REQ_LINE_RECEIVING;\n  /* Read and parse the request line */\n  mhd_assert (1 <= c->read_buffer_offset);\n\n  while (p < c->read_buffer_offset)\n  {\n    const char chr = c->read_buffer[p];\n    bool end_of_line;\n    /*\n       The processing logic is different depending on the configured strictness:\n\n       When whitespace BLOCKS are NOT ALLOWED, the end of the whitespace is\n       processed BEFORE processing of the current character.\n       When whitespace BLOCKS are ALLOWED, the end of the whitespace is\n       processed AFTER processing of the current character.\n\n       When space char in the URI is ALLOWED, the delimiter between the URI and\n       the HTTP version string is processed only at the END of the line.\n       When space in the URI is NOT ALLOWED, the delimiter between the URI and\n       the HTTP version string is processed as soon as the FIRST whitespace is\n       found after URI start.\n     */\n\n    end_of_line = false;\n\n    mhd_assert ((0 == c->rq.hdrs.rq_line.last_ws_end) || \\\n                (c->rq.hdrs.rq_line.last_ws_end > \\\n                 c->rq.hdrs.rq_line.last_ws_start));\n    mhd_assert ((0 == c->rq.hdrs.rq_line.last_ws_start) || \\\n                (0 != c->rq.hdrs.rq_line.last_ws_end));\n\n    /* Check for the end of the line */\n    if ('\\r' == chr)\n    {\n      if (p + 1 == c->read_buffer_offset)\n      {\n        c->rq.hdrs.rq_line.proc_pos = p;\n        return false; /* Not enough data yet */\n      }\n      else if ('\\n' == c->read_buffer[p + 1])\n        end_of_line = true;\n      else\n      {\n        /* Bare CR alone */\n        /* Must be rejected or replaced with space char.\n           See RFC 9112, section 2.2 */\n        if (bare_cr_as_sp)\n        {\n          c->read_buffer[p] = ' ';\n          c->rq.num_cr_sp_replaced++;\n          continue; /* Re-start processing of the current character */\n        }\n        else if (! bare_cr_keep)\n        {\n          /* A quick simple check whether this line looks like an HTTP request */\n          if ((MHD_HTTP_MTHD_GET <= c->rq.http_mthd) &&\n              (MHD_HTTP_MTHD_DELETE >= c->rq.http_mthd))\n          {\n            transmit_error_response_static (c,\n                                            MHD_HTTP_BAD_REQUEST,\n                                            BARE_CR_IN_HEADER);\n          }\n          else\n            connection_close_error (c,\n                                    _ (\"Bare CR characters are not allowed \" \\\n                                       \"in the request line.\\n\"));\n          return true; /* Error in the request */\n        }\n      }\n    }\n    else if ('\\n' == chr)\n    {\n      /* Bare LF may be recognised as a line delimiter.\n         See RFC 9112, section 2.2 */\n      if (bare_lf_as_crlf)\n        end_of_line = true;\n      else\n      {\n        /* While RFC does not enforce error for bare LF character,\n           if this char is not treated as a line delimiter, it should be\n           rejected to avoid any security weakness due to request smuggling. */\n        /* A quick simple check whether this line looks like an HTTP request */\n        if ((MHD_HTTP_MTHD_GET <= c->rq.http_mthd) &&\n            (MHD_HTTP_MTHD_DELETE >= c->rq.http_mthd))\n        {\n          transmit_error_response_static (c,\n                                          MHD_HTTP_BAD_REQUEST,\n                                          BARE_LF_IN_HEADER);\n        }\n        else\n          connection_close_error (c,\n                                  _ (\"Bare LF characters are not allowed \" \\\n                                     \"in the request line.\\n\"));\n        return true; /* Error in the request */\n      }\n    }\n\n    if (end_of_line)\n    {\n      /* Handle the end of the request line */\n\n      if (NULL != c->rq.method)\n      {\n        if (wsp_in_uri)\n        {\n          /* The end of the URI and the start of the HTTP version string\n             should be determined now. */\n          mhd_assert (NULL == c->rq.version);\n          mhd_assert (0 == c->rq.req_target_len);\n          if (0 != c->rq.hdrs.rq_line.last_ws_end)\n          {\n            /* Determine the end and the length of the URI */\n            if (NULL != c->rq.hdrs.rq_line.rq_tgt)\n            {\n              c->read_buffer [c->rq.hdrs.rq_line.last_ws_start] = 0; /* Zero terminate the URI */\n              c->rq.req_target_len =\n                c->rq.hdrs.rq_line.last_ws_start\n                - (size_t) (c->rq.hdrs.rq_line.rq_tgt - c->read_buffer);\n            }\n            else if ((c->rq.hdrs.rq_line.last_ws_start + 1 <\n                      c->rq.hdrs.rq_line.last_ws_end) &&\n                     (HTTP_VER_LEN == (p - c->rq.hdrs.rq_line.last_ws_end)))\n            {\n              /* Found only HTTP method and HTTP version and more than one\n                 whitespace between them. Assume zero-length URI. */\n              mhd_assert (wsp_blocks);\n              c->rq.hdrs.rq_line.last_ws_start++;\n              c->read_buffer[c->rq.hdrs.rq_line.last_ws_start] = 0; /* Zero terminate the URI */\n              c->rq.hdrs.rq_line.rq_tgt =\n                c->read_buffer + c->rq.hdrs.rq_line.last_ws_start;\n              c->rq.req_target_len = 0;\n              c->rq.hdrs.rq_line.num_ws_in_uri = 0;\n              c->rq.hdrs.rq_line.rq_tgt_qmark = NULL;\n            }\n            /* Determine the start of the HTTP version string */\n            if (NULL != c->rq.hdrs.rq_line.rq_tgt)\n            {\n              c->rq.version = c->read_buffer + c->rq.hdrs.rq_line.last_ws_end;\n            }\n          }\n        }\n        else\n        {\n          /* The end of the URI and the start of the HTTP version string\n             should be already known. */\n          if ((NULL == c->rq.version)\n              && (NULL != c->rq.hdrs.rq_line.rq_tgt)\n              && (HTTP_VER_LEN == p - (size_t) (c->rq.hdrs.rq_line.rq_tgt\n                                                - c->read_buffer))\n              && (0 != c->read_buffer[(size_t)\n                                      (c->rq.hdrs.rq_line.rq_tgt\n                                       - c->read_buffer) - 1]))\n          {\n            /* Found only HTTP method and HTTP version and more than one\n               whitespace between them. Assume zero-length URI. */\n            size_t uri_pos;\n            mhd_assert (wsp_blocks);\n            mhd_assert (0 == c->rq.req_target_len);\n            uri_pos = (size_t) (c->rq.hdrs.rq_line.rq_tgt - c->read_buffer) - 1;\n            mhd_assert (uri_pos < p);\n            c->rq.version = c->rq.hdrs.rq_line.rq_tgt;\n            c->read_buffer[uri_pos] = 0;  /* Zero terminate the URI */\n            c->rq.hdrs.rq_line.rq_tgt = c->read_buffer + uri_pos;\n            c->rq.req_target_len = 0;\n            c->rq.hdrs.rq_line.num_ws_in_uri = 0;\n            c->rq.hdrs.rq_line.rq_tgt_qmark = NULL;\n          }\n        }\n\n        if (NULL != c->rq.version)\n        {\n          mhd_assert (NULL != c->rq.hdrs.rq_line.rq_tgt);\n          if (! parse_http_version (c, c->rq.version,\n                                    p\n                                    - (size_t) (c->rq.version\n                                                - c->read_buffer)))\n          {\n            mhd_assert (MHD_CONNECTION_REQ_LINE_RECEIVING < c->state);\n            return true; /* Unsupported / broken HTTP version */\n          }\n          c->read_buffer[p] = 0; /* Zero terminate the HTTP version strings */\n          if ('\\r' == chr)\n          {\n            p++; /* Consume CR */\n            mhd_assert (p < c->read_buffer_offset); /* The next character has been already checked */\n          }\n          p++; /* Consume LF */\n          c->read_buffer += p;\n          c->read_buffer_size -= p;\n          c->read_buffer_offset -= p;\n          mhd_assert (c->rq.hdrs.rq_line.num_ws_in_uri <= \\\n                      c->rq.req_target_len);\n          mhd_assert ((NULL == c->rq.hdrs.rq_line.rq_tgt_qmark) || \\\n                      (0 != c->rq.req_target_len));\n          mhd_assert ((NULL == c->rq.hdrs.rq_line.rq_tgt_qmark) || \\\n                      ((size_t) (c->rq.hdrs.rq_line.rq_tgt_qmark \\\n                                 - c->rq.hdrs.rq_line.rq_tgt) < \\\n                       c->rq.req_target_len));\n          mhd_assert ((NULL == c->rq.hdrs.rq_line.rq_tgt_qmark) || \\\n                      (c->rq.hdrs.rq_line.rq_tgt_qmark >= \\\n                       c->rq.hdrs.rq_line.rq_tgt));\n          return true; /* The request line is successfully parsed */\n        }\n      }\n      /* Error in the request line */\n\n      /* A quick simple check whether this line looks like an HTTP request */\n      if ((MHD_HTTP_MTHD_GET <= c->rq.http_mthd) &&\n          (MHD_HTTP_MTHD_DELETE >= c->rq.http_mthd))\n      {\n        transmit_error_response_static (c,\n                                        MHD_HTTP_BAD_REQUEST,\n                                        REQUEST_MALFORMED);\n      }\n      else\n        connection_close_error (c,\n                                _ (\"The request line is malformed.\\n\"));\n\n      return true;\n    }\n\n    /* Process possible end of the previously found whitespace delimiter */\n    if ((! wsp_blocks) &&\n        (p == c->rq.hdrs.rq_line.last_ws_end) &&\n        (0 != c->rq.hdrs.rq_line.last_ws_end))\n    {\n      /* Previous character was a whitespace char and whitespace blocks\n         are not allowed. */\n      /* The current position is the next character after\n         a whitespace delimiter */\n      if (NULL == c->rq.hdrs.rq_line.rq_tgt)\n      {\n        /* The current position is the start of the URI */\n        mhd_assert (0 == c->rq.req_target_len);\n        mhd_assert (NULL == c->rq.version);\n        c->rq.hdrs.rq_line.rq_tgt = c->read_buffer + p;\n        /* Reset the whitespace marker */\n        c->rq.hdrs.rq_line.last_ws_start = 0;\n        c->rq.hdrs.rq_line.last_ws_end = 0;\n      }\n      else\n      {\n        /* It was a whitespace after the start of the URI */\n        if (! wsp_in_uri)\n        {\n          mhd_assert ((0 != c->rq.req_target_len) || \\\n                      (c->rq.hdrs.rq_line.rq_tgt + 1 == c->read_buffer + p));\n          mhd_assert (NULL == c->rq.version); /* Too many whitespaces? This error is handled at whitespace start */\n          c->rq.version = c->read_buffer + p;\n          /* Reset the whitespace marker */\n          c->rq.hdrs.rq_line.last_ws_start = 0;\n          c->rq.hdrs.rq_line.last_ws_end = 0;\n        }\n      }\n    }\n\n    /* Process the current character.\n       Is it not the end of the line.  */\n    if ((' ' == chr)\n        || (('\\t' == chr) && (tab_as_wsp))\n        || ((other_wsp_as_wsp) && ((0xb == chr) || (0xc == chr))))\n    {\n      /* A whitespace character */\n      if ((0 == c->rq.hdrs.rq_line.last_ws_end) ||\n          (p != c->rq.hdrs.rq_line.last_ws_end) ||\n          (! wsp_blocks))\n      {\n        /* Found first whitespace char of the new whitespace block */\n        if (NULL == c->rq.method)\n        {\n          /* Found the end of the HTTP method string */\n          mhd_assert (0 == c->rq.hdrs.rq_line.last_ws_start);\n          mhd_assert (0 == c->rq.hdrs.rq_line.last_ws_end);\n          mhd_assert (NULL == c->rq.hdrs.rq_line.rq_tgt);\n          mhd_assert (0 == c->rq.req_target_len);\n          mhd_assert (NULL == c->rq.version);\n          if (0 == p)\n          {\n            connection_close_error (c,\n                                    _ (\"The request line starts with \"\n                                       \"a whitespace.\\n\"));\n            return true; /* Error in the request */\n          }\n          c->read_buffer[p] = 0; /* Zero-terminate the request method string */\n          c->rq.method = c->read_buffer;\n          parse_http_std_method (c, c->rq.method, p);\n        }\n        else\n        {\n          /* A whitespace after the start of the URI */\n          if (! wsp_in_uri)\n          {\n            /* Whitespace in URI is not allowed to be parsed */\n            if (NULL == c->rq.version)\n            {\n              mhd_assert (NULL != c->rq.hdrs.rq_line.rq_tgt);\n              /* This is a delimiter between URI and HTTP version string */\n              c->read_buffer[p] = 0; /* Zero-terminate request URI string */\n              mhd_assert (((size_t) (c->rq.hdrs.rq_line.rq_tgt   \\\n                                     - c->read_buffer)) <= p);\n              c->rq.req_target_len =\n                p - (size_t) (c->rq.hdrs.rq_line.rq_tgt - c->read_buffer);\n            }\n            else\n            {\n              /* This is a delimiter AFTER version string */\n\n              /* A quick simple check whether this line looks like an HTTP request */\n              if ((MHD_HTTP_MTHD_GET <= c->rq.http_mthd) &&\n                  (MHD_HTTP_MTHD_DELETE >= c->rq.http_mthd))\n              {\n                transmit_error_response_static (c,\n                                                MHD_HTTP_BAD_REQUEST,\n                                                RQ_LINE_TOO_MANY_WSP);\n              }\n              else\n                connection_close_error (c,\n                                        _ (\"The request line has more than \"\n                                           \"two whitespaces.\\n\"));\n              return true; /* Error in the request */\n            }\n          }\n          else\n          {\n            /* Whitespace in URI is allowed to be parsed */\n            if (0 != c->rq.hdrs.rq_line.last_ws_end)\n            {\n              /* The whitespace after the start of the URI has been found already */\n              c->rq.hdrs.rq_line.num_ws_in_uri +=\n                c->rq.hdrs.rq_line.last_ws_end\n                - c->rq.hdrs.rq_line.last_ws_start;\n            }\n          }\n        }\n        c->rq.hdrs.rq_line.last_ws_start = p;\n        c->rq.hdrs.rq_line.last_ws_end = p + 1; /* Will be updated on the next char parsing */\n      }\n      else\n      {\n        /* Continuation of the whitespace block */\n        mhd_assert (0 != c->rq.hdrs.rq_line.last_ws_end);\n        mhd_assert (0 != p);\n        c->rq.hdrs.rq_line.last_ws_end = p + 1;\n      }\n    }\n    else\n    {\n      /* Non-whitespace char, not the end of the line */\n      mhd_assert ((0 == c->rq.hdrs.rq_line.last_ws_end) || \\\n                  (c->rq.hdrs.rq_line.last_ws_end == p) || \\\n                  wsp_in_uri);\n\n      if ((p == c->rq.hdrs.rq_line.last_ws_end) &&\n          (0 != c->rq.hdrs.rq_line.last_ws_end) &&\n          (wsp_blocks))\n      {\n        /* The end of the whitespace block */\n        if (NULL == c->rq.hdrs.rq_line.rq_tgt)\n        {\n          /* This is the first character of the URI */\n          mhd_assert (0 == c->rq.req_target_len);\n          mhd_assert (NULL == c->rq.version);\n          c->rq.hdrs.rq_line.rq_tgt = c->read_buffer + p;\n          /* Reset the whitespace marker */\n          c->rq.hdrs.rq_line.last_ws_start = 0;\n          c->rq.hdrs.rq_line.last_ws_end = 0;\n        }\n        else\n        {\n          if (! wsp_in_uri)\n          {\n            /* This is the first character of the HTTP version */\n            mhd_assert (NULL != c->rq.hdrs.rq_line.rq_tgt);\n            mhd_assert ((0 != c->rq.req_target_len) || \\\n                        (c->rq.hdrs.rq_line.rq_tgt + 1 == c->read_buffer + p));\n            mhd_assert (NULL == c->rq.version); /* Handled at whitespace start */\n            c->rq.version = c->read_buffer + p;\n            /* Reset the whitespace marker */\n            c->rq.hdrs.rq_line.last_ws_start = 0;\n            c->rq.hdrs.rq_line.last_ws_end = 0;\n          }\n        }\n      }\n\n      /* Handle other special characters */\n      if ('?' == chr)\n      {\n        if ((NULL == c->rq.hdrs.rq_line.rq_tgt_qmark) &&\n            (NULL != c->rq.hdrs.rq_line.rq_tgt))\n        {\n          c->rq.hdrs.rq_line.rq_tgt_qmark = c->read_buffer + p;\n        }\n      }\n      else if ((0xb == chr) || (0xc == chr))\n      {\n        /* VT or LF characters */\n        mhd_assert (! other_wsp_as_wsp);\n        if ((NULL != c->rq.hdrs.rq_line.rq_tgt) &&\n            (NULL == c->rq.version) &&\n            (wsp_in_uri))\n        {\n          c->rq.hdrs.rq_line.num_ws_in_uri++;\n        }\n        else\n        {\n          connection_close_error (c,\n                                  _ (\"Invalid character is in the \"\n                                     \"request line.\\n\"));\n          return true; /* Error in the request */\n        }\n      }\n      else if (0 == chr)\n      {\n        /* NUL character */\n        connection_close_error (c,\n                                _ (\"The NUL character is in the \"\n                                   \"request line.\\n\"));\n        return true; /* Error in the request */\n      }\n    }\n\n    p++;\n  }\n\n  c->rq.hdrs.rq_line.proc_pos = p;\n  return false; /* Not enough data yet */\n}\n```\n</target_code>\nPlease provide the modified get_request_line_inner code.\n",
  "test_code": "#include <stdio.h>\n#include <stdarg.h>\n#include <stdbool.h>\n#include <stddef.h>\n\nstatic void\nmhd_log_probe (const char *fmt, ...)\n{\n  FILE *f = fopen(\"/tmp/logs/423.txt\", \"a\");\n  if (NULL == f)\n    return;\n  va_list ap;\n  va_start (ap, fmt);\n  vfprintf (f, fmt, ap);\n  va_end (ap);\n  fprintf (f, \"\\n\");\n  fclose (f);\n}\n\nstatic bool\nget_request_line_inner (struct MHD_Connection *c)\n{\n  size_t p; /**< The current processing position */\n  const int discp_lvl = c->daemon->client_discipline;\n  /* Allow to skip one or more empty lines before the request line.\n     RFC 9112, section 2.2 */\n  const bool skip_empty_lines = (1 >= discp_lvl);\n  /* Allow to skip more then one empty line before the request line.\n     RFC 9112, section 2.2 */\n  const bool skip_several_empty_lines = (skip_empty_lines && (0 >= discp_lvl));\n  /* Allow to skip number of unlimited empty lines before the request line.\n     RFC 9112, section 2.2 */\n  const bool skip_unlimited_empty_lines =\n    (skip_empty_lines && (-3 >= discp_lvl));\n  /* Treat bare LF as the end of the line.\n     RFC 9112, section 2.2 */\n  const bool bare_lf_as_crlf = MHD_ALLOW_BARE_LF_AS_CRLF_ (discp_lvl);\n  /* Treat tab as whitespace delimiter.\n     RFC 9112, section 3 */\n  const bool tab_as_wsp = (0 >= discp_lvl);\n  /* Treat VT (vertical tab) and FF (form feed) as whitespace delimiters.\n     RFC 9112, section 3 */\n  const bool other_wsp_as_wsp = (-1 >= discp_lvl);\n  /* Treat continuous whitespace block as a single space.\n     RFC 9112, section 3 */\n  const bool wsp_blocks = (-1 >= discp_lvl);\n  /* Parse whitespace in URI, special parsing of the request line.\n     RFC 9112, section 3.2 */\n  const bool wsp_in_uri = (0 >= discp_lvl);\n  /* Keep whitespace in URI, give app URI with whitespace instead of\n     automatic redirect to fixed URI.\n     Violates RFC 9112, section 3.2 */\n  const bool wsp_in_uri_keep = (-2 >= discp_lvl);\n  /* Keep bare CR character as is.\n     Violates RFC 9112, section 2.2 */\n  const bool bare_cr_keep = (wsp_in_uri_keep && (-3 >= discp_lvl));\n  /* Treat bare CR as space; replace it with space before processing.\n     RFC 9112, section 2.2 */\n  const bool bare_cr_as_sp = ((! bare_cr_keep) && (-1 >= discp_lvl));\n\n  mhd_assert (MHD_CONNECTION_INIT == c->state || \\\n              MHD_CONNECTION_REQ_LINE_RECEIVING == c->state);\n  mhd_assert (NULL == c->rq.method || \\\n              MHD_CONNECTION_REQ_LINE_RECEIVING == c->state);\n  mhd_assert (MHD_HTTP_MTHD_NO_METHOD == c->rq.http_mthd || \\\n              MHD_CONNECTION_REQ_LINE_RECEIVING == c->state);\n  mhd_assert (MHD_HTTP_MTHD_NO_METHOD == c->rq.http_mthd || \\\n              0 != c->rq.hdrs.rq_line.proc_pos);\n\n  /* Log initial state */\n  mhd_log_probe (\"enter get_request_line_inner: discp_lvl=%d, skip_empty_lines=%d, skip_several_empty_lines=%d, skip_unlimited_empty_lines=%d, bare_lf_as_crlf=%d, tab_as_wsp=%d, other_wsp_as_wsp=%d, wsp_blocks=%d, wsp_in_uri=%d, bare_cr_keep=%d, bare_cr_as_sp=%d, state=%d, rq.method=%p, rq.version=%p, read_buffer_offset=%zu\",\n                 discp_lvl,\n                 (int) skip_empty_lines,\n                 (int) skip_several_empty_lines,\n                 (int) skip_unlimited_empty_lines,\n                 (int) bare_lf_as_crlf,\n                 (int) tab_as_wsp,\n                 (int) other_wsp_as_wsp,\n                 (int) wsp_blocks,\n                 (int) wsp_in_uri,\n                 (int) bare_cr_keep,\n                 (int) bare_cr_as_sp,\n                 c->state,\n                 (void *) c->rq.method,\n                 (void *) c->rq.version,\n                 c->read_buffer_offset);\n\n  if (0 == c->read_buffer_offset)\n  {\n    mhd_assert (MHD_CONNECTION_INIT == c->state);\n    mhd_log_probe (\"no data to process: read_buffer_offset==0, returning false\");\n    return false; /* No data to process */\n  }\n  p = c->rq.hdrs.rq_line.proc_pos;\n  mhd_assert (p <= c->read_buffer_offset);\n\n  /* Skip empty lines, if any (and if allowed) */\n  /* See RFC 9112, section 2.2 */\n  if ((0 == p)\n      && (skip_empty_lines))\n  {\n    /* Skip empty lines before the request line.\n       See RFC 9112, section 2.2 */\n    bool is_empty_line;\n    mhd_assert (MHD_CONNECTION_INIT == c->state);\n    mhd_assert (NULL == c->rq.method);\n    mhd_assert (NULL == c->rq.url);\n    mhd_assert (0 == c->rq.url_len);\n    mhd_assert (NULL == c->rq.hdrs.rq_line.rq_tgt);\n    mhd_assert (0 == c->rq.req_target_len);\n    mhd_assert (NULL == c->rq.version);\n    mhd_log_probe (\"enter skip-empty-lines loop: proc_pos=%zu, skipped=%u\", p, c->rq.hdrs.rq_line.skipped_empty_lines);\n    do\n    {\n      is_empty_line = false;\n      if ('\\r' == c->read_buffer[0])\n      {\n        if (1 == c->read_buffer_offset)\n        {\n          mhd_log_probe (\"CR at buffer end, not enough data, returning false\");\n          return false; /* Not enough data yet */\n        }\n        if ('\\n' == c->read_buffer[1])\n        {\n          is_empty_line = true;\n          c->read_buffer += 2;\n          c->read_buffer_size -= 2;\n          c->read_buffer_offset -= 2;\n          c->rq.hdrs.rq_line.skipped_empty_lines++;\n          mhd_log_probe (\"skipped CRLF empty line, new read_buffer_offset=%zu, skipped=%u\", c->read_buffer_offset, c->rq.hdrs.rq_line.skipped_empty_lines);\n        }\n      }\n      else if (('\\n' == c->read_buffer[0]) &&\n               (bare_lf_as_crlf))\n      {\n        is_empty_line = true;\n        c->read_buffer += 1;\n        c->read_buffer_size -= 1;\n        c->read_buffer_offset -= 1;\n        c->rq.hdrs.rq_line.skipped_empty_lines++;\n        mhd_log_probe (\"skipped LF empty line (bare_lf_as_crlf), new read_buffer_offset=%zu, skipped=%u\", c->read_buffer_offset, c->rq.hdrs.rq_line.skipped_empty_lines);\n      }\n      if (is_empty_line)\n      {\n        if ((! skip_unlimited_empty_lines) &&\n            (((unsigned int) ((skip_several_empty_lines) ?\n                              MHD_MAX_EMPTY_LINES_SKIP : 1)) <\n             c->rq.hdrs.rq_line.skipped_empty_lines))\n        {\n          mhd_log_probe (\"too many empty lines: skipped=%u, closing connection with error\", c->rq.hdrs.rq_line.skipped_empty_lines);\n          connection_close_error (c,\n                                  _ (\"Too many meaningless extra empty lines \" \\\n                                     \"received before the request\"));\n          return true; /* Process connection closure */\n        }\n        if (0 == c->read_buffer_offset)\n        {\n          mhd_log_probe (\"no more data after skipping empty lines, returning false\");\n          return false;  /* No more data to process */\n        }\n      }\n    } while (is_empty_line);\n    mhd_log_probe (\"exit skip-empty-lines loop: proc_pos=%zu, read_buffer_offset=%zu, skipped=%u\", p, c->read_buffer_offset, c->rq.hdrs.rq_line.skipped_empty_lines);\n  }\n  /* All empty lines are skipped */\n\n  c->state = MHD_CONNECTION_REQ_LINE_RECEIVING;\n  /* Read and parse the request line */\n  mhd_assert (1 <= c->read_buffer_offset);\n\n  while (p < c->read_buffer_offset)\n  {\n    const char chr = c->read_buffer[p];\n    bool end_of_line;\n\n    end_of_line = false;\n\n    mhd_assert ((0 == c->rq.hdrs.rq_line.last_ws_end) || \\\n                (c->rq.hdrs.rq_line.last_ws_end > \\\n                 c->rq.hdrs.rq_line.last_ws_start));\n    mhd_assert ((0 == c->rq.hdrs.rq_line.last_ws_start) || \\\n                (0 != c->rq.hdrs.rq_line.last_ws_end));\n\n    /* Check for the end of the line */\n    if ('\\r' == chr)\n    {\n      if (p + 1 == c->read_buffer_offset)\n      {\n        c->rq.hdrs.rq_line.proc_pos = p;\n        mhd_log_probe (\"CR at end of buffer while parsing, saving proc_pos=%zu and returning false\", p);\n        return false; /* Not enough data yet */\n      }\n      else if ('\\n' == c->read_buffer[p + 1])\n        end_of_line = true;\n      else\n      {\n        /* Bare CR alone */\n        if (bare_cr_as_sp)\n        {\n          c->read_buffer[p] = ' ';\n          c->rq.num_cr_sp_replaced++;\n          mhd_log_probe (\"replaced bare CR with space at pos=%zu, num_cr_sp_replaced=%u\", p, c->rq.num_cr_sp_replaced);\n          continue; /* Re-start processing of the current character */\n        }\n        else if (! bare_cr_keep)\n        {\n          if ((MHD_HTTP_MTHD_GET <= c->rq.http_mthd) &&\n              (MHD_HTTP_MTHD_DELETE >= c->rq.http_mthd))\n          {\n            mhd_log_probe (\"bare CR not allowed and looks like HTTP request, transmitting BAD_REQUEST\");\n            transmit_error_response_static (c,\n                                            MHD_HTTP_BAD_REQUEST,\n                                            BARE_CR_IN_HEADER);\n          }\n          else\n          {\n            mhd_log_probe (\"bare CR not allowed, closing connection with error\");\n            connection_close_error (c,\n                                    _ (\"Bare CR characters are not allowed \" \\\n                                       \"in the request line.\\n\"));\n          }\n          return true; /* Error in the request */\n        }\n      }\n    }\n    else if ('\\n' == chr)\n    {\n      if (bare_lf_as_crlf)\n        end_of_line = true;\n      else\n      {\n        if ((MHD_HTTP_MTHD_GET <= c->rq.http_mthd) &&\n            (MHD_HTTP_MTHD_DELETE >= c->rq.http_mthd))\n        {\n          mhd_log_probe (\"bare LF not treated as CRLF and looks like HTTP request, transmitting BAD_REQUEST\");\n          transmit_error_response_static (c,\n                                          MHD_HTTP_BAD_REQUEST,\n                                          BARE_LF_IN_HEADER);\n        }\n        else\n        {\n          mhd_log_probe (\"bare LF not treated as CRLF, closing connection with error\");\n          connection_close_error (c,\n                                  _ (\"Bare LF characters are not allowed \" \\\n                                     \"in the request line.\\n\"));\n        }\n        return true; /* Error in the request */\n      }\n    }\n\n    if (end_of_line)\n    {\n      /* Handle the end of the request line */\n\n      mhd_log_probe (\"end_of_line reached at p=%zu, method=%p, version=%p, rq_tgt=%p, last_ws_start=%zu, last_ws_end=%zu, req_target_len=%zu\",\n                     p,\n                     (void *) c->rq.method,\n                     (void *) c->rq.version,\n                     (void *) c->rq.hdrs.rq_line.rq_tgt,\n                     c->rq.hdrs.rq_line.last_ws_start,\n                     c->rq.hdrs.rq_line.last_ws_end,\n                     c->rq.req_target_len);\n\n      if (NULL != c->rq.method)\n      {\n        if (wsp_in_uri)\n        {\n          mhd_assert (NULL == c->rq.version);\n          mhd_assert (0 == c->rq.req_target_len);\n          if (0 != c->rq.hdrs.rq_line.last_ws_end)\n          {\n            /* Determine the end and the length of the URI */\n            if (NULL != c->rq.hdrs.rq_line.rq_tgt)\n            {\n              c->read_buffer [c->rq.hdrs.rq_line.last_ws_start] = 0; /* Zero terminate the URI */\n              c->rq.req_target_len =\n                c->rq.hdrs.rq_line.last_ws_start\n                - (size_t) (c->rq.hdrs.rq_line.rq_tgt - c->read_buffer);\n              mhd_log_probe (\"terminated URI at pos=%zu, req_target_len=%zu\", c->rq.hdrs.rq_line.last_ws_start, c->rq.req_target_len);\n            }\n            else if ((c->rq.hdrs.rq_line.last_ws_start + 1 <\n                      c->rq.hdrs.rq_line.last_ws_end) &&\n                     (HTTP_VER_LEN == (p - c->rq.hdrs.rq_line.last_ws_end)))\n            {\n              mhd_assert (wsp_blocks);\n              c->rq.hdrs.rq_line.last_ws_start++;\n              c->read_buffer[c->rq.hdrs.rq_line.last_ws_start] = 0; /* Zero terminate the URI */\n              c->rq.hdrs.rq_line.rq_tgt =\n                c->read_buffer + c->rq.hdrs.rq_line.last_ws_start;\n              c->rq.req_target_len = 0;\n              c->rq.hdrs.rq_line.num_ws_in_uri = 0;\n              c->rq.hdrs.rq_line.rq_tgt_qmark = NULL;\n              mhd_log_probe (\"assumed zero-length URI, set rq_tgt=%p, req_target_len=0\", (void *) c->rq.hdrs.rq_line.rq_tgt);\n            }\n            /* Determine the start of the HTTP version string */\n            if (NULL != c->rq.hdrs.rq_line.rq_tgt)\n            {\n              /* Log before assigning version pointer */\n              mhd_log_probe (\"about to set c->rq.version (wsp_in_uri path): read_buffer=%p, last_ws_end=%zu, computed_version_ptr=%p\",\n                             (void *) c->read_buffer,\n                             c->rq.hdrs.rq_line.last_ws_end,\n                             (void *) (c->read_buffer + c->rq.hdrs.rq_line.last_ws_end));\n\n              c->rq.version = c->read_buffer + c->rq.hdrs.rq_line.last_ws_end;\n\n              mhd_log_probe (\"assigned c->rq.version=%p (wsp_in_uri path)\", (void *) c->rq.version);\n            }\n          }\n        }\n        else\n        {\n          /* The end of the URI and the start of the HTTP version string\n             should be already known. */\n          if ((NULL == c->rq.version)\n              && (NULL != c->rq.hdrs.rq_line.rq_tgt)\n              && (HTTP_VER_LEN == p - (size_t) (c->rq.hdrs.rq_line.rq_tgt\n                                                - c->read_buffer))\n              && (0 != c->read_buffer[(size_t)\n                                      (c->rq.hdrs.rq_line.rq_tgt\n                                       - c->read_buffer) - 1]))\n          {\n            /* Found only HTTP method and HTTP version and more than one\n               whitespace between them. Assume zero-length URI. */\n            size_t uri_pos;\n            mhd_assert (wsp_blocks);\n            mhd_assert (0 == c->rq.req_target_len);\n            uri_pos = (size_t) (c->rq.hdrs.rq_line.rq_tgt - c->read_buffer) - 1;\n            mhd_assert (uri_pos < p);\n\n            /* Log computed uri_pos and pointers before assignments */\n            mhd_log_probe (\"wsp_not_in_uri path: setting version and zero-terminating URI, uri_pos=%zu, p=%zu, rq_tgt=%p, read_buffer=%p\",\n                           uri_pos, p, (void *) c->rq.hdrs.rq_line.rq_tgt, (void *) c->read_buffer);\n\n            c->rq.version = c->rq.hdrs.rq_line.rq_tgt;\n            c->read_buffer[uri_pos] = 0;  /* Zero terminate the URI */\n            c->rq.hdrs.rq_line.rq_tgt = c->read_buffer + uri_pos;\n            c->rq.req_target_len = 0;\n            c->rq.hdrs.rq_line.num_ws_in_uri = 0;\n            c->rq.hdrs.rq_line.rq_tgt_qmark = NULL;\n\n            mhd_log_probe (\"assigned c->rq.version=%p, adjusted rq_tgt=%p, req_target_len=%zu\",\n                           (void *) c->rq.version, (void *) c->rq.hdrs.rq_line.rq_tgt, c->rq.req_target_len);\n          }\n        }\n\n        if (NULL != c->rq.version)\n        {\n          mhd_assert (NULL != c->rq.hdrs.rq_line.rq_tgt);\n          mhd_log_probe (\"about to call parse_http_version: version_ptr=%p, version_len=%zu\",\n                         (void *) c->rq.version,\n                         p - (size_t) (c->rq.version - c->read_buffer));\n          if (! parse_http_version (c, c->rq.version,\n                                    p\n                                    - (size_t) (c->rq.version\n                                                - c->read_buffer)))\n          {\n            mhd_log_probe (\"parse_http_version failed for version_ptr=%p, closing/erroring connection\", (void *) c->rq.version);\n            mhd_assert (MHD_CONNECTION_REQ_LINE_RECEIVING < c->state);\n            return true; /* Unsupported / broken HTTP version */\n          }\n          c->read_buffer[p] = 0; /* Zero terminate the HTTP version strings */\n          mhd_log_probe (\"zero-terminated HTTP version at pos=%zu; read_buffer now has zero at that pos\", p);\n          if ('\\r' == chr)\n          {\n            p++; /* Consume CR */\n            mhd_assert (p < c->read_buffer_offset); /* The next character has been already checked */\n          }\n          p++; /* Consume LF */\n          c->read_buffer += p;\n          c->read_buffer_size -= p;\n          c->read_buffer_offset -= p;\n\n          mhd_log_probe (\"successfully parsed request line: consumed p=%zu bytes; new read_buffer_offset=%zu; final rq.method=%p, rq.version=%p, rq_tgt=%p, req_target_len=%zu\",\n                         p,\n                         c->read_buffer_offset,\n                         (void *) c->rq.method,\n                         (void *) c->rq.version,\n                         (void *) c->rq.hdrs.rq_line.rq_tgt,\n                         c->rq.req_target_len);\n\n          mhd_assert (c->rq.hdrs.rq_line.num_ws_in_uri <= \\\n                      c->rq.req_target_len);\n          mhd_assert ((NULL == c->rq.hdrs.rq_line.rq_tgt_qmark) || \\\n                      (0 != c->rq.req_target_len));\n          mhd_assert ((NULL == c->rq.hdrs.rq_line.rq_tgt_qmark) || \\\n                      ((size_t) (c->rq.hdrs.rq_line.rq_tgt_qmark \\\n                                 - c->rq.hdrs.rq_line.rq_tgt) < \\\n                       c->rq.req_target_len));\n          mhd_assert ((NULL == c->rq.hdrs.rq_line.rq_tgt_qmark) || \\\n                      (c->rq.hdrs.rq_line.rq_tgt_qmark >= \\\n                       c->rq.hdrs.rq_line.rq_tgt));\n          mhd_log_probe (\"returning true (success) from get_request_line_inner\");\n          return true; /* The request line is successfully parsed */\n        }\n      }\n      /* Error in the request line */\n\n      /* A quick simple check whether this line looks like an HTTP request */\n      if ((MHD_HTTP_MTHD_GET <= c->rq.http_mthd) &&\n          (MHD_HTTP_MTHD_DELETE >= c->rq.http_mthd))\n      {\n        mhd_log_probe (\"request line malformed and looks like HTTP request, transmitting BAD_REQUEST\");\n        transmit_error_response_static (c,\n                                        MHD_HTTP_BAD_REQUEST,\n                                        REQUEST_MALFORMED);\n      }\n      else\n      {\n        mhd_log_probe (\"request line malformed, closing connection with error\");\n        connection_close_error (c,\n                                _ (\"The request line is malformed.\\n\"));\n      }\n\n      return true;\n    }\n\n    /* Process possible end of the previously found whitespace delimiter */\n    if ((! wsp_blocks) &&\n        (p == c->rq.hdrs.rq_line.last_ws_end) &&\n        (0 != c->rq.hdrs.rq_line.last_ws_end))\n    {\n      /* Previous character was a whitespace char and whitespace blocks\n         are not allowed. */\n      /* The current position is the next character after\n         a whitespace delimiter */\n      if (NULL == c->rq.hdrs.rq_line.rq_tgt)\n      {\n        /* The current position is the start of the URI */\n        mhd_assert (0 == c->rq.req_target_len);\n        mhd_assert (NULL == c->rq.version);\n        c->rq.hdrs.rq_line.rq_tgt = c->read_buffer + p;\n        /* Reset the whitespace marker */\n        c->rq.hdrs.rq_line.last_ws_start = 0;\n        c->rq.hdrs.rq_line.last_ws_end = 0;\n        mhd_log_probe (\"found start of URI at p=%zu (no wsp_blocks path), rq_tgt=%p\", p, (void *) c->rq.hdrs.rq_line.rq_tgt);\n      }\n      else\n      {\n        /* It was a whitespace after the start of the URI */\n        if (! wsp_in_uri)\n        {\n          mhd_assert ((0 != c->rq.req_target_len) || \\\n                      (c->rq.hdrs.rq_line.rq_tgt + 1 == c->read_buffer + p));\n          mhd_assert (NULL == c->rq.version); /* Too many whitespaces? This error is handled at whitespace start */\n          c->rq.version = c->read_buffer + p;\n          /* Reset the whitespace marker */\n          c->rq.hdrs.rq_line.last_ws_start = 0;\n          c->rq.hdrs.rq_line.last_ws_end = 0;\n          mhd_log_probe (\"set c->rq.version=%p (no wsp_in_uri path) at p=%zu\", (void *) c->rq.version, p);\n        }\n      }\n    }\n\n    /* Process the current character.\n       Is it not the end of the line.  */\n    if ((' ' == chr)\n        || (('\\t' == chr) && (tab_as_wsp))\n        || ((other_wsp_as_wsp) && ((0xb == chr) || (0xc == chr))))\n    {\n      /* A whitespace character */\n      if ((0 == c->rq.hdrs.rq_line.last_ws_end) ||\n          (p != c->rq.hdrs.rq_line.last_ws_end) ||\n          (! wsp_blocks))\n      {\n        /* Found first whitespace char of the new whitespace block */\n        if (NULL == c->rq.method)\n        {\n          /* Found the end of the HTTP method string */\n          mhd_assert (0 == c->rq.hdrs.rq_line.last_ws_start);\n          mhd_assert (0 == c->rq.hdrs.rq_line.last_ws_end);\n          mhd_assert (NULL == c->rq.hdrs.rq_line.rq_tgt);\n          mhd_assert (0 == c->rq.req_target_len);\n          mhd_assert (NULL == c->rq.version);\n          if (0 == p)\n          {\n            mhd_log_probe (\"request line starts with whitespace at p=0, closing connection with error\");\n            connection_close_error (c,\n                                    _ (\"The request line starts with \"\n                                       \"a whitespace.\\n\"));\n            return true; /* Error in the request */\n          }\n          c->read_buffer[p] = 0; /* Zero-terminate the request method string */\n          c->rq.method = c->read_buffer;\n          mhd_log_probe (\"terminated method at pos=%zu, method ptr=%p\", p, (void *) c->rq.method);\n          parse_http_std_method (c, c->rq.method, p);\n        }\n        else\n        {\n          /* A whitespace after the start of the URI */\n          if (! wsp_in_uri)\n          {\n            /* Whitespace in URI is not allowed to be parsed */\n            if (NULL == c->rq.version)\n            {\n              mhd_assert (NULL != c->rq.hdrs.rq_line.rq_tgt);\n              /* This is a delimiter between URI and HTTP version string */\n              c->read_buffer[p] = 0; /* Zero-terminate request URI string */\n              mhd_assert (((size_t) (c->rq.hdrs.rq_line.rq_tgt   \\\n                                     - c->read_buffer)) <= p);\n              c->rq.req_target_len =\n                p - (size_t) (c->rq.hdrs.rq_line.rq_tgt - c->read_buffer);\n              mhd_log_probe (\"terminated URI at p=%zu, req_target_len=%zu (delimiter between URI and version)\", p, c->rq.req_target_len);\n            }\n            else\n            {\n              /* This is a delimiter AFTER version string */\n\n              /* A quick simple check whether this line looks like an HTTP request */\n              if ((MHD_HTTP_MTHD_GET <= c->rq.http_mthd) &&\n                  (MHD_HTTP_MTHD_DELETE >= c->rq.http_mthd))\n              {\n                mhd_log_probe (\"too many whitespaces after version, transmitting BAD_REQUEST\");\n                transmit_error_response_static (c,\n                                                MHD_HTTP_BAD_REQUEST,\n                                                RQ_LINE_TOO_MANY_WSP);\n              }\n              else\n              {\n                mhd_log_probe (\"too many whitespaces after version, closing connection with error\");\n                connection_close_error (c,\n                                        _ (\"The request line has more than \"\n                                           \"two whitespaces.\\n\"));\n              }\n              return true; /* Error in the request */\n            }\n          }\n          else\n          {\n            /* Whitespace in URI is allowed to be parsed */\n            if (0 != c->rq.hdrs.rq_line.last_ws_end)\n            {\n              /* The whitespace after the start of the URI has been found already */\n              c->rq.hdrs.rq_line.num_ws_in_uri +=\n                c->rq.hdrs.rq_line.last_ws_end\n                - c->rq.hdrs.rq_line.last_ws_start;\n              mhd_log_probe (\"counted wsp in uri, num_ws_in_uri=%u\", c->rq.hdrs.rq_line.num_ws_in_uri);\n            }\n          }\n        }\n        c->rq.hdrs.rq_line.last_ws_start = p;\n        c->rq.hdrs.rq_line.last_ws_end = p + 1; /* Will be updated on the next char parsing */\n      }\n      else\n      {\n        /* Continuation of the whitespace block */\n        mhd_assert (0 != c->rq.hdrs.rq_line.last_ws_end);\n        mhd_assert (0 != p);\n        c->rq.hdrs.rq_line.last_ws_end = p + 1;\n      }\n    }\n    else\n    {\n      /* Non-whitespace char, not the end of the line */\n      mhd_assert ((0 == c->rq.hdrs.rq_line.last_ws_end) || \\\n                  (c->rq.hdrs.rq_line.last_ws_end == p) || \\\n                  wsp_in_uri);\n\n      if ((p == c->rq.hdrs.rq_line.last_ws_end) &&\n          (0 != c->rq.hdrs.rq_line.last_ws_end) &&\n          (wsp_blocks))\n      {\n        /* The end of the whitespace block */\n        if (NULL == c->rq.hdrs.rq_line.rq_tgt)\n        {\n          /* This is the first character of the URI */\n          mhd_assert (0 == c->rq.req_target_len);\n          mhd_assert (NULL == c->rq.version);\n          c->rq.hdrs.rq_line.rq_tgt = c->read_buffer + p;\n          /* Reset the whitespace marker */\n          c->rq.hdrs.rq_line.last_ws_start = 0;\n          c->rq.hdrs.rq_line.last_ws_end = 0;\n          mhd_log_probe (\"found start of URI at p=%zu (wsp_blocks path), rq_tgt=%p\", p, (void *) c->rq.hdrs.rq_line.rq_tgt);\n        }\n        else\n        {\n          if (! wsp_in_uri)\n          {\n            /* This is the first character of the HTTP version */\n            mhd_assert (NULL != c->rq.hdrs.rq_line.rq_tgt);\n            mhd_assert ((0 != c->rq.req_target_len) || \\\n                        (c->rq.hdrs.rq_line.rq_tgt + 1 == c->read_buffer + p));\n            mhd_assert (NULL == c->rq.version); /* Handled at whitespace start */\n            c->rq.version = c->read_buffer + p;\n            /* Reset the whitespace marker */\n            c->rq.hdrs.rq_line.last_ws_start = 0;\n            c->rq.hdrs.rq_line.last_ws_end = 0;\n            mhd_log_probe (\"set c->rq.version=%p (wsp_blocks & not wsp_in_uri) at p=%zu\", (void *) c->rq.version, p);\n          }\n        }\n      }\n\n      /* Handle other special characters */\n      if ('?' == chr)\n      {\n        if ((NULL == c->rq.hdrs.rq_line.rq_tgt_qmark) &&\n            (NULL != c->rq.hdrs.rq_line.rq_tgt))\n        {\n          c->rq.hdrs.rq_line.rq_tgt_qmark = c->read_buffer + p;\n          mhd_log_probe (\"found '?' in URI at p=%zu, rq_tgt_qmark=%p\", p, (void *) c->rq.hdrs.rq_line.rq_tgt_qmark);\n        }\n      }\n      else if ((0xb == chr) || (0xc == chr))\n      {\n        /* VT or LF characters */\n        mhd_assert (! other_wsp_as_wsp);\n        if ((NULL != c->rq.hdrs.rq_line.rq_tgt) &&\n            (NULL == c->rq.version) &&\n            (wsp_in_uri))\n        {\n          c->rq.hdrs.rq_line.num_ws_in_uri++;\n        }\n        else\n        {\n          mhd_log_probe (\"invalid VT/FF char in request line at p=%zu, closing connection with error\", p);\n          connection_close_error (c,\n                                  _ (\"Invalid character is in the \"\n                                     \"request line.\\n\"));\n          return true; /* Error in the request */\n        }\n      }\n      else if (0 == chr)\n      {\n        /* NUL character */\n        mhd_log_probe (\"NUL character found in request line at p=%zu, closing connection with error\", p);\n        connection_close_error (c,\n                                _ (\"The NUL character is in the \"\n                                   \"request line.\\n\"));\n        return true; /* Error in the request */\n      }\n    }\n\n    p++;\n  }\n\n  c->rq.hdrs.rq_line.proc_pos = p;\n  mhd_log_probe (\"not enough data yet, saved proc_pos=%zu, returning false\", p);\n  return false; /* Not enough data yet */\n}\n"
}