{
  "user_message": "An agent A claimed that the following list_directory code violates the MISRA C 2023 rule 8.13.\n<misra_rule>\nMISRA C 2023 Rule 8.13 is A pointer should point to a const-qualified type whenever possible.\n\n</misra_rule>\n<target_code>\nHere is the original code of list_directory.\n```c\nstatic enum MHD_Result\nlist_directory (struct ResponseDataContext *rdc,\n                const char *dirname)\n{\n  char fullname[PATH_MAX];\n  struct stat sbuf;\n  DIR *dir;\n  struct dirent *de;\n\n  if (NULL == (dir = opendir (dirname)))\n    return MHD_NO;\n  while (NULL != (de = readdir (dir)))\n  {\n    int res;\n    if ('.' == de->d_name[0])\n      continue;\n    if (sizeof (fullname) <= (unsigned int)\n        snprintf (fullname, sizeof (fullname),\n                  \"%s/%s\",\n                  dirname, de->d_name))\n      continue;  /* ugh, file too long? how can this be!? */\n    if (0 != stat (fullname, &sbuf))\n      continue;  /* ugh, failed to 'stat' */\n    if (! S_ISREG (sbuf.st_mode))\n      continue;  /* not a regular file, skip */\n    if (rdc->off + 1024 > rdc->buf_len)\n    {\n      void *r;\n\n      if ( (2 * rdc->buf_len + 1024) < rdc->buf_len)\n        break; /* more than SIZE_T _index_ size? Too big for us */\n      rdc->buf_len = 2 * rdc->buf_len + 1024;\n      if (NULL == (r = realloc (rdc->buf, rdc->buf_len)))\n        break; /* out of memory */\n      rdc->buf = r;\n    }\n    res = snprintf (&rdc->buf[rdc->off],\n                    rdc->buf_len - rdc->off,\n                    \"<li><a href=\\\"/%s\\\">%s</a></li>\\n\",\n                    fullname,\n                    de->d_name);\n    if (0 >= res)\n      continue;  /* snprintf() error */\n    if (rdc->buf_len - rdc->off <= (size_t) res)\n      continue;  /* buffer too small?? */\n    rdc->off += (size_t) res;\n  }\n  (void) closedir (dir);\n  return MHD_YES;\n}\n```\n</target_code>\n<response format>\nProvide your answer with these fields.\n- explanation: your evaluation of the scenario provided by the agent A.\n- is_report_correct: whether the report is correct or not (true/false). True means there is a violation.\n</response format>\n<scenario>\nThe agent A provided the following violation scenario:\nThe loop assigns the result of readdir() to de which is declared as a non-const pointer (struct dirent *de), but the code only reads from the pointed object (checks d_name, uses it in snprintf) and does not modify it. Per MISRA C 2023 Rule 8.13, the pointer should be to a const-qualified type whenever possible. Therefore de should be declared as const struct dirent *de (assigning the non-const return of readdir to a const-qualified pointer is allowed) \u2014 the current fragment violates R8.13.\n</scenario>\n\n<instruction>\nJudge whether the report is correct or not.\n</instruction>\n",
  "is_report_correct": true,
  "explanation": "The report is correct. In the loop the variable de is only used for read-only access (checking de->d_name and passing it to snprintf); therefore, per MISRA C 2023 Rule 8.13 a pointer that does not need to modify the pointed object should be declared to point to a const-qualified type. Changing the declaration to\n\n  const struct dirent *de;\n\nis valid: assigning the non-const result of readdir() to a pointer-to-const is allowed and documents the read-only intent.\n\nNote the practical caveat: making the struct dirent const means its members become const-qualified (e.g. de->d_name decays to const char *). If your toolchain or other MISRA rules flag passing a const char * to a variadic %s (printf-family) call, address that separately (for example by copying the name into a non-const buffer before calling a function that requires a non-const char *). That caveat does not invalidate the R8.13 issue \u2014 it only points out a possible secondary adjustment when applying the fix."
}