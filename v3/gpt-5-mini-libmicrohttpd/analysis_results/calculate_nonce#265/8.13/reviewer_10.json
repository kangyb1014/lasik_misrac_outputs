{
  "user_message": "An agent A claimed that the following calculate_nonce code violates the MISRA C 2023 rule 8.13.\n<misra_rule>\nMISRA C 2023 Rule 8.13 is A pointer should point to a const-qualified type whenever possible.\n\n</misra_rule>\n<target_code>\nHere is the original code of calculate_nonce.\n```c\nstatic void\ncalculate_nonce (uint64_t nonce_time,\n                 enum MHD_HTTP_Method mthd_e,\n                 const char *method,\n                 const char *rnd,\n                 size_t rnd_size,\n                 const struct sockaddr_storage *saddr,\n                 size_t saddr_size,\n                 const char *uri,\n                 size_t uri_len,\n                 const struct MHD_HTTP_Req_Header *first_header,\n                 const char *realm,\n                 size_t realm_len,\n                 unsigned int bind_options,\n                 struct DigestAlgorithm *da,\n                 char *nonce)\n{\n  mhd_assert (! da->hashing);\n  if (1)\n  {\n    /* Add the timestamp to the hash calculation */\n    uint8_t timestamp[TIMESTAMP_BIN_SIZE];\n    /* If the nonce_time is milliseconds, then the same 48 bit value will repeat\n     * every 8 919 years, which is more than enough to mitigate a replay attack */\n#if TIMESTAMP_BIN_SIZE != 6\n#error The code needs to be updated here\n#endif\n    timestamp[0] = (uint8_t) (nonce_time >> (8 * (TIMESTAMP_BIN_SIZE - 1 - 0)));\n    timestamp[1] = (uint8_t) (nonce_time >> (8 * (TIMESTAMP_BIN_SIZE - 1 - 1)));\n    timestamp[2] = (uint8_t) (nonce_time >> (8 * (TIMESTAMP_BIN_SIZE - 1 - 2)));\n    timestamp[3] = (uint8_t) (nonce_time >> (8 * (TIMESTAMP_BIN_SIZE - 1 - 3)));\n    timestamp[4] = (uint8_t) (nonce_time >> (8 * (TIMESTAMP_BIN_SIZE - 1 - 4)));\n    timestamp[5] = (uint8_t) (nonce_time >> (8 * (TIMESTAMP_BIN_SIZE - 1 - 5)));\n    MHD_bin_to_hex (timestamp,\n                    sizeof (timestamp),\n                    nonce + digest_get_size (da) * 2);\n    digest_update (da,\n                   timestamp,\n                   sizeof (timestamp));\n  }\n  if (rnd_size > 0)\n  {\n    /* Add the unique random value to the hash calculation */\n    digest_update_with_colon (da);\n    digest_update (da,\n                   rnd,\n                   rnd_size);\n  }\n  if ( (MHD_DAUTH_BIND_NONCE_NONE == bind_options) &&\n       (0 != saddr_size) )\n  {\n    /* Add full client address including source port to make unique nonces\n     * for requests received exactly at the same time */\n    digest_update_with_colon (da);\n    digest_update (da,\n                   saddr,\n                   saddr_size);\n  }\n  if ( (0 != (bind_options & MHD_DAUTH_BIND_NONCE_CLIENT_IP)) &&\n       (0 != saddr_size) )\n  {\n    /* Add the client's IP address to the hash calculation */\n    digest_update_with_colon (da);\n    if (AF_INET == saddr->ss_family)\n      digest_update (da,\n                     &((const struct sockaddr_in *) saddr)->sin_addr,\n                     sizeof(((const struct sockaddr_in *) saddr)->sin_addr));\n#ifdef HAVE_INET6\n    else if (AF_INET6 == saddr->ss_family)\n      digest_update (da,\n                     &((const struct sockaddr_in6 *) saddr)->sin6_addr,\n                     sizeof(((const struct sockaddr_in6 *) saddr)->sin6_addr));\n#endif /* HAVE_INET6 */\n  }\n  if ( (MHD_DAUTH_BIND_NONCE_NONE == bind_options) ||\n       (0 != (bind_options & MHD_DAUTH_BIND_NONCE_URI)))\n  {\n    /* Add the request method to the hash calculation */\n    digest_update_with_colon (da);\n    if (MHD_HTTP_MTHD_OTHER != mthd_e)\n    {\n      uint8_t mthd_for_hash;\n      if (MHD_HTTP_MTHD_HEAD != mthd_e)\n        mthd_for_hash = (uint8_t) mthd_e;\n      else /* Treat HEAD method in the same way as GET method */\n        mthd_for_hash = (uint8_t) MHD_HTTP_MTHD_GET;\n      digest_update (da,\n                     &mthd_for_hash,\n                     sizeof(mthd_for_hash));\n    }\n    else\n      digest_update_str (da, method);\n  }\n\n  if (0 != (bind_options & MHD_DAUTH_BIND_NONCE_URI))\n  {\n    /* Add the request URI to the hash calculation */\n    digest_update_with_colon (da);\n\n    digest_update (da,\n                   uri,\n                   uri_len);\n  }\n  if (0 != (bind_options & MHD_DAUTH_BIND_NONCE_URI_PARAMS))\n  {\n    /* Add the request URI parameters to the hash calculation */\n    const struct MHD_HTTP_Req_Header *h;\n\n    digest_update_with_colon (da);\n    for (h = first_header; NULL != h; h = h->next)\n    {\n      if (MHD_GET_ARGUMENT_KIND != h->kind)\n        continue;\n      digest_update (da, \"\\0\", 2);\n      if (0 != h->header_size)\n        digest_update (da, h->header, h->header_size);\n      digest_update (da, \"\", 1);\n      if (0 != h->value_size)\n        digest_update (da, h->value, h->value_size);\n    }\n  }\n  if ( (MHD_DAUTH_BIND_NONCE_NONE == bind_options) ||\n       (0 != (bind_options & MHD_DAUTH_BIND_NONCE_REALM)))\n  {\n    /* Add the realm to the hash calculation */\n    digest_update_with_colon (da);\n    digest_update (da,\n                   realm,\n                   realm_len);\n  }\n  if (1)\n  {\n    uint8_t hash[MAX_DIGEST];\n    digest_calc_hash (da, hash);\n    MHD_bin_to_hex (hash,\n                    digest_get_size (da),\n                    nonce);\n  }\n}\n```\n</target_code>\n<response format>\nProvide your answer with these fields.\n- explanation: your evaluation of the scenario provided by the agent A.\n- is_report_correct: whether the report is correct or not (true/false). True means there is a violation.\n</response format>\n<scenario>\nThe agent A provided the following violation scenario:\nViolation occurs if the prototype of digest_update_str does not take a const-qualified pointer. For example, if it is declared as\n\nvoid digest_update_str(struct DigestAlgorithm *da, char *s);\n\nthen calling digest_update_str(da, method) passes a const char * (method) to a non-const char * parameter, discarding the const qualifier and violating MISRA C 2023 Rule 8.13. To conform, the function parameter should be declared as const char * (or otherwise ensure the pointer type is const-qualified).\n</scenario>\n\n<execution_log>\nThe agent A also provided the following output log:\n[calculate_nonce] ENTER\nnonce_time=791, mthd_e=1, method_ptr=0x7f5040000df0, method_str='GET'\nrnd_ptr=0x7ffd7832cb88, rnd_size=8, saddr_ptr=0x55815e8d6e00, saddr_size=16\nuri_ptr=0x7f5040000df4, uri_len=8, realm_ptr=0x558135ab013b, realm_len=16\nbind_options=0x00000000, da_ptr=0x7f5047470560, nonce_ptr=0x7f5040008f03\n[calculate_nonce] BRANCH: timestamp block\n[calculate_nonce] BRANCH: rnd_size > 0\n[calculate_nonce] BRANCH: bind none && saddr_size != 0 (full client address)\n[calculate_nonce] BRANCH: include method in hash\n[calculate_nonce] BRANCH: include realm in hash\n[calculate_nonce] BRANCH: finalize hash and hex encode\n[calculate_nonce] EXIT: nonce_ptr=0x7f5040008f03, nonce_str='6b1e63cc7c052b6b5e5b05d7a58e1165000000000317', da=0x7f5047470560\n[calculate_nonce] ENTER\nnonce_time=839, mthd_e=1, method_ptr=0x7f2bec000df0, method_str='GET'\nrnd_ptr=0x7ffcf7602478, rnd_size=8, saddr_ptr=0x560befe2ee00, saddr_size=16\nuri_ptr=0x7f2bec000df4, uri_len=8, realm_ptr=0x560bbb429107, realm_len=16\nbind_options=0x00000000, da_ptr=0x7f2bf08a7560, nonce_ptr=0x7f2bec008f07\n[calculate_nonce] BRANCH: timestamp block\n[calculate_nonce] BRANCH: rnd_size > 0\n[calculate_nonce] BRANCH: bind none && saddr_size != 0 (full client address)\n[calculate_nonce] BRANCH: include method in hash\n[calculate_nonce] BRANCH: include realm in hash\n[calculate_nonce] BRANCH: finalize hash and hex encode\n[calculate_nonce] EXIT: nonce_ptr=0x7f2bec008f07, nonce_str='7711f3904a39a7bf4ef6d06cc8c89b924cc5761fedef2a1b42b0e709766c340e000000000347', da=0x7f2bf08a7560\n\n</execution_log>\n\n<instruction>\nJudge whether the report is correct or not.\n</instruction>\n",
  "is_report_correct": false,
  "explanation": "The underlying issue described by agent A is real: calculate_nonce passes a const char * (method) to digest_update_str(\u2026), so if digest_update_str is declared to take a non-const char * parameter then the const qualifier would be discarded and that would violate the spirit of MISRA C 2023 Rule 8.13. However, the calculate_nonce source alone does not prove a violation \u2014 whether a rule breach actually occurs depends on the prototype of digest_update_str (and any other called functions). If digest_update_str is declared as void digest_update_str(struct DigestAlgorithm *da, const char *s); there is no violation. If it is declared as void digest_update_str(struct DigestAlgorithm *da, char *s); then agent A\u2019s scenario is correct and the code would violate Rule 8.13. Therefore the report as an absolute statement that calculate_nonce violates Rule 8.13 is not proven by the provided code; it is only a valid finding if the digest_update_str prototype (or other called APIs) lacks the const qualification."
}