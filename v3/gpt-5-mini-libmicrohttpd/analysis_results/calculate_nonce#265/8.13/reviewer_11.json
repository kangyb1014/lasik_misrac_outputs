{
  "user_message": "An agent A claimed that the following calculate_nonce code violates the MISRA C 2023 rule 8.13.\n<misra_rule>\nMISRA C 2023 Rule 8.13 is A pointer should point to a const-qualified type whenever possible.\n\n</misra_rule>\n<target_code>\nHere is the original code of calculate_nonce.\n```c\nstatic void\ncalculate_nonce (uint64_t nonce_time,\n                 enum MHD_HTTP_Method mthd_e,\n                 const char *method,\n                 const char *rnd,\n                 size_t rnd_size,\n                 const struct sockaddr_storage *saddr,\n                 size_t saddr_size,\n                 const char *uri,\n                 size_t uri_len,\n                 const struct MHD_HTTP_Req_Header *first_header,\n                 const char *realm,\n                 size_t realm_len,\n                 unsigned int bind_options,\n                 struct DigestAlgorithm *da,\n                 char *nonce)\n{\n  mhd_assert (! da->hashing);\n  if (1)\n  {\n    /* Add the timestamp to the hash calculation */\n    uint8_t timestamp[TIMESTAMP_BIN_SIZE];\n    /* If the nonce_time is milliseconds, then the same 48 bit value will repeat\n     * every 8 919 years, which is more than enough to mitigate a replay attack */\n#if TIMESTAMP_BIN_SIZE != 6\n#error The code needs to be updated here\n#endif\n    timestamp[0] = (uint8_t) (nonce_time >> (8 * (TIMESTAMP_BIN_SIZE - 1 - 0)));\n    timestamp[1] = (uint8_t) (nonce_time >> (8 * (TIMESTAMP_BIN_SIZE - 1 - 1)));\n    timestamp[2] = (uint8_t) (nonce_time >> (8 * (TIMESTAMP_BIN_SIZE - 1 - 2)));\n    timestamp[3] = (uint8_t) (nonce_time >> (8 * (TIMESTAMP_BIN_SIZE - 1 - 3)));\n    timestamp[4] = (uint8_t) (nonce_time >> (8 * (TIMESTAMP_BIN_SIZE - 1 - 4)));\n    timestamp[5] = (uint8_t) (nonce_time >> (8 * (TIMESTAMP_BIN_SIZE - 1 - 5)));\n    MHD_bin_to_hex (timestamp,\n                    sizeof (timestamp),\n                    nonce + digest_get_size (da) * 2);\n    digest_update (da,\n                   timestamp,\n                   sizeof (timestamp));\n  }\n  if (rnd_size > 0)\n  {\n    /* Add the unique random value to the hash calculation */\n    digest_update_with_colon (da);\n    digest_update (da,\n                   rnd,\n                   rnd_size);\n  }\n  if ( (MHD_DAUTH_BIND_NONCE_NONE == bind_options) &&\n       (0 != saddr_size) )\n  {\n    /* Add full client address including source port to make unique nonces\n     * for requests received exactly at the same time */\n    digest_update_with_colon (da);\n    digest_update (da,\n                   saddr,\n                   saddr_size);\n  }\n  if ( (0 != (bind_options & MHD_DAUTH_BIND_NONCE_CLIENT_IP)) &&\n       (0 != saddr_size) )\n  {\n    /* Add the client's IP address to the hash calculation */\n    digest_update_with_colon (da);\n    if (AF_INET == saddr->ss_family)\n      digest_update (da,\n                     &((const struct sockaddr_in *) saddr)->sin_addr,\n                     sizeof(((const struct sockaddr_in *) saddr)->sin_addr));\n#ifdef HAVE_INET6\n    else if (AF_INET6 == saddr->ss_family)\n      digest_update (da,\n                     &((const struct sockaddr_in6 *) saddr)->sin6_addr,\n                     sizeof(((const struct sockaddr_in6 *) saddr)->sin6_addr));\n#endif /* HAVE_INET6 */\n  }\n  if ( (MHD_DAUTH_BIND_NONCE_NONE == bind_options) ||\n       (0 != (bind_options & MHD_DAUTH_BIND_NONCE_URI)))\n  {\n    /* Add the request method to the hash calculation */\n    digest_update_with_colon (da);\n    if (MHD_HTTP_MTHD_OTHER != mthd_e)\n    {\n      uint8_t mthd_for_hash;\n      if (MHD_HTTP_MTHD_HEAD != mthd_e)\n        mthd_for_hash = (uint8_t) mthd_e;\n      else /* Treat HEAD method in the same way as GET method */\n        mthd_for_hash = (uint8_t) MHD_HTTP_MTHD_GET;\n      digest_update (da,\n                     &mthd_for_hash,\n                     sizeof(mthd_for_hash));\n    }\n    else\n      digest_update_str (da, method);\n  }\n\n  if (0 != (bind_options & MHD_DAUTH_BIND_NONCE_URI))\n  {\n    /* Add the request URI to the hash calculation */\n    digest_update_with_colon (da);\n\n    digest_update (da,\n                   uri,\n                   uri_len);\n  }\n  if (0 != (bind_options & MHD_DAUTH_BIND_NONCE_URI_PARAMS))\n  {\n    /* Add the request URI parameters to the hash calculation */\n    const struct MHD_HTTP_Req_Header *h;\n\n    digest_update_with_colon (da);\n    for (h = first_header; NULL != h; h = h->next)\n    {\n      if (MHD_GET_ARGUMENT_KIND != h->kind)\n        continue;\n      digest_update (da, \"\\0\", 2);\n      if (0 != h->header_size)\n        digest_update (da, h->header, h->header_size);\n      digest_update (da, \"\", 1);\n      if (0 != h->value_size)\n        digest_update (da, h->value, h->value_size);\n    }\n  }\n  if ( (MHD_DAUTH_BIND_NONCE_NONE == bind_options) ||\n       (0 != (bind_options & MHD_DAUTH_BIND_NONCE_REALM)))\n  {\n    /* Add the realm to the hash calculation */\n    digest_update_with_colon (da);\n    digest_update (da,\n                   realm,\n                   realm_len);\n  }\n  if (1)\n  {\n    uint8_t hash[MAX_DIGEST];\n    digest_calc_hash (da, hash);\n    MHD_bin_to_hex (hash,\n                    digest_get_size (da),\n                    nonce);\n  }\n}\n```\n</target_code>\n<response format>\nProvide your answer with these fields.\n- explanation: your evaluation of the scenario provided by the agent A.\n- is_report_correct: whether the report is correct or not (true/false). True means there is a violation.\n</response format>\n<scenario>\nThe agent A provided the following violation scenario:\nIf the struct member h->value is declared as a non-const pointer (e.g. char *value) but is only used as read-only input to digest_update, this violates MISRA C 2023 Rule 8.13. The pointer should be declared pointing to a const-qualified type (e.g. const char *value) because the data is not modified. (If h->value is already declared as const-qualified, then no violation occurs.)\n</scenario>\n\n<execution_log>\nThe agent A also provided the following output log:\ncalculate_nonce: entry nonce_time=530, mthd_e=1, method=0x7efd0c000df0, rnd=0x7ffe60515da8, rnd_size=8, saddr=0x559a616f0e00, saddr_size=16, uri=0x7efd0c000df4, uri_len=8, first_header=0x7efd0c008db0, realm=0x559a4a85813b, realm_len=16, bind_options=0x0, da=0x7efd10891560, nonce=0x7efd0c008f03\ntimestamp bytes added: 00 00 00 00 02 12\nrnd present: rnd=0x7ffe60515da8, rnd_size=8\nbound to full saddr: saddr=0x559a616f0e00, saddr_size=16, bind_options=0x0\nmethod used as enum: mthd_e=1, mthd_for_hash=1\nrealm added: realm=0x559a4a85813b, realm_len=16\nfinal nonce hex (len=32): f5ec5c53926374d48cefbd582278dc37\ncalculate_nonce: exit\ncalculate_nonce: entry nonce_time=566, mthd_e=1, method=0x7effec000df0, rnd=0x7ffd82a91038, rnd_size=8, saddr=0x559b459e9e00, saddr_size=16, uri=0x7effec000df4, uri_len=8, first_header=0x7effec008db0, realm=0x559b2d455107, realm_len=16, bind_options=0x0, da=0x7efff1740560, nonce=0x7effec008f07\ntimestamp bytes added: 00 00 00 00 02 36\nrnd present: rnd=0x7ffd82a91038, rnd_size=8\nbound to full saddr: saddr=0x559b459e9e00, saddr_size=16, bind_options=0x0\nmethod used as enum: mthd_e=1, mthd_for_hash=1\nrealm added: realm=0x559b2d455107, realm_len=16\nfinal nonce hex (len=64): 9b8ab349b451486841611e69af787780cf18e362ea1c87ce98b223ad257df5a4\ncalculate_nonce: exit\n\n</execution_log>\n\n<instruction>\nJudge whether the report is correct or not.\n</instruction>\n",
  "is_report_correct": false,
  "explanation": "MISRA C:2023 Rule 8.13 is about how pointers are declared: a pointer type should be const\u2011qualified when the pointed\u2011to object is not modified. The code shown does the right thing for its own declarations: first_header is declared as const struct MHD_HTTP_Req_Header * and the loop variable h is also a pointer to const struct. Passing h->value to digest_update (which almost certainly takes a const void * data parameter) is allowed even if the member type is a non\u2011const char * because an object pointer may be converted to a pointer to const for a read\u2011only parameter.\n\nThe snippet alone does not show the declaration of struct MHD_HTTP_Req_Header. If that struct actually declares value as char * (non\u2011const) while it is never modified anywhere, then that struct declaration would be the place that could be flagged by Rule 8.13 \u2014 not the calculate_nonce function itself. In other words, Agent A\u2019s scenario is only correct insofar as the struct member is indeed declared non\u2011const; the violation would be in the struct member declaration, not in the use within calculate_nonce. Therefore the claim that calculate_nonce itself violates Rule 8.13 is not correct based on the code shown. Recommendation: if h->value (and similarly h->header) are truly immutable, change their declarations to const char * in the struct so they satisfy Rule 8.13 across the codebase."
}