{
  "user_message": "An agent A claimed that the following MHD_get_response_element_n_ code violates the MISRA C 2023 rule 21.17.\n<misra_rule>\nMISRA C 2023 Rule 21.17 is Use of the string handling functions from <string.h> shall not result in accesses beyond the bounds of the objects referenced by their pointer parameters.\nThis rule strictly applies to the Standard Library functions in <string.h> such as memcpy, memmove, memset, memcmp, strcpy, strncpy, strcat, strncat, strlen, and strspn.\n</misra_rule>\n<target_code>\nHere is the original code of MHD_get_response_element_n_.\n```c\nstruct MHD_HTTP_Res_Header *\nMHD_get_response_element_n_ (struct MHD_Response *response,\n                             enum MHD_ValueKind kind,\n                             const char *key,\n                             size_t key_len)\n{\n  struct MHD_HTTP_Res_Header *pos;\n\n  mhd_assert (NULL != key);\n  mhd_assert (0 != key[0]);\n  mhd_assert (0 != key_len);\n\n  for (pos = response->first_header;\n       NULL != pos;\n       pos = pos->next)\n  {\n    if ((pos->header_size == key_len) &&\n        (kind == pos->kind) &&\n        (MHD_str_equal_caseless_bin_n_ (pos->header, key, pos->header_size)))\n      return pos;\n  }\n  return NULL;\n}\n```\n</target_code>\n<response format>\nProvide your answer with these fields.\n- explanation: your evaluation of the scenario provided by the agent A.\n- is_report_correct: whether the report is correct or not (true/false). True means there is a violation.\n</response format>\n<scenario>\nThe agent A provided the following violation scenario:\nThe call itself invokes a custom comparator MHD_str_equal_caseless_bin_n_. If that function internally uses <string.h> functions that expect NUL-terminated C-strings (for example strlen(), strcmp(), strcasecmp(), strcpy(), strcat() or any implementation that calls those), and pos->header is a length-delimited buffer without a terminating '\\0' (or the implementation calls strlen(pos->header) or otherwise reads past header_size), then those library calls can read beyond the bounds of pos->header (or key) and thus violate MISRA C 2023 Rule 21.17. For example, an implementation that does if (strlen(pos->header) == strlen(key) && strncasecmp(pos->header, key, pos->header_size) == 0) would read bytes past the header_size when pos->header is not NUL-terminated.\n</scenario>\n\n<execution_log>\nThe agent A also provided the following output log:\nMHD_get_response_element_n_: pos=0x555ce221da20 header=0x555ce221d900 header_size=10 key=0x7ff9c099acb2 key_len=10 kind=1 pos->kind=1\nheader bytes (up to 10): 43 6f 6e 6e 65 63 74 69 6f 6e\nNo NUL within header_size 10\nComparator called for pos=0x555ce221da20 result=1\nMatch found: returning pos=0x555ce221da20\nMHD_get_response_element_n_: pos=0x555ce221dc70 header=0x555ce221d900 header_size=10 key=0x7ff9c099acb2 key_len=10 kind=1 pos->kind=1\nheader bytes (up to 10): 43 6f 6e 6e 65 63 74 69 6f 6e\nNo NUL within header_size 10\nComparator called for pos=0x555ce221dc70 result=1\nMatch found: returning pos=0x555ce221dc70\nMHD_get_response_element_n_: pos=0x555ce221dcb0 header=0x555ce221d900 header_size=10 key=0x7ff9c099acb2 key_len=10 kind=1 pos->kind=1\nheader bytes (up to 10): 43 6f 6e 6e 65 63 74 69 6f 6e\nNo NUL within header_size 10\nComparator called for pos=0x555ce221dcb0 result=1\nMatch found: returning pos=0x555ce221dcb0\nMHD_get_response_element_n_: pos=0x555ce221dcb0 header=0x555ce221d900 header_size=10 key=0x7ff9c099acb2 key_len=10 kind=1 pos->kind=1\nheader bytes (up to 10): 43 6f 6e 6e 65 63 74 69 6f 6e\nNo NUL within header_size 10\nComparator called for pos=0x555ce221dcb0 result=1\nMatch found: returning pos=0x555ce221dcb0\nMHD_get_response_element_n_: pos=0x555ce221dcb0 header=0x555ce221d900 header_size=10 key=0x7ff9c099acb2 key_len=10 kind=1 pos->kind=1\nheader bytes (up to 10): 43 6f 6e 6e 65 63 74 69 6f 6e\nNo NUL within header_size 10\nComparator called for pos=0x555ce221dcb0 result=1\nMatch found: returning pos=0x555ce221dcb0\nMHD_get_response_element_n_: pos=0x555ce221dcb0 header=0x555ce221d900 header_size=10 key=0x7ff9c099acb2 key_len=10 kind=1 pos->kind=1\nheader bytes (up to 10): 43 6f 6e 6e 65 63 74 69 6f 6e\nNo NUL within header_size 10\nComparator called for pos=0x555ce221dcb0 result=1\nMatch found: returning pos=0x555ce221dcb0\nMHD_get_response_element_n_: pos=0x555ce221dcb0 header=0x555ce221d900 header_size=10 key=0x7ff9c099acb2 key_len=10 kind=1 pos->kind=1\nheader bytes (up to 10): 43 6f 6e 6e 65 63 74 69 6f 6e\nNo NUL within header_size 10\nComparator called for pos=0x555ce221dcb0 result=1\nMatch found: returning pos=0x555ce221dcb0\nMHD_get_response_element_n_: pos=0x555ce221dcb0 header=0x555ce221d900 header_size=10 key=0x7ff9c099acb2 key_len=10 kind=1 pos->kind=1\nheader bytes (up to 10): 43 6f 6e 6e 65 63 74 69 6f 6e\nNo NUL within header_size 10\nComparator called for pos=0x555ce221dcb0 result=1\nMatch found: returning pos=0x555ce221dcb0\nMHD_get_response_element_n_: pos=0x555ce221dcb0 header=0x555ce221d900 header_size=10 key=0x7ff9c099acb2 key_len=10 kind=1 pos->kind=1\nheader bytes (up to 10): 43 6f 6e 6e 65 63 74 69 6f 6e\nNo NUL within header_size 10\nComparator called for pos=0x555ce221dcb0 result=1\nMatch found: returning pos=0x555ce221dcb0\nMHD_get_response_element_n_: pos=0x555ce221dcb0 header=0x555ce221d900 header_size=10 key=0x7ff9c099acb2 key_len=10 kind=1 pos->kind=1\nheader bytes (up to 10): 43 6f 6e 6e 65 63 74 69 6f 6e\nNo NUL within header_size 10\nComparator called for pos=0x555ce221dcb0 result=1\nMatch found: returning pos=0x555ce221dcb0\nMHD_get_response_element_n_: pos=0x555ce221dcb0 header=0x555ce221d900 header_size=10 key=0x7ff9c099acb2 key_len=10 kind=1 pos->kind=1\nheader bytes (up to 10): 43 6f 6e 6e 65 63 74 69 6f 6e\nNo NUL within header_size 10\nComparator called for pos=0x555ce221dcb0 result=1\nMatch found: returning pos=0x555ce221dcb0\nMHD_get_response_element_n_: pos=0x555ce221dd10 header=0x555ce221d8e0 header_size=10 key=0x7ff9c099acb2 key_len=10 kind=1 pos->kind=1\nheader bytes (up to 10): 43 6f 6e 6e 65 63 74 69 6f 6e\nNo NUL within header_size 10\nComparator called for pos=0x555ce221dd10 result=1\nMatch found: returning pos=0x555ce221dd10\nMHD_get_response_element_n_: pos=0x555ce221dd10 header=0x555ce221d8e0 header_size=10 key=0x7ff9c099acb2 key_len=10 kind=1 pos->kind=1\nheader bytes (up to 10): 43 6f 6e 6e 65 63 74 69 6f 6e\nNo NUL within header_size 10\nComparator called for pos=0x555ce221dd10 result=1\nMatch found: returning pos=0x555ce221dd10\nMHD_get_response_element_n_: pos=0x555ce221dd50 header=0x555ce221d\n</execution_log>\n\n<instruction>\nJudge whether the report is correct or not.\n</instruction>\n",
  "is_report_correct": false,
  "explanation": "The reported violation is not correct for this function itself. MISRA C:2023 Rule 21.17 targets uses of the <string.h> library functions that may read past the bounds of objects. MHD_get_response_element_n_ does not call any <string.h> functions directly \u2014 it calls a custom comparator MHD_str_equal_caseless_bin_n_. Whether a violation occurs depends on the implementation of that comparator. If that comparator were implemented unsafely (e.g. calling strlen/strcmp on a non-NUL-terminated buffer) then the comparator implementation would violate Rule 21.17, not the caller shown here. The caller does perform a header_size == key_len check and passes the explicit length to the comparator, which is the correct approach for length-delimited buffers. Therefore the claim that MHD_get_response_element_n_ itself violates Rule 21.17 is false; any violation would be located in MHD_str_equal_caseless_bin_n_ if it uses unsafe string.h calls."
}