{
  "user_message": "<misra_rule>\nMISRA C 2023 Rule 21.17 is: Use of the string handling functions from <string.h> shall not result in accesses beyond the bounds of the objects referenced by their pointer parameters.\nThis rule strictly applies to the Standard Library functions in <string.h> such as memcpy, memmove, memset, memcmp, strcpy, strncpy, strcat, strncat, strlen, and strspn.\n</misra_rule>\n<response format>\nProvide your answer with these fields.\n- is_rule_violated: whether the rule is violated or not (true/false),\n- scenario: a specific violation scenario.\n</response format>\n<target_code>\nHere is the code of MHD_uint16_to_str:\n```c\nsize_t\nMHD_uint16_to_str (uint16_t val,\n                   char *buf,\n                   size_t buf_size)\n{\n  char *chr;  /**< pointer to the current printed digit */\n  /* The biggest printable number is 65535 */\n  uint16_t divisor = UINT16_C (10000);\n  int digit;\n\n  chr = buf;\n  digit = (int) (val / divisor);\n  mhd_assert (digit < 10);\n\n  /* Do not print leading zeros */\n  while ((0 == digit) && (1 < divisor))\n  {\n    divisor /= 10;\n    digit = (int) (val / divisor);\n    mhd_assert (digit < 10);\n  }\n\n  while (0 != buf_size)\n  {\n    *chr = (char) ((char) digit + '0');\n    chr++;\n    buf_size--;\n    if (1 == divisor)\n      return (size_t) (chr - buf);\n    val = (uint16_t) (val % divisor);\n    divisor /= 10;\n    digit = (int) (val / divisor);\n    mhd_assert (digit < 10);\n  }\n  return 0; /* The buffer is too small */\n}\n```\n</target_code>\n<target_code>\nHere is the code fragment that you need to analyze:\n```c\nbuf_size--;\n```\nFocus on the above code fragment and judge whether it violates the rule 21.17 or not.\n</target_code>\n",
  "is_rule_violated": false,
  "scenario": "Not violated. The statement 'buf_size--' operates on a local size_t parameter and does not call any functions from <string.h>. Rule 21.17 concerns use of string.h functions that might access beyond object bounds; none are used here. Additionally, buffer writes are guarded by the preceding 'while (0 != buf_size)' check, so the decrement itself does not introduce an out\u2011of\u2011bounds access in this code path."
}