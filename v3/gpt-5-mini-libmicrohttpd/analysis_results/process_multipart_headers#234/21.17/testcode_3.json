{
  "user_message": "<misra_rule>\nMISRA C 2023 Rule 21.17 is: Use of the string handling functions from <string.h> shall not result in accesses beyond the bounds of the objects referenced by their pointer parameters.\nThis rule strictly applies to the Standard Library functions in <string.h> such as memcpy, memmove, memset, memcmp, strcpy, strncpy, strcat, strncat, strlen, and strspn.\n</misra_rule>\n\nAnother agent reported that the target code violated the Rule 21.17.\nHere is the comment from the agent.\n<violation scenario>\nLikely violated. The call passes buf and a fixed prefix length (MHD_STATICSTR_LEN_(\"Content-type: \")) to try_match_header without ensuring that the buffer contains at least that many bytes. If try_match_header implements the prefix comparison using a string.h routine that reads exactly the provided length (e.g. memcmp/strncmp with the length parameter), and the prefix length is greater than the number of bytes safely addressable in the object pointed to by buf (for example if pp->buffer_size or the remaining allocated bytes at &pp[1] are smaller than the prefix length, or the code only ensured newline < pp->buffer_pos but not that pp->buffer_size >= prefix_len), then the comparison can read past the end of the buffer and violate Rule 21.17.\n</violation scenario>\n\nYour job is to insert logging code to capture the control flow and state information of the program.\nInsert logging code so that other agents can reproduce and get evidence for the violation scenario.\n<response format>\n- test_code: a modified process_multipart_headers code that contains useful probe functions that print useful logs to a file \"/tmp/logs/2349.txt\". The logs should contain the control path and state information of the violation scenario. If test code is not required to validate the scenario, you can leave this blank.\nHere are the constraints for the test code:\n- The test code MUST preserve the original logic of process_multipart_headers as much as possible.\nYou CAN just insert probe functions to the original code.\n- DO NOT introduce new violations to demonstrate your scenario.\n- The test code MUST be compilable and executable.\n- The test code MUST include line breaks.\n- You MUST NOT define the main function.\n- You MUST NOT define macros.\n</response format>\n<target_code>\nHere is the code of process_multipart_headers:\n```c\nstatic int\nprocess_multipart_headers (struct MHD_PostProcessor *pp,\n                           size_t *ioffptr,\n                           enum PP_State next_state)\n{\n  char *buf = (char *) &pp[1];\n  size_t newline;\n\n  newline = 0;\n  while ( (newline < pp->buffer_pos) &&\n          (buf[newline] != '\\r') &&\n          (buf[newline] != '\\n') )\n    newline++;\n  if (newline == pp->buffer_size)\n  {\n    pp->state = PP_Error;\n    return MHD_NO;              /* out of memory */\n  }\n  if (newline == pp->buffer_pos)\n    return MHD_NO;              /* will need more data */\n  if (0 == newline)\n  {\n    /* empty line - end of headers */\n    pp->skip_rn = RN_Full;\n    pp->state = next_state;\n    return MHD_YES;\n  }\n  /* got an actual header */\n  if (buf[newline] == '\\r')\n    pp->skip_rn = RN_OptN;\n  buf[newline] = '\\0';\n  if (MHD_str_equal_caseless_n_ (\"Content-disposition: \",\n                                 buf,\n                                 MHD_STATICSTR_LEN_ (\"Content-disposition: \")))\n  {\n    try_get_value (&buf[MHD_STATICSTR_LEN_ (\"Content-disposition: \")],\n                   \"name\",\n                   &pp->content_name);\n    try_get_value (&buf[MHD_STATICSTR_LEN_ (\"Content-disposition: \")],\n                   \"filename\",\n                   &pp->content_filename);\n  }\n  else\n  {\n    try_match_header (\"Content-type: \",\n                      MHD_STATICSTR_LEN_ (\"Content-type: \"),\n                      buf,\n                      &pp->content_type);\n    try_match_header (\"Content-Transfer-Encoding: \",\n                      MHD_STATICSTR_LEN_ (\"Content-Transfer-Encoding: \"),\n                      buf,\n                      &pp->content_transfer_encoding);\n  }\n  (*ioffptr) += newline + 1;\n  return MHD_YES;\n}\n```\n</target_code>\nPlease provide the modified process_multipart_headers code.\n",
  "test_code": "#include <stdio.h>\n#include <stdarg.h>\n#include <string.h>\n#include <stddef.h>\n\n/* Probe logging helpers. These write append logs to /tmp/logs/2349.txt. */\nstatic void probe_logf(const char *fmt, ...)\n{\n    FILE *f = fopen(\"/tmp/logs/2349.txt\", \"a\");\n    if (NULL == f)\n        return;\n    va_list ap;\n    va_start(ap, fmt);\n    vfprintf(f, fmt, ap);\n    va_end(ap);\n    fprintf(f, \"\\n\");\n    fclose(f);\n}\n\nstatic void probe_log_buffer_preview(char *buf, size_t preview_len)\n{\n    /* Dump up to preview_len bytes as hex and as printable chars. */\n    probe_logf(\"buffer preview (len=%zu):\", preview_len);\n    if (preview_len == 0)\n    {\n        probe_logf(\"<empty>\");\n        return;\n    }\n    /* Hex line */\n    {\n        char hexline[3 * 128 + 1];\n        size_t i, max = preview_len;\n        if (max > 128) max = 128;\n        size_t pos = 0;\n        for (i = 0; i < max; ++i)\n        {\n            int n = snprintf(&hexline[pos], sizeof(hexline) - pos, \"%02X \", (unsigned char)buf[i]);\n            if (n < 0) break;\n            pos += (size_t)n;\n            if (pos >= sizeof(hexline)) break;\n        }\n        hexline[(pos < sizeof(hexline)) ? pos : (sizeof(hexline)-1)] = '\\0';\n        probe_logf(\"hex: %s\", hexline);\n    }\n    /* Chars line */\n    {\n        char charline[129];\n        size_t i, max = preview_len;\n        if (max > 128) max = 128;\n        for (i = 0; i < max; ++i)\n        {\n            char c = buf[i];\n            if (c >= 32 && c <= 126)\n                charline[i] = c;\n            else\n                charline[i] = '.';\n        }\n        charline[max] = '\\0';\n        probe_logf(\"chars: %s\", charline);\n    }\n}\n\nstatic void probe_state(void *pp_ptr,\n                        char *buf,\n                        size_t newline,\n                        size_t *ioffptr)\n{\n    /* We don't dereference pp_ptr generically here; caller will log typed fields as needed. */\n    probe_logf(\"process_multipart_headers: pp=%p buf=%p newline=%zu ioff=%p(%zu)\",\n               pp_ptr, (void *)buf, newline, (void *)ioffptr, (ioffptr ? *ioffptr : 0));\n}\n\n/* Modified function with probes inserted. Original logic preserved. */\nstatic int\nprocess_multipart_headers (struct MHD_PostProcessor *pp,\n                           size_t *ioffptr,\n                           enum PP_State next_state)\n{\n  char *buf = (char *) &pp[1];\n  size_t newline;\n\n  /* Log entry state */\n  probe_logf(\"ENTRY: pp=%p buffer_pos=%zu buffer_size=%zu\", (void *)pp, pp->buffer_pos, pp->buffer_size);\n\n  newline = 0;\n  while ( (newline < pp->buffer_pos) &&\n          (buf[newline] != '\\r') &&\n          (buf[newline] != '\\n') )\n    newline++;\n\n  /* Log newline position and the next char (if safe) */\n  if (newline < pp->buffer_pos)\n    probe_logf(\"found potential newline at index %zu char=0x%02X\", newline, (unsigned char)buf[newline]);\n  else\n    probe_logf(\"no newline found within buffer_pos (%zu); newline=%zu\", pp->buffer_pos, newline);\n\n  /* Safety: do not attempt to log buffer contents beyond either buffer_pos or buffer_size */\n  {\n    size_t preview_len = pp->buffer_pos;\n    if (preview_len > pp->buffer_size)\n      preview_len = pp->buffer_size;\n    /* Cap preview to a reasonable size to avoid huge logs */\n    if (preview_len > 128)\n      preview_len = 128;\n    probe_log_buffer_preview(buf, preview_len);\n  }\n\n  if (newline == pp->buffer_size)\n  {\n    probe_logf(\"ERROR-OUT-OF-MEM: newline == buffer_size (%zu). Setting state to PP_Error and returning MHD_NO\", pp->buffer_size);\n    pp->state = PP_Error;\n    return MHD_NO;              /* out of memory */\n  }\n  if (newline == pp->buffer_pos)\n  {\n    probe_logf(\"NEED-MORE-DATA: newline == buffer_pos (%zu). Returning MHD_NO (will need more data)\", pp->buffer_pos);\n    return MHD_NO;              /* will need more data */\n  }\n  if (0 == newline)\n  {\n    /* empty line - end of headers */\n    probe_logf(\"EMPTY-LINE: end of headers. Setting skip_rn=RN_Full, state=%d\", next_state);\n    pp->skip_rn = RN_Full;\n    pp->state = next_state;\n    return MHD_YES;\n  }\n  /* got an actual header */\n  if (buf[newline] == '\\r')\n    pp->skip_rn = RN_OptN;\n\n  /* Null-terminate the header in-place as original code does */\n  buf[newline] = '\\0';\n\n  /* Log header line (safely) */\n  {\n    size_t header_preview_len = newline;\n    if (header_preview_len > pp->buffer_size)\n      header_preview_len = pp->buffer_size;\n    if (header_preview_len > 128)\n      header_preview_len = 128;\n    probe_logf(\"HEADER-LINE at buf=%p length=%zu\", (void *)buf, newline);\n    probe_log_buffer_preview(buf, header_preview_len);\n  }\n\n  /* Log the candidate prefix lengths we'll compare; use strlen of literals to mirror the macro lengths */\n  {\n    const char *cd_literal = \"Content-disposition: \";\n    const char *ct_literal = \"Content-type: \";\n    const char *cte_literal = \"Content-Transfer-Encoding: \";\n    size_t cd_len = strlen(cd_literal);\n    size_t ct_len = strlen(ct_literal);\n    size_t cte_len = strlen(cte_literal);\n    probe_logf(\"prefix lengths: Content-disposition=%zu Content-type=%zu Content-Transfer-Encoding=%zu\",\n               cd_len, ct_len, cte_len);\n\n    /* Log parameters to try_get_value / try_match_header about to be called */\n    probe_logf(\"About to check Content-disposition: calling MHD_str_equal_caseless_n_ with buf=%p and len=%zu\",\n               (void *)buf, cd_len);\n\n    if (MHD_str_equal_caseless_n_ (cd_literal,\n                                   buf,\n                                   MHD_STATICSTR_LEN_ (\"Content-disposition: \")))\n    {\n      probe_logf(\"MATCHED Content-disposition: -> calling try_get_value for name and filename\");\n      try_get_value (&buf[MHD_STATICSTR_LEN_ (\"Content-disposition: \")],\n                     \"name\",\n                     &pp->content_name);\n      probe_logf(\"after try_get_value(name): content_name=%p\", (void *)pp->content_name);\n      try_get_value (&buf[MHD_STATICSTR_LEN_ (\"Content-disposition: \")],\n                     \"filename\",\n                     &pp->content_filename);\n      probe_logf(\"after try_get_value(filename): content_filename=%p\", (void *)pp->content_filename);\n    }\n    else\n    {\n      /* Log the exact arguments passed to try_match_header so callers can see the lengths and pointers */\n      probe_logf(\"NOT Content-disposition: -> will call try_match_header for Content-type and Content-Transfer-Encoding\");\n      probe_logf(\"try_match_header args 1: literal=%p (\\\"Content-type: \\\"), len=%zu, buf=%p, target=&pp->content_type\",\n                 (void *)ct_literal, ct_len, (void *)buf);\n      try_match_header (\"Content-type: \",\n                        MHD_STATICSTR_LEN_ (\"Content-type: \"),\n                        buf,\n                        &pp->content_type);\n      probe_logf(\"after try_match_header(Content-type): content_type=%p\", (void *)pp->content_type);\n\n      probe_logf(\"try_match_header args 2: literal=%p (\\\"Content-Transfer-Encoding: \\\"), len=%zu, buf=%p, target=&pp->content_transfer_encoding\",\n                 (void *)cte_literal, cte_len, (void *)buf);\n      try_match_header (\"Content-Transfer-Encoding: \",\n                        MHD_STATICSTR_LEN_ (\"Content-Transfer-Encoding: \"),\n                        buf,\n                        &pp->content_transfer_encoding);\n      probe_logf(\"after try_match_header(Content-Transfer-Encoding): content_transfer_encoding=%p\",\n                 (void *)pp->content_transfer_encoding);\n    }\n  }\n\n  (*ioffptr) += newline + 1;\n  probe_logf(\"ADVANCE: incremented ioffptr by %zu -> new ioff=%zu\", newline + 1, *ioffptr);\n  return MHD_YES;\n}\n"
}