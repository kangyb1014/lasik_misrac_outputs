{
  "user_message": "<misra_rule>\nMISRA C 2023 Rule 8.13 is: A pointer should point to a const-qualified type whenever possible.\n\n</misra_rule>\n\nAnother agent reported that the target code violated the Rule 8.13.\nHere is the comment from the agent.\n<violation scenario>\nThe call passes &buf[MHD_STATICSTR_LEN_(\"Content-disposition: \")] (a char *) to try_get_value. If try_get_value\u2019s parameter is declared as char * (i.e. non-const) but the function only reads the string, then the pointer parameter is not const-qualified and Rule 8.13 is violated. The correct approach is for try_get_value to accept a const char * (or for the passed pointer to be const-qualified) when the function does not modify the buffer.\n</violation scenario>\n\nYour job is to insert logging code to capture the control flow and state information of the program.\nInsert logging code so that other agents can reproduce and get evidence for the violation scenario.\n<response format>\n- test_code: a modified process_multipart_headers code that contains useful probe functions that print useful logs to a file \"/tmp/logs/2343.txt\". The logs should contain the control path and state information of the violation scenario. If test code is not required to validate the scenario, you can leave this blank.\nHere are the constraints for the test code:\n- The test code MUST preserve the original logic of process_multipart_headers as much as possible.\nYou CAN just insert probe functions to the original code.\n- DO NOT introduce new violations to demonstrate your scenario.\n- The test code MUST be compilable and executable.\n- The test code MUST include line breaks.\n- You MUST NOT define the main function.\n- You MUST NOT define macros.\n</response format>\n<target_code>\nHere is the code of process_multipart_headers:\n```c\nstatic int\nprocess_multipart_headers (struct MHD_PostProcessor *pp,\n                           size_t *ioffptr,\n                           enum PP_State next_state)\n{\n  char *buf = (char *) &pp[1];\n  size_t newline;\n\n  newline = 0;\n  while ( (newline < pp->buffer_pos) &&\n          (buf[newline] != '\\r') &&\n          (buf[newline] != '\\n') )\n    newline++;\n  if (newline == pp->buffer_size)\n  {\n    pp->state = PP_Error;\n    return MHD_NO;              /* out of memory */\n  }\n  if (newline == pp->buffer_pos)\n    return MHD_NO;              /* will need more data */\n  if (0 == newline)\n  {\n    /* empty line - end of headers */\n    pp->skip_rn = RN_Full;\n    pp->state = next_state;\n    return MHD_YES;\n  }\n  /* got an actual header */\n  if (buf[newline] == '\\r')\n    pp->skip_rn = RN_OptN;\n  buf[newline] = '\\0';\n  if (MHD_str_equal_caseless_n_ (\"Content-disposition: \",\n                                 buf,\n                                 MHD_STATICSTR_LEN_ (\"Content-disposition: \")))\n  {\n    try_get_value (&buf[MHD_STATICSTR_LEN_ (\"Content-disposition: \")],\n                   \"name\",\n                   &pp->content_name);\n    try_get_value (&buf[MHD_STATICSTR_LEN_ (\"Content-disposition: \")],\n                   \"filename\",\n                   &pp->content_filename);\n  }\n  else\n  {\n    try_match_header (\"Content-type: \",\n                      MHD_STATICSTR_LEN_ (\"Content-type: \"),\n                      buf,\n                      &pp->content_type);\n    try_match_header (\"Content-Transfer-Encoding: \",\n                      MHD_STATICSTR_LEN_ (\"Content-Transfer-Encoding: \"),\n                      buf,\n                      &pp->content_transfer_encoding);\n  }\n  (*ioffptr) += newline + 1;\n  return MHD_YES;\n}\n```\n</target_code>\nPlease provide the modified process_multipart_headers code.\n",
  "test_code": "#include <stdio.h>\n#include <stdarg.h>\n#include <string.h>\n#include <time.h>\n\n/* Probe helper: append a formatted log line to the mandated log file. */\nstatic void probe_log(const char *fmt, ...)\n{\n    FILE *f = fopen(\"/tmp/logs/2343.txt\", \"a\");\n    if (NULL == f)\n        return;\n    time_t t = time(NULL);\n    struct tm *tm = localtime(&t);\n    if (tm)\n        fprintf(f, \"%04d-%02d-%02d %02d:%02d:%02d \",\n                tm->tm_year + 1900, tm->tm_mon + 1, tm->tm_mday,\n                tm->tm_hour, tm->tm_min, tm->tm_sec);\n    va_list ap;\n    va_start(ap, fmt);\n    vfprintf(f, fmt, ap);\n    va_end(ap);\n    fputc('\\n', f);\n    fclose(f);\n}\n\n/* Snapshot up to `maxlen` bytes from a char pointer into a local buffer for logging. */\nstatic void probe_snapshot(const char *p, char *out, size_t maxlen)\n{\n    if (p == NULL || out == NULL || maxlen == 0)\n    {\n        if (out && maxlen > 0)\n            out[0] = '\\0';\n        return;\n    }\n    /* Copy up to maxlen-1 bytes or until '\\0' */\n    size_t i = 0;\n    while (i + 1 < maxlen && p[i] != '\\0')\n    {\n        out[i] = p[i];\n        i++;\n    }\n    out[i] = '\\0';\n}\n\n/* Wrapper around try_get_value that logs before and after state so callers can see if\n   the buffer passed as a non-const char * gets modified by the callee. */\nstatic void probe_try_get_value_wrapper(char *bufptr, const char *key, void **dest, const char *label)\n{\n    char before[256];\n    char after[256];\n\n    probe_snapshot(bufptr, before, sizeof(before));\n    probe_log(\"[probe] try_get_value entry label='%s' key='%s' bufptr=%p content_before='%s' dest_ptr=%p\",\n              label ? label : \"(null)\", key ? key : \"(null)\", (void *)bufptr, before, (void *)dest);\n\n    /* Call the original function. It must exist in the surrounding code base. */\n    try_get_value(bufptr, key, (char **)dest);\n\n    probe_snapshot(bufptr, after, sizeof(after));\n    if (strcmp(before, after) != 0)\n    {\n        probe_log(\"[probe] try_get_value modified buffer for label='%s' bufptr=%p before='%s' after='%s'\",\n                  label ? label : \"(null)\", (void *)bufptr, before, after);\n    }\n    else\n    {\n        probe_log(\"[probe] try_get_value did NOT modify buffer for label='%s' bufptr=%p content='%s'\",\n                  label ? label : \"(null)\", (void *)bufptr, after);\n    }\n\n    /* Also log resulting dest pointer value */\n    probe_log(\"[probe] try_get_value exit label='%s' dest_ptr=%p\", label ? label : \"(null)\", (void *)*dest);\n}\n\n/* Wrapper around try_match_header for logging purposes. */\nstatic void probe_try_match_header_wrapper(const char *hdr,\n                                           size_t hdr_len,\n                                           char *buf,\n                                           void **dest,\n                                           const char *label)\n{\n    char snapshot[256];\n    probe_snapshot(buf, snapshot, sizeof(snapshot));\n    probe_log(\"[probe] try_match_header entry label='%s' hdr='%s' hdr_len=%zu buf=%p buf_content='%s' dest_ptr=%p\",\n              label ? label : \"(null)\", hdr ? hdr : \"(null)\", hdr_len, (void *)buf, snapshot, (void *)dest);\n\n    try_match_header(hdr, hdr_len, buf, (char **)dest);\n\n    probe_snapshot(buf, snapshot, sizeof(snapshot));\n    probe_log(\"[probe] try_match_header exit label='%s' buf=%p buf_content='%s' dest_ptr=%p\",\n              label ? label : \"(null)\", (void *)buf, snapshot, (void *)*dest);\n}\n\n/* Modified process_multipart_headers with inserted probes. The original logic is preserved. */\nstatic int\nprocess_multipart_headers (struct MHD_PostProcessor *pp,\n                           size_t *ioffptr,\n                           enum PP_State next_state)\n{\n  char *buf = (char *) &pp[1];\n  size_t newline;\n\n  probe_log(\"[probe] process_multipart_headers entry pp=%p buf=%p buffer_pos=%zu buffer_size=%zu state=%d\",\n            (void *)pp, (void *)buf, pp->buffer_pos, pp->buffer_size, (int)pp->state);\n\n  newline = 0;\n  while ( (newline < pp->buffer_pos) &&\n          (buf[newline] != '\\r') &&\n          (buf[newline] != '\\n') )\n    newline++;\n  probe_log(\"[probe] scanned newline position=%zu (buffer_pos=%zu)\", newline, pp->buffer_pos);\n\n  if (newline == pp->buffer_size)\n  {\n    pp->state = PP_Error;\n    probe_log(\"[probe] newline == buffer_size -> PP_Error\");\n    return MHD_NO;              /* out of memory */\n  }\n  if (newline == pp->buffer_pos)\n  {\n    probe_log(\"[probe] newline == buffer_pos -> need more data (MHD_NO)\");\n    return MHD_NO;              /* will need more data */\n  }\n  if (0 == newline)\n  {\n    /* empty line - end of headers */\n    pp->skip_rn = RN_Full;\n    pp->state = next_state;\n    probe_log(\"[probe] empty line: end of headers, next_state=%d\", (int)next_state);\n    return MHD_YES;\n  }\n  /* got an actual header */\n  if (buf[newline] == '\\r')\n    pp->skip_rn = RN_OptN;\n  buf[newline] = '\\0';\n\n  probe_log(\"[probe] header line extracted buf=%p header_content='%s' newline=%zu\", (void *)buf, buf, newline);\n\n  if (MHD_str_equal_caseless_n_ (\"Content-disposition: \",\n                                 buf,\n                                 MHD_STATICSTR_LEN_ (\"Content-disposition: \")))\n  {\n    /* Use our wrapper to capture whether try_get_value mutates the non-const char* buffer. */\n    probe_try_get_value_wrapper(&buf[MHD_STATICSTR_LEN_ (\"Content-disposition: \")],\n                                \"name\",\n                                (void **)&pp->content_name,\n                                \"Content-disposition:name\");\n\n    probe_try_get_value_wrapper(&buf[MHD_STATICSTR_LEN_ (\"Content-disposition: \")],\n                                \"filename\",\n                                (void **)&pp->content_filename,\n                                \"Content-disposition:filename\");\n  }\n  else\n  {\n    probe_try_match_header_wrapper(\"Content-type: \",\n                                   MHD_STATICSTR_LEN_ (\"Content-type: \"),\n                                   buf,\n                                   (void **)&pp->content_type,\n                                   \"Content-type\");\n\n    probe_try_match_header_wrapper(\"Content-Transfer-Encoding: \",\n                                   MHD_STATICSTR_LEN_ (\"Content-Transfer-Encoding: \"),\n                                   buf,\n                                   (void **)&pp->content_transfer_encoding,\n                                   \"Content-Transfer-Encoding\");\n  }\n\n  (*ioffptr) += newline + 1;\n  probe_log(\"[probe] advancing ioffptr by %zu -> new ioffptr value=%zu\", newline + 1, *ioffptr);\n  probe_log(\"[probe] process_multipart_headers exit pp=%p state=%d content_name=%p content_filename=%p content_type=%p content_transfer_encoding=%p\",\n            (void *)pp, (int)pp->state,\n            (void *)pp->content_name, (void *)pp->content_filename,\n            (void *)pp->content_type, (void *)pp->content_transfer_encoding);\n  return MHD_YES;\n}\n"
}