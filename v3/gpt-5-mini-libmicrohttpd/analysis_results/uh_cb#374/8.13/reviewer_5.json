{
  "user_message": "An agent A claimed that the following uh_cb code violates the MISRA C 2023 rule 8.13.\n<misra_rule>\nMISRA C 2023 Rule 8.13 is A pointer should point to a const-qualified type whenever possible.\n\n</misra_rule>\n<target_code>\nHere is the original code of uh_cb.\n```c\nstatic void\nuh_cb (void *cls,\n       struct MHD_Connection *connection,\n       void *req_cls,\n       const char *extra_in,\n       size_t extra_in_size,\n       MHD_socket sock,\n       struct MHD_UpgradeResponseHandle *urh)\n{\n  struct MyData *md;\n  pthread_t pt;\n  (void) cls;         /* Unused. Silent compiler warning. */\n  (void) connection;  /* Unused. Silent compiler warning. */\n  (void) req_cls;     /* Unused. Silent compiler warning. */\n\n  md = malloc (sizeof (struct MyData));\n  if (NULL == md)\n    abort ();\n  memset (md, 0, sizeof (struct MyData));\n  if (0 != extra_in_size)\n  {\n    md->extra_in = malloc (extra_in_size);\n    if (NULL == md->extra_in)\n      abort ();\n    memcpy (md->extra_in,\n            extra_in,\n            extra_in_size);\n  }\n  md->extra_in_size = extra_in_size;\n  md->sock = sock;\n  md->urh = urh;\n  if (0 != pthread_create (&pt,\n                           NULL,\n                           &run_usock,\n                           md))\n    abort ();\n  /* Note that by detaching like this we make it impossible to ensure\n     a clean shutdown, as the we stop the daemon even if a worker thread\n     is still running. Alas, this is a simple example... */\n  pthread_detach (pt);\n\n  /* This callback must return as soon as possible. */\n\n  /* Data forwarding to \"upgraded\" socket will be started\n   * after return from this callback. */\n}\n```\n</target_code>\n<response format>\nProvide your answer with these fields.\n- explanation: your evaluation of the scenario provided by the agent A.\n- is_report_correct: whether the report is correct or not (true/false). True means there is a violation.\n</response format>\n<scenario>\nThe agent A provided the following violation scenario:\nThe function parameters cls, connection and req_cls are non-const pointers but are not modified (they are only cast to void to silence unused warnings), so they could and should be declared as const (e.g. const void *cls, const struct MHD_Connection *connection, const void *req_cls). extra_in is already const. Depending on the use of urh (it is stored into md->urh here), urh could also be const if neither this function nor the worker thread modify the pointed-to object; if the worker needs to modify it then urh must remain non-const. Given the fragment as shown, the non-const declarations of cls, connection and req_cls violate MISRA C 2023 Rule 8.13.\n</scenario>\n\n<instruction>\nJudge whether the report is correct or not.\n</instruction>\n",
  "is_report_correct": false,
  "explanation": "The report overstates the problem. Rule 8.13 recommends that pointers should point to const-qualified types where possible, but it is not an absolute requirement that you change every unused pointer parameter to const. In this case uh_cb is a callback whose signature is dictated by the microhttpd API (the parameters must match the expected callback prototype). You cannot legally change those parameter types without breaking the required function prototype or the function-pointer type the library expects. Therefore declaring cls, connection or req_cls as const in this function would generally not be possible unless the library's callback typedef itself uses const \u2014 so the situation is an allowed practical exception to applying 8.13. Also, extra_in is already const. As for urh, whether it can be const depends on whether the worker thread or other code will modify the pointed-to object; from the fragment we cannot assume it can be made const. If you control the API and can change the callback typedef to use const where appropriate, then doing so would satisfy 8.13; otherwise the current code is acceptable (and casting unused parameters to void to suppress warnings is common practice)."
}