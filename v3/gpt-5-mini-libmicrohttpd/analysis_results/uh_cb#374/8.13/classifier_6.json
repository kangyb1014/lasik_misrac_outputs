{
  "user_message": "<misra_rule>\nMISRA C 2023 Rule 8.13 is: A pointer should point to a const-qualified type whenever possible.\n\n</misra_rule>\n<response format>\nProvide your answer with these fields.\n- is_rule_violated: whether the rule is violated or not (true/false),\n- scenario: a specific violation scenario.\n</response format>\n<target_code>\nHere is the code of uh_cb:\n```c\nstatic void\nuh_cb (void *cls,\n       struct MHD_Connection *connection,\n       void *req_cls,\n       const char *extra_in,\n       size_t extra_in_size,\n       MHD_socket sock,\n       struct MHD_UpgradeResponseHandle *urh)\n{\n  struct MyData *md;\n  pthread_t pt;\n  (void) cls;         /* Unused. Silent compiler warning. */\n  (void) connection;  /* Unused. Silent compiler warning. */\n  (void) req_cls;     /* Unused. Silent compiler warning. */\n\n  md = malloc (sizeof (struct MyData));\n  if (NULL == md)\n    abort ();\n  memset (md, 0, sizeof (struct MyData));\n  if (0 != extra_in_size)\n  {\n    md->extra_in = malloc (extra_in_size);\n    if (NULL == md->extra_in)\n      abort ();\n    memcpy (md->extra_in,\n            extra_in,\n            extra_in_size);\n  }\n  md->extra_in_size = extra_in_size;\n  md->sock = sock;\n  md->urh = urh;\n  if (0 != pthread_create (&pt,\n                           NULL,\n                           &run_usock,\n                           md))\n    abort ();\n  /* Note that by detaching like this we make it impossible to ensure\n     a clean shutdown, as the we stop the daemon even if a worker thread\n     is still running. Alas, this is a simple example... */\n  pthread_detach (pt);\n\n  /* This callback must return as soon as possible. */\n\n  /* Data forwarding to \"upgraded\" socket will be started\n   * after return from this callback. */\n}\n```\n</target_code>\n<target_code>\nHere is the code fragment that you need to analyze:\n```c\n(void) cls;         /* Unused. Silent compiler warning. */\n```\nFocus on the above code fragment and judge whether it violates the rule 8.13 or not.\n</target_code>\n",
  "is_rule_violated": false,
  "scenario": "The parameter cls is declared as void *cls in the callback prototype and only used in the discard cast (void)cls; \u2014 it is not dereferenced or modified. Rule 8.13 asks that pointers point to const-qualified types when possible, but the function signature is imposed by the external callback API and cannot be changed here. The discard cast itself does not affect qualification. Therefore there is no violation in this fragment (if the signature could be changed to const void *cls it would be preferable, but that is not possible when matching the external API)."
}