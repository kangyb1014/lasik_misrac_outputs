{
  "user_message": "An agent A claimed that the following MHD_create_response_from_buffer_copy code violates the MISRA C 2023 rule 21.17.\n<misra_rule>\nMISRA C 2023 Rule 21.17 is Use of the string handling functions from <string.h> shall not result in accesses beyond the bounds of the objects referenced by their pointer parameters.\nThis rule strictly applies to the Standard Library functions in <string.h> such as memcpy, memmove, memset, memcmp, strcpy, strncpy, strcat, strncat, strlen, and strspn.\n</misra_rule>\n<target_code>\nHere is the original code of MHD_create_response_from_buffer_copy.\n```c\n_MHD_EXTERN struct MHD_Response *\nMHD_create_response_from_buffer_copy (size_t size,\n                                      const void *buffer)\n{\n  struct MHD_Response *r;\n  void *mhd_copy;\n\n  if (0 == size)\n    return MHD_create_response_from_buffer_with_free_callback_cls (0,\n                                                                   NULL,\n                                                                   NULL,\n                                                                   NULL);\n  if (NULL == buffer)\n    return NULL;\n\n  mhd_copy = malloc (size);\n  if (NULL == mhd_copy)\n    return NULL;\n  memcpy (mhd_copy, buffer, size);\n\n  r = MHD_create_response_from_buffer_with_free_callback_cls (size,\n                                                              mhd_copy,\n                                                              &free,\n                                                              mhd_copy);\n  if (NULL == r)\n    free (mhd_copy);\n  else\n  {\n    /* TODO: remove the next assignment, the buffer should not be modifiable */\n    r->data_buffer_size = size;\n  }\n\n  return r;\n}\n```\n</target_code>\n<response format>\nProvide your answer with these fields.\n- explanation: your evaluation of the scenario provided by the agent A.\n- is_report_correct: whether the report is correct or not (true/false). True means there is a violation.\n</response format>\n<scenario>\nThe agent A provided the following violation scenario:\nThe call memcpy(mhd_copy, buffer, size) can read beyond the bounds of the object referenced by 'buffer' because the function only checks buffer != NULL and does not ensure that the object pointed to by 'buffer' is at least 'size' bytes long. For example, if the caller passes a source array char src[4] = \"abc\\0\" but passes size == 10, memcpy will read past src and invoke undefined behavior. The destination is allocated with malloc(size) (so the destination is OK), but the source side is not checked, so Rule 21.17 is violated.\n</scenario>\n\n<instruction>\nJudge whether the report is correct or not.\n</instruction>\n",
  "is_report_correct": true,
  "explanation": "Agent A is correct. MISRA C:2023 Rule 21.17 covers use of memcpy and requires that such calls shall not result in accesses beyond the bounds of the objects referenced by their pointer parameters. In the code memcpy(mhd_copy, buffer, size) the destination is allocated to size bytes but there is no guarantee performed (or provable) that the object referenced by buffer is at least size bytes long. The function only checks buffer != NULL; if a caller passes an undersized source (e.g. char src[4] = \"abc\\0\" but size == 10) the memcpy will read beyond the bounds of src, invoking undefined behaviour and violating Rule 21.17. The call therefore violates the rule unless an externally enforced and verifiable precondition (that buffer points to at least size bytes) is documented and enforced; as written the function does not ensure that precondition, so the report of a violation is correct."
}