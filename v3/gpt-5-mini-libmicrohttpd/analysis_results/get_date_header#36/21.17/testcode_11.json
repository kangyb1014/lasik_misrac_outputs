{
  "user_message": "<misra_rule>\nMISRA C 2023 Rule 21.17 is: Use of the string handling functions from <string.h> shall not result in accesses beyond the bounds of the objects referenced by their pointer parameters.\nThis rule strictly applies to the Standard Library functions in <string.h> such as memcpy, memmove, memset, memcmp, strcpy, strncpy, strcat, strncat, strlen, and strspn.\n</misra_rule>\n\nAnother agent reported that the target code violated the Rule 21.17.\nHere is the comment from the agent.\n<violation scenario>\nThis call can violate Rule 21.17 unless there is a documented/checked contract guaranteeing the buffer size. Passing header + 6 hands get_date_str a pointer into the caller's buffer; if that buffer is smaller than the space get_date_str (or the string.h routines it uses) will read/write, accesses beyond the object will occur. Example: if header points to char header[20], header+6 provides only 14 bytes of storage but get_date_str writes a full date (e.g. ~29 bytes) and the caller later writes header[35..37], causing out-of-bounds writes. Without an explicit guarantee that header has sufficient size (at least 38 bytes in this function), the code can violate Rule 21.17.\n</violation scenario>\n\nYour job is to insert logging code to capture the control flow and state information of the program.\nInsert logging code so that other agents can reproduce and get evidence for the violation scenario.\n<response format>\n- test_code: a modified get_date_header code that contains useful probe functions that print useful logs to a file \"/tmp/logs/369.txt\". The logs should contain the control path and state information of the violation scenario. If test code is not required to validate the scenario, you can leave this blank.\nHere are the constraints for the test code:\n- The test code MUST preserve the original logic of get_date_header as much as possible.\nYou CAN just insert probe functions to the original code.\n- DO NOT introduce new violations to demonstrate your scenario.\n- The test code MUST be compilable and executable.\n- The test code MUST include line breaks.\n- You MUST NOT define the main function.\n- You MUST NOT define macros.\n</response format>\n<target_code>\nHere is the code of get_date_header:\n```c\nstatic bool\nget_date_header (char *header)\n{\n  if (! get_date_str (header + 6))\n  {\n    header[0] = 0;\n    return false;\n  }\n  header[0] = 'D';\n  header[1] = 'a';\n  header[2] = 't';\n  header[3] = 'e';\n  header[4] = ':';\n  header[5] = ' ';\n  header[35] = '\\r';\n  header[36] = '\\n';\n  header[37] = 0;\n  return true;\n}\n```\n</target_code>\nPlease provide the modified get_date_header code.\n",
  "test_code": "#include <stdio.h>\n#include <stdarg.h>\n#include <stdbool.h>\n\n/* Probe logger: append human-readable traces to /tmp/logs/369.txt */\nstatic void\nlog_probe(const char *fmt, ...)\n{\n    FILE *f = fopen(\"/tmp/logs/369.txt\", \"a\");\n    if (!f)\n        return;\n    va_list ap;\n    va_start(ap, fmt);\n    vfprintf(f, fmt, ap);\n    va_end(ap);\n    fputc('\\n', f);\n    fclose(f);\n}\n\n/* Declaration of external dependency (provided elsewhere in the program) */\nextern bool get_date_str(char *);\n\nstatic bool\nget_date_header (char *header)\n{\n  /* Log entry and the pointer value so callers can correlate buffer address */\n  log_probe(\"ENTER get_date_header: header=%p\", (void *) header);\n\n  /* Log intent to call get_date_str with header+6 (this is where the potential\n     OOB originates if the caller's buffer is too small). Do not perform any\n     extra reads of header here (to avoid introducing new OOB accesses). */\n  log_probe(\"Calling get_date_str with header+6=%p\", (void *) (header + 6));\n\n  if (! get_date_str (header + 6))\n  {\n    log_probe(\"get_date_str returned false for header+6=%p\", (void *) (header + 6));\n    header[0] = 0;\n    log_probe(\"Wrote header[0]=0; returning false\");\n    return false;\n  }\n\n  log_probe(\"get_date_str succeeded for header+6=%p\", (void *) (header + 6));\n\n  /* Log that the function will write specific offsets. This documents the\n     exact indices that must be valid in the caller-supplied buffer to avoid\n     Rule 21.17 violations. We intentionally do NOT read from these offsets\n     here (only write), preserving the original function behavior and\n     avoiding introducing additional reads that could themselves be OOB. */\n  log_probe(\"About to write header[0..5] and header[35..37] for header=%p\", (void *) header);\n\n  header[0] = 'D';\n  header[1] = 'a';\n  header[2] = 't';\n  header[3] = 'e';\n  header[4] = ':';\n  header[5] = ' ';\n\n  log_probe(\"Wrote header[0..5] for header=%p\", (void *) header);\n\n  header[35] = '\\r';\n  header[36] = '\\n';\n  header[37] = 0;\n\n  /* Log that the trailing CRLF and terminator were written (no reads performed). */\n  log_probe(\"Wrote header[35..37] (CRLF and NUL) for header=%p\", (void *) header);\n  log_probe(\"EXIT get_date_header: returning true for header=%p\", (void *) header);\n\n  return true;\n}\n"
}