{
  "user_message": "<misra_rule>\nMISRA C 2023 Rule 21.17 is: Use of the string handling functions from <string.h> shall not result in accesses beyond the bounds of the objects referenced by their pointer parameters.\nThis rule strictly applies to the Standard Library functions in <string.h> such as memcpy, memmove, memset, memcmp, strcpy, strncpy, strcat, strncat, strlen, and strspn.\n</misra_rule>\n\nAnother agent reported that the target code violated the Rule 21.17.\nHere is the comment from the agent.\n<violation scenario>\nIf get_date_header is called with a char buffer smaller than 38 bytes (for example char buf[20]; get_date_header(buf);), the write header[35] = '\\r' (and subsequent writes header[36], header[37]) will access beyond the bounds of the object. This also interacts with get_date_str(header + 6): if that function uses <string.h> routines and assumes a larger buffer, those calls could likewise produce out\u2011of\u2011bounds accesses. The code provides no bounds information or checks, so an invocation with a too\u2011small buffer violates the requirement that string handling and related accesses must not exceed object bounds.\n</violation scenario>\n\nYour job is to insert logging code to capture the control flow and state information of the program.\nInsert logging code so that other agents can reproduce and get evidence for the violation scenario.\n<response format>\n- test_code: a modified get_date_header code that contains useful probe functions that print useful logs to a file \"/tmp/logs/369.txt\". The logs should contain the control path and state information of the violation scenario. If test code is not required to validate the scenario, you can leave this blank.\nHere are the constraints for the test code:\n- The test code MUST preserve the original logic of get_date_header as much as possible.\nYou CAN just insert probe functions to the original code.\n- DO NOT introduce new violations to demonstrate your scenario.\n- The test code MUST be compilable and executable.\n- The test code MUST include line breaks.\n- You MUST NOT define the main function.\n- You MUST NOT define macros.\n</response format>\n<target_code>\nHere is the code of get_date_header:\n```c\nstatic bool\nget_date_header (char *header)\n{\n  if (! get_date_str (header + 6))\n  {\n    header[0] = 0;\n    return false;\n  }\n  header[0] = 'D';\n  header[1] = 'a';\n  header[2] = 't';\n  header[3] = 'e';\n  header[4] = ':';\n  header[5] = ' ';\n  header[35] = '\\r';\n  header[36] = '\\n';\n  header[37] = 0;\n  return true;\n}\n```\n</target_code>\nPlease provide the modified get_date_header code.\n",
  "test_code": "#include <stdio.h>\n#include <stdbool.h>\n#include <errno.h>\n#include <sys/stat.h>\n\n/* Forward declaration of external function used by original code. */\nextern bool get_date_str (char *);\n\n/* Helper: append a short log entry describing the control point and\n   the header pointer value. We deliberately avoid performing any\n   pointer arithmetic on `header` (e.g. header + 6 or header + 35) to\n   avoid introducing additional pointer/array arithmetic beyond the\n   original function. */\nstatic void\nlog_date_header_event(const char *stage, char *header)\n{\n  FILE *f;\n\n  /* Try to create the log directory if it does not exist. Ignore\n     errors except for reasons other than \"already exists\". */\n  (void)mkdir(\"/tmp/logs\", 0755);\n\n  f = fopen(\"/tmp/logs/369.txt\", \"a\");\n  if (!f)\n    return;\n\n  /* Log the stage and the raw pointer value for `header`. Do not\n     dereference or perform pointer arithmetic on `header` here. */\n  fprintf(f, \"%s: header=%p\\n\", stage, (void *)header);\n  fflush(f);\n  fclose(f);\n}\n\nstatic bool\nget_date_header (char *header)\n{\n  /* Log entry into the function before invoking get_date_str. We log\n     the pointer and the fact that we'll call get_date_str at offset 6\n     (but we do NOT compute header+6 here to avoid additional pointer\n     arithmetic). */\n  log_date_header_event(\"enter\", header);\n  log_date_header_event(\"about_to_call_get_date_str_at_offset_6\", header);\n\n  if (! get_date_str (header + 6))\n  {\n    /* Record failure of get_date_str. */\n    log_date_header_event(\"get_date_str_failed\", header);\n\n    header[0] = 0;\n\n    /* Record that we are exiting with false after setting header[0]=0. */\n    log_date_header_event(\"exit_false_after_set0\", header);\n    return false;\n  }\n\n  /* Record that get_date_str succeeded. We will now populate the\n     header bytes (including offsets 35..37). We log that these writes\n     will occur, but again we avoid performing pointer arithmetic in the\n     logger itself. */\n  log_date_header_event(\"get_date_str_succeeded\", header);\n  log_date_header_event(\"about_to_write_trailer_offsets_35_36_37\", header);\n\n  header[0] = 'D';\n  header[1] = 'a';\n  header[2] = 't';\n  header[3] = 'e';\n  header[4] = ':';\n  header[5] = ' ';\n\n  /* These writes are the ones reported in the violation scenario. */\n  header[35] = '\\r';\n  header[36] = '\\n';\n  header[37] = 0;\n\n  /* Log that the trailer writes have been performed. */\n  log_date_header_event(\"wrote_trailer_offsets_35_36_37\", header);\n\n  return true;\n}\n"
}