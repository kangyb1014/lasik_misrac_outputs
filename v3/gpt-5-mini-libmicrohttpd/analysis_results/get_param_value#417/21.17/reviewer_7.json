{
  "user_message": "An agent A claimed that the following get_param_value code violates the MISRA C 2023 rule 21.17.\n<misra_rule>\nMISRA C 2023 Rule 21.17 is Use of the string handling functions from <string.h> shall not result in accesses beyond the bounds of the objects referenced by their pointer parameters.\nThis rule strictly applies to the Standard Library functions in <string.h> such as memcpy, memmove, memset, memcmp, strcpy, strncpy, strcat, strncat, strlen, and strspn.\n</misra_rule>\n<target_code>\nHere is the original code of get_param_value.\n```c\nstatic enum PerfRepl_param_result\nget_param_value (const char *param_name, const char *param_tail,\n                 const char *next_param, unsigned int *param_value)\n{\n  const char *value_str;\n  size_t digits;\n  if (0 != param_tail[0])\n  {\n    if ('=' != param_tail[0])\n      value_str = param_tail;\n    else\n      value_str = param_tail + 1;\n  }\n  else\n    value_str = next_param;\n\n  if (NULL != value_str)\n    digits = mhd_tool_str_to_uint (value_str, param_value);\n  else\n    digits = 0;\n\n  if ((0 == digits) || (0 != value_str[digits]))\n  {\n    fprintf (stderr, \"Parameter '%s' is not followed by valid number.\\n\",\n             param_name);\n    return PERF_RPL_PARAM_ERROR;\n  }\n\n  if (0 != param_tail[0])\n    return PERF_RPL_PARAM_FULL_STR;\n\n  return PERF_RPL_PARAM_STR_PLUS_NEXT;\n}\n```\n</target_code>\n<response format>\nProvide your answer with these fields.\n- explanation: your evaluation of the scenario provided by the agent A.\n- is_report_correct: whether the report is correct or not (true/false). True means there is a violation.\n</response format>\n<scenario>\nThe agent A provided the following violation scenario:\nIf param_tail points to the last valid character of its underlying object and that object is not NUL\u2011terminated after that character, then value_str = param_tail + 1 produces a pointer that (when dereferenced or passed to string-handling code) may access memory beyond the object. Example: param_tail points to a one\u2011byte array containing '=' with no following '\\0'. The code takes the '=' branch and sets value_str = param_tail + 1 (one\u2011past\u2011end). A subsequent call (e.g. mhd_tool_str_to_uint or any standard <string.h> routine like strlen/strspn) that reads value_str will access beyond the bounds of the object, violating MISRA C 2023 Rule 21.17.\n</scenario>\n\n<instruction>\nJudge whether the report is correct or not.\n</instruction>\n",
  "is_report_correct": true,
  "explanation": "The report is correct. The code may produce a pointer that is one\u2011past\u2011the\u2011end of the underlying object (value_str = param_tail + 1) when param_tail points to a final character (e.g. '=' ) that is not followed by a terminating NUL. That one\u2011past\u2011end pointer is valid as a pointer value but cannot be dereferenced or used as the start of a NUL\u2011terminated string. The function then passes value_str to mhd_tool_str_to_uint (which presumably reads the pointed\u2011to bytes or calls string.h routines) and later indexes value_str[digits]. If mhd_tool_str_to_uint or any subsequent string-handling routine attempts to read from value_str, it may access memory beyond the object bounds, which is exactly what MISRA C 2023 Rule 21.17 aims to prevent (string handling must not result in accesses beyond object bounds). Even if mhd_tool_str_to_uint is not a standard <string.h> function, the code allows an out\u2011of\u2011bounds read. To fix, ensure param_tail is known to be NUL\u2011terminated before taking param_tail+1 (or prefer using next_param when '=' is the only character, or use bounded parsing that doesn\u2019t rely on NUL termination)."
}