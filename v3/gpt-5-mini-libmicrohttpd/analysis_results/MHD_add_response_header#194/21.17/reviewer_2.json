{
  "user_message": "An agent A claimed that the following MHD_add_response_header code violates the MISRA C 2023 rule 21.17.\n<misra_rule>\nMISRA C 2023 Rule 21.17 is Use of the string handling functions from <string.h> shall not result in accesses beyond the bounds of the objects referenced by their pointer parameters.\nThis rule strictly applies to the Standard Library functions in <string.h> such as memcpy, memmove, memset, memcmp, strcpy, strncpy, strcat, strncat, strlen, and strspn.\n</misra_rule>\n<target_code>\nHere is the original code of MHD_add_response_header.\n```c\n_MHD_EXTERN enum MHD_Result\nMHD_add_response_header (struct MHD_Response *response,\n                         const char *header,\n                         const char *content)\n{\n  if (MHD_str_equal_caseless_ (header, MHD_HTTP_HEADER_CONNECTION))\n    return add_response_header_connection (response, content);\n\n  if (MHD_str_equal_caseless_ (header,\n                               MHD_HTTP_HEADER_TRANSFER_ENCODING))\n  {\n    if (! MHD_str_equal_caseless_ (content, \"chunked\"))\n      return MHD_NO;   /* Only \"chunked\" encoding is allowed */\n    if (0 != (response->flags_auto & MHD_RAF_HAS_TRANS_ENC_CHUNKED))\n      return MHD_YES;  /* Already has \"chunked\" encoding header */\n    if ( (0 != (response->flags_auto & MHD_RAF_HAS_CONTENT_LENGTH)) &&\n         (0 == (MHD_RF_INSANITY_HEADER_CONTENT_LENGTH & response->flags)) )\n      return MHD_NO; /* Has \"Content-Length\" header and no \"Insanity\" flag */\n    if (MHD_NO != add_response_entry (response,\n                                      MHD_HEADER_KIND,\n                                      header,\n                                      content))\n    {\n      response->flags_auto |= MHD_RAF_HAS_TRANS_ENC_CHUNKED;\n      return MHD_YES;\n    }\n    return MHD_NO;\n  }\n  if (MHD_str_equal_caseless_ (header,\n                               MHD_HTTP_HEADER_DATE))\n  {\n    if (0 != (response->flags_auto & MHD_RAF_HAS_DATE_HDR))\n    {\n      struct MHD_HTTP_Res_Header *hdr;\n      hdr = MHD_get_response_element_n_ (response, MHD_HEADER_KIND,\n                                         MHD_HTTP_HEADER_DATE,\n                                         MHD_STATICSTR_LEN_ ( \\\n                                           MHD_HTTP_HEADER_DATE));\n      mhd_assert (NULL != hdr);\n      _MHD_remove_header (response, hdr);\n      if (NULL != hdr->value)\n        free (hdr->value);\n      free (hdr->header);\n      free (hdr);\n    }\n    if (MHD_NO != add_response_entry (response,\n                                      MHD_HEADER_KIND,\n                                      header,\n                                      content))\n    {\n      response->flags_auto |= MHD_RAF_HAS_DATE_HDR;\n      return MHD_YES;\n    }\n    return MHD_NO;\n  }\n\n  if (MHD_str_equal_caseless_ (header,\n                               MHD_HTTP_HEADER_CONTENT_LENGTH))\n  {\n    /* Generally MHD sets automatically correct \"Content-Length\" always when\n     * needed.\n     * Custom \"Content-Length\" header is allowed only in special cases. */\n    if ( (0 != (MHD_RF_INSANITY_HEADER_CONTENT_LENGTH & response->flags)) ||\n         ((0 != (MHD_RF_HEAD_ONLY_RESPONSE & response->flags)) &&\n          (0 == (response->flags_auto & (MHD_RAF_HAS_TRANS_ENC_CHUNKED\n                                         | MHD_RAF_HAS_CONTENT_LENGTH)))) )\n    {\n      if (MHD_NO != add_response_entry (response,\n                                        MHD_HEADER_KIND,\n                                        header,\n                                        content))\n      {\n        response->flags_auto |= MHD_RAF_HAS_CONTENT_LENGTH;\n        return MHD_YES;\n      }\n    }\n    return MHD_NO;\n  }\n\n  return add_response_entry (response,\n                             MHD_HEADER_KIND,\n                             header,\n                             content);\n}\n```\n</target_code>\n<response format>\nProvide your answer with these fields.\n- explanation: your evaluation of the scenario provided by the agent A.\n- is_report_correct: whether the report is correct or not (true/false). True means there is a violation.\n</response format>\n<scenario>\nThe agent A provided the following violation scenario:\nThe call passes raw pointers (header, content) directly into add_response_entry without validating lengths or NUL-termination; if add_response_entry uses <string.h> routines such as strlen, strcpy, strncpy, strcat, memcpy or memmove on those pointers or into fixed-size destination buffers, this can read or write beyond the bounds of the source or destination objects. Example violation: header is not NUL-terminated (or is longer than an internal fixed buffer) and add_response_entry calls strlen(header) or strcpy(dest, header) leading to a read or write past the object bounds.\n</scenario>\n\n<execution_log>\nThe agent A also provided the following output log:\nMHD_add_response_header ENTRY: response=0x55ef0f4d0820 header=0x55eee34f301f content=0x55eee34f302d flags=0x00000000 flags_auto=0x00000000\ndefault: about to call add_response_entry (header=0x55eee34f301f content=0x55eee34f302d)\nMHD_add_response_header ENTRY: response=0x55ef0f4d0820 header=0x55eee34f301f content=0x55eee34f304d flags=0x00000000 flags_auto=0x00000000\ndefault: about to call add_response_entry (header=0x55eee34f301f content=0x55eee34f304d)\nMHD_add_response_header ENTRY: response=0x55ef0f4d0820 header=0x55eee34f301f content=0x55eee34f3087 flags=0x00000000 flags_auto=0x00000000\ndefault: about to call add_response_entry (header=0x55eee34f301f content=0x55eee34f3087)\nMHD_add_response_header ENTRY: response=0x55ef0f4d0820 header=0x55eee34f30f6 content=0x55eee34f3101 flags=0x00000000 flags_auto=0x00000000\nbranch: CONNECTION matched (header=0x55eee34f30f6)\ncall: add_response_header_connection returned 1 for header=0x55eee34f30f6 content=0x55eee34f3101\nMHD_add_response_header ENTRY: response=0x55ef0f4d0820 header=0x55eee34f30f6 content=0x55eee34f318e flags=0x00000000 flags_auto=0x00000000\nbranch: CONNECTION matched (header=0x55eee34f30f6)\ncall: add_response_header_connection returned 1 for header=0x55eee34f30f6 content=0x55eee34f318e\nMHD_add_response_header ENTRY: response=0x55ef0f4d0820 header=0x55eee34f30f6 content=0x55eee34f3240 flags=0x00000000 flags_auto=0x00000000\nbranch: CONNECTION matched (header=0x55eee34f30f6)\ncall: add_response_header_connection returned 1 for header=0x55eee34f30f6 content=0x55eee34f3240\nMHD_add_response_header ENTRY: response=0x55ef0f4d0820 header=0x55eee34f30f6 content=0x55eee34f326f flags=0x00000000 flags_auto=0x00000003\nbranch: CONNECTION matched (header=0x55eee34f30f6)\ncall: add_response_header_connection returned 1 for header=0x55eee34f30f6 content=0x55eee34f326f\nMHD_add_response_header ENTRY: response=0x55ef0f4d0820 header=0x55eee34f30f6 content=0x55eee34f333c flags=0x00000000 flags_auto=0x00000003\nbranch: CONNECTION matched (header=0x55eee34f30f6)\ncall: add_response_header_connection returned 1 for header=0x55eee34f30f6 content=0x55eee34f333c\nMHD_add_response_header ENTRY: response=0x55ef0f4d0820 header=0x55eee34f30f6 content=0x55eee34f395d flags=0x00000000 flags_auto=0x00000001\nbranch: CONNECTION matched (header=0x55eee34f30f6)\ncall: add_response_header_connection returned 1 for header=0x55eee34f30f6 content=0x55eee34f395d\nMHD_add_response_header ENTRY: response=0x55ef0f4d0820 header=0x55eee34f30f6 content=0x55eee34f395d flags=0x00000000 flags_auto=0x00000003\nbranch: CONNECTION matched (header=0x55eee34f30f6)\ncall: add_response_header_connection returned 1 for header=0x55eee34f30f6 content=0x55eee34f395d\nMHD_add_response_header ENTRY: response=0x55ef0f4d0820 header=0x55eee34f30f6 content=0x55eee34f395d flags=0x00000000 flags_auto=0x00000000\nbranch: CONNECTION matched (header=0x55eee34f30f6)\ncall: add_response_header_connection returned 1 for header=0x55eee34f30f6 content=0x55eee34f395d\nMHD_add_response_header ENTRY: response=0x55ef0f4d0820 header=0x55eee34f30f6 content=0x55eee34f395d flags=0x00000000 flags_auto=0x00000003\nbranch: CONNECTION matched (header=0x55eee34f30f6)\ncall: add_response_header_connection returned 1 for header=0x55eee34f30f6 content=0x55eee34f395d\nMHD_add_response_header ENTRY: response=0x55ef0f4d0820 header=0x55eee34f30f6 content=0x55eee34f3570 flags=0x00000000 flags_auto=0x00000000\nbranch: CONNECTION matched (header=0x55eee34f30f6)\ncall: add_response_header_connection returned 1 for header=0x55eee34f30f6 content=0x55eee34f3570\nMHD_add_response_header ENTRY: response=0x55ef0f4d0820 header=0x55eee34f30f6 content=0x55eee34f3595 flags=0x00000000 flags_auto=0x00000003\nbranch: CONNECTION matched (header=0x55eee34f30f6)\ncall: add_response_header_connection returned 1 for header=0x55eee34f30f6 content=0x55eee34f3595\nMHD_add_response_header ENTRY: response=0x55ef0f4d0820 header=0x55eee34f30f6 content=0x55eee34f35ed flags=0x00000000 flags_auto=0x00000000\nbranch: CONNECTION matched (header=0x55eee34f30f6)\ncall: add_response_header_connection returned 1 for header=0x55ee\n</execution_log>\n\n<instruction>\nJudge whether the report is correct or not.\n</instruction>\n",
  "is_report_correct": false,
  "explanation": "The code shown does not itself call any functions from <string.h> (strlen/strcpy/etc.); it only forwards the header and content pointers to helper functions such as add_response_entry and add_response_header_connection. MISRA C:2023 Rule 21.17 restricts the use of the string.h routines so that their use cannot access beyond object bounds. Any violation involving strlen/strcpy/etc. would occur inside the functions that actually invoke those string.h routines (for example add_response_entry), not in MHD_add_response_header merely because it passes pointers onward. Therefore the report that MHD_add_response_header itself violates Rule 21.17 is not correct. That said, to be fully MISRA-compliant the implementation that consumes these pointers (and the function contract) must ensure the inputs are NUL-terminated/within bounds or otherwise guarded; if add_response_entry uses string.h unsafely, the violation belongs to that function."
}