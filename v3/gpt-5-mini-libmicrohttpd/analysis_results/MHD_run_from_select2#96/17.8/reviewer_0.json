{
  "user_message": "An agent A claimed that the following MHD_run_from_select2 code violates the MISRA C 2023 rule 17.8.\n<misra_rule>\nMISRA C 2023 Rule 17.8 is A function parameter should not be modified.\nNote that the object referred to by a pointer parameter may be modified, but the pointer itself shall not be modified.\n</misra_rule>\n<target_code>\nHere is the original code of MHD_run_from_select2.\n```c\n_MHD_EXTERN enum MHD_Result\nMHD_run_from_select2 (struct MHD_Daemon *daemon,\n                      const fd_set *read_fd_set,\n                      const fd_set *write_fd_set,\n                      const fd_set *except_fd_set,\n                      unsigned int fd_setsize)\n{\n  if (MHD_D_IS_USING_POLL_ (daemon) ||\n      MHD_D_IS_USING_THREADS_ (daemon))\n    return MHD_NO;\n  if ((NULL == read_fd_set) || (NULL == write_fd_set))\n    return MHD_NO;\n#ifdef HAVE_MESSAGES\n  if (NULL == except_fd_set)\n  {\n    MHD_DLOG (daemon,\n              _ (\"MHD_run_from_select() called with except_fd_set \"\n                 \"set to NULL. Such behavior is deprecated.\\n\"));\n  }\n#endif /* HAVE_MESSAGES */\n\n#ifdef HAS_FD_SETSIZE_OVERRIDABLE\n  if (0 == fd_setsize)\n    return MHD_NO;\n  else if (((unsigned int) INT_MAX) < fd_setsize)\n    fd_setsize = (unsigned int) INT_MAX;\n#ifdef HAVE_MESSAGES\n  else if (daemon->fdset_size > ((int) fd_setsize))\n  {\n    if (daemon->fdset_size_set_by_app)\n    {\n      MHD_DLOG (daemon,\n                _ (\"%s() called with fd_setsize (%u) \" \\\n                   \"less than value set by MHD_OPTION_APP_FD_SETSIZE (%d). \" \\\n                   \"Some socket FDs may be not processed. \" \\\n                   \"Use MHD_OPTION_APP_FD_SETSIZE with the correct value.\\n\"),\n                \"MHD_run_from_select2\", fd_setsize, daemon->fdset_size);\n    }\n    else\n    {\n      MHD_DLOG (daemon,\n                _ (\"%s() called with fd_setsize (%u) \" \\\n                   \"less than FD_SETSIZE used by MHD (%d). \" \\\n                   \"Some socket FDs may be not processed. \" \\\n                   \"Consider using MHD_OPTION_APP_FD_SETSIZE option.\\n\"),\n                \"MHD_run_from_select2\", fd_setsize, daemon->fdset_size);\n    }\n  }\n#endif /* HAVE_MESSAGES */\n#else  /* ! HAS_FD_SETSIZE_OVERRIDABLE */\n  if (((unsigned int) FD_SETSIZE) > fd_setsize)\n  {\n#ifdef HAVE_MESSAGES\n    MHD_DLOG (daemon,\n              _ (\"%s() called with fd_setsize (%u) \" \\\n                 \"less than fixed FD_SETSIZE value (%d) used on the \" \\\n                 \"platform.\\n\"),\n              \"MHD_run_from_select2\", fd_setsize, (int) FD_SETSIZE);\n#endif /* HAVE_MESSAGES */\n    return MHD_NO;\n  }\n#endif /* ! HAS_FD_SETSIZE_OVERRIDABLE */\n\n  if (MHD_D_IS_USING_EPOLL_ (daemon))\n  {\n#ifdef EPOLL_SUPPORT\n    enum MHD_Result ret = MHD_epoll (daemon,\n                                     0);\n\n    MHD_cleanup_connections (daemon);\n    return ret;\n#else  /* ! EPOLL_SUPPORT */\n    return MHD_NO;\n#endif /* ! EPOLL_SUPPORT */\n  }\n\n  /* Resuming external connections when using an extern mainloop  */\n  if (0 != (daemon->options & MHD_TEST_ALLOW_SUSPEND_RESUME))\n    resume_suspended_connections (daemon);\n\n  return internal_run_from_select (daemon,\n                                   read_fd_set,\n                                   write_fd_set,\n                                   except_fd_set,\n                                   (int) fd_setsize);\n}\n```\n</target_code>\n<response format>\nProvide your answer with these fields.\n- explanation: your evaluation of the scenario provided by the agent A.\n- is_report_correct: whether the report is correct or not (true/false). True means there is a violation.\n</response format>\n<scenario>\nThe agent A provided the following violation scenario:\nIn the HAS_FD_SETSIZE_OVERRIDABLE branch the value parameter 'fd_setsize' is assigned to: 'fd_setsize = (unsigned int) INT_MAX;'. This modifies a function parameter (fd_setsize), violating MISRA C 2023 Rule 17.8.\n</scenario>\n\n<execution_log>\nThe agent A also provided the following output log:\nMHD_run_from_select2: entry: daemon=0x5597837878d0, read_fd_set=0x7ffc3d2f2a20, write_fd_set=0x7ffc3d2f29a0, except_fd_set=0x7ffc3d2f2920, fd_setsize=1024\nMHD_run_from_select2: !HAS_FD_SETSIZE_OVERRIDABLE branch taken, FD_SETSIZE=1024, fd_setsize=1024\nMHD_run_from_select2: calling internal_run_from_select with fd_setsize=1024\nMHD_run_from_select2: entry: daemon=0x5597837878d0, read_fd_set=0x7ffc3d2f2a20, write_fd_set=0x7ffc3d2f29a0, except_fd_set=0x7ffc3d2f2920, fd_setsize=1024\nMHD_run_from_select2: !HAS_FD_SETSIZE_OVERRIDABLE branch taken, FD_SETSIZE=1024, fd_setsize=1024\nMHD_run_from_select2: calling internal_run_from_select with fd_setsize=1024\nMHD_run_from_select2: entry: daemon=0x5597837878d0, read_fd_set=0x7ffc3d2f2a20, write_fd_set=0x7ffc3d2f29a0, except_fd_set=0x7ffc3d2f2920, fd_setsize=1024\nMHD_run_from_select2: !HAS_FD_SETSIZE_OVERRIDABLE branch taken, FD_SETSIZE=1024, fd_setsize=1024\nMHD_run_from_select2: calling internal_run_from_select with fd_setsize=1024\nMHD_run_from_select2: entry: daemon=0x5597837878d0, read_fd_set=0x7ffc3d2f2a20, write_fd_set=0x7ffc3d2f29a0, except_fd_set=0x7ffc3d2f2920, fd_setsize=1024\nMHD_run_from_select2: !HAS_FD_SETSIZE_OVERRIDABLE branch taken, FD_SETSIZE=1024, fd_setsize=1024\nMHD_run_from_select2: calling internal_run_from_select with fd_setsize=1024\nMHD_run_from_select2: entry: daemon=0x5597837878d0, read_fd_set=0x7ffc3d2f2a20, write_fd_set=0x7ffc3d2f29a0, except_fd_set=0x7ffc3d2f2920, fd_setsize=1024\nMHD_run_from_select2: !HAS_FD_SETSIZE_OVERRIDABLE branch taken, FD_SETSIZE=1024, fd_setsize=1024\nMHD_run_from_select2: calling internal_run_from_select with fd_setsize=1024\nMHD_run_from_select2: entry: daemon=0x5597837878d0, read_fd_set=0x7ffc3d2f2a20, write_fd_set=0x7ffc3d2f29a0, except_fd_set=0x7ffc3d2f2920, fd_setsize=1024\nMHD_run_from_select2: !HAS_FD_SETSIZE_OVERRIDABLE branch taken, FD_SETSIZE=1024, fd_setsize=1024\nMHD_run_from_select2: calling internal_run_from_select with fd_setsize=1024\nMHD_run_from_select2: entry: daemon=0x5597837878d0, read_fd_set=0x7ffc3d2f2a20, write_fd_set=0x7ffc3d2f29a0, except_fd_set=0x7ffc3d2f2920, fd_setsize=1024\nMHD_run_from_select2: !HAS_FD_SETSIZE_OVERRIDABLE branch taken, FD_SETSIZE=1024, fd_setsize=1024\nMHD_run_from_select2: calling internal_run_from_select with fd_setsize=1024\nMHD_run_from_select2: entry: daemon=0x5597837878d0, read_fd_set=0x7ffc3d2f2a20, write_fd_set=0x7ffc3d2f29a0, except_fd_set=0x7ffc3d2f2920, fd_setsize=1024\nMHD_run_from_select2: !HAS_FD_SETSIZE_OVERRIDABLE branch taken, FD_SETSIZE=1024, fd_setsize=1024\nMHD_run_from_select2: calling internal_run_from_select with fd_setsize=1024\nMHD_run_from_select2: entry: daemon=0x5597837878d0, read_fd_set=0x7ffc3d2f2a20, write_fd_set=0x7ffc3d2f29a0, except_fd_set=0x7ffc3d2f2920, fd_setsize=1024\nMHD_run_from_select2: !HAS_FD_SETSIZE_OVERRIDABLE branch taken, FD_SETSIZE=1024, fd_setsize=1024\nMHD_run_from_select2: calling internal_run_from_select with fd_setsize=1024\nMHD_run_from_select2: entry: daemon=0x5597837878d0, read_fd_set=0x7ffc3d2f2a20, write_fd_set=0x7ffc3d2f29a0, except_fd_set=0x7ffc3d2f2920, fd_setsize=1024\nMHD_run_from_select2: !HAS_FD_SETSIZE_OVERRIDABLE branch taken, FD_SETSIZE=1024, fd_setsize=1024\nMHD_run_from_select2: calling internal_run_from_select with fd_setsize=1024\nMHD_run_from_select2: entry: daemon=0x5597837878d0, read_fd_set=0x7ffc3d2f2a20, write_fd_set=0x7ffc3d2f29a0, except_fd_set=0x7ffc3d2f2920, fd_setsize=1024\nMHD_run_from_select2: !HAS_FD_SETSIZE_OVERRIDABLE branch taken, FD_SETSIZE=1024, fd_setsize=1024\nMHD_run_from_select2: calling internal_run_from_select with fd_setsize=1024\nMHD_run_from_select2: entry: daemon=0x5597837878d0, read_fd_set=0x7ffc3d2f2a20, write_fd_set=0x7ffc3d2f29a0, except_fd_set=0x7ffc3d2f2920, fd_setsize=1024\nMHD_run_from_select2: !HAS_FD_SETSIZE_OVERRIDABLE branch taken, FD_SETSIZE=1024, fd_setsize=1024\nMHD_run_from_select2: calling internal_run_from_select with fd_setsize=1024\nMHD_run_from_select2: entry: daemon=0x5597837878d0, read_fd_set=0x7ffc3d2f2a20, write_fd_set=0x7ffc3d2f29a0, except_fd_set=0x7ffc3d2f2920, fd_setsize=1024\nMHD_r\n</execution_log>\n\n<instruction>\nJudge whether the report is correct or not.\n</instruction>\n",
  "is_report_correct": true,
  "explanation": "Agent A is correct. MISRA C 2023 Rule 17.8 states that a function parameter shall not be modified. In MHD_run_from_select2 the parameter fd_setsize (type unsigned int) is assigned to in the HAS_FD_SETSIZE_OVERRIDABLE branch: fd_setsize = (unsigned int) INT_MAX; \u2014 this directly modifies the value of a non\u2011pointer function parameter and therefore violates Rule 17.8. Note that the runtime execution log showing the other branch (!HAS_FD_SETSIZE_OVERRIDABLE) does not negate the static violation in the source: the problematic assignment exists in the source when HAS_FD_SETSIZE_OVERRIDABLE is defined. Recommended remediation is to copy the parameter to a local variable and modify that local instead (e.g. unsigned int local_fd_setsize = fd_setsize; \u2026 modify local_fd_setsize \u2026 and pass local_fd_setsize to internal_run_from_select), or otherwise restructure the code so the parameter itself is never assigned to."
}