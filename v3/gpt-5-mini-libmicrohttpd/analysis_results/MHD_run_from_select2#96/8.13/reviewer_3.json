{
  "user_message": "An agent A claimed that the following MHD_run_from_select2 code violates the MISRA C 2023 rule 8.13.\n<misra_rule>\nMISRA C 2023 Rule 8.13 is A pointer should point to a const-qualified type whenever possible.\n\n</misra_rule>\n<target_code>\nHere is the original code of MHD_run_from_select2.\n```c\n_MHD_EXTERN enum MHD_Result\nMHD_run_from_select2 (struct MHD_Daemon *daemon,\n                      const fd_set *read_fd_set,\n                      const fd_set *write_fd_set,\n                      const fd_set *except_fd_set,\n                      unsigned int fd_setsize)\n{\n  if (MHD_D_IS_USING_POLL_ (daemon) ||\n      MHD_D_IS_USING_THREADS_ (daemon))\n    return MHD_NO;\n  if ((NULL == read_fd_set) || (NULL == write_fd_set))\n    return MHD_NO;\n#ifdef HAVE_MESSAGES\n  if (NULL == except_fd_set)\n  {\n    MHD_DLOG (daemon,\n              _ (\"MHD_run_from_select() called with except_fd_set \"\n                 \"set to NULL. Such behavior is deprecated.\\n\"));\n  }\n#endif /* HAVE_MESSAGES */\n\n#ifdef HAS_FD_SETSIZE_OVERRIDABLE\n  if (0 == fd_setsize)\n    return MHD_NO;\n  else if (((unsigned int) INT_MAX) < fd_setsize)\n    fd_setsize = (unsigned int) INT_MAX;\n#ifdef HAVE_MESSAGES\n  else if (daemon->fdset_size > ((int) fd_setsize))\n  {\n    if (daemon->fdset_size_set_by_app)\n    {\n      MHD_DLOG (daemon,\n                _ (\"%s() called with fd_setsize (%u) \" \\\n                   \"less than value set by MHD_OPTION_APP_FD_SETSIZE (%d). \" \\\n                   \"Some socket FDs may be not processed. \" \\\n                   \"Use MHD_OPTION_APP_FD_SETSIZE with the correct value.\\n\"),\n                \"MHD_run_from_select2\", fd_setsize, daemon->fdset_size);\n    }\n    else\n    {\n      MHD_DLOG (daemon,\n                _ (\"%s() called with fd_setsize (%u) \" \\\n                   \"less than FD_SETSIZE used by MHD (%d). \" \\\n                   \"Some socket FDs may be not processed. \" \\\n                   \"Consider using MHD_OPTION_APP_FD_SETSIZE option.\\n\"),\n                \"MHD_run_from_select2\", fd_setsize, daemon->fdset_size);\n    }\n  }\n#endif /* HAVE_MESSAGES */\n#else  /* ! HAS_FD_SETSIZE_OVERRIDABLE */\n  if (((unsigned int) FD_SETSIZE) > fd_setsize)\n  {\n#ifdef HAVE_MESSAGES\n    MHD_DLOG (daemon,\n              _ (\"%s() called with fd_setsize (%u) \" \\\n                 \"less than fixed FD_SETSIZE value (%d) used on the \" \\\n                 \"platform.\\n\"),\n              \"MHD_run_from_select2\", fd_setsize, (int) FD_SETSIZE);\n#endif /* HAVE_MESSAGES */\n    return MHD_NO;\n  }\n#endif /* ! HAS_FD_SETSIZE_OVERRIDABLE */\n\n  if (MHD_D_IS_USING_EPOLL_ (daemon))\n  {\n#ifdef EPOLL_SUPPORT\n    enum MHD_Result ret = MHD_epoll (daemon,\n                                     0);\n\n    MHD_cleanup_connections (daemon);\n    return ret;\n#else  /* ! EPOLL_SUPPORT */\n    return MHD_NO;\n#endif /* ! EPOLL_SUPPORT */\n  }\n\n  /* Resuming external connections when using an extern mainloop  */\n  if (0 != (daemon->options & MHD_TEST_ALLOW_SUSPEND_RESUME))\n    resume_suspended_connections (daemon);\n\n  return internal_run_from_select (daemon,\n                                   read_fd_set,\n                                   write_fd_set,\n                                   except_fd_set,\n                                   (int) fd_setsize);\n}\n```\n</target_code>\n<response format>\nProvide your answer with these fields.\n- explanation: your evaluation of the scenario provided by the agent A.\n- is_report_correct: whether the report is correct or not (true/false). True means there is a violation.\n</response format>\n<scenario>\nThe agent A provided the following violation scenario:\nViolation occurs if internal_run_from_select is declared to take non-const fd_set * parameters. In this function the fd_set pointers are const fd_set *; passing them to a function that accepts fd_set * would discard the const qualifier and therefore violate MISRA C 2023 Rule 8.13. To comply, internal_run_from_select should declare its parameters as const fd_set * if it does not modify the sets.\n</scenario>\n\n<execution_log>\nThe agent A also provided the following output log:\nENTER MHD_run_from_select2: daemon=0x55e343bb08d0 read_fd_set=0x7ffe419e77a0 write_fd_set=0x7ffe419e7720 except_fd_set=0x7ffe419e76a0 fd_setsize=1024\nCALL: internal_run_from_select(daemon=0x55e343bb08d0, read_fd_set=0x7ffe419e77a0, write_fd_set=0x7ffe419e7720, except_fd_set=0x7ffe419e76a0, fd_setsize=1024)\nENTER MHD_run_from_select2: daemon=0x55e343bb08d0 read_fd_set=0x7ffe419e77a0 write_fd_set=0x7ffe419e7720 except_fd_set=0x7ffe419e76a0 fd_setsize=1024\nCALL: internal_run_from_select(daemon=0x55e343bb08d0, read_fd_set=0x7ffe419e77a0, write_fd_set=0x7ffe419e7720, except_fd_set=0x7ffe419e76a0, fd_setsize=1024)\nENTER MHD_run_from_select2: daemon=0x55e343bb08d0 read_fd_set=0x7ffe419e77a0 write_fd_set=0x7ffe419e7720 except_fd_set=0x7ffe419e76a0 fd_setsize=1024\nCALL: internal_run_from_select(daemon=0x55e343bb08d0, read_fd_set=0x7ffe419e77a0, write_fd_set=0x7ffe419e7720, except_fd_set=0x7ffe419e76a0, fd_setsize=1024)\nENTER MHD_run_from_select2: daemon=0x55e343bb08d0 read_fd_set=0x7ffe419e77a0 write_fd_set=0x7ffe419e7720 except_fd_set=0x7ffe419e76a0 fd_setsize=1024\nCALL: internal_run_from_select(daemon=0x55e343bb08d0, read_fd_set=0x7ffe419e77a0, write_fd_set=0x7ffe419e7720, except_fd_set=0x7ffe419e76a0, fd_setsize=1024)\nENTER MHD_run_from_select2: daemon=0x55e343bb08d0 read_fd_set=0x7ffe419e77a0 write_fd_set=0x7ffe419e7720 except_fd_set=0x7ffe419e76a0 fd_setsize=1024\nCALL: internal_run_from_select(daemon=0x55e343bb08d0, read_fd_set=0x7ffe419e77a0, write_fd_set=0x7ffe419e7720, except_fd_set=0x7ffe419e76a0, fd_setsize=1024)\nENTER MHD_run_from_select2: daemon=0x55e343bb08d0 read_fd_set=0x7ffe419e77a0 write_fd_set=0x7ffe419e7720 except_fd_set=0x7ffe419e76a0 fd_setsize=1024\nCALL: internal_run_from_select(daemon=0x55e343bb08d0, read_fd_set=0x7ffe419e77a0, write_fd_set=0x7ffe419e7720, except_fd_set=0x7ffe419e76a0, fd_setsize=1024)\nENTER MHD_run_from_select2: daemon=0x55e343bb08d0 read_fd_set=0x7ffe419e77a0 write_fd_set=0x7ffe419e7720 except_fd_set=0x7ffe419e76a0 fd_setsize=1024\nCALL: internal_run_from_select(daemon=0x55e343bb08d0, read_fd_set=0x7ffe419e77a0, write_fd_set=0x7ffe419e7720, except_fd_set=0x7ffe419e76a0, fd_setsize=1024)\nENTER MHD_run_from_select2: daemon=0x55e343bb08d0 read_fd_set=0x7ffe419e77a0 write_fd_set=0x7ffe419e7720 except_fd_set=0x7ffe419e76a0 fd_setsize=1024\nCALL: internal_run_from_select(daemon=0x55e343bb08d0, read_fd_set=0x7ffe419e77a0, write_fd_set=0x7ffe419e7720, except_fd_set=0x7ffe419e76a0, fd_setsize=1024)\nENTER MHD_run_from_select2: daemon=0x55e343bb08d0 read_fd_set=0x7ffe419e77a0 write_fd_set=0x7ffe419e7720 except_fd_set=0x7ffe419e76a0 fd_setsize=1024\nCALL: internal_run_from_select(daemon=0x55e343bb08d0, read_fd_set=0x7ffe419e77a0, write_fd_set=0x7ffe419e7720, except_fd_set=0x7ffe419e76a0, fd_setsize=1024)\nENTER MHD_run_from_select2: daemon=0x55e343bb08d0 read_fd_set=0x7ffe419e77a0 write_fd_set=0x7ffe419e7720 except_fd_set=0x7ffe419e76a0 fd_setsize=1024\nCALL: internal_run_from_select(daemon=0x55e343bb08d0, read_fd_set=0x7ffe419e77a0, write_fd_set=0x7ffe419e7720, except_fd_set=0x7ffe419e76a0, fd_setsize=1024)\nENTER MHD_run_from_select2: daemon=0x55e343bb08d0 read_fd_set=0x7ffe419e77a0 write_fd_set=0x7ffe419e7720 except_fd_set=0x7ffe419e76a0 fd_setsize=1024\nCALL: internal_run_from_select(daemon=0x55e343bb08d0, read_fd_set=0x7ffe419e77a0, write_fd_set=0x7ffe419e7720, except_fd_set=0x7ffe419e76a0, fd_setsize=1024)\nENTER MHD_run_from_select2: daemon=0x55e343bb08d0 read_fd_set=0x7ffe419e77a0 write_fd_set=0x7ffe419e7720 except_fd_set=0x7ffe419e76a0 fd_setsize=1024\nCALL: internal_run_from_select(daemon=0x55e343bb08d0, read_fd_set=0x7ffe419e77a0, write_fd_set=0x7ffe419e7720, except_fd_set=0x7ffe419e76a0, fd_setsize=1024)\nENTER MHD_run_from_select2: daemon=0x55e343bb08d0 read_fd_set=0x7ffe419e77a0 write_fd_set=0x7ffe419e7720 except_fd_set=0x7ffe419e76a0 fd_setsize=1024\nCALL: internal_run_from_select(daemon=0x55e343bb08d0, read_fd_set=0x7ffe419e77a0, write_fd_set=0x7ffe419e7720, except_fd_set=0x7ffe419e76a0, fd_setsize=1024)\nENTER MHD_run_from_select2: daemon=0x55e343bb08d0 read_fd_set=0x7ffe419e77a0 write_fd_set=0x\n</execution_log>\n\n<instruction>\nJudge whether the report is correct or not.\n</instruction>\n",
  "is_report_correct": true,
  "explanation": "The agent A description is correct in substance but conditional. MHD_run_from_select2 declares the fd_set parameters as const fd_set *; if internal_run_from_select is declared to take plain (non-const) fd_set * parameters then passing these const pointers would discard the const qualifier. That is both a C qualifier-discard (incompatible pointer types unless a cast is used) and contrary to the intent of MISRA C:2023 Rule 8.13 (pointer types should be const-qualified where possible). To fix this, internal_run_from_select should accept const fd_set * parameters if it does not modify the sets. If, on the other hand, internal_run_from_select is already declared to take const fd_set * (or if the call uses an explicit cast documenting why const is discarded), there is no violation. The provided execution log does not show the prototype of internal_run_from_select, so the claim can neither be confirmed nor refuted from the log alone \u2014 but the reported rule violation scenario is correct and would indeed be a MISRA 8.13 violation if internal_run_from_select uses non-const pointers."
}