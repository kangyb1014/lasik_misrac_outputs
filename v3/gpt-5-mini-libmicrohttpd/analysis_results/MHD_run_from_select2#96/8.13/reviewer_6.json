{
  "user_message": "An agent A claimed that the following MHD_run_from_select2 code violates the MISRA C 2023 rule 8.13.\n<misra_rule>\nMISRA C 2023 Rule 8.13 is A pointer should point to a const-qualified type whenever possible.\n\n</misra_rule>\n<target_code>\nHere is the original code of MHD_run_from_select2.\n```c\n_MHD_EXTERN enum MHD_Result\nMHD_run_from_select2 (struct MHD_Daemon *daemon,\n                      const fd_set *read_fd_set,\n                      const fd_set *write_fd_set,\n                      const fd_set *except_fd_set,\n                      unsigned int fd_setsize)\n{\n  if (MHD_D_IS_USING_POLL_ (daemon) ||\n      MHD_D_IS_USING_THREADS_ (daemon))\n    return MHD_NO;\n  if ((NULL == read_fd_set) || (NULL == write_fd_set))\n    return MHD_NO;\n#ifdef HAVE_MESSAGES\n  if (NULL == except_fd_set)\n  {\n    MHD_DLOG (daemon,\n              _ (\"MHD_run_from_select() called with except_fd_set \"\n                 \"set to NULL. Such behavior is deprecated.\\n\"));\n  }\n#endif /* HAVE_MESSAGES */\n\n#ifdef HAS_FD_SETSIZE_OVERRIDABLE\n  if (0 == fd_setsize)\n    return MHD_NO;\n  else if (((unsigned int) INT_MAX) < fd_setsize)\n    fd_setsize = (unsigned int) INT_MAX;\n#ifdef HAVE_MESSAGES\n  else if (daemon->fdset_size > ((int) fd_setsize))\n  {\n    if (daemon->fdset_size_set_by_app)\n    {\n      MHD_DLOG (daemon,\n                _ (\"%s() called with fd_setsize (%u) \" \\\n                   \"less than value set by MHD_OPTION_APP_FD_SETSIZE (%d). \" \\\n                   \"Some socket FDs may be not processed. \" \\\n                   \"Use MHD_OPTION_APP_FD_SETSIZE with the correct value.\\n\"),\n                \"MHD_run_from_select2\", fd_setsize, daemon->fdset_size);\n    }\n    else\n    {\n      MHD_DLOG (daemon,\n                _ (\"%s() called with fd_setsize (%u) \" \\\n                   \"less than FD_SETSIZE used by MHD (%d). \" \\\n                   \"Some socket FDs may be not processed. \" \\\n                   \"Consider using MHD_OPTION_APP_FD_SETSIZE option.\\n\"),\n                \"MHD_run_from_select2\", fd_setsize, daemon->fdset_size);\n    }\n  }\n#endif /* HAVE_MESSAGES */\n#else  /* ! HAS_FD_SETSIZE_OVERRIDABLE */\n  if (((unsigned int) FD_SETSIZE) > fd_setsize)\n  {\n#ifdef HAVE_MESSAGES\n    MHD_DLOG (daemon,\n              _ (\"%s() called with fd_setsize (%u) \" \\\n                 \"less than fixed FD_SETSIZE value (%d) used on the \" \\\n                 \"platform.\\n\"),\n              \"MHD_run_from_select2\", fd_setsize, (int) FD_SETSIZE);\n#endif /* HAVE_MESSAGES */\n    return MHD_NO;\n  }\n#endif /* ! HAS_FD_SETSIZE_OVERRIDABLE */\n\n  if (MHD_D_IS_USING_EPOLL_ (daemon))\n  {\n#ifdef EPOLL_SUPPORT\n    enum MHD_Result ret = MHD_epoll (daemon,\n                                     0);\n\n    MHD_cleanup_connections (daemon);\n    return ret;\n#else  /* ! EPOLL_SUPPORT */\n    return MHD_NO;\n#endif /* ! EPOLL_SUPPORT */\n  }\n\n  /* Resuming external connections when using an extern mainloop  */\n  if (0 != (daemon->options & MHD_TEST_ALLOW_SUSPEND_RESUME))\n    resume_suspended_connections (daemon);\n\n  return internal_run_from_select (daemon,\n                                   read_fd_set,\n                                   write_fd_set,\n                                   except_fd_set,\n                                   (int) fd_setsize);\n}\n```\n</target_code>\n<response format>\nProvide your answer with these fields.\n- explanation: your evaluation of the scenario provided by the agent A.\n- is_report_correct: whether the report is correct or not (true/false). True means there is a violation.\n</response format>\n<scenario>\nThe agent A provided the following violation scenario:\nThe call passes string literals (the format string wrapped by _() and the literal \"MHD_run_from_select2\") and the daemon pointer to MHD_DLOG. If the MHD_DLOG/_() prototypes accept non-const pointer types (e.g. char * for the format or argument strings or struct MHD_Daemon * when the function does not modify the daemon), then pointers that could/should be const-qualified are not const-qualified. For example, a prototype like\n  void MHD_DLOG(struct MHD_Daemon *d, char *fmt, ...);\nshould instead use const qualifiers:\n  void MHD_DLOG(const struct MHD_Daemon *d, const char *fmt, ...);\nWithout such const qualification in the called function's parameter types this call-site usage violates MISRA C:2023 Rule 8.13.\n</scenario>\n\n<execution_log>\nThe agent A also provided the following output log:\nMHD_cleanup_connections called: daemon=0x5585f4ca6820\nMHD_cleanup_connections called: daemon=0x5585f4ca6de0\nMHD_cleanup_connections called: daemon=0x5585f4ca76e0\nMHD_cleanup_connections called: daemon=0x5585f4ca7988\nMHD_cleanup_connections called: daemon=0x5585f4ca76e0\nMHD_cleanup_connections called: daemon=0x5585f4ca7f60\nMHD_cleanup_connections called: daemon=0x5585f4ca83a0\nMHD_cleanup_connections called: daemon=0x5585f4ca87e0\nMHD_cleanup_connections called: daemon=0x5585f4ca9308\nMHD_cleanup_connections called: daemon=0x5585f4ca9060\nMHD_cleanup_connections called: daemon=0x5585f4ca8c20\nMHD_cleanup_connections called: daemon=0x5585f4ca9308\nMHD_cleanup_connections called: daemon=0x5585f4ca9060\nMHD_cleanup_connections called: daemon=0x5594d427d820\ninternal_run_from_select called: daemon=0x5594d427dde0, read=0x7fffae04a068, write=0x7fffae049fe8, except=0x7fffae049f68, fd_setsize=1024\ninternal_run_from_select called: daemon=0x5594d427dde0, read=0x7fffae04a068, write=0x7fffae049fe8, except=0x7fffae049f68, fd_setsize=1024\ninternal_run_from_select called: daemon=0x5594d427dde0, read=0x7fffae04a068, write=0x7fffae049fe8, except=0x7fffae049f68, fd_setsize=1024\ninternal_run_from_select called: daemon=0x5594d427dde0, read=0x7fffae04a068, write=0x7fffae049fe8, except=0x7fffae049f68, fd_setsize=1024\ninternal_run_from_select called: daemon=0x5594d427dde0, read=0x7fffae04a068, write=0x7fffae049fe8, except=0x7fffae049f68, fd_setsize=1024\ninternal_run_from_select called: daemon=0x5594d427dde0, read=0x7fffae04a068, write=0x7fffae049fe8, except=0x7fffae049f68, fd_setsize=1024\ninternal_run_from_select called: daemon=0x5594d427dde0, read=0x7fffae04a068, write=0x7fffae049fe8, except=0x7fffae049f68, fd_setsize=1024\ninternal_run_from_select called: daemon=0x5594d427dde0, read=0x7fffae04a068, write=0x7fffae049fe8, except=0x7fffae049f68, fd_setsize=1024\ninternal_run_from_select called: daemon=0x5594d427dde0, read=0x7fffae04a068, write=0x7fffae049fe8, except=0x7fffae049f68, fd_setsize=1024\ninternal_run_from_select called: daemon=0x5594d427dde0, read=0x7fffae04a068, write=0x7fffae049fe8, except=0x7fffae049f68, fd_setsize=1024\ninternal_run_from_select called: daemon=0x5594d427dde0, read=0x7fffae04a068, write=0x7fffae049fe8, except=0x7fffae049f68, fd_setsize=1024\ninternal_run_from_select called: daemon=0x5594d427dde0, read=0x7fffae04a068, write=0x7fffae049fe8, except=0x7fffae049f68, fd_setsize=1024\ninternal_run_from_select called: daemon=0x5594d427dde0, read=0x7fffae04a068, write=0x7fffae049fe8, except=0x7fffae049f68, fd_setsize=1024\ninternal_run_from_select called: daemon=0x5594d427dde0, read=0x7fffae04a068, write=0x7fffae049fe8, except=0x7fffae049f68, fd_setsize=1024\ninternal_run_from_select called: daemon=0x5594d427dde0, read=0x7fffae04a068, write=0x7fffae049fe8, except=0x7fffae049f68, fd_setsize=1024\nMHD_cleanup_connections called: daemon=0x5594d427dde0\ninternal_run_from_select called: daemon=0x5594d427e440, read=0x7fffae04a068, write=0x7fffae049fe8, except=0x7fffae049f68, fd_setsize=1024\ninternal_run_from_select called: daemon=0x5594d427e440, read=0x7fffae04a068, write=0x7fffae049fe8, except=0x7fffae049f68, fd_setsize=1024\ninternal_run_from_select called: daemon=0x5594d427e440, read=0x7fffae04a068, write=0x7fffae049fe8, except=0x7fffae049f68, fd_setsize=1024\ninternal_run_from_select called: daemon=0x5594d427e440, read=0x7fffae04a068, write=0x7fffae049fe8, except=0x7fffae049f68, fd_setsize=1024\ninternal_run_from_select called: daemon=0x5594d427e440, read=0x7fffae04a068, write=0x7fffae049fe8, except=0x7fffae049f68, fd_setsize=1024\ninternal_run_from_select called: daemon=0x5594d427e440, read=0x7fffae04a068, write=0x7fffae049fe8, except=0x7fffae049f68, fd_setsize=1024\ninternal_run_from_select called: daemon=0x5594d427e440, read=0x7fffae04a068, write=0x7fffae049fe8, except=0x7fffae049f68, fd_setsize=1024\ninternal_run_from_select called: daemon=0x5594d427e440, read=0x7fffae04a068, write=0x7fffae049fe8, except=0x7fffae049f68, fd_setsize=1024\ninternal_run_from_select called: daemon=0x5594d427e440, read=0x7fffae04a068, write=0x7fffae049fe8, except=0x7fff\n</execution_log>\n\n<instruction>\nJudge whether the report is correct or not.\n</instruction>\n",
  "is_report_correct": false,
  "explanation": "MISRA C:2023 Rule 8.13 is a requirement on declarations: pointer types should be const\u2011qualified where possible. The code you show only contains calls to MHD_DLOG and the _() macro; it does not show the declarations/prototypes of MHD_DLOG or of _. Whether there is a rule violation therefore depends entirely on those declarations. If MHD_DLOG (or _) is declared with non\u2011const pointer parameters even though it does not modify the pointees (e.g. char *fmt instead of const char *fmt, or struct MHD_Daemon * when the function does not modify the daemon), then the declarations would violate Rule 8.13 and the agent A\u2019s reasoning would be correct. However, the call sites in the snippet by themselves do not prove a violation. Without the function/prototype definitions you cannot conclude a violation from this code alone. Recommendation: inspect and (if appropriate) update the prototypes of MHD_DLOG and _() to use const (e.g. const char *fmt, and const struct MHD_Daemon * if the function does not modify the daemon) to satisfy Rule 8.13."
}