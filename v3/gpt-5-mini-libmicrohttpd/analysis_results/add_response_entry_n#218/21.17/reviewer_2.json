{
  "user_message": "An agent A claimed that the following add_response_entry_n code violates the MISRA C 2023 rule 21.17.\n<misra_rule>\nMISRA C 2023 Rule 21.17 is Use of the string handling functions from <string.h> shall not result in accesses beyond the bounds of the objects referenced by their pointer parameters.\nThis rule strictly applies to the Standard Library functions in <string.h> such as memcpy, memmove, memset, memcmp, strcpy, strncpy, strcat, strncat, strlen, and strspn.\n</misra_rule>\n<target_code>\nHere is the original code of add_response_entry_n.\n```c\nstatic bool\nadd_response_entry_n (struct MHD_Response *response,\n                      enum MHD_ValueKind kind,\n                      const char *header,\n                      size_t header_len,\n                      const char *content,\n                      size_t content_len)\n{\n  if (NULL == response)\n    return false;\n  if (0 == header_len)\n    return false;\n  if (0 == content_len)\n    return false;\n  if (NULL != memchr (header, '\\t', header_len))\n    return false;\n  if (NULL != memchr (header, ' ', header_len))\n    return false;\n  if (NULL != memchr (header, '\\r', header_len))\n    return false;\n  if (NULL != memchr (header, '\\n', header_len))\n    return false;\n  if (NULL != memchr (content, '\\r', content_len))\n    return false;\n  if (NULL != memchr (content, '\\n', content_len))\n    return false;\n\n  return MHD_add_response_entry_no_check_ (response, kind, header, header_len,\n                                           content, content_len);\n}\n```\n</target_code>\n<response format>\nProvide your answer with these fields.\n- explanation: your evaluation of the scenario provided by the agent A.\n- is_report_correct: whether the report is correct or not (true/false). True means there is a violation.\n</response format>\n<scenario>\nThe agent A provided the following violation scenario:\nCalling add_response_entry_n(response, kind, NULL, 1, content, content_len) (or passing any header pointer that points to an object smaller than header_len) causes memchr(header, ' ', header_len) to access memory beyond the object (dereferencing NULL or reading past the buffer). The code does not validate header != NULL or that header_len does not exceed the actual object size, so this use of memchr can result in out-of-bounds access.\n</scenario>\n\n<execution_log>\nThe agent A also provided the following output log:\nadd_response_entry_n ENTER: response=0x55d49e569820 kind=1 header=0x55d49579601f header_len=13 content=0x55d49579602d content_len=8\nCHECK: memchr(header, '\\t', header_len) with header=0x55d49579601f header_len=13\nRESULT: memchr '\\t' -> (nil)\nCHECK: memchr(header, ' ', header_len) with header=0x55d49579601f header_len=13\nRESULT: memchr ' ' -> (nil)\nCHECK: memchr(header, '\\r', header_len) with header=0x55d49579601f header_len=13\nRESULT: memchr '\\r' -> (nil)\nCHECK: memchr(header, '\\n', header_len) with header=0x55d49579601f header_len=13\nRESULT: memchr '\\n' -> (nil)\nCHECK: memchr(content, '\\r', content_len) with content=0x55d49579602d content_len=8\nRESULT: memchr content '\\r' -> (nil)\nCHECK: memchr(content, '\\n', content_len) with content=0x55d49579602d content_len=8\nRESULT: memchr content '\\n' -> (nil)\nCALL: MHD_add_response_entry_no_check_ with same parameters\nadd_response_entry_n ENTER: response=0x55d49e569820 kind=1 header=0x55d49579601f header_len=13 content=0x55d49579604d content_len=8\nCHECK: memchr(header, '\\t', header_len) with header=0x55d49579601f header_len=13\nRESULT: memchr '\\t' -> (nil)\nCHECK: memchr(header, ' ', header_len) with header=0x55d49579601f header_len=13\nRESULT: memchr ' ' -> (nil)\nCHECK: memchr(header, '\\r', header_len) with header=0x55d49579601f header_len=13\nRESULT: memchr '\\r' -> (nil)\nCHECK: memchr(header, '\\n', header_len) with header=0x55d49579601f header_len=13\nRESULT: memchr '\\n' -> (nil)\nCHECK: memchr(content, '\\r', content_len) with content=0x55d49579604d content_len=8\nRESULT: memchr content '\\r' -> (nil)\nCHECK: memchr(content, '\\n', content_len) with content=0x55d49579604d content_len=8\nRESULT: memchr content '\\n' -> (nil)\nCALL: MHD_add_response_entry_no_check_ with same parameters\nadd_response_entry_n ENTER: response=0x55d49e569820 kind=1 header=0x55d49579601f header_len=13 content=0x55d495796087 content_len=8\nCHECK: memchr(header, '\\t', header_len) with header=0x55d49579601f header_len=13\nRESULT: memchr '\\t' -> (nil)\nCHECK: memchr(header, ' ', header_len) with header=0x55d49579601f header_len=13\nRESULT: memchr ' ' -> (nil)\nCHECK: memchr(header, '\\r', header_len) with header=0x55d49579601f header_len=13\nRESULT: memchr '\\r' -> (nil)\nCHECK: memchr(header, '\\n', header_len) with header=0x55d49579601f header_len=13\nRESULT: memchr '\\n' -> (nil)\nCHECK: memchr(content, '\\r', content_len) with content=0x55d495796087 content_len=8\nRESULT: memchr content '\\r' -> (nil)\nCHECK: memchr(content, '\\n', content_len) with content=0x55d495796087 content_len=8\nRESULT: memchr content '\\n' -> (nil)\nCALL: MHD_add_response_entry_no_check_ with same parameters\nadd_response_entry_n ENTER: response=0x55d49e569820 kind=1 header=0x55d495796a16 header_len=4 content=0x55d495796a1b content_len=29\nCHECK: memchr(header, '\\t', header_len) with header=0x55d495796a16 header_len=4\nRESULT: memchr '\\t' -> (nil)\nCHECK: memchr(header, ' ', header_len) with header=0x55d495796a16 header_len=4\nRESULT: memchr ' ' -> (nil)\nCHECK: memchr(header, '\\r', header_len) with header=0x55d495796a16 header_len=4\nRESULT: memchr '\\r' -> (nil)\nCHECK: memchr(header, '\\n', header_len) with header=0x55d495796a16 header_len=4\nRESULT: memchr '\\n' -> (nil)\nCHECK: memchr(content, '\\r', content_len) with content=0x55d495796a1b content_len=29\nRESULT: memchr content '\\r' -> (nil)\nCHECK: memchr(content, '\\n', content_len) with content=0x55d495796a1b content_len=29\nRESULT: memchr content '\\n' -> (nil)\nCALL: MHD_add_response_entry_no_check_ with same parameters\nadd_response_entry_n ENTER: response=0x55d49e569820 kind=1 header=0x55d495796a16 header_len=4 content=0x55d495796a79 content_len=29\nCHECK: memchr(header, '\\t', header_len) with header=0x55d495796a16 header_len=4\nRESULT: memchr '\\t' -> (nil)\nCHECK: memchr(header, ' ', header_len) with header=0x55d495796a16 header_len=4\nRESULT: memchr ' ' -> (nil)\nCHECK: memchr(header, '\\r', header_len) with header=0x55d495796a16 header_len=4\nRESULT: memchr '\\r' -> (nil)\nCHECK: memchr(header, '\\n', header_len) with header=0x55d495796a16 header_len=4\nRESULT: memchr '\\n' -> (nil)\nCHECK: memchr(content, '\\r', content_len) wi\n</execution_log>\n\n<instruction>\nJudge whether the report is correct or not.\n</instruction>\n",
  "is_report_correct": true,
  "explanation": "The report is correct. Rule 21.17 forbids uses of string.h functions that may access beyond the bounds of the object referenced by their pointer parameters. In this function memchr(header, ..., header_len) and memchr(content, ..., content_len) are called while the code only checks that header_len and content_len are non\u2011zero; it does not check that header and content point to valid objects of at least header_len/content_len bytes (or are non\u2011NULL). Consequently a caller that passes header == NULL with header_len > 0 (or a pointer to a smaller object than header_len) will cause memchr to access out of bounds (undefined behavior), which violates MISRA C 2023 Rule 21.17. Note: memchr(ptr, ..., 0) would be safe even if ptr is NULL, but the code explicitly disallows zero lengths, so that protection is not present. A corrective action is to validate header != NULL and content != NULL (and/or otherwise ensure the contract that callers provide suitably sized objects) before calling memchr."
}