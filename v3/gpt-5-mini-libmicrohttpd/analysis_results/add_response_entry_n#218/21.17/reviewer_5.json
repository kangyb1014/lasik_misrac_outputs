{
  "user_message": "An agent A claimed that the following add_response_entry_n code violates the MISRA C 2023 rule 21.17.\n<misra_rule>\nMISRA C 2023 Rule 21.17 is Use of the string handling functions from <string.h> shall not result in accesses beyond the bounds of the objects referenced by their pointer parameters.\nThis rule strictly applies to the Standard Library functions in <string.h> such as memcpy, memmove, memset, memcmp, strcpy, strncpy, strcat, strncat, strlen, and strspn.\n</misra_rule>\n<target_code>\nHere is the original code of add_response_entry_n.\n```c\nstatic bool\nadd_response_entry_n (struct MHD_Response *response,\n                      enum MHD_ValueKind kind,\n                      const char *header,\n                      size_t header_len,\n                      const char *content,\n                      size_t content_len)\n{\n  if (NULL == response)\n    return false;\n  if (0 == header_len)\n    return false;\n  if (0 == content_len)\n    return false;\n  if (NULL != memchr (header, '\\t', header_len))\n    return false;\n  if (NULL != memchr (header, ' ', header_len))\n    return false;\n  if (NULL != memchr (header, '\\r', header_len))\n    return false;\n  if (NULL != memchr (header, '\\n', header_len))\n    return false;\n  if (NULL != memchr (content, '\\r', content_len))\n    return false;\n  if (NULL != memchr (content, '\\n', content_len))\n    return false;\n\n  return MHD_add_response_entry_no_check_ (response, kind, header, header_len,\n                                           content, content_len);\n}\n```\n</target_code>\n<response format>\nProvide your answer with these fields.\n- explanation: your evaluation of the scenario provided by the agent A.\n- is_report_correct: whether the report is correct or not (true/false). True means there is a violation.\n</response format>\n<scenario>\nThe agent A provided the following violation scenario:\nYes \u2014 the memchr call can access beyond the bounds. The function does not check header != NULL (or that header_len does not exceed the actual object size). If header == NULL and header_len > 0, or if header points to a buffer smaller than header_len, memchr(header, '\\n', header_len) will dereference/scan beyond the object bounds, violating Rule 21.17.\n</scenario>\n\n<execution_log>\nThe agent A also provided the following output log:\nenter add_response_entry_n: response=0x555e150a1820 kind=1 header=0x555e09a1001f header_len=13 content=0x555e09a1002d content_len=8\nabout to memchr check: header for '\t' header=0x555e09a1001f header_len=13\nabout to memchr check: header for ' ' header=0x555e09a1001f header_len=13\nabout to memchr check: header for '\n' header=0x555e09a1001f header_len=13\nabout to memchr check: header for '\n' header=0x555e09a1001f header_len=13\nabout to memchr check: content for '\n' content=0x555e09a1002d content_len=8\nabout to memchr check: content for '\n' content=0x555e09a1002d content_len=8\ncalling MHD_add_response_entry_no_check_\nMHD_add_response_entry_no_check_ returned 1\nenter add_response_entry_n: response=0x555e150a1820 kind=1 header=0x555e09a1001f header_len=13 content=0x555e09a1004d content_len=8\nabout to memchr check: header for '\t' header=0x555e09a1001f header_len=13\nabout to memchr check: header for ' ' header=0x555e09a1001f header_len=13\nabout to memchr check: header for '\n' header=0x555e09a1001f header_len=13\nabout to memchr check: header for '\n' header=0x555e09a1001f header_len=13\nabout to memchr check: content for '\n' content=0x555e09a1004d content_len=8\nabout to memchr check: content for '\n' content=0x555e09a1004d content_len=8\ncalling MHD_add_response_entry_no_check_\nMHD_add_response_entry_no_check_ returned 1\nenter add_response_entry_n: response=0x555e150a1820 kind=1 header=0x555e09a1001f header_len=13 content=0x555e09a10087 content_len=8\nabout to memchr check: header for '\t' header=0x555e09a1001f header_len=13\nabout to memchr check: header for ' ' header=0x555e09a1001f header_len=13\nabout to memchr check: header for '\n' header=0x555e09a1001f header_len=13\nabout to memchr check: header for '\n' header=0x555e09a1001f header_len=13\nabout to memchr check: content for '\n' content=0x555e09a10087 content_len=8\nabout to memchr check: content for '\n' content=0x555e09a10087 content_len=8\ncalling MHD_add_response_entry_no_check_\nMHD_add_response_entry_no_check_ returned 1\nenter add_response_entry_n: response=0x555e150a1820 kind=1 header=0x555e09a10a16 header_len=4 content=0x555e09a10a1b content_len=29\nabout to memchr check: header for '\t' header=0x555e09a10a16 header_len=4\nabout to memchr check: header for ' ' header=0x555e09a10a16 header_len=4\nabout to memchr check: header for '\n' header=0x555e09a10a16 header_len=4\nabout to memchr check: header for '\n' header=0x555e09a10a16 header_len=4\nabout to memchr check: content for '\n' content=0x555e09a10a1b content_len=29\nabout to memchr check: content for '\n' content=0x555e09a10a1b content_len=29\ncalling MHD_add_response_entry_no_check_\nMHD_add_response_entry_no_check_ returned 1\nenter add_response_entry_n: response=0x555e150a1820 kind=1 header=0x555e09a10a16 header_len=4 content=0x555e09a10a79 content_len=29\nabout to memchr check: header for '\t' header=0x555e09a10a16 header_len=4\nabout to memchr check: header for ' ' header=0x555e09a10a16 header_len=4\nabout to memchr check: header for '\n' header=0x555e09a10a16 header_len=4\nabout to memchr check: header for '\n' header=0x555e09a10a16 header_len=4\nabout to memchr check: content for '\n' content=0x555e09a10a79 content_len=29\nabout to memchr check: content for '\n' content=0x555e09a10a79 content_len=29\ncalling MHD_add_response_entry_no_check_\nMHD_add_response_entry_no_check_ returned 1\nenter add_response_entry_n: response=0x555e150a1820 kind=1 header=0x555e09a10af5 header_len=17 content=0x555e09a10b07 content_len=7\nabout to memchr check: header for '\t' header=0x555e09a10af5 header_len=17\nabout to memchr check: header for ' ' header=0x555e09a10af5 header_len=17\nabout to memchr check: header for '\n' header=0x555e09a10af5 header_len=17\nabout to memchr check: header for '\n' header=0x555e09a10af5 header_len=17\nabout to memchr check: content for '\n' content=0x555e09a10b07 content_len=7\nabout to memchr check: content for '\n' content=0x555e09a10b07 content_len=7\ncalling MHD_add_response_entry_no_check_\nMHD_add_response_entry_no_check_ returned 1\nenter add_response_entry_n: response=0x55cd201470c0 kind=1 header=0x55ccfed45ac5 header_len=7 content=0x55ccfe\n</execution_log>\n\n<instruction>\nJudge whether the report is correct or not.\n</instruction>\n",
  "is_report_correct": true,
  "explanation": "The report is correct. memchr(header, \u2026, header_len) and memchr(content, \u2026, content_len) will read up to header_len/content_len bytes starting at the given pointer. The function only checks that the lengths are non\u2011zero, it does not check that header and content are non\u2011NULL or that they refer to objects at least that large. If header == NULL with header_len > 0 (or the pointer refers to a smaller object), memchr will access out of bounds (undefined behavior), which violates MISRA C 2023 Rule 21.17. Note: the code could be acceptable only if there is a proved external precondition that every non\u2011zero length implies a valid pointer to at least that many bytes; absent such a guaranteed and verifiable contract, the code is non\u2011compliant. To fix: verify header != NULL and content != NULL (and/or otherwise ensure the pointer/length relationship is guaranteed), or document and enforce the precondition so static analysis can prove the call is safe."
}