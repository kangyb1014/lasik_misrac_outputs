{
  "user_message": "An agent A claimed that the following add_response_entry_n code violates the MISRA C 2023 rule 21.17.\n<misra_rule>\nMISRA C 2023 Rule 21.17 is Use of the string handling functions from <string.h> shall not result in accesses beyond the bounds of the objects referenced by their pointer parameters.\nThis rule strictly applies to the Standard Library functions in <string.h> such as memcpy, memmove, memset, memcmp, strcpy, strncpy, strcat, strncat, strlen, and strspn.\n</misra_rule>\n<target_code>\nHere is the original code of add_response_entry_n.\n```c\nstatic bool\nadd_response_entry_n (struct MHD_Response *response,\n                      enum MHD_ValueKind kind,\n                      const char *header,\n                      size_t header_len,\n                      const char *content,\n                      size_t content_len)\n{\n  if (NULL == response)\n    return false;\n  if (0 == header_len)\n    return false;\n  if (0 == content_len)\n    return false;\n  if (NULL != memchr (header, '\\t', header_len))\n    return false;\n  if (NULL != memchr (header, ' ', header_len))\n    return false;\n  if (NULL != memchr (header, '\\r', header_len))\n    return false;\n  if (NULL != memchr (header, '\\n', header_len))\n    return false;\n  if (NULL != memchr (content, '\\r', content_len))\n    return false;\n  if (NULL != memchr (content, '\\n', content_len))\n    return false;\n\n  return MHD_add_response_entry_no_check_ (response, kind, header, header_len,\n                                           content, content_len);\n}\n```\n</target_code>\n<response format>\nProvide your answer with these fields.\n- explanation: your evaluation of the scenario provided by the agent A.\n- is_report_correct: whether the report is correct or not (true/false). True means there is a violation.\n</response format>\n<scenario>\nThe agent A provided the following violation scenario:\nPotential violation: the call passes 'header' and 'content' pointers with explicit lengths, but there is no guarantee these buffers are NUL-terminated. If MHD_add_response_entry_no_check_ internally uses any <string.h> functions that expect NUL-terminated strings (e.g. strlen, strcpy, strcat, strncat) or otherwise reads beyond the provided header_len/content_len, that would result in out\u2011of\u2011bounds accesses. The wrapper did not enforce NUL-termination or the actual object sizes, so a callee that ignores the provided lengths can violate Rule 21.17.\n</scenario>\n\n<execution_log>\nThe agent A also provided the following output log:\nEVENT: entry\nNOTE: function entry\nresponse_ptr=0x55a72b004820 kind=1\nheader_ptr=0x55a70a77001f header_len=13\ncontent_ptr=0x55a70a77002d content_len=8\nheader_has_nul_within_len=no\nheader_sample_hex: 48 65 61 64 65 72 2D 54 79 70 65 2D 41\ncontent_has_nul_within_len=no\ncontent_sample_hex: 76 61 6C 75 65 2D 61 31\n----\nEVENT: call_downstream\nNOTE: calling MHD_add_response_entry_no_check_\nresponse_ptr=0x55a72b004820 kind=1\nheader_ptr=0x55a70a77001f header_len=13\ncontent_ptr=0x55a70a77002d content_len=8\nheader_has_nul_within_len=no\nheader_sample_hex: 48 65 61 64 65 72 2D 54 79 70 65 2D 41\ncontent_has_nul_within_len=no\ncontent_sample_hex: 76 61 6C 75 65 2D 61 31\n----\nEVENT: downstream_return\nNOTE: downstream returned true\nresponse_ptr=0x55a72b004820 kind=1\nheader_ptr=0x55a70a77001f header_len=13\ncontent_ptr=0x55a70a77002d content_len=8\nheader_has_nul_within_len=no\nheader_sample_hex: 48 65 61 64 65 72 2D 54 79 70 65 2D 41\ncontent_has_nul_within_len=no\ncontent_sample_hex: 76 61 6C 75 65 2D 61 31\n----\nEVENT: entry\nNOTE: function entry\nresponse_ptr=0x55a72b004820 kind=1\nheader_ptr=0x55a70a77001f header_len=13\ncontent_ptr=0x55a70a77004d content_len=8\nheader_has_nul_within_len=no\nheader_sample_hex: 48 65 61 64 65 72 2D 54 79 70 65 2D 41\ncontent_has_nul_within_len=no\ncontent_sample_hex: 76 61 6C 75 65 2D 61 32\n----\nEVENT: call_downstream\nNOTE: calling MHD_add_response_entry_no_check_\nresponse_ptr=0x55a72b004820 kind=1\nheader_ptr=0x55a70a77001f header_len=13\ncontent_ptr=0x55a70a77004d content_len=8\nheader_has_nul_within_len=no\nheader_sample_hex: 48 65 61 64 65 72 2D 54 79 70 65 2D 41\ncontent_has_nul_within_len=no\ncontent_sample_hex: 76 61 6C 75 65 2D 61 32\n----\nEVENT: downstream_return\nNOTE: downstream returned true\nresponse_ptr=0x55a72b004820 kind=1\nheader_ptr=0x55a70a77001f header_len=13\ncontent_ptr=0x55a70a77004d content_len=8\nheader_has_nul_within_len=no\nheader_sample_hex: 48 65 61 64 65 72 2D 54 79 70 65 2D 41\ncontent_has_nul_within_len=no\ncontent_sample_hex: 76 61 6C 75 65 2D 61 32\n----\nEVENT: entry\nNOTE: function entry\nresponse_ptr=0x55a72b004820 kind=1\nheader_ptr=0x55a70a77001f header_len=13\ncontent_ptr=0x55a70a770087 content_len=8\nheader_has_nul_within_len=no\nheader_sample_hex: 48 65 61 64 65 72 2D 54 79 70 65 2D 41\ncontent_has_nul_within_len=no\ncontent_sample_hex: 76 61 6C 75 65 2D 61 33\n----\nEVENT: call_downstream\nNOTE: calling MHD_add_response_entry_no_check_\nresponse_ptr=0x55a72b004820 kind=1\nheader_ptr=0x55a70a77001f header_len=13\ncontent_ptr=0x55a70a770087 content_len=8\nheader_has_nul_within_len=no\nheader_sample_hex: 48 65 61 64 65 72 2D 54 79 70 65 2D 41\ncontent_has_nul_within_len=no\ncontent_sample_hex: 76 61 6C 75 65 2D 61 33\n----\nEVENT: downstream_return\nNOTE: downstream returned true\nresponse_ptr=0x55a72b004820 kind=1\nheader_ptr=0x55a70a77001f header_len=13\ncontent_ptr=0x55a70a770087 content_len=8\nheader_has_nul_within_len=no\nheader_sample_hex: 48 65 61 64 65 72 2D 54 79 70 65 2D 41\ncontent_has_nul_within_len=no\ncontent_sample_hex: 76 61 6C 75 65 2D 61 33\n----\nEVENT: entry\nNOTE: function entry\nresponse_ptr=0x55a72b004820 kind=1\nheader_ptr=0x55a70a770a16 header_len=4\ncontent_ptr=0x55a70a770a1b content_len=29\nheader_has_nul_within_len=no\nheader_sample_hex: 44 61 74 65\ncontent_has_nul_within_len=no\ncontent_sample_hex: 57 65 64 2C 20 30 31 20 41 70 72 20 32 30 31 35 20 30 30 3A 30 30 3A 30 30 20 47 4D 54\n----\nEVENT: call_downstream\nNOTE: calling MHD_add_response_entry_no_check_\nresponse_ptr=0x55a72b004820 kind=1\nheader_ptr=0x55a70a770a16 header_len=4\ncontent_ptr=0x55a70a770a1b content_len=29\nheader_has_nul_within_len=no\nheader_sample_hex: 44 61 74 65\ncontent_has_nul_within_len=no\ncontent_sample_hex: 57 65 64 2C 20 30 31 20 41 70 72 20 32 30 31 35 20 30 30 3A 30 30 3A 30 30 20 47 4D 54\n----\nEVENT: downstream_return\nNOTE: downstream returned true\nresponse_ptr=0x55a72b004820 kind=1\nheader_ptr=0x55a70a770a16 header_len=4\ncontent_ptr=0x55a70a770a1b content_len=29\nheader_has_nul_within_len=no\nheader_sample_hex: 44 61 74 65\ncontent_has_nul_within_len=no\ncontent_sample_hex: 57 65 64 2C 20 30 31 20 41 70 72 20 32 30 31 35 20 30 30\n</execution_log>\n\n<instruction>\nJudge whether the report is correct or not.\n</instruction>\n",
  "is_report_correct": false,
  "explanation": "The reported violation is not correct for this function itself. add_response_entry_n only uses memchr (from <string.h>) with explicit length arguments, and it validates header_len and content_len are non\u2011zero before use. memchr(header, c, header_len) and memchr(content, c, content_len) are bounded and cannot read beyond the supplied sizes. The function does pass the pointers along with their explicit lengths to MHD_add_response_entry_no_check_. If that downstream function were to ignore the provided lengths and call string functions that expect NUL\u2011terminated strings (e.g. strlen/strcpy) then that downstream function would be the location of a Rule 21.17 violation \u2014 not add_response_entry_n. To avoid ambiguity, the API contract should document that callers pass lengths and the callee must respect them or require NUL termination. But based on the code shown, there is no violation in add_response_entry_n itself."
}