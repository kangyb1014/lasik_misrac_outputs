{
  "user_message": "An agent A claimed that the following parse_cookies_string code violates the MISRA C 2023 rule 8.13.\n<misra_rule>\nMISRA C 2023 Rule 8.13 is A pointer should point to a const-qualified type whenever possible.\n\n</misra_rule>\n<target_code>\nHere is the original code of parse_cookies_string.\n```c\nstatic enum _MHD_ParseCookie\nparse_cookies_string (char *str,\n                      const size_t str_len,\n                      struct MHD_Connection *connection)\n{\n  size_t i;\n  bool non_strict;\n  /* Skip extra whitespaces and empty cookies */\n  const bool allow_wsp_empty = (0 >= connection->daemon->client_discipline);\n  /* Allow whitespaces around '=' character */\n  const bool wsp_around_eq = (-3 >= connection->daemon->client_discipline);\n  /* Allow whitespaces in quoted cookie value */\n  const bool wsp_in_quoted = (-2 >= connection->daemon->client_discipline);\n  /* Allow tab as space after semicolon between cookies */\n  const bool tab_as_sp = (0 >= connection->daemon->client_discipline);\n  /* Allow no space after semicolon between cookies */\n  const bool allow_no_space = (0 >= connection->daemon->client_discipline);\n\n  non_strict = false;\n  i = 0;\n  while (i < str_len)\n  {\n    size_t name_start;\n    size_t name_len;\n    size_t value_start;\n    size_t value_len;\n    bool val_quoted;\n    /* Skip any whitespaces and empty cookies */\n    while (' ' == str[i] || '\\t' == str[i] || ';' == str[i])\n    {\n      if (! allow_wsp_empty)\n        return MHD_PARSE_COOKIE_MALFORMED;\n      non_strict = true;\n      i++;\n      if (i == str_len)\n        return non_strict? MHD_PARSE_COOKIE_OK_LAX : MHD_PARSE_COOKIE_OK;\n    }\n    /* 'i' must point to the first char of cookie-name */\n    name_start = i;\n    /* Find the end of the cookie-name */\n    do\n    {\n      const char l = str[i];\n      if (('=' == l) || (' ' == l) || ('\\t' == l) || ('\"' == l) || (',' == l) ||\n          (';' == l) || (0 == l))\n        break;\n    } while (str_len > ++i);\n    name_len = i - name_start;\n    /* Skip any whitespaces */\n    while (str_len > i && (' ' == str[i] || '\\t' == str[i]))\n    {\n      if (! wsp_around_eq)\n        return MHD_PARSE_COOKIE_MALFORMED;\n      non_strict = true;\n      i++;\n    }\n    if ((str_len == i) || ('=' != str[i]) || (0 == name_len))\n      return MHD_PARSE_COOKIE_MALFORMED; /* Incomplete cookie name */\n    /* 'i' must point to the '=' char */\n    mhd_assert ('=' == str[i]);\n    i++;\n    /* Skip any whitespaces */\n    while (str_len > i && (' ' == str[i] || '\\t' == str[i]))\n    {\n      if (! wsp_around_eq)\n        return MHD_PARSE_COOKIE_MALFORMED;\n      non_strict = true;\n      i++;\n    }\n    /* 'i' must point to the first char of cookie-value */\n    if (str_len == i)\n    {\n      value_start = 0;\n      value_len = 0;\n#ifdef _DEBUG\n      val_quoted = false; /* This assignment used in assert */\n#endif\n    }\n    else\n    {\n      bool valid_cookie;\n      val_quoted = ('\"' == str[i]);\n      if (val_quoted)\n        i++;\n      value_start = i;\n      /* Find the end of the cookie-value */\n      while (str_len > i)\n      {\n        const char l = str[i];\n        if ((';' == l) || ('\"' == l) || (',' == l) || (';' == l) ||\n            ('\\\\' == l) || (0 == l))\n          break;\n        if ((' ' == l) || ('\\t' == l))\n        {\n          if (! val_quoted)\n            break;\n          if (! wsp_in_quoted)\n            return MHD_PARSE_COOKIE_MALFORMED;\n          non_strict = true;\n        }\n        i++;\n      }\n      value_len = i - value_start;\n      if (val_quoted)\n      {\n        if ((str_len == i) || ('\"' != str[i]))\n          return MHD_PARSE_COOKIE_MALFORMED; /* Incomplete cookie value, no closing quote */\n        i++;\n      }\n      /* Skip any whitespaces */\n      if ((str_len > i) && ((' ' == str[i]) || ('\\t' == str[i])))\n      {\n        do\n        {\n          i++;\n        } while (str_len > i && (' ' == str[i] || '\\t' == str[i]));\n        /* Whitespace at the end? */\n        if (str_len > i)\n        {\n          if (! allow_wsp_empty)\n            return MHD_PARSE_COOKIE_MALFORMED;\n          non_strict = true;\n        }\n      }\n      if (str_len == i)\n        valid_cookie = true;\n      else if (';' == str[i])\n        valid_cookie = true;\n      else\n        valid_cookie = false;\n\n      if (! valid_cookie)\n        return MHD_PARSE_COOKIE_MALFORMED; /* Garbage at the end of the cookie value */\n    }\n    mhd_assert (0 != name_len);\n    str[name_start + name_len] = 0; /* Zero-terminate the name */\n    if (0 != value_len)\n    {\n      mhd_assert (value_start + value_len <= str_len);\n      str[value_start + value_len] = 0; /* Zero-terminate the value */\n      if (MHD_NO ==\n          MHD_set_connection_value_n_nocheck_ (connection,\n                                               MHD_COOKIE_KIND,\n                                               str + name_start,\n                                               name_len,\n                                               str + value_start,\n                                               value_len))\n        return MHD_PARSE_COOKIE_NO_MEMORY;\n    }\n    else\n    {\n      if (MHD_NO ==\n          MHD_set_connection_value_n_nocheck_ (connection,\n                                               MHD_COOKIE_KIND,\n                                               str + name_start,\n                                               name_len,\n                                               \"\",\n                                               0))\n        return MHD_PARSE_COOKIE_NO_MEMORY;\n    }\n    if (str_len > i)\n    {\n      mhd_assert (0 == str[i] || ';' == str[i]);\n      mhd_assert (! val_quoted || ';' == str[i]);\n      mhd_assert (';' != str[i] || val_quoted || non_strict || 0 == value_len);\n      i++;\n      if (str_len == i)\n      { /* No next cookie after semicolon */\n        if (! allow_wsp_empty)\n          return MHD_PARSE_COOKIE_MALFORMED;\n        non_strict = true;\n      }\n      else if (' ' != str[i])\n      {/* No space after semicolon */\n        if (('\\t' == str[i]) && tab_as_sp)\n          i++;\n        else if (! allow_no_space)\n          return MHD_PARSE_COOKIE_MALFORMED;\n        non_strict = true;\n      }\n      else\n      {\n        i++;\n        if (str_len == i)\n        {\n          if (! allow_wsp_empty)\n            return MHD_PARSE_COOKIE_MALFORMED;\n          non_strict = true;\n        }\n      }\n    }\n  }\n  return non_strict? MHD_PARSE_COOKIE_OK_LAX : MHD_PARSE_COOKIE_OK;\n}\n```\n</target_code>\n<response format>\nProvide your answer with these fields.\n- explanation: your evaluation of the scenario provided by the agent A.\n- is_report_correct: whether the report is correct or not (true/false). True means there is a violation.\n</response format>\n<scenario>\nThe agent A provided the following violation scenario:\nThe call passes mutable char * pointers (str + name_start, str + value_start) into MHD_set_connection_value_n_nocheck_. If that function's prototype declares the corresponding parameters as char * (non-const) even though it does not modify the pointed-to characters, then the pointers should be to const-qualified types. In that case the code violates MISRA C 2023 Rule 8.13 because the function parameter types (and thus the pointers used) are not const-qualified when they could be.\n</scenario>\n\n<instruction>\nJudge whether the report is correct or not.\n</instruction>\n",
  "is_report_correct": false,
  "explanation": "Not correct. parse_cookies_string explicitly modifies the buffer pointed-to by str (e.g. str[name_start + name_len] = 0 and str[value_start + value_len] = 0), so the pointer cannot reasonably be const-qualified in this function. MISRA 8.13 requires pointers to point to const-qualified types when the pointed-to object is not modified; here the object is modified, so no violation in this caller. If MHD_set_connection_value_n_nocheck_ is declared to take non-const char * but in fact does not modify the characters, then that function\u2019s prototype (or its implementation) would be the place to consider adding const and could be a separate 8.13 concern \u2014 but that is not a violation by parse_cookies_string itself."
}