{
  "user_message": "<misra_rule>\nMISRA C 2023 Rule 2.2 is: A project shall not contain dead code.\nAny operation that is executed but whose removal would not affect program behaviour constitutes dead code. Notes:\n1. The behaviour of an embedded sytem is often determined not just by the nature of its actions, but also by the time at which they occur.\n2. unreachable code is not dead code, as it cannot be executed.\n3.Initialization is not the same as an assignment operation and is therfore not a candidate for dead code.\n</misra_rule>\n\nAnother agent reported that the target code violated the Rule 2.2.\nHere is the comment from the agent.\n<violation scenario>\nIf mhd_assert is enabled at runtime (i.e. it expands to code that performs the check) and the program logic guarantees c->connection_timeout_ms (timeout) is never zero (for example it is initialized to a non\u2011zero value and never modified to zero elsewhere), then the assertion will always evaluate true, will always execute, and its removal would not affect program behaviour. In that situation the statement is dead code and thus violates MISRA C 2023 Rule 2.2. Note: if mhd_assert is compiled out (expands to nothing) then it is not executed and does not constitute dead code.\n</violation scenario>\n\nYour job is to insert logging code to capture the control flow and state information of the program.\nInsert logging code so that other agents can reproduce and get evidence for the violation scenario.\n<response format>\n- test_code: a modified connection_get_wait code that contains useful probe functions that print useful logs to a file \"/tmp/logs/1082.txt\". The logs should contain the control path and state information of the violation scenario. If test code is not required to validate the scenario, you can leave this blank.\nHere are the constraints for the test code:\n- The test code MUST preserve the original logic of connection_get_wait as much as possible.\nYou CAN just insert probe functions to the original code.\n- DO NOT introduce new violations to demonstrate your scenario.\n- The test code MUST be compilable and executable.\n- The test code MUST include line breaks.\n- You MUST NOT define the main function.\n- You MUST NOT define macros.\n</response format>\n<target_code>\nHere is the code of connection_get_wait:\n```c\nstatic uint64_t\nconnection_get_wait (struct MHD_Connection *c)\n{\n  const uint64_t now = MHD_monotonic_msec_counter ();\n  const uint64_t since_actv = now - c->last_activity;\n  const uint64_t timeout = c->connection_timeout_ms;\n  uint64_t mseconds_left;\n\n  mhd_assert (0 != timeout);\n  /* Keep the next lines in sync with #connection_check_timedout() to avoid\n   * undesired side-effects like busy-waiting. */\n  if (timeout < since_actv)\n  {\n    if (UINT64_MAX / 2 < since_actv)\n    {\n      const uint64_t jump_back = c->last_activity - now;\n      /* Very unlikely that it is more than quarter-million years pause.\n       * More likely that system clock jumps back. */\n      if (5000 >= jump_back)\n      { /* Jump back is less than 5 seconds, try to recover. */\n        return 100; /* Set wait time to 0.1 seconds */\n      }\n      /* Too large jump back */\n    }\n    return 0; /* Connection has timed out */\n  }\n  else if (since_actv == timeout)\n  {\n    /* Exact match for timeout and time from last activity.\n     * Maybe this is just a precise match or this happens because the timer\n     * resolution is too low.\n     * Set wait time to 0.1 seconds to avoid busy-waiting with low\n     * timer resolution as connection is not timed-out yet. */\n    return 100;\n  }\n  mseconds_left = timeout - since_actv;\n\n  return mseconds_left;\n}\n```\n</target_code>\nPlease provide the modified connection_get_wait code.\n",
  "test_code": "#include <stdio.h>\n#include <stdint.h>\n#include <inttypes.h>\n\n/* Minimal struct definition to allow standalone compilation for testing.\n * In the real project, the full struct is defined elsewhere. */\nstruct MHD_Connection\n{\n  uint64_t last_activity;\n  uint64_t connection_timeout_ms;\n};\n\n/* Probe logging helper. Appends detailed info to /tmp/logs/1082.txt so other\n * agents can inspect control flow and state for the violation scenario. */\nstatic void\nprobe_log(const char *label,\n          const struct MHD_Connection *c,\n          uint64_t now,\n          uint64_t since_actv,\n          uint64_t timeout,\n          uint64_t mseconds_left,\n          const char *path)\n{\n  FILE *f = fopen(\"/tmp/logs/1082.txt\", \"a\");\n  if (f == NULL)\n  {\n    return;\n  }\n\n  fprintf(f, \"[connection_get_wait] %s | path=%s\\n\", label, path);\n  if (c != NULL)\n  {\n    fprintf(f, \"  last_activity=%\" PRIu64 \"\\n\", c->last_activity);\n    fprintf(f, \"  connection_timeout_ms=%\" PRIu64 \"\\n\", c->connection_timeout_ms);\n  }\n  fprintf(f, \"  now=%\" PRIu64 \"\\n\", now);\n  fprintf(f, \"  since_actv=%\" PRIu64 \"\\n\", since_actv);\n  fprintf(f, \"  timeout=%\" PRIu64 \"\\n\", timeout);\n  fprintf(f, \"  mseconds_left=%\" PRIu64 \"\\n\", mseconds_left);\n  fprintf(f, \"---\\n\");\n  fclose(f);\n}\n\n/* Provide a minimal mhd_assert implementation for this test code so the\n * compilation is self-contained. This stub logs the assertion evaluation so\n * that agents can see whether the assertion is always true (the violation\n * scenario) or not. In the real product mhd_assert may be a macro that\n * aborts on failure; we intentionally keep it non-aborting here to avoid\n * changing control flow too much for logging. */\nstatic void\nmhd_assert(int cond)\n{\n  /* Log that the assertion was evaluated and its boolean result. */\n  probe_log(\"mhd_assert\", NULL, 0ULL, 0ULL, (uint64_t)cond, 0ULL,\n            cond ? \"assert_true\" : \"assert_false\");\n  /* Do not abort here to allow the calling function to continue and log\n   * further state for diagnosis. */\n}\n\n/* Minimal stub for monotonic counter to allow standalone compilation.\n * In integration, the real MHD_monotonic_msec_counter() will be used. */\nstatic uint64_t\nMHD_monotonic_msec_counter(void)\n{\n  /* For standalone compilation this returns 0. Tests can override or link\n   * with the real implementation in the build system. */\n  return 0ULL;\n}\n\nstatic uint64_t\nconnection_get_wait (struct MHD_Connection *c)\n{\n  const uint64_t now = MHD_monotonic_msec_counter ();\n  const uint64_t since_actv = now - c->last_activity;\n  const uint64_t timeout = c->connection_timeout_ms;\n  uint64_t mseconds_left;\n\n  /* Log entry state before the assertion so we capture values that make the\n   * assertion redundant (the reported violation scenario). */\n  probe_log(\"entry\", c, now, since_actv, timeout, 0ULL, \"before_assert\");\n\n  mhd_assert (0 != timeout);\n\n  /* Keep the next lines in sync with #connection_check_timedout() to avoid\n   * undesired side-effects like busy-waiting. */\n  if (timeout < since_actv)\n  {\n    if (UINT64_MAX / 2 < since_actv)\n    {\n      const uint64_t jump_back = c->last_activity - now;\n      /* Very unlikely that it is more than quarter-million years pause.\n       * More likely that system clock jumps back. */\n      if (5000 >= jump_back)\n      { /* Jump back is less than 5 seconds, try to recover. */\n        probe_log(\"branch\", c, now, since_actv, timeout, 100ULL,\n                  \"jump_back_recover_return_100\");\n        return 100; /* Set wait time to 0.1 seconds */\n      }\n      /* Too large jump back */\n    }\n    probe_log(\"branch\", c, now, since_actv, timeout, 0ULL,\n              \"timed_out_return_0\");\n    return 0; /* Connection has timed out */\n  }\n  else if (since_actv == timeout)\n  {\n    /* Exact match for timeout and time from last activity.\n     * Maybe this is just a precise match or this happens because the timer\n     * resolution is too low.\n     * Set wait time to 0.1 seconds to avoid busy-waiting with low\n     * timer resolution as connection is not timed-out yet. */\n    probe_log(\"branch\", c, now, since_actv, timeout, 100ULL,\n              \"exact_match_return_100\");\n    return 100;\n  }\n  mseconds_left = timeout - since_actv;\n\n  probe_log(\"exit\", c, now, since_actv, timeout, mseconds_left, \"return_left\");\n\n  return mseconds_left;\n}\n"
}