{
  "user_message": "<target code>Here is the code that failed to compile:\n```c\nstatic void\nprobe_log(const char *label,\n          const struct MHD_Connection *c,\n          uint64_t now,\n          uint64_t since_actv,\n          uint64_t timeout,\n          uint64_t mseconds_left,\n          const char *path)\n{\n  FILE *f = fopen(\"/tmp/logs/1082.txt\", \"a\");\n  if (f == NULL)\n  {\n    return;\n  }\n\n  fprintf(f, \"[connection_get_wait] %s | path=%s\\n\", label, path);\n  if (c != NULL)\n  {\n    fprintf(f, \"  last_activity=%\" PRIu64 \"\\n\", c->last_activity);\n    fprintf(f, \"  connection_timeout_ms=%\" PRIu64 \"\\n\", c->connection_timeout_ms);\n  }\n  fprintf(f, \"  now=%\" PRIu64 \"\\n\", now);\n  fprintf(f, \"  since_actv=%\" PRIu64 \"\\n\", since_actv);\n  fprintf(f, \"  timeout=%\" PRIu64 \"\\n\", timeout);\n  fprintf(f, \"  mseconds_left=%\" PRIu64 \"\\n\", mseconds_left);\n  fprintf(f, \"---\\n\");\n  fclose(f);\n}\nstatic void\nmhd_assert(int cond)\n{\n  /* Log that the assertion was evaluated and its boolean result. */\n  probe_log(\"mhd_assert\", NULL, 0ULL, 0ULL, (uint64_t)cond, 0ULL,\n            cond ? \"assert_true\" : \"assert_false\");\n  /* Do not abort here to allow the calling function to continue and log\n   * further state for diagnosis. */\n}\n\nstatic uint64_t\nconnection_get_wait (struct MHD_Connection *c)\n{\n  const uint64_t now = MHD_monotonic_msec_counter ();\n  const uint64_t since_actv = now - c->last_activity;\n  const uint64_t timeout = c->connection_timeout_ms;\n  uint64_t mseconds_left;\n\n  /* Log entry state before the assertion so we capture values that make the\n   * assertion redundant (the reported violation scenario). */\n  probe_log(\"entry\", c, now, since_actv, timeout, 0ULL, \"before_assert\");\n\n  mhd_assert (0 != timeout);\n\n  /* Keep the next lines in sync with #connection_check_timedout() to avoid\n   * undesired side-effects like busy-waiting. */\n  if (timeout < since_actv)\n  {\n    if (UINT64_MAX / 2 < since_actv)\n    {\n      const uint64_t jump_back = c->last_activity - now;\n      /* Very unlikely that it is more than quarter-million years pause.\n       * More likely that system clock jumps back. */\n      if (5000 >= jump_back)\n      { /* Jump back is less than 5 seconds, try to recover. */\n        probe_log(\"branch\", c, now, since_actv, timeout, 100ULL,\n                  \"jump_back_recover_return_100\");\n        return 100; /* Set wait time to 0.1 seconds */\n      }\n      /* Too large jump back */\n    }\n    probe_log(\"branch\", c, now, since_actv, timeout, 0ULL,\n              \"timed_out_return_0\");\n    return 0; /* Connection has timed out */\n  }\n  else if (since_actv == timeout)\n  {\n    /* Exact match for timeout and time from last activity.\n     * Maybe this is just a precise match or this happens because the timer\n     * resolution is too low.\n     * Set wait time to 0.1 seconds to avoid busy-waiting with low\n     * timer resolution as connection is not timed-out yet. */\n    probe_log(\"branch\", c, now, since_actv, timeout, 100ULL,\n              \"exact_match_return_100\");\n    return 100;\n  }\n  mseconds_left = timeout - since_actv;\n\n  probe_log(\"exit\", c, now, since_actv, timeout, mseconds_left, \"return_left\");\n\n  return mseconds_left;\n}\n\n```\n</target code>\n<build error>\nThe build failed with the following error:\n```\ndaemon.c:1983:1: error: expected identifier or '('\n 1983 | mhd_assert(int cond)\n      | ^\n./mhd_assert.h:45:32: note: expanded from macro 'mhd_assert'\n   45 | #  define mhd_assert(ignore) ((void) 0)\n      |                                ^\ndaemon.c:1983:1: error: expected ')'\n./mhd_assert.h:45:32: note: expanded from macro 'mhd_assert'\n   45 | #  define mhd_assert(ignore) ((void) 0)\n      |                                ^\ndaemon.c:1983:1: note: to match this '('\n./mhd_assert.h:45:31: note: expanded from macro 'mhd_assert'\n   45 | #  define mhd_assert(ignore) ((void) 0)\n      |                               ^\ndaemon.c:1983:1: error: expected ')'\n 1983 | mhd_assert(int cond)\n      | ^\n./mhd_assert.h:45:38: note: expanded from macro 'mhd_assert'\n   45 | #  define mhd_assert(ignore) ((void) 0)\n      |                                      ^\ndaemon.c:1983:1: note: to match this '('\n./mhd_assert.h:45:30: note: expanded from macro 'mhd_assert'\n   45 | #  define mhd_assert(ignore) ((void) 0)\n      |                              ^\n3 errors generated.\nmake[3]: *** [Makefile:2112: libmicrohttpd_la-daemon.lo] Error 1\nmake[2]: *** [Makefile:449: all-recursive] Error 1\nmake[1]: *** [Makefile:788: all-recursive] Error 1\nmake: *** [Makefile:693: all] Error 2\n```\n</build error>\n<response format>\nProvide your answer with these answers.\n- fixed_test_code: the fixed test code that compiles successfully.\n- explanation: a brief explanation of the changes you made to fix the code.\nHere are the constraints for the test code:\n- The test code MUST be compilable and executable.\n- The test code MUST include line breaks.\n- The test code MUST preserve the original logic of connection_get_wait as much as possible.\n- You MUST not define the main function.\n- You MUST not define macros.\n- The test code MUST not contain any mock functions.\n</response format>\n<instruction>\nPlease fix the code so that it compiles successfully.\n</instruction>\n",
  "fixed_test_code": "static void\nprobe_log(const char *label,\n          const struct MHD_Connection *c,\n          uint64_t now,\n          uint64_t since_actv,\n          uint64_t timeout,\n          uint64_t mseconds_left,\n          const char *path)\n{\n  FILE *f = fopen(\"/tmp/logs/1082.txt\", \"a\");\n  if (f == NULL)\n  {\n    return;\n  }\n\n  fprintf(f, \"[connection_get_wait] %s | path=%s\\n\", label, path);\n  if (c != NULL)\n  {\n    fprintf(f, \"  last_activity=%\" PRIu64 \"\\n\", c->last_activity);\n    fprintf(f, \"  connection_timeout_ms=%\" PRIu64 \"\\n\", c->connection_timeout_ms);\n  }\n  fprintf(f, \"  now=%\" PRIu64 \"\\n\", now);\n  fprintf(f, \"  since_actv=%\" PRIu64 \"\\n\", since_actv);\n  fprintf(f, \"  timeout=%\" PRIu64 \"\\n\", timeout);\n  fprintf(f, \"  mseconds_left=%\" PRIu64 \"\\n\", mseconds_left);\n  fprintf(f, \"---\\n\");\n  fclose(f);\n}\nstatic void\nmhd_assert_local(int cond)\n{\n  /* Log that the assertion was evaluated and its boolean result. */\n  probe_log(\"mhd_assert\", NULL, 0ULL, 0ULL, (uint64_t)cond, 0ULL,\n            cond ? \"assert_true\" : \"assert_false\");\n  /* Do not abort here to allow the calling function to continue and log\n   * further state for diagnosis. */\n}\n\nstatic uint64_t\nconnection_get_wait (struct MHD_Connection *c)\n{\n  const uint64_t now = MHD_monotonic_msec_counter ();\n  const uint64_t since_actv = now - c->last_activity;\n  const uint64_t timeout = c->connection_timeout_ms;\n  uint64_t mseconds_left;\n\n  /* Log entry state before the assertion so we capture values that make the\n   * assertion redundant (the reported violation scenario). */\n  probe_log(\"entry\", c, now, since_actv, timeout, 0ULL, \"before_assert\");\n\n  mhd_assert_local (0 != timeout);\n\n  /* Keep the next lines in sync with #connection_check_timedout() to avoid\n   * undesired side-effects like busy-waiting. */\n  if (timeout < since_actv)\n  {\n    if (UINT64_MAX / 2 < since_actv)\n    {\n      const uint64_t jump_back = c->last_activity - now;\n      /* Very unlikely that it is more than quarter-million years pause.\n       * More likely that system clock jumps back. */\n      if (5000 >= jump_back)\n      { /* Jump back is less than 5 seconds, try to recover. */\n        probe_log(\"branch\", c, now, since_actv, timeout, 100ULL,\n                  \"jump_back_recover_return_100\");\n        return 100; /* Set wait time to 0.1 seconds */\n      }\n      /* Too large jump back */\n    }\n    probe_log(\"branch\", c, now, since_actv, timeout, 0ULL,\n              \"timed_out_return_0\");\n    return 0; /* Connection has timed out */\n  }\n  else if (since_actv == timeout)\n  {\n    /* Exact match for timeout and time from last activity.\n     * Maybe this is just a precise match or this happens because the timer\n     * resolution is too low.\n     * Set wait time to 0.1 seconds to avoid busy-waiting with low\n     * timer resolution as connection is not timed-out yet. */\n    probe_log(\"branch\", c, now, since_actv, timeout, 100ULL,\n              \"exact_match_return_100\");\n    return 100;\n  }\n  mseconds_left = timeout - since_actv;\n\n  probe_log(\"exit\", c, now, since_actv, timeout, mseconds_left, \"return_left\");\n\n  return mseconds_left;\n}\n",
  "explanation": "The build failed because a macro named mhd_assert was defined by an included header, causing a name collision when attempting to define a function with the same name. I renamed the function to mhd_assert_local and updated the single call site in connection_get_wait accordingly. This avoids macro expansion collisions while preserving the original logic and behavior of connection_get_wait."
}