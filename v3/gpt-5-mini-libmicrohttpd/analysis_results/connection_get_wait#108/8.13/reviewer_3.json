{
  "user_message": "An agent A claimed that the following connection_get_wait code violates the MISRA C 2023 rule 8.13.\n<misra_rule>\nMISRA C 2023 Rule 8.13 is A pointer should point to a const-qualified type whenever possible.\n\n</misra_rule>\n<target_code>\nHere is the original code of connection_get_wait.\n```c\nstatic uint64_t\nconnection_get_wait (struct MHD_Connection *c)\n{\n  const uint64_t now = MHD_monotonic_msec_counter ();\n  const uint64_t since_actv = now - c->last_activity;\n  const uint64_t timeout = c->connection_timeout_ms;\n  uint64_t mseconds_left;\n\n  mhd_assert (0 != timeout);\n  /* Keep the next lines in sync with #connection_check_timedout() to avoid\n   * undesired side-effects like busy-waiting. */\n  if (timeout < since_actv)\n  {\n    if (UINT64_MAX / 2 < since_actv)\n    {\n      const uint64_t jump_back = c->last_activity - now;\n      /* Very unlikely that it is more than quarter-million years pause.\n       * More likely that system clock jumps back. */\n      if (5000 >= jump_back)\n      { /* Jump back is less than 5 seconds, try to recover. */\n        return 100; /* Set wait time to 0.1 seconds */\n      }\n      /* Too large jump back */\n    }\n    return 0; /* Connection has timed out */\n  }\n  else if (since_actv == timeout)\n  {\n    /* Exact match for timeout and time from last activity.\n     * Maybe this is just a precise match or this happens because the timer\n     * resolution is too low.\n     * Set wait time to 0.1 seconds to avoid busy-waiting with low\n     * timer resolution as connection is not timed-out yet. */\n    return 100;\n  }\n  mseconds_left = timeout - since_actv;\n\n  return mseconds_left;\n}\n```\n</target_code>\n<response format>\nProvide your answer with these fields.\n- explanation: your evaluation of the scenario provided by the agent A.\n- is_report_correct: whether the report is correct or not (true/false). True means there is a violation.\n</response format>\n<scenario>\nThe agent A provided the following violation scenario:\nThe function takes a pointer parameter 'struct MHD_Connection *c' but only reads from c (accesses c->last_activity and c->connection_timeout_ms) and does not modify the pointed-to object. Per MISRA C 2023 Rule 8.13 the pointer should be const-qualified when possible. The signature should be: static uint64_t connection_get_wait(const struct MHD_Connection *c).\n</scenario>\n\n<execution_log>\nThe agent A also provided the following output log:\nconnection_get_wait ENTRY: now=892 since_actv=0 timeout=5000 last_activity=892\nEXIT: time remaining=5000 ms (timeout=5000 - since_actv=0)\nconnection_get_wait ENTRY: now=892 since_actv=0 timeout=5000 last_activity=892\nEXIT: time remaining=5000 ms (timeout=5000 - since_actv=0)\nconnection_get_wait ENTRY: now=892 since_actv=0 timeout=5000 last_activity=892\nEXIT: time remaining=5000 ms (timeout=5000 - since_actv=0)\nconnection_get_wait ENTRY: now=892 since_actv=0 timeout=5000 last_activity=892\nEXIT: time remaining=5000 ms (timeout=5000 - since_actv=0)\nconnection_get_wait ENTRY: now=892 since_actv=0 timeout=5000 last_activity=892\nEXIT: time remaining=5000 ms (timeout=5000 - since_actv=0)\nconnection_get_wait ENTRY: now=892 since_actv=0 timeout=5000 last_activity=892\nEXIT: time remaining=5000 ms (timeout=5000 - since_actv=0)\nconnection_get_wait ENTRY: now=892 since_actv=0 timeout=5000 last_activity=892\nEXIT: time remaining=5000 ms (timeout=5000 - since_actv=0)\nconnection_get_wait ENTRY: now=892 since_actv=0 timeout=5000 last_activity=892\nEXIT: time remaining=5000 ms (timeout=5000 - since_actv=0)\nconnection_get_wait ENTRY: now=892 since_actv=0 timeout=5000 last_activity=892\nEXIT: time remaining=5000 ms (timeout=5000 - since_actv=0)\nconnection_get_wait ENTRY: now=892 since_actv=0 timeout=5000 last_activity=892\nEXIT: time remaining=5000 ms (timeout=5000 - since_actv=0)\nconnection_get_wait ENTRY: now=892 since_actv=0 timeout=5000 last_activity=892\nEXIT: time remaining=5000 ms (timeout=5000 - since_actv=0)\nconnection_get_wait ENTRY: now=892 since_actv=0 timeout=5000 last_activity=892\nEXIT: time remaining=5000 ms (timeout=5000 - since_actv=0)\nconnection_get_wait ENTRY: now=892 since_actv=0 timeout=5000 last_activity=892\nEXIT: time remaining=5000 ms (timeout=5000 - since_actv=0)\nconnection_get_wait ENTRY: now=892 since_actv=0 timeout=5000 last_activity=892\nEXIT: time remaining=5000 ms (timeout=5000 - since_actv=0)\nconnection_get_wait ENTRY: now=892 since_actv=0 timeout=5000 last_activity=892\nEXIT: time remaining=5000 ms (timeout=5000 - since_actv=0)\nconnection_get_wait ENTRY: now=892 since_actv=0 timeout=5000 last_activity=892\nEXIT: time remaining=5000 ms (timeout=5000 - since_actv=0)\nconnection_get_wait ENTRY: now=892 since_actv=0 timeout=5000 last_activity=892\nEXIT: time remaining=5000 ms (timeout=5000 - since_actv=0)\nconnection_get_wait ENTRY: now=892 since_actv=0 timeout=5000 last_activity=892\nEXIT: time remaining=5000 ms (timeout=5000 - since_actv=0)\nconnection_get_wait ENTRY: now=892 since_actv=0 timeout=5000 last_activity=892\nEXIT: time remaining=5000 ms (timeout=5000 - since_actv=0)\nconnection_get_wait ENTRY: now=892 since_actv=0 timeout=5000 last_activity=892\nEXIT: time remaining=5000 ms (timeout=5000 - since_actv=0)\nconnection_get_wait ENTRY: now=892 since_actv=0 timeout=5000 last_activity=892\nEXIT: time remaining=5000 ms (timeout=5000 - since_actv=0)\nconnection_get_wait ENTRY: now=896 since_actv=0 timeout=5000 last_activity=896\nEXIT: time remaining=5000 ms (timeout=5000 - since_actv=0)\nconnection_get_wait ENTRY: now=896 since_actv=0 timeout=5000 last_activity=896\nEXIT: time remaining=5000 ms (timeout=5000 - since_actv=0)\nconnection_get_wait ENTRY: now=896 since_actv=0 timeout=5000 last_activity=896\nEXIT: time remaining=5000 ms (timeout=5000 - since_actv=0)\nconnection_get_wait ENTRY: now=896 since_actv=0 timeout=5000 last_activity=896\nEXIT: time remaining=5000 ms (timeout=5000 - since_actv=0)\nconnection_get_wait ENTRY: now=896 since_actv=0 timeout=5000 last_activity=896\nEXIT: time remaining=5000 ms (timeout=5000 - since_actv=0)\nconnection_get_wait ENTRY: now=896 since_actv=0 timeout=5000 last_activity=896\nEXIT: time remaining=5000 ms (timeout=5000 - since_actv=0)\nconnection_get_wait ENTRY: now=896 since_actv=0 timeout=5000 last_activity=896\nEXIT: time remaining=5000 ms (timeout=5000 - since_actv=0)\nconnection_get_wait ENTRY: now=896 since_actv=0 timeout=5000 last_activity=896\nEXIT: time remaining=5000 ms (timeout=5000 - since_actv=0)\nconnection_get_wait ENTRY: now=896 since_actv=0 timeout=5000 last_activity=896\nEXIT: time rema\n</execution_log>\n\n<instruction>\nJudge whether the report is correct or not.\n</instruction>\n",
  "is_report_correct": true,
  "explanation": "The report is correct. connection_get_wait only reads members of the object pointed to by c (c->last_activity and c->connection_timeout_ms) and does not modify the pointed-to object or store the pointer for later modification. Per MISRA C 2023 Rule 8.13 a pointer parameter that is only used for reading should be declared to point to a const-qualified type. Changing the signature to\n\nstatic uint64_t connection_get_wait(const struct MHD_Connection *c)\n\nwould satisfy the rule. Note: callers that currently pass a non-const struct MHD_Connection * can do so without casts because conversion from T* to const T* is implicit in C. Only if the function needed to pass the pointer to code that modifies the object or to store it for later modification would keeping it non-const be justified \u2014 there is no evidence of that here (the provided execution log shows only reads), so the violation stands."
}