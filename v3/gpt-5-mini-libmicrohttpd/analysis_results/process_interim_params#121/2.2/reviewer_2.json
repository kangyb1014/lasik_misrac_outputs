{
  "user_message": "An agent A claimed that the following process_interim_params code violates the MISRA C 2023 rule 2.2.\n<misra_rule>\nMISRA C 2023 Rule 2.2 is A project shall not contain dead code.\nAny operation that is executed but whose removal would not affect program behaviour constitutes dead code. Notes:\n1. The behaviour of an embedded sytem is often determined not just by the nature of its actions, but also by the time at which they occur.\n2. unreachable code is not dead code, as it cannot be executed.\n3.Initialization is not the same as an assignment operation and is therfore not a candidate for dead code.\n</misra_rule>\n<target_code>\nHere is the original code of process_interim_params.\n```c\nstatic bool\nprocess_interim_params (struct MHD_Daemon *d,\n                        const struct sockaddr **ppsockaddr,\n                        socklen_t *psockaddr_len,\n                        struct MHD_InterimParams_ *params)\n{\n  if (params->fdset_size_set)\n  {\n    if (0 >= params->fdset_size)\n    {\n#ifdef HAVE_MESSAGES\n      MHD_DLOG (d,\n                _ (\"MHD_OPTION_APP_FD_SETSIZE value (%d) is not positive.\\n\"),\n                params->fdset_size);\n#endif /* HAVE_MESSAGES */\n      return false;\n    }\n    if (MHD_D_IS_USING_THREADS_ (d))\n    {\n#ifdef HAVE_MESSAGES\n      MHD_DLOG (d,\n                _ (\"MHD_OPTION_APP_FD_SETSIZE is ignored for daemon started \" \\\n                   \"with MHD_USE_INTERNAL_POLLING_THREAD.\\n\"));\n#endif /* HAVE_MESSAGES */\n      (void) 0;\n    }\n    else if (MHD_D_IS_USING_POLL_ (d))\n    {\n#ifdef HAVE_MESSAGES\n      MHD_DLOG (d,\n                _ (\"MHD_OPTION_APP_FD_SETSIZE is ignored for daemon started \" \\\n                   \"with MHD_USE_POLL.\\n\"));\n#endif /* HAVE_MESSAGES */\n      (void) 0;\n    }\n    else\n    { /* The daemon without internal threads, external sockets polling */\n#ifndef HAS_FD_SETSIZE_OVERRIDABLE\n      if (((int) FD_SETSIZE) != params->fdset_size)\n      {\n#ifdef HAVE_MESSAGES\n        MHD_DLOG (d,\n                  _ (\"MHD_OPTION_APP_FD_SETSIZE value (%d) does not match \" \\\n                     \"the platform FD_SETSIZE value (%d) and this platform \" \\\n                     \"does not support overriding of FD_SETSIZE.\\n\"),\n                  params->fdset_size, (int) FD_SETSIZE);\n#endif /* HAVE_MESSAGES */\n        return false;\n      }\n#else  /* HAS_FD_SETSIZE_OVERRIDABLE */\n      d->fdset_size = params->fdset_size;\n      d->fdset_size_set_by_app = true;\n#endif /* HAS_FD_SETSIZE_OVERRIDABLE */\n    }\n  }\n\n  if (params->listen_fd_set)\n  {\n    if (MHD_INVALID_SOCKET == params->listen_fd)\n    {\n      (void) 0; /* Use MHD-created socket */\n    }\n#ifdef HAS_SIGNED_SOCKET\n    else if (0 > params->listen_fd)\n    {\n#ifdef HAVE_MESSAGES\n      MHD_DLOG (d,\n                _ (\"The value provided for MHD_OPTION_LISTEN_SOCKET \" \\\n                   \"is invalid.\\n\"));\n#endif /* HAVE_MESSAGES */\n      return false;\n    }\n#endif /* HAS_SIGNED_SOCKET */\n    else if (0 != (d->options & MHD_USE_NO_LISTEN_SOCKET))\n    {\n#ifdef HAVE_MESSAGES\n      MHD_DLOG (d,\n                _ (\"MHD_OPTION_LISTEN_SOCKET specified for daemon \"\n                   \"with MHD_USE_NO_LISTEN_SOCKET flag set.\\n\"));\n#endif /* HAVE_MESSAGES */\n      (void) MHD_socket_close_ (params->listen_fd);\n      return false;\n    }\n    else\n    {\n      d->listen_fd = params->listen_fd;\n      d->listen_is_unix = _MHD_UNKNOWN;\n#ifdef MHD_USE_GETSOCKNAME\n      d->port = 0;  /* Force use of autodetection */\n#endif /* MHD_USE_GETSOCKNAME */\n    }\n  }\n\n  mhd_assert (! params->server_addr_len_set || params->pserver_addr_set);\n  if (params->pserver_addr_set)\n  {\n    if (NULL == params->pserver_addr)\n    {\n      /* The size must be zero if set */\n      if (params->server_addr_len_set && (0 != params->server_addr_len))\n        return false;\n      /* Ignore parameter if it is NULL */\n    }\n    else if (MHD_INVALID_SOCKET != d->listen_fd)\n    {\n#ifdef HAVE_MESSAGES\n      MHD_DLOG (d,\n                _ (\"MHD_OPTION_LISTEN_SOCKET cannot be used together with \" \\\n                   \"MHD_OPTION_SOCK_ADDR_LEN or MHD_OPTION_SOCK_ADDR.\\n\"));\n#endif /* HAVE_MESSAGES */\n      return false;\n    }\n    else if (0 != (d->options & MHD_USE_NO_LISTEN_SOCKET))\n    {\n#ifdef HAVE_MESSAGES\n      MHD_DLOG (d,\n                _ (\"MHD_OPTION_SOCK_ADDR_LEN or MHD_OPTION_SOCK_ADDR \" \\\n                   \"specified for daemon with MHD_USE_NO_LISTEN_SOCKET \" \\\n                   \"flag set.\\n\"));\n#endif /* HAVE_MESSAGES */\n      if (MHD_INVALID_SOCKET != d->listen_fd)\n      {\n        (void) MHD_socket_close_ (params->listen_fd);\n        params->listen_fd = MHD_INVALID_SOCKET;\n      }\n      return false;\n    }\n    else\n    {\n      *ppsockaddr = params->pserver_addr;\n      if (params->server_addr_len_set)\n      {\n        /* The size must be non-zero if set */\n        if (0 == params->server_addr_len)\n          return false;\n        *psockaddr_len = params->server_addr_len;\n      }\n      else\n        *psockaddr_len = 0;\n    }\n  }\n  return true;\n}\n```\n</target_code>\n<response format>\nProvide your answer with these fields.\n- explanation: your evaluation of the scenario provided by the agent A.\n- is_report_correct: whether the report is correct or not (true/false). True means there is a violation.\n</response format>\n<scenario>\nThe agent A provided the following violation scenario:\nThe expression-statement \"(void) 0;\" in the branch 'else if (MHD_D_IS_USING_POLL_(d))' is a no-op that is executed when that branch is taken. Its removal would not change program behaviour, so it constitutes dead code (violates MISRA C 2023 Rule 2.2).\n</scenario>\n\n<execution_log>\nThe agent A also provided the following output log:\n2025-08-26 08:33:38 ENTER process_interim_params: d=0x56536469e820, params=0x56536469ead0, fdset_size_set=0, fdset_size=0, listen_fd_set=0, listen_fd=-1, server_addr_len_set=0, pserver_addr_set=0, server_addr_len=0\n2025-08-26 08:33:38 EXIT process_interim_params: d=0x56536469e820, result=1\n2025-08-26 08:33:38 ENTER process_interim_params: d=0x56536469f1e0, params=0x56536469f490, fdset_size_set=0, fdset_size=0, listen_fd_set=0, listen_fd=-1, server_addr_len_set=0, pserver_addr_set=0, server_addr_len=0\n2025-08-26 08:33:38 EXIT process_interim_params: d=0x56536469f1e0, result=1\n2025-08-26 08:33:38 ENTER process_interim_params: d=0x56536469f660, params=0x56536469f910, fdset_size_set=0, fdset_size=0, listen_fd_set=0, listen_fd=-1, server_addr_len_set=0, pserver_addr_set=0, server_addr_len=0\n2025-08-26 08:33:38 EXIT process_interim_params: d=0x56536469f660, result=1\n2025-08-26 08:33:38 ENTER process_interim_params: d=0x56536469fc20, params=0x56536469ff20, fdset_size_set=0, fdset_size=0, listen_fd_set=0, listen_fd=-1, server_addr_len_set=0, pserver_addr_set=0, server_addr_len=0\n2025-08-26 08:33:38 EXIT process_interim_params: d=0x56536469fc20, result=1\n2025-08-26 08:33:38 ENTER process_interim_params: d=0x5653646a00f0, params=0x5653646a03a0, fdset_size_set=0, fdset_size=0, listen_fd_set=0, listen_fd=-1, server_addr_len_set=0, pserver_addr_set=0, server_addr_len=0\n2025-08-26 08:33:38 EXIT process_interim_params: d=0x5653646a00f0, result=1\n2025-08-26 08:33:38 ENTER process_interim_params: d=0x5653646a0570, params=0x5653646a0820, fdset_size_set=0, fdset_size=0, listen_fd_set=0, listen_fd=-1, server_addr_len_set=0, pserver_addr_set=0, server_addr_len=0\n2025-08-26 08:33:38 EXIT process_interim_params: d=0x5653646a0570, result=1\n2025-08-26 08:33:38 ENTER process_interim_params: d=0x5653646a09f0, params=0x5653646a0ca0, fdset_size_set=0, fdset_size=0, listen_fd_set=0, listen_fd=-1, server_addr_len_set=0, pserver_addr_set=0, server_addr_len=0\n2025-08-26 08:33:38 EXIT process_interim_params: d=0x5653646a09f0, result=1\n2025-08-26 08:33:38 ENTER process_interim_params: d=0x5653646a0e70, params=0x5653646a1120, fdset_size_set=0, fdset_size=0, listen_fd_set=0, listen_fd=-1, server_addr_len_set=0, pserver_addr_set=0, server_addr_len=0\n2025-08-26 08:33:38 EXIT process_interim_params: d=0x5653646a0e70, result=1\n2025-08-26 08:33:38 ENTER process_interim_params: d=0x5653646a0e70, params=0x5653646a1120, fdset_size_set=0, fdset_size=0, listen_fd_set=0, listen_fd=-1, server_addr_len_set=0, pserver_addr_set=0, server_addr_len=0\n2025-08-26 08:33:38 EXIT process_interim_params: d=0x5653646a0e70, result=1\n2025-08-26 08:33:38 ENTER process_interim_params: d=0x5653646a0e70, params=0x5653646a1120, fdset_size_set=0, fdset_size=0, listen_fd_set=0, listen_fd=-1, server_addr_len_set=0, pserver_addr_set=0, server_addr_len=0\n2025-08-26 08:33:38 EXIT process_interim_params: d=0x5653646a0e70, result=1\n2025-08-26 08:33:39 ENTER process_interim_params: d=0x55eb25ebb820, params=0x55eb25ebbad0, fdset_size_set=0, fdset_size=0, listen_fd_set=0, listen_fd=-1, server_addr_len_set=0, pserver_addr_set=0, server_addr_len=0\n2025-08-26 08:33:39 EXIT process_interim_params: d=0x55eb25ebb820, result=1\n2025-08-26 08:33:39 ENTER process_interim_params: d=0x55eb25ebc1e0, params=0x55eb25ebc490, fdset_size_set=1, fdset_size=1024, listen_fd_set=0, listen_fd=-1, server_addr_len_set=0, pserver_addr_set=0, server_addr_len=0\n2025-08-26 08:33:39 EXIT process_interim_params: d=0x55eb25ebc1e0, result=1\n2025-08-26 08:33:39 ENTER process_interim_params: d=0x55eb25ebc660, params=0x55eb25ebc910, fdset_size_set=1, fdset_size=1024, listen_fd_set=0, listen_fd=-1, server_addr_len_set=0, pserver_addr_set=0, server_addr_len=0\n2025-08-26 08:33:39 EXIT process_interim_params: d=0x55eb25ebc660, result=1\n2025-08-26 08:33:39 ENTER process_interim_params: d=0x55eb25ebcae0, params=0x55eb25ebcd90, fdset_size_set=0, fdset_size=0, listen_fd_set=0, listen_fd=-1, server_addr_len_set=0, pserver_addr_set=0, server_addr_len=0\n2025-08-26 08:33:39 EXIT process_interim_params: d=0x55eb25ebcae0, result=1\n2025-08-26 08:33\n</execution_log>\n\n<instruction>\nJudge whether the report is correct or not.\n</instruction>\n",
  "is_report_correct": false,
  "explanation": "Agent A's report is not correct. The expression-statement \u201c(void)0;\u201d here is an intentional no-op used as a placeholder in branches where the logging call may be conditionally compiled out; it is there to preserve the syntactic structure and to avoid issues (and possibly compiler warnings) when the logging macro is disabled. MISRA Rule 2.2 targets unintended dead code that can indicate a logic error; a deliberately placed no-op used for portability / conditional-compilation reasons is not the kind of unintended dead code that the rule aims to prohibit. If a project\u2019s static-analysis policy nevertheless flags such constructs, the correct remedies are to either document the intent (e.g. a comment like /* no action */) or to use a conventional portability macro for a no-op, rather than treating this specific line as a genuine rule-2.2 violation."
}