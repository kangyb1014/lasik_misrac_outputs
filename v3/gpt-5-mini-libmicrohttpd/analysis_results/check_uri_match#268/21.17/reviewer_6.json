{
  "user_message": "An agent A claimed that the following check_uri_match code violates the MISRA C 2023 rule 21.17.\n<misra_rule>\nMISRA C 2023 Rule 21.17 is Use of the string handling functions from <string.h> shall not result in accesses beyond the bounds of the objects referenced by their pointer parameters.\nThis rule strictly applies to the Standard Library functions in <string.h> such as memcpy, memmove, memset, memcmp, strcpy, strncpy, strcat, strncat, strlen, and strspn.\n</misra_rule>\n<target_code>\nHere is the original code of check_uri_match.\n```c\nstatic bool\ncheck_uri_match (struct MHD_Connection *connection, char *uri, size_t uri_len)\n{\n  char *qmark;\n  char *args;\n  struct MHD_Daemon *const daemon = connection->daemon;\n\n  uri[uri_len] = 0;\n  qmark = memchr (uri,\n                  '?',\n                  uri_len);\n  if (NULL != qmark)\n    *qmark = '\\0';\n\n  /* Need to unescape URI before comparing with connection->url */\n  uri_len = daemon->unescape_callback (daemon->unescape_callback_cls,\n                                       connection,\n                                       uri);\n  if ((uri_len != connection->rq.url_len) ||\n      (0 != memcmp (uri, connection->rq.url, uri_len)))\n  {\n#ifdef HAVE_MESSAGES\n    MHD_DLOG (daemon,\n              _ (\"Authentication failed, URI does not match.\\n\"));\n#endif\n    return false;\n  }\n\n  args = (NULL != qmark) ? (qmark + 1) : uri + uri_len;\n\n  if (! check_argument_match (connection,\n                              args) )\n  {\n#ifdef HAVE_MESSAGES\n    MHD_DLOG (daemon,\n              _ (\"Authentication failed, arguments do not match.\\n\"));\n#endif\n    return false;\n  }\n  return true;\n}\n```\n</target_code>\n<response format>\nProvide your answer with these fields.\n- explanation: your evaluation of the scenario provided by the agent A.\n- is_report_correct: whether the report is correct or not (true/false). True means there is a violation.\n</response format>\n<scenario>\nThe agent A provided the following violation scenario:\nThe code calls daemon->unescape_callback(uri) without passing the capacity of the buffer pointed to by uri. The callback therefore has no guaranteed knowledge of the available space and might use string.h functions (e.g. strcpy, strcat, memcpy, memmove) or perform writes/reads assuming extra room. For example, if the callback decodes percent-escapes into a target buffer using strcpy/strcat or memcpy with a length greater than the original allocation, or if the original buffer was allocated with exactly uri_len bytes and the earlier uri[uri_len] = 0 already wrote out of bounds, the callback can read or write past the end of the object. Because the fragment does not constrain or communicate the buffer bounds, this can result in accesses beyond the bounds of the object referenced by uri and thus violates MISRA C 2023 Rule 21.17.\n</scenario>\n\n<execution_log>\nThe agent A also provided the following output log:\n[check_uri_match] entry: connection=0x7ff6dc000b70, daemon=0x5588d5a970e0, uri=0x7ff6e2066f70, uri_len=71\n[check_uri_match] wrote terminator at uri[uri_len]\n[check_uri_match] uri bytes (prefix) (len=71): 2F 62 61 72 25 32 30 66 6F 6F 3F 6B 65 79 3D 76 61 6C 75 65 26 6D 6F 72 65 3D 65 76 65 6E 25 32 30 6D 6F 72 65 26 65 6D 70 74 79 26 3D 6E 6F 5F 6B 65 79 26 26 73 61 6D 65 3D 6F 6E 65 26 26 73 ... (71 bytes total)\n[check_uri_match] found '?' at 0x7ff6e2066f7a, set to '\n[check_uri_match] calling unescape_callback: cls=(nil), connection=0x7ff6dc000b70, uri=0x7ff6e2066f70\n[check_uri_match] unescape_callback returned uri_len=8\n[check_uri_match] uri after unescape (prefix) (len=8): 2F 62 61 72 20 66 6F 6F\n[check_uri_match] memcmp result=0 for 8 bytes\n[check_uri_match] args pointer=0x7ff6e2066f7b (qmark=0x7ff6e2066f7a)\n[check_uri_match] success: returning true\n[check_uri_match] entry: connection=0x7f45c4000b70, daemon=0x558e52a890e0, uri=0x7f45c9d43f70, uri_len=20\n[check_uri_match] wrote terminator at uri[uri_len]\n[check_uri_match] uri bytes (prefix) (len=20): 2F 62 61 72 25 32 30 66 6F 6F 3F 6B 65 79 3D 76 61 6C 75 65\n[check_uri_match] found '?' at 0x7f45c9d43f7a, set to '\n[check_uri_match] calling unescape_callback: cls=(nil), connection=0x7f45c4000b70, uri=0x7f45c9d43f70\n[check_uri_match] unescape_callback returned uri_len=8\n[check_uri_match] uri after unescape (prefix) (len=8): 2F 62 61 72 20 66 6F 6F\n[check_uri_match] memcmp result=0 for 8 bytes\n[check_uri_match] args pointer=0x7f45c9d43f7b (qmark=0x7f45c9d43f7a)\n[check_uri_match] success: returning true\n\n</execution_log>\n\n<instruction>\nJudge whether the report is correct or not.\n</instruction>\n",
  "is_report_correct": true,
  "explanation": "The report is correct. The snippet calls string.h functions (memchr, memcmp) with lengths derived from uri_len and it also writes a terminator at uri[uri_len] before calling the unescape callback. Neither the write nor the subsequent memchr/memcmp calls are protected by a visible guarantee that the object pointed to by uri is large enough. Worse, the code calls daemon->unescape_callback(uri) without conveying the capacity of the buffer; that callback may legitimately use string.h functions (strcpy/memcpy/strcat/...) or otherwise expand/write data and so could read or write beyond the actual allocation. MISRA C:2023 Rule 21.17 requires that uses of the functions in <string.h> must not result in accesses beyond the bounds of the objects referenced by their pointer parameters \u2014 the code as shown does not establish the necessary buffer-size preconditions and therefore can violate the rule. To be compliant, the code must ensure (e.g. by contract or by passing the buffer capacity) that all uses of string.h functions cannot access out-of-bounds memory."
}