{
  "user_message": "An agent A claimed that the following check_uri_match code violates the MISRA C 2023 rule 21.17.\n<misra_rule>\nMISRA C 2023 Rule 21.17 is Use of the string handling functions from <string.h> shall not result in accesses beyond the bounds of the objects referenced by their pointer parameters.\nThis rule strictly applies to the Standard Library functions in <string.h> such as memcpy, memmove, memset, memcmp, strcpy, strncpy, strcat, strncat, strlen, and strspn.\n</misra_rule>\n<target_code>\nHere is the original code of check_uri_match.\n```c\nstatic bool\ncheck_uri_match (struct MHD_Connection *connection, char *uri, size_t uri_len)\n{\n  char *qmark;\n  char *args;\n  struct MHD_Daemon *const daemon = connection->daemon;\n\n  uri[uri_len] = 0;\n  qmark = memchr (uri,\n                  '?',\n                  uri_len);\n  if (NULL != qmark)\n    *qmark = '\\0';\n\n  /* Need to unescape URI before comparing with connection->url */\n  uri_len = daemon->unescape_callback (daemon->unescape_callback_cls,\n                                       connection,\n                                       uri);\n  if ((uri_len != connection->rq.url_len) ||\n      (0 != memcmp (uri, connection->rq.url, uri_len)))\n  {\n#ifdef HAVE_MESSAGES\n    MHD_DLOG (daemon,\n              _ (\"Authentication failed, URI does not match.\\n\"));\n#endif\n    return false;\n  }\n\n  args = (NULL != qmark) ? (qmark + 1) : uri + uri_len;\n\n  if (! check_argument_match (connection,\n                              args) )\n  {\n#ifdef HAVE_MESSAGES\n    MHD_DLOG (daemon,\n              _ (\"Authentication failed, arguments do not match.\\n\"));\n#endif\n    return false;\n  }\n  return true;\n}\n```\n</target_code>\n<response format>\nProvide your answer with these fields.\n- explanation: your evaluation of the scenario provided by the agent A.\n- is_report_correct: whether the report is correct or not (true/false). True means there is a violation.\n</response format>\n<scenario>\nThe agent A provided the following violation scenario:\nThe call to memcmp uses uri_len returned by daemon->unescape_callback without verifying that both pointers reference objects at least uri_len bytes long. If the unescape_callback returns a length greater than the actual storage for uri (or connection->rq.url_len equals a length greater than the storage for connection->rq.url), memcmp(uri, connection->rq.url, uri_len) will read beyond the bounds of one or both buffers (e.g. unescape_callback returns M > allocated size of uri and connection->rq.url_len == M), causing an out-of-bounds access.\n</scenario>\n\n<instruction>\nJudge whether the report is correct or not.\n</instruction>\n",
  "is_report_correct": true,
  "explanation": "The report is correct. The call to memcmp(uri, connection->rq.url, uri_len) uses uri_len returned by daemon->unescape_callback without any check that the returned length does not exceed the actual storage available for uri (or for connection->rq.url). If unescape_callback can return a value larger than the allocated buffer(s) (or is malicious/buggy), memcmp may read past the end of one or both objects, which violates MISRA C 2023 Rule 21.17. (As an additional note, the code also writes uri[uri_len] = 0 before calling unescape_callback and never verifies the original uri_len relative to the buffer capacity, which is another potential out-of-bounds risk.)"
}