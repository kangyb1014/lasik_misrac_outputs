{
  "user_message": "An agent A claimed that the following check_uri_match code violates the MISRA C 2023 rule 21.17.\n<misra_rule>\nMISRA C 2023 Rule 21.17 is Use of the string handling functions from <string.h> shall not result in accesses beyond the bounds of the objects referenced by their pointer parameters.\nThis rule strictly applies to the Standard Library functions in <string.h> such as memcpy, memmove, memset, memcmp, strcpy, strncpy, strcat, strncat, strlen, and strspn.\n</misra_rule>\n<target_code>\nHere is the original code of check_uri_match.\n```c\nstatic bool\ncheck_uri_match (struct MHD_Connection *connection, char *uri, size_t uri_len)\n{\n  char *qmark;\n  char *args;\n  struct MHD_Daemon *const daemon = connection->daemon;\n\n  uri[uri_len] = 0;\n  qmark = memchr (uri,\n                  '?',\n                  uri_len);\n  if (NULL != qmark)\n    *qmark = '\\0';\n\n  /* Need to unescape URI before comparing with connection->url */\n  uri_len = daemon->unescape_callback (daemon->unescape_callback_cls,\n                                       connection,\n                                       uri);\n  if ((uri_len != connection->rq.url_len) ||\n      (0 != memcmp (uri, connection->rq.url, uri_len)))\n  {\n#ifdef HAVE_MESSAGES\n    MHD_DLOG (daemon,\n              _ (\"Authentication failed, URI does not match.\\n\"));\n#endif\n    return false;\n  }\n\n  args = (NULL != qmark) ? (qmark + 1) : uri + uri_len;\n\n  if (! check_argument_match (connection,\n                              args) )\n  {\n#ifdef HAVE_MESSAGES\n    MHD_DLOG (daemon,\n              _ (\"Authentication failed, arguments do not match.\\n\"));\n#endif\n    return false;\n  }\n  return true;\n}\n```\n</target_code>\n<response format>\nProvide your answer with these fields.\n- explanation: your evaluation of the scenario provided by the agent A.\n- is_report_correct: whether the report is correct or not (true/false). True means there is a violation.\n</response format>\n<scenario>\nThe agent A provided the following violation scenario:\nThe call passes args (either qmark+1 or uri+uri_len) to check_argument_match without guaranteeing that args points to a valid, null\u2011terminated region inside the original buffer. If check_argument_match uses <string.h> functions (e.g. strlen/strcmp/strchr), they can read beyond the object bounds when: (a) qmark was found before calling daemon->unescape_callback and that callback modifies/reallocates/shifts the uri buffer or changes its length, leaving qmark (and thus qmark+1) invalid or not pointing at a terminated string; or (b) uri[uri_len] was written before unescape but unescape changes uri_len or content so uri+uri_len is not a valid, NUL\u2011terminated start of the arguments. In those cases string.h functions inside check_argument_match may access out of bounds \u2014 a MISRA C 2023 Rule 21.17 violation.\n</scenario>\n\n<instruction>\nJudge whether the report is correct or not.\n</instruction>\n",
  "is_report_correct": true,
  "explanation": "The report is correct. check_uri_match computes qmark (a pointer into the original uri buffer) and writes a NUL at uri[uri_len] before calling daemon->unescape_callback, then relies on qmark (or on uri + uri_len using the value returned by unescape_callback) when calling check_argument_match. Nothing in the shown code guarantees that the unescape callback will leave the buffer at the same address, preserve the earlier qmark location, or leave a NUL at the expected position. If the callback reallocates/moves/compacts the buffer or changes the termination (or returns a different uri_len), then qmark+1 may no longer point into the valid object or uri+uri_len may not be a valid NUL\u2011terminated argument start. If check_argument_match uses string.h functions that expect a valid, NUL\u2011terminated region (strlen, strcmp, strchr, etc.), those functions can read beyond the object bounds \u2014 exactly the situation Rule 21.17 forbids.\n\nTo fix: either (a) ensure by contract that unescape_callback does not reallocate/move the buffer and always NUL\u2011terminates at the returned length; or (b) avoid keeping raw pointers computed before unescape (store the offset of the question mark instead and recompute qmark after unescape, or compute args based on the returned uri_len and explicitly ensure NUL termination), or (c) pass a length-bounded view into check_argument_match so that it does not rely on NUL termination. Any of these will prevent potential out\u2011of\u2011bounds reads by string.h functions."
}