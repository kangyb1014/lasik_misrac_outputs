{
  "user_message": "An agent A claimed that the following check_uri_match code violates the MISRA C 2023 rule 8.13.\n<misra_rule>\nMISRA C 2023 Rule 8.13 is A pointer should point to a const-qualified type whenever possible.\n\n</misra_rule>\n<target_code>\nHere is the original code of check_uri_match.\n```c\nstatic bool\ncheck_uri_match (struct MHD_Connection *connection, char *uri, size_t uri_len)\n{\n  char *qmark;\n  char *args;\n  struct MHD_Daemon *const daemon = connection->daemon;\n\n  uri[uri_len] = 0;\n  qmark = memchr (uri,\n                  '?',\n                  uri_len);\n  if (NULL != qmark)\n    *qmark = '\\0';\n\n  /* Need to unescape URI before comparing with connection->url */\n  uri_len = daemon->unescape_callback (daemon->unescape_callback_cls,\n                                       connection,\n                                       uri);\n  if ((uri_len != connection->rq.url_len) ||\n      (0 != memcmp (uri, connection->rq.url, uri_len)))\n  {\n#ifdef HAVE_MESSAGES\n    MHD_DLOG (daemon,\n              _ (\"Authentication failed, URI does not match.\\n\"));\n#endif\n    return false;\n  }\n\n  args = (NULL != qmark) ? (qmark + 1) : uri + uri_len;\n\n  if (! check_argument_match (connection,\n                              args) )\n  {\n#ifdef HAVE_MESSAGES\n    MHD_DLOG (daemon,\n              _ (\"Authentication failed, arguments do not match.\\n\"));\n#endif\n    return false;\n  }\n  return true;\n}\n```\n</target_code>\n<response format>\nProvide your answer with these fields.\n- explanation: your evaluation of the scenario provided by the agent A.\n- is_report_correct: whether the report is correct or not (true/false). True means there is a violation.\n</response format>\n<scenario>\nThe agent A provided the following violation scenario:\nThe local pointer 'args' is declared as 'char *' but is only used to point into the URI buffer for read-only use (assigned from qmark+1 or uri+uri_len and then passed to check_argument_match). It does not need to be used to modify the pointed-to characters and therefore should be declared as 'const char *args' to reflect immutability and satisfy MISRA C 2023 Rule 8.13.\n</scenario>\n\n<instruction>\nJudge whether the report is correct or not.\n</instruction>\n",
  "is_report_correct": true,
  "explanation": "Agent A\u2019s observation is essentially correct: the local pointer args is only used to refer to characters in the URI buffer and is not used to modify the pointee in this function. Per MISRA C 2023 Rule 8.13, a pointer should point to a const-qualified type whenever possible, so args should be declared as const char *args to reflect that it is used read\u2011only.\n\nCaveat: this conclusion assumes that the called function check_argument_match does not require a modifiable char * (i.e. its parameter can be const char * or otherwise does not perform modifications). If check_argument_match is declared to take a non-const char * and actually modifies the buffer (or cannot be changed for API compatibility), then args cannot be made const and no violation exists in this translation unit. Also note that uri and qmark must remain non-const because the code explicitly writes through them (uri[uri_len] = 0 and *qmark = '\\0'), so those are fine as char *.\n\nSo, unless constrained by the signature/behavior of check_argument_match, the report is correct: args should be const-qualified and the current code violates Rule 8.13."
}