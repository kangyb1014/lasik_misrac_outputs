{
  "user_message": "<misra_rule>\nMISRA C 2023 Rule 8.13 is: A pointer should point to a const-qualified type whenever possible.\n\n</misra_rule>\n\nAnother agent reported that the target code violated the Rule 8.13.\nHere is the comment from the agent.\n<violation scenario>\nThe expression memcmp(uri, connection->rq.url, uri_len) passes connection->rq.url (likely a pointer to read-only stored URL) as a read-only operand. If connection->rq.url is declared as char * (non-const) even though it is never modified, this violates MISRA C 2023 Rule 8.13 because the pointer should be const-qualified (e.g. const char *url) when possible. Note: uri must remain non-const because it is modified earlier in the function.\n</violation scenario>\n\nYour job is to insert logging code to capture the control flow and state information of the program.\nInsert logging code so that other agents can reproduce and get evidence for the violation scenario.\n<response format>\n- test_code: a modified check_uri_match code that contains useful probe functions that print useful logs to a file \"/tmp/logs/2683.txt\". The logs should contain the control path and state information of the violation scenario. If test code is not required to validate the scenario, you can leave this blank.\nHere are the constraints for the test code:\n- The test code MUST preserve the original logic of check_uri_match as much as possible.\nYou CAN just insert probe functions to the original code.\n- DO NOT introduce new violations to demonstrate your scenario.\n- The test code MUST be compilable and executable.\n- The test code MUST include line breaks.\n- You MUST NOT define the main function.\n- You MUST NOT define macros.\n</response format>\n<target_code>\nHere is the code of check_uri_match:\n```c\nstatic bool\ncheck_uri_match (struct MHD_Connection *connection, char *uri, size_t uri_len)\n{\n  char *qmark;\n  char *args;\n  struct MHD_Daemon *const daemon = connection->daemon;\n\n  uri[uri_len] = 0;\n  qmark = memchr (uri,\n                  '?',\n                  uri_len);\n  if (NULL != qmark)\n    *qmark = '\\0';\n\n  /* Need to unescape URI before comparing with connection->url */\n  uri_len = daemon->unescape_callback (daemon->unescape_callback_cls,\n                                       connection,\n                                       uri);\n  if ((uri_len != connection->rq.url_len) ||\n      (0 != memcmp (uri, connection->rq.url, uri_len)))\n  {\n#ifdef HAVE_MESSAGES\n    MHD_DLOG (daemon,\n              _ (\"Authentication failed, URI does not match.\\n\"));\n#endif\n    return false;\n  }\n\n  args = (NULL != qmark) ? (qmark + 1) : uri + uri_len;\n\n  if (! check_argument_match (connection,\n                              args) )\n  {\n#ifdef HAVE_MESSAGES\n    MHD_DLOG (daemon,\n              _ (\"Authentication failed, arguments do not match.\\n\"));\n#endif\n    return false;\n  }\n  return true;\n}\n```\n</target_code>\nPlease provide the modified check_uri_match code.\n",
  "test_code": "#include <stdio.h>\n#include <stdarg.h>\n#include <string.h>\n#include <stdbool.h>\n#include <stddef.h>\n#include <stdint.h>\n\n/* Minimal forward declarations so this file is compilable as a unit.\n   Real project will provide the real definitions. These are chosen to\n   preserve the original logic and types used in check_uri_match. */\nstruct MHD_Connection;\nstruct MHD_Daemon {\n  void *unescape_callback_cls;\n  size_t (*unescape_callback) (void *cls,\n                               struct MHD_Connection *connection,\n                               char *uri);\n};\n\nstruct MHD_RQ {\n  char *url;        /* note: intentionally non-const to reflect the reported scenario */\n  size_t url_len;\n};\n\nstruct MHD_Connection {\n  struct MHD_Daemon *daemon;\n  struct MHD_RQ rq;\n};\n\n/* External dependency from original codebase. Provide a prototype so this\n   compiles. The real implementation exists elsewhere. */\nextern bool check_argument_match (struct MHD_Connection *connection, char *args);\n\n/* Logging helpers: append human-readable traces to the specified logfile.\n   These functions are safe and do not change the behavior of check_uri_match. */\nstatic void log_append (const char *fmt, ...)\n{\n  FILE *f = fopen(\"/tmp/logs/2683.txt\", \"a\");\n  if (NULL == f)\n    return;\n  va_list ap;\n  va_start (ap, fmt);\n  vfprintf (f, fmt, ap);\n  va_end (ap);\n  fputc('\\n', f);\n  fclose (f);\n}\n\nstatic void log_buffer_snippet (FILE *f, const char *label, const char *buf, size_t len)\n{\n  /* Write up to a reasonable amount (256) to avoid huge logs. */\n  size_t lim = (len < 256u) ? len : 256u;\n  if (lim == 0u)\n  {\n    fprintf (f, \"%s: (empty)\\n\", label);\n    return;\n  }\n  fprintf (f, \"%s: '\", label);\n  for (size_t i = 0u; i < lim; ++i)\n  {\n    unsigned char c = (unsigned char) buf[i];\n    if (c >= 32u && c <= 126u)\n      fputc ((int) c, f);\n    else if (c == '\\0')\n      fputs (\"\\\\0\", f);\n    else\n      fprintf (f, \"\\\\x%02X\", c);\n  }\n  if (len > lim)\n    fprintf (f, \"...(+%zu bytes)\", len - lim);\n  fprintf (f, \"'\\n\");\n}\n\nstatic void probe_log_initial (struct MHD_Connection *connection, char *uri, size_t uri_len)\n{\n  FILE *f = fopen(\"/tmp/logs/2683.txt\", \"a\");\n  if (NULL == f)\n    return;\n  fprintf (f, \"ENTER check_uri_match: connection=%p, daemon=%p, uri=%p, uri_len=%zu\\n\",\n           (void *) connection, (void *) (connection ? connection->daemon : NULL), (void *) uri, uri_len);\n  log_buffer_snippet (f, \"uri (initial, up to uri_len)\", uri, uri_len);\n  fclose (f);\n}\n\nstatic void probe_log_after_qmark (char *uri, size_t uri_len, char *qmark)\n{\n  FILE *f = fopen(\"/tmp/logs/2683.txt\", \"a\");\n  if (NULL == f)\n    return;\n  if (qmark != NULL)\n    fprintf (f, \"qmark found at offset %td (uri+%td)\\n\", (ptrdiff_t) (qmark - uri), (ptrdiff_t) (qmark - uri));\n  else\n    fprintf (f, \"qmark not found\\n\");\n  /* After possibly null-terminating at qmark */\n  log_buffer_snippet (f, \"uri (post-qmark, nul-terminated)\", uri, uri_len);\n  fclose (f);\n}\n\nstatic void probe_log_before_compare (struct MHD_Connection *connection, char *uri, size_t uri_len)\n{\n  FILE *f = fopen(\"/tmp/logs/2683.txt\", \"a\");\n  if (NULL == f)\n    return;\n  fprintf (f, \"About to compare: uri_len=%zu, connection->rq.url_len=%zu, connection->rq.url=%p\\n\",\n           uri_len, connection->rq.url_len, (void *) connection->rq.url);\n  log_buffer_snippet (f, \"uri (for compare)\", uri, uri_len);\n  log_buffer_snippet (f, \"connection->rq.url (for compare)\", connection->rq.url, connection->rq.url_len);\n  fclose (f);\n}\n\nstatic void probe_log_argument_check (struct MHD_Connection *connection, char *args, bool arg_result)\n{\n  FILE *f = fopen(\"/tmp/logs/2683.txt\", \"a\");\n  if (NULL == f)\n    return;\n  fprintf (f, \"check_argument_match called with args=%p, result=%s\\n\", (void *) args, arg_result ? \"true\" : \"false\");\n  log_buffer_snippet (f, \"args (snippet)\", args, args ? strlen (args) : 0);\n  fclose (f);\n}\n\n/* Modified check_uri_match with logging probes inserted. Logic preserved. */\nstatic bool\ncheck_uri_match (struct MHD_Connection *connection, char *uri, size_t uri_len)\n{\n  char *qmark;\n  char *args;\n  struct MHD_Daemon *const daemon = connection->daemon;\n\n  /* Probe initial state */\n  probe_log_initial (connection, uri, uri_len);\n\n  uri[uri_len] = 0;\n  qmark = memchr (uri,\n                  '?',\n                  uri_len);\n  if (NULL != qmark)\n    *qmark = '\\0';\n\n  probe_log_after_qmark (uri, uri_len, qmark);\n\n  /* Need to unescape URI before comparing with connection->url */\n  uri_len = daemon->unescape_callback (daemon->unescape_callback_cls,\n                                       connection,\n                                       uri);\n\n  FILE *f = fopen(\"/tmp/logs/2683.txt\", \"a\");\n  if (f != NULL)\n  {\n    fprintf (f, \"After unescape_callback: new uri_len=%zu\\n\", uri_len);\n    log_buffer_snippet (f, \"uri (post-unescape)\", uri, uri_len);\n    fclose (f);\n  }\n\n  /* Perform memcmp once and log the result before branching to preserve\n     the original control flow semantics while capturing evidence of the\n     pointer and content comparison. */\n  probe_log_before_compare (connection, uri, uri_len);\n  int cmp_result = 0;\n  if (uri_len > 0u)\n    cmp_result = memcmp (uri, connection->rq.url, uri_len);\n  else\n    cmp_result = 0; /* both zero-length considered equal for comparison */\n\n  if ((uri_len != connection->rq.url_len) || (0 != cmp_result))\n  {\n#ifdef HAVE_MESSAGES\n    MHD_DLOG (daemon,\n              _ (\"Authentication failed, URI does not match.\\n\"));\n#endif\n    log_append (\"RESULT: URI mismatch (uri_len=%zu, rq.url_len=%zu, memcmp=%d)\", uri_len, connection->rq.url_len, cmp_result);\n    return false;\n  }\n\n  args = (NULL != qmark) ? (qmark + 1) : uri + uri_len;\n\n  bool arg_match = check_argument_match (connection,\n                                         args);\n  probe_log_argument_check (connection, args, arg_match);\n\n  if (! arg_match)\n  {\n#ifdef HAVE_MESSAGES\n    MHD_DLOG (daemon,\n              _ (\"Authentication failed, arguments do not match.\\n\"));\n#endif\n    log_append (\"RESULT: argument mismatch\");\n    return false;\n  }\n  log_append (\"RESULT: match successful\");\n  return true;\n}\n"
}