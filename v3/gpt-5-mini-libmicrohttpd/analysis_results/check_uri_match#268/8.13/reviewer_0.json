{
  "user_message": "An agent A claimed that the following check_uri_match code violates the MISRA C 2023 rule 8.13.\n<misra_rule>\nMISRA C 2023 Rule 8.13 is A pointer should point to a const-qualified type whenever possible.\n\n</misra_rule>\n<target_code>\nHere is the original code of check_uri_match.\n```c\nstatic bool\ncheck_uri_match (struct MHD_Connection *connection, char *uri, size_t uri_len)\n{\n  char *qmark;\n  char *args;\n  struct MHD_Daemon *const daemon = connection->daemon;\n\n  uri[uri_len] = 0;\n  qmark = memchr (uri,\n                  '?',\n                  uri_len);\n  if (NULL != qmark)\n    *qmark = '\\0';\n\n  /* Need to unescape URI before comparing with connection->url */\n  uri_len = daemon->unescape_callback (daemon->unescape_callback_cls,\n                                       connection,\n                                       uri);\n  if ((uri_len != connection->rq.url_len) ||\n      (0 != memcmp (uri, connection->rq.url, uri_len)))\n  {\n#ifdef HAVE_MESSAGES\n    MHD_DLOG (daemon,\n              _ (\"Authentication failed, URI does not match.\\n\"));\n#endif\n    return false;\n  }\n\n  args = (NULL != qmark) ? (qmark + 1) : uri + uri_len;\n\n  if (! check_argument_match (connection,\n                              args) )\n  {\n#ifdef HAVE_MESSAGES\n    MHD_DLOG (daemon,\n              _ (\"Authentication failed, arguments do not match.\\n\"));\n#endif\n    return false;\n  }\n  return true;\n}\n```\n</target_code>\n<response format>\nProvide your answer with these fields.\n- explanation: your evaluation of the scenario provided by the agent A.\n- is_report_correct: whether the report is correct or not (true/false). True means there is a violation.\n</response format>\n<scenario>\nThe agent A provided the following violation scenario:\nThe variable 'args' is declared as a modifiable char * but is only used to read from the URI (it is assigned either qmark + 1 or uri + uri_len after any writes to uri have already been performed). Because there is no further modification through 'args', it could be declared as 'const char *args'. Declaring it non-const therefore violates MISRA C 2023 Rule 8.13.\n</scenario>\n\n<instruction>\nJudge whether the report is correct or not.\n</instruction>\n",
  "is_report_correct": true,
  "explanation": "The agent\u2019s observation is correct in the typical reading of this function: the local pointer args is only used to read characters (it is set to qmark+1 or uri+uri_len after any writes to the uri buffer) and is never used to modify the pointed-to data. Per MISRA C:2023 Rule 8.13, a pointer should point to a const-qualified type whenever possible, so args could and should be declared as const char *args.\n\nCaveat: this conclusion depends on the signature and behaviour of check_argument_match. If check_argument_match is declared to accept a char * and/or may modify the data through that parameter, then making args a const char * would be impossible without changing that function\u2019s prototype or inserting casts; in that case the current code would not be considered a violation. If, however, check_argument_match does not modify the buffer and could accept a const char *, then the code as shown does violate Rule 8.13.\n\nSo the agent\u2019s report is correct provided there is no external constraint (such as a required non-const parameter) preventing args from being const-qualified."
}