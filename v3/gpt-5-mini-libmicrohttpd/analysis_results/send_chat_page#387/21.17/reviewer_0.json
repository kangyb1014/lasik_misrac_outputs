{
  "user_message": "An agent A claimed that the following send_chat_page code violates the MISRA C 2023 rule 21.17.\n<misra_rule>\nMISRA C 2023 Rule 21.17 is Use of the string handling functions from <string.h> shall not result in accesses beyond the bounds of the objects referenced by their pointer parameters.\nThis rule strictly applies to the Standard Library functions in <string.h> such as memcpy, memmove, memset, memcmp, strcpy, strncpy, strcat, strncat, strlen, and strspn.\n</misra_rule>\n<target_code>\nHere is the original code of send_chat_page.\n```c\nstatic enum MHD_Result\nsend_chat_page (struct MHD_Connection *con)\n{\n  struct MHD_Response *res;\n  enum MHD_Result ret;\n\n  res = MHD_create_response_from_buffer_static (strlen (CHAT_PAGE),\n                                                (const void *) CHAT_PAGE);\n  ret = MHD_queue_response (con, MHD_HTTP_OK, res);\n  MHD_destroy_response (res);\n  return ret;\n}\n```\n</target_code>\n<response format>\nProvide your answer with these fields.\n- explanation: your evaluation of the scenario provided by the agent A.\n- is_report_correct: whether the report is correct or not (true/false). True means there is a violation.\n</response format>\n<scenario>\nThe agent A provided the following violation scenario:\nCalling strlen(CHAT_PAGE) is only safe if CHAT_PAGE points to a null\u2011terminated character array. If CHAT_PAGE is not guaranteed to contain a '\\0' within its object bounds (for example if it is a pointer to a buffer with an explicit length but missing NUL, or if it was produced/filled without ensuring termination), strlen will scan past the buffer and access memory beyond the object. In that case the use of strlen violates MISRA C 2023 Rule 21.17.\n</scenario>\n\n<instruction>\nJudge whether the report is correct or not.\n</instruction>\n",
  "is_report_correct": false,
  "explanation": "MISRA C:2023 Rule 21.17 prohibits calling string.h functions in a way that can read past the bounds of the object. strlen(CHAT_PAGE) is unsafe only if CHAT_PAGE is not guaranteed to be a NUL\u2011terminated character array (strlen scans until it finds a '\\0'). The snippet shown does not include the definition of CHAT_PAGE. If CHAT_PAGE is a string literal or a char array that is NUL\u2011terminated (e.g. \"...\" or const char CHAT_PAGE[] = \"...\"), then strlen is safe and there is no rule violation. If CHAT_PAGE can be a pointer/buffer without a terminating '\\0' or with an explicit separate length, then using strlen would indeed risk out\u2011of\u2011bounds access and would violate Rule 21.17. Therefore the agent\u2019s claim is not unconditionally correct \u2014 it is a valid concern only when CHAT_PAGE is not guaranteed NUL\u2011terminated. Recommend either ensure CHAT_PAGE is NUL\u2011terminated or use an API that takes an explicit length to avoid any ambiguity."
}