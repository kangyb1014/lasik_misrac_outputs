{
  "user_message": "An agent A claimed that the following MHD_get_fdset code violates the MISRA C 2023 rule 8.13.\n<misra_rule>\nMISRA C 2023 Rule 8.13 is A pointer should point to a const-qualified type whenever possible.\n\n</misra_rule>\n<target_code>\nHere is the original code of MHD_get_fdset.\n```c\n_MHD_EXTERN enum MHD_Result\nMHD_get_fdset (struct MHD_Daemon *daemon,\n               fd_set *read_fd_set,\n               fd_set *write_fd_set,\n               fd_set *except_fd_set,\n               MHD_socket *max_fd)\n{\n  return MHD_get_fdset2 (daemon,\n                         read_fd_set,\n                         write_fd_set,\n                         except_fd_set,\n                         max_fd,\n#ifdef HAS_FD_SETSIZE_OVERRIDABLE\n                         daemon->fdset_size_set_by_app ?\n                         ((unsigned int) daemon->fdset_size) :\n                         ((unsigned int) _MHD_SYS_DEFAULT_FD_SETSIZE)\n#else  /* ! HAS_FD_SETSIZE_OVERRIDABLE */\n                         ((unsigned int) _MHD_SYS_DEFAULT_FD_SETSIZE)\n#endif /* ! HAS_FD_SETSIZE_OVERRIDABLE */\n                         );\n}\n```\n</target_code>\n<response format>\nProvide your answer with these fields.\n- explanation: your evaluation of the scenario provided by the agent A.\n- is_report_correct: whether the report is correct or not (true/false). True means there is a violation.\n</response format>\n<scenario>\nThe agent A provided the following violation scenario:\nMHD_get_fdset takes parameter 'struct MHD_Daemon *daemon' and forwards it to MHD_get_fdset2. If neither MHD_get_fdset nor MHD_get_fdset2 modify the daemon object (i.e. they only read from it), then the pointer should be to a const-qualified type (const struct MHD_Daemon *) per MISRA C 2023 Rule 8.13. As written the non-const pointer is used where a const-qualified pointer would be possible, so this is a rule violation.\n</scenario>\n\n<instruction>\nJudge whether the report is correct or not.\n</instruction>\n",
  "is_report_correct": false,
  "explanation": "The report is not verifiably correct from the snippet alone. MISRA C 2023 Rule 8.13 does recommend that pointers that are only used to access objects should point to const-qualified types, but determining a violation requires knowing whether the daemon object is ever modified and the signature/behavior of MHD_get_fdset2 (and any other callees). In this snippet MHD_get_fdset simply forwards the daemon pointer to MHD_get_fdset2. If MHD_get_fdset2 (or downstream code) modifies the structure or has a non-const API that must accept a non-const pointer, then the current signature is appropriate and there is no violation. Conversely, if neither MHD_get_fdset nor MHD_get_fdset2 (and no other reachable callees) modify the daemon and the API could be changed, then making the parameter const struct MHD_Daemon * would be required by Rule 8.13 and the report would be correct. Because the necessary information (the definition/signature and behavior of MHD_get_fdset2 and whether the daemon is ever modified) is not present, the claim cannot be confirmed from the provided code alone."
}