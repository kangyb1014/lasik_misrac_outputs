{
  "user_message": "An agent A claimed that the following parse_connection_headers code violates the MISRA C 2023 rule 21.17.\n<misra_rule>\nMISRA C 2023 Rule 21.17 is Use of the string handling functions from <string.h> shall not result in accesses beyond the bounds of the objects referenced by their pointer parameters.\nThis rule strictly applies to the Standard Library functions in <string.h> such as memcpy, memmove, memset, memcmp, strcpy, strncpy, strcat, strncat, strlen, and strspn.\n</misra_rule>\n<target_code>\nHere is the original code of parse_connection_headers.\n```c\nstatic void\nparse_connection_headers (struct MHD_Connection *connection)\n{\n  const char *clen;\n  const char *enc;\n  size_t val_len;\n\n#ifdef COOKIE_SUPPORT\n  if (MHD_PARSE_COOKIE_NO_MEMORY == parse_cookie_header (connection))\n  {\n    handle_req_cookie_no_space (connection);\n    return;\n  }\n#endif /* COOKIE_SUPPORT */\n  if ( (-3 < connection->daemon->client_discipline) &&\n       (MHD_IS_HTTP_VER_1_1_COMPAT (connection->rq.http_ver)) &&\n       (MHD_NO ==\n        MHD_lookup_connection_value_n (connection,\n                                       MHD_HEADER_KIND,\n                                       MHD_HTTP_HEADER_HOST,\n                                       MHD_STATICSTR_LEN_ (\n                                         MHD_HTTP_HEADER_HOST),\n                                       NULL,\n                                       NULL)) )\n  {\n#ifdef HAVE_MESSAGES\n    MHD_DLOG (connection->daemon,\n              _ (\"Received HTTP/1.1 request without `Host' header.\\n\"));\n#endif\n    transmit_error_response_static (connection,\n                                    MHD_HTTP_BAD_REQUEST,\n                                    REQUEST_LACKS_HOST);\n    return;\n  }\n\n  /* The presence of the request body is indicated by \"Content-Length:\" or\n     \"Transfer-Encoding:\" request headers.\n     Unless one of these two headers is used, the request has no request body.\n     See RFC9112, Section 6, paragraph 4. */\n  connection->rq.remaining_upload_size = 0;\n  if (MHD_NO !=\n      MHD_lookup_connection_value_n (connection,\n                                     MHD_HEADER_KIND,\n                                     MHD_HTTP_HEADER_TRANSFER_ENCODING,\n                                     MHD_STATICSTR_LEN_ (\n                                       MHD_HTTP_HEADER_TRANSFER_ENCODING),\n                                     &enc,\n                                     NULL))\n  {\n    if (! MHD_str_equal_caseless_ (enc,\n                                   \"chunked\"))\n    {\n      transmit_error_response_static (connection,\n                                      MHD_HTTP_BAD_REQUEST,\n                                      REQUEST_UNSUPPORTED_TR_ENCODING);\n      return;\n    }\n    else if (MHD_NO !=\n             MHD_lookup_connection_value_n (connection,\n                                            MHD_HEADER_KIND,\n                                            MHD_HTTP_HEADER_CONTENT_LENGTH,\n                                            MHD_STATICSTR_LEN_ ( \\\n                                              MHD_HTTP_HEADER_CONTENT_LENGTH),\n                                            NULL,\n                                            NULL))\n    {\n      /* TODO: add individual settings */\n      if (1 <= connection->daemon->client_discipline)\n      {\n        transmit_error_response_static (connection,\n                                        MHD_HTTP_BAD_REQUEST,\n                                        REQUEST_LENGTH_WITH_TR_ENCODING);\n        return;\n      }\n      else\n      {\n        /* Must close connection after reply to prevent potential attack */\n        connection->keepalive = MHD_CONN_MUST_CLOSE;\n#ifdef HAVE_MESSAGES\n        MHD_DLOG (connection->daemon,\n                  _ (\"The 'Content-Length' request header is ignored \"\n                     \"as chunked Transfer-Encoding is used \"\n                     \"for this request.\\n\"));\n#endif /* HAVE_MESSAGES */\n      }\n    }\n    connection->rq.have_chunked_upload = true;\n    connection->rq.remaining_upload_size = MHD_SIZE_UNKNOWN;\n  }\n  else if (MHD_NO !=\n           MHD_lookup_connection_value_n (connection,\n                                          MHD_HEADER_KIND,\n                                          MHD_HTTP_HEADER_CONTENT_LENGTH,\n                                          MHD_STATICSTR_LEN_ (\n                                            MHD_HTTP_HEADER_CONTENT_LENGTH),\n                                          &clen,\n                                          &val_len))\n  {\n    size_t num_digits;\n\n    num_digits = MHD_str_to_uint64_n_ (clen,\n                                       val_len,\n                                       &connection->rq.remaining_upload_size);\n\n    if (((0 == num_digits) &&\n         (0 != val_len) &&\n         ('0' <= clen[0]) && ('9' >= clen[0]))\n        || (MHD_SIZE_UNKNOWN == connection->rq.remaining_upload_size))\n    {\n      connection->rq.remaining_upload_size = 0;\n#ifdef HAVE_MESSAGES\n      MHD_DLOG (connection->daemon,\n                _ (\"Too large value of 'Content-Length' header. \" \\\n                   \"Closing connection.\\n\"));\n#endif\n      transmit_error_response_static (connection,\n                                      MHD_HTTP_CONTENT_TOO_LARGE,\n                                      REQUEST_CONTENTLENGTH_TOOLARGE);\n    }\n    else if ((val_len != num_digits) ||\n             (0 == num_digits))\n    {\n      connection->rq.remaining_upload_size = 0;\n#ifdef HAVE_MESSAGES\n      MHD_DLOG (connection->daemon,\n                _ (\"Failed to parse 'Content-Length' header. \" \\\n                   \"Closing connection.\\n\"));\n#endif\n      transmit_error_response_static (connection,\n                                      MHD_HTTP_BAD_REQUEST,\n                                      REQUEST_CONTENTLENGTH_MALFORMED);\n    }\n  }\n}\n```\n</target_code>\n<response format>\nProvide your answer with these fields.\n- explanation: your evaluation of the scenario provided by the agent A.\n- is_report_correct: whether the report is correct or not (true/false). True means there is a violation.\n</response format>\n<scenario>\nThe agent A provided the following violation scenario:\nMHD_lookup_connection_value_n is called with &enc and NULL for the length. If that lookup returns a pointer to a header value that is not NUL-terminated (or whose validity length is not reported because the length argument was NULL), then the subsequent call MHD_str_equal_caseless_(enc, \"chunked\") may internally use standard <string.h> functions that assume NUL-terminated strings (e.g. strcmp/strcasecmp/strlen) and thus read past the end of the object referenced by enc. That would be an out-of-bounds access and therefore a violation of MISRA C 2023 Rule 21.17. To avoid the violation, the code should obtain the value length and use a length-aware comparison or ensure the returned string is NUL-terminated.\n</scenario>\n\n<execution_log>\nThe agent A also provided the following output log:\nparse_connection_headers: entry: connection=0x55c2ad72d270 daemon=0x55c2ad72a8d0 rq.http_ver=3 client_discipline=0\nparse_connection_headers: lookup Transfer-Encoding rc=0 enc_ptr=0x55c2ad72d270 length_requested=NULL\nparse_connection_headers: found Content-Length header; clen_ptr=0x55c2ad72d50f val_len=2\nparse_connection_headers: exit: have_chunked_upload=0 remaining_upload_size=18\nparse_connection_headers: entry: connection=0x55c2ad72d270 daemon=0x55c2ad72a8d0 rq.http_ver=3 client_discipline=0\nparse_connection_headers: lookup Transfer-Encoding rc=0 enc_ptr=0x55c2ad72d270 length_requested=NULL\nparse_connection_headers: found Content-Length header; clen_ptr=0x55c2ad72d50f val_len=2\nparse_connection_headers: exit: have_chunked_upload=0 remaining_upload_size=18\nparse_connection_headers: entry: connection=0x55c2ad72d270 daemon=0x55c2ad72a8d0 rq.http_ver=3 client_discipline=0\nparse_connection_headers: lookup Transfer-Encoding rc=0 enc_ptr=0x55c2ad72d270 length_requested=NULL\nparse_connection_headers: found Content-Length header; clen_ptr=0x55c2ad72d50f val_len=2\nparse_connection_headers: exit: have_chunked_upload=0 remaining_upload_size=18\nparse_connection_headers: entry: connection=0x55c2ad72d270 daemon=0x55c2ad72a8d0 rq.http_ver=3 client_discipline=0\nparse_connection_headers: lookup Transfer-Encoding rc=0 enc_ptr=0x55c2ad72d270 length_requested=NULL\nparse_connection_headers: found Content-Length header; clen_ptr=0x55c2ad72d50f val_len=2\nparse_connection_headers: exit: have_chunked_upload=0 remaining_upload_size=18\nparse_connection_headers: entry: connection=0x55c2ad72d270 daemon=0x55c2ad72a8d0 rq.http_ver=3 client_discipline=0\nparse_connection_headers: lookup Transfer-Encoding rc=0 enc_ptr=0x55c2ad72d270 length_requested=NULL\nparse_connection_headers: found Content-Length header; clen_ptr=0x55c2ad72d50f val_len=2\nparse_connection_headers: exit: have_chunked_upload=0 remaining_upload_size=18\nparse_connection_headers: entry: connection=0x55c2ad72d270 daemon=0x55c2ad72a8d0 rq.http_ver=3 client_discipline=0\nparse_connection_headers: lookup Transfer-Encoding rc=0 enc_ptr=0x55c2ad72d270 length_requested=NULL\nparse_connection_headers: found Content-Length header; clen_ptr=0x55c2ad72d50f val_len=2\nparse_connection_headers: exit: have_chunked_upload=0 remaining_upload_size=18\nparse_connection_headers: entry: connection=0x55c2ad72d270 daemon=0x55c2ad72a8d0 rq.http_ver=3 client_discipline=0\nparse_connection_headers: lookup Transfer-Encoding rc=0 enc_ptr=0x55c2ad72d270 length_requested=NULL\nparse_connection_headers: found Content-Length header; clen_ptr=0x55c2ad72d50f val_len=2\nparse_connection_headers: exit: have_chunked_upload=0 remaining_upload_size=18\nparse_connection_headers: entry: connection=0x55c2ad72d270 daemon=0x55c2ad72a8d0 rq.http_ver=3 client_discipline=0\nparse_connection_headers: lookup Transfer-Encoding rc=0 enc_ptr=0x55c2ad72d270 length_requested=NULL\nparse_connection_headers: found Content-Length header; clen_ptr=0x55c2ad72d50f val_len=2\nparse_connection_headers: exit: have_chunked_upload=0 remaining_upload_size=18\nparse_connection_headers: entry: connection=0x55c2ad72d270 daemon=0x55c2ad72a8d0 rq.http_ver=3 client_discipline=0\nparse_connection_headers: lookup Transfer-Encoding rc=0 enc_ptr=0x55c2ad72d270 length_requested=NULL\nparse_connection_headers: found Content-Length header; clen_ptr=0x55c2ad72d50f val_len=2\nparse_connection_headers: exit: have_chunked_upload=0 remaining_upload_size=18\nparse_connection_headers: entry: connection=0x55c2ad72d270 daemon=0x55c2ad72a8d0 rq.http_ver=3 client_discipline=0\nparse_connection_headers: lookup Transfer-Encoding rc=0 enc_ptr=0x55c2ad72d270 length_requested=NULL\nparse_connection_headers: found Content-Length header; clen_ptr=0x55c2ad72d50f val_len=2\nparse_connection_headers: exit: have_chunked_upload=0 remaining_upload_size=18\nparse_connection_headers: entry: connection=0x55c2ad72d270 daemon=0x55c2ad72a8d0 rq.http_ver=3 client_discipline=0\nparse_connection_headers: lookup Transfer-Encoding rc=0 enc_ptr=0x55c2ad72d270 length_requested=NULL\nparse_connection_headers: found Content-\n</execution_log>\n\n<instruction>\nJudge whether the report is correct or not.\n</instruction>\n",
  "is_report_correct": false,
  "explanation": "The agent's scenario is speculative and not demonstrated from the code shown. MISRA C:2023 Rule 21.17 forbids letting standard <string.h> functions access past object bounds. In parse_connection_headers the code calls MHD_lookup_connection_value_n(..., &enc, NULL) and then calls MHD_str_equal_caseless_(enc, \"chunked\"). Two points: (1) the comparison is not a direct call to a standard <string.h> function in this function \u2014 it is an internal helper (MHD_str_equal_caseless_). Whether a violation exists depends on the contracts/implementation of the two library functions involved, not on this call site alone. (2) Typical libmicrohttpd semantics are that when the caller does not request a length (value_len == NULL) the returned pointer points to a NUL-terminated string; the codebase\u2019s runtime traces show the function returning a valid pointer when length_requested == NULL. If that API guarantee holds (or if MHD_str_equal_caseless_ is implemented to be length-aware or otherwise safe), no out-of-bounds access occurs and there is no Rule 21.17 violation. If, conversely, the lookup function can return a non-NUL-terminated buffer when no length is requested, or if MHD_str_equal_caseless_ uses standard string functions that assume NUL-termination, then the scenario described would indeed create a potential Rule 21.17 violation. Because the report does not cite the actual API contract or the implementation of MHD_str_equal_caseless_, it does not prove a violation of MISRA Rule 21.17. Recommendation: confirm the contract of MHD_lookup_connection_value_n and inspect MHD_str_equal_caseless_ implementation. If there is any doubt, request the length (pass a size_t pointer) and use a length-aware comparison to satisfy MISRA Rule 21.17 unambiguously."
}