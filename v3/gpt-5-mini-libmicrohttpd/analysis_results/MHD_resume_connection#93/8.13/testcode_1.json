{
  "user_message": "<misra_rule>\nMISRA C 2023 Rule 8.13 is: A pointer should point to a const-qualified type whenever possible.\n\n</misra_rule>\n\nAnother agent reported that the target code violated the Rule 8.13.\nHere is the comment from the agent.\n<violation scenario>\nThe call passes the string literal \"r\" to MHD_itc_activate_. If the prototype of MHD_itc_activate_ accepts a non-const char * (e.g. int MHD_itc_activate_(..., char *cmd)), this is a violation: the function should take a const char * because the argument is a string literal and not meant to be modified. If, however, MHD_itc_activate_ is declared to take a const char * (or daemon->itc is a pointer to a type that must be mutable and is legitimately non-const), then there is no violation. Based on the fragment alone the likely problematic scenario is a non-const parameter for the string literal.\n</violation scenario>\n\nYour job is to insert logging code to capture the control flow and state information of the program.\nInsert logging code so that other agents can reproduce and get evidence for the violation scenario.\n<response format>\n- test_code: a modified MHD_resume_connection code that contains useful probe functions that print useful logs to a file \"/tmp/logs/933.txt\". The logs should contain the control path and state information of the violation scenario. If test code is not required to validate the scenario, you can leave this blank.\nHere are the constraints for the test code:\n- The test code MUST preserve the original logic of MHD_resume_connection as much as possible.\nYou CAN just insert probe functions to the original code.\n- DO NOT introduce new violations to demonstrate your scenario.\n- The test code MUST be compilable and executable.\n- The test code MUST include line breaks.\n- You MUST NOT define the main function.\n- You MUST NOT define macros.\n</response format>\n<target_code>\nHere is the code of MHD_resume_connection:\n```c\n_MHD_EXTERN void\nMHD_resume_connection (struct MHD_Connection *connection)\n{\n  struct MHD_Daemon *daemon = connection->daemon;\n#if defined(MHD_USE_THREADS)\n  mhd_assert (NULL == daemon->worker_pool);\n#endif /* MHD_USE_THREADS */\n\n  if (0 == (daemon->options & MHD_TEST_ALLOW_SUSPEND_RESUME))\n    MHD_PANIC (_ (\"Cannot resume connections without enabling \" \\\n                  \"MHD_ALLOW_SUSPEND_RESUME!\\n\"));\n#if defined(MHD_USE_POSIX_THREADS) || defined(MHD_USE_W32_THREADS)\n  MHD_mutex_lock_chk_ (&daemon->cleanup_connection_mutex);\n#endif\n  connection->resuming = true;\n  daemon->resuming = true;\n#if defined(MHD_USE_POSIX_THREADS) || defined(MHD_USE_W32_THREADS)\n  MHD_mutex_unlock_chk_ (&daemon->cleanup_connection_mutex);\n#endif\n  if ( (MHD_ITC_IS_VALID_ (daemon->itc)) &&\n       (! MHD_itc_activate_ (daemon->itc, \"r\")) )\n  {\n#ifdef HAVE_MESSAGES\n    MHD_DLOG (daemon,\n              _ (\"Failed to signal resume via inter-thread \" \\\n                 \"communication channel.\\n\"));\n#endif\n  }\n}\n```\n</target_code>\nPlease provide the modified MHD_resume_connection code.\n",
  "test_code": "#include <stdio.h>\n#include <stdbool.h>\n#include <time.h>\n\n/* Probe logger: append human-readable trace information to /tmp/logs/933.txt.\n   Implemented as a small utility so we do not alter original control flow. */\nstatic void\nmhd_probe_log_(const char *stage,\n               const void *daemon_ptr,\n               const void *itc_ptr,\n               unsigned long daemon_options,\n               int itc_valid,\n               int itc_activate_result,\n               bool connection_resuming,\n               bool daemon_resuming)\n{\n  FILE *fp = fopen(\"/tmp/logs/933.txt\", \"a\");\n  if (NULL == fp)\n    return;\n\n  /* Simple timestamp */\n  time_t t = time(NULL);\n  fprintf(fp, \"[%ld] STAGE: %s\\n\", (long)t, stage);\n  fprintf(fp, \"  daemon ptr: %p\\n\", daemon_ptr);\n  fprintf(fp, \"  daemon->itc ptr: %p\\n\", itc_ptr);\n  fprintf(fp, \"  daemon->options: 0x%08lx\\n\", daemon_options);\n  fprintf(fp, \"  itc_valid: %d\\n\", itc_valid);\n  fprintf(fp, \"  itc_activate_result: %d\\n\", itc_activate_result);\n  fprintf(fp, \"  connection->resuming: %d\\n\", connection_resuming ? 1 : 0);\n  fprintf(fp, \"  daemon->resuming: %d\\n\", daemon_resuming ? 1 : 0);\n\n  /* Record the literal \"r\" pointer value so callers can inspect whether\n     a string literal is being passed (relevant for const qualification checks). */\n  fprintf(fp, \"  string_literal_\\\"r\\\" ptr: %p\\n\", (const void *)\"r\");\n  fprintf(fp, \"---\\n\");\n\n  (void)fclose(fp);\n}\n\n_MHD_EXTERN void\nMHD_resume_connection (struct MHD_Connection *connection)\n{\n  struct MHD_Daemon *daemon = connection->daemon;\n#if defined(MHD_USE_THREADS)\n  mhd_assert (NULL == daemon->worker_pool);\n#endif /* MHD_USE_THREADS */\n\n  /* Log entry state before any action */\n  mhd_probe_log_(\"entry\",\n                 (const void *)daemon,\n                 (const void *)daemon->itc,\n                 (unsigned long)daemon->options,\n                 /* itc_valid */ (int)MHD_ITC_IS_VALID_ (daemon->itc),\n                 /* itc_activate_result */ -1,\n                 /* connection_resuming */ connection->resuming,\n                 /* daemon_resuming */ daemon->resuming);\n\n  if (0 == (daemon->options & MHD_TEST_ALLOW_SUSPEND_RESUME))\n    MHD_PANIC (_ (\"Cannot resume connections without enabling \" \\\n                  \"MHD_ALLOW_SUSPEND_RESUME!\\n\"));\n#if defined(MHD_USE_POSIX_THREADS) || defined(MHD_USE_W32_THREADS)\n  MHD_mutex_lock_chk_ (&daemon->cleanup_connection_mutex);\n#endif\n  connection->resuming = true;\n  daemon->resuming = true;\n#if defined(MHD_USE_POSIX_THREADS) || defined(MHD_USE_W32_THREADS)\n  MHD_mutex_unlock_chk_ (&daemon->cleanup_connection_mutex);\n#endif\n\n  /* Log state after marking as resuming */\n  mhd_probe_log_(\"after_set_resuming\",\n                 (const void *)daemon,\n                 (const void *)daemon->itc,\n                 (unsigned long)daemon->options,\n                 (int)MHD_ITC_IS_VALID_ (daemon->itc),\n                 /* itc_activate_result */ -1,\n                 /* connection_resuming */ connection->resuming,\n                 /* daemon_resuming */ daemon->resuming);\n\n  if ( (MHD_ITC_IS_VALID_ (daemon->itc)) )\n  {\n    /* Evaluate activation and log the result. We preserve the original\n       semantics while allowing probes to capture the return value and the\n       pointer of the string literal \"r\" that is passed to the activation\n       function (relevant for const-qualification checks). */\n    int itc_valid = 1;\n    int activated = MHD_itc_activate_ (daemon->itc, \"r\");\n\n    mhd_probe_log_(\"after_itc_activate\",\n                   (const void *)daemon,\n                   (const void *)daemon->itc,\n                   (unsigned long)daemon->options,\n                   itc_valid,\n                   activated,\n                   connection->resuming,\n                   daemon->resuming);\n\n    if (! activated)\n    {\n#ifdef HAVE_MESSAGES\n      MHD_DLOG (daemon,\n                _ (\"Failed to signal resume via inter-thread \" \\\n                   \"communication channel.\\n\"));\n#endif\n    }\n  }\n}\n"
}