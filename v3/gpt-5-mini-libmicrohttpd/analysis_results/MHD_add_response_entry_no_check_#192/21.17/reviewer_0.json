{
  "user_message": "An agent A claimed that the following MHD_add_response_entry_no_check_ code violates the MISRA C 2023 rule 21.17.\n<misra_rule>\nMISRA C 2023 Rule 21.17 is Use of the string handling functions from <string.h> shall not result in accesses beyond the bounds of the objects referenced by their pointer parameters.\nThis rule strictly applies to the Standard Library functions in <string.h> such as memcpy, memmove, memset, memcmp, strcpy, strncpy, strcat, strncat, strlen, and strspn.\n</misra_rule>\n<target_code>\nHere is the original code of MHD_add_response_entry_no_check_.\n```c\nbool\nMHD_add_response_entry_no_check_ (struct MHD_Response *response,\n                                  enum MHD_ValueKind kind,\n                                  const char *header,\n                                  size_t header_len,\n                                  const char *content,\n                                  size_t content_len)\n{\n  char *header_malloced;\n  char *value_malloced;\n\n  mhd_assert (0 != header_len);\n  mhd_assert (0 != content_len);\n  header_malloced = malloc (header_len + 1);\n  if (NULL == header_malloced)\n    return false;\n\n  memcpy (header_malloced, header, header_len);\n  header_malloced[header_len] = 0;\n\n  value_malloced = malloc (content_len + 1);\n  if (NULL != value_malloced)\n  {\n    memcpy (value_malloced, content, content_len);\n    value_malloced[content_len] = 0;\n\n    if (MHD_add_response_entry_no_alloc_ (response, kind,\n                                          header_malloced, header_len,\n                                          value_malloced, content_len))\n      return true; /* Success exit point */\n\n    free (value_malloced);\n  }\n  free (header_malloced);\n\n  return false; /* Failure exit point */\n}\n```\n</target_code>\n<response format>\nProvide your answer with these fields.\n- explanation: your evaluation of the scenario provided by the agent A.\n- is_report_correct: whether the report is correct or not (true/false). True means there is a violation.\n</response format>\n<scenario>\nThe agent A provided the following violation scenario:\nViolation: memcpy(value_malloced, content, content_len) may read beyond the source object. The code does not validate that 'content' is non-NULL and that the object it points to has at least content_len bytes. For example, if content points to a 5-byte buffer but content_len == 10 (or content == NULL while content_len != 0), memcpy will access beyond the bounds of the source object, causing undefined behavior and violating MISRA C 2023 Rule 21.17.\n</scenario>\n\n<execution_log>\nThe agent A also provided the following output log:\nENTRY: MHD_add_response_entry_no_check_: response=0x55e7a8c08820, kind=1, header=0x55e76d5bb01f, header_len=13, content=0x55e76d5bb02d, content_len=8\nmalloc succeeded for header_malloced=0x55e7a8c08ac0 (size=14)\nabout to memcpy(header_malloced=0x55e7a8c08ac0, header=0x55e76d5bb01f, header_len=13)\ncopied header -> header_malloced[13]=0\nmalloc succeeded for value_malloced=0x55e7a8c08ae0 (size=9)\nabout to memcpy(value_malloced=0x55e7a8c08ae0, content=0x55e76d5bb02d, content_len=8)\ncopied content -> value_malloced[8]=0\ncalling MHD_add_response_entry_no_alloc_(response=0x55e7a8c08820, kind=1, header_malloced=0x55e7a8c08ac0, header_len=13, value_malloced=0x55e7a8c08ae0, content_len=8)\nMHD_add_response_entry_no_alloc_ returned true -> success exit\nENTRY: MHD_add_response_entry_no_check_: response=0x55e7a8c08820, kind=1, header=0x55e76d5bb01f, header_len=13, content=0x55e76d5bb04d, content_len=8\nmalloc succeeded for header_malloced=0x55e7a8c08b40 (size=14)\nabout to memcpy(header_malloced=0x55e7a8c08b40, header=0x55e76d5bb01f, header_len=13)\ncopied header -> header_malloced[13]=0\nmalloc succeeded for value_malloced=0x55e7a8c08b60 (size=9)\nabout to memcpy(value_malloced=0x55e7a8c08b60, content=0x55e76d5bb04d, content_len=8)\ncopied content -> value_malloced[8]=0\ncalling MHD_add_response_entry_no_alloc_(response=0x55e7a8c08820, kind=1, header_malloced=0x55e7a8c08b40, header_len=13, value_malloced=0x55e7a8c08b60, content_len=8)\nMHD_add_response_entry_no_alloc_ returned true -> success exit\nENTRY: MHD_add_response_entry_no_check_: response=0x55e7a8c08820, kind=1, header=0x55e76d5bb01f, header_len=13, content=0x55e76d5bb087, content_len=8\nmalloc succeeded for header_malloced=0x55e7a8c08ae0 (size=14)\nabout to memcpy(header_malloced=0x55e7a8c08ae0, header=0x55e76d5bb01f, header_len=13)\ncopied header -> header_malloced[13]=0\nmalloc succeeded for value_malloced=0x55e7a8c08ac0 (size=9)\nabout to memcpy(value_malloced=0x55e7a8c08ac0, content=0x55e76d5bb087, content_len=8)\ncopied content -> value_malloced[8]=0\ncalling MHD_add_response_entry_no_alloc_(response=0x55e7a8c08820, kind=1, header_malloced=0x55e7a8c08ae0, header_len=13, value_malloced=0x55e7a8c08ac0, content_len=8)\nMHD_add_response_entry_no_alloc_ returned true -> success exit\nENTRY: MHD_add_response_entry_no_check_: response=0x55e7a8c08820, kind=1, header=0x55e76d5bba16, header_len=4, content=0x55e76d5bba1b, content_len=29\nmalloc succeeded for header_malloced=0x55e7a8c08ac0 (size=5)\nabout to memcpy(header_malloced=0x55e7a8c08ac0, header=0x55e76d5bba16, header_len=4)\ncopied header -> header_malloced[4]=0\nmalloc succeeded for value_malloced=0x55e7a8c08c40 (size=30)\nabout to memcpy(value_malloced=0x55e7a8c08c40, content=0x55e76d5bba1b, content_len=29)\ncopied content -> value_malloced[29]=0\ncalling MHD_add_response_entry_no_alloc_(response=0x55e7a8c08820, kind=1, header_malloced=0x55e7a8c08ac0, header_len=4, value_malloced=0x55e7a8c08c40, content_len=29)\nMHD_add_response_entry_no_alloc_ returned true -> success exit\nENTRY: MHD_add_response_entry_no_check_: response=0x55e7a8c08820, kind=1, header=0x55e76d5bba16, header_len=4, content=0x55e76d5bba79, content_len=29\nmalloc succeeded for header_malloced=0x55e7a8c08ac0 (size=5)\nabout to memcpy(header_malloced=0x55e7a8c08ac0, header=0x55e76d5bba16, header_len=4)\ncopied header -> header_malloced[4]=0\nmalloc succeeded for value_malloced=0x55e7a8c08c40 (size=30)\nabout to memcpy(value_malloced=0x55e7a8c08c40, content=0x55e76d5bba79, content_len=29)\ncopied content -> value_malloced[29]=0\ncalling MHD_add_response_entry_no_alloc_(response=0x55e7a8c08820, kind=1, header_malloced=0x55e7a8c08ac0, header_len=4, value_malloced=0x55e7a8c08c40, content_len=29)\nMHD_add_response_entry_no_alloc_ returned true -> success exit\nENTRY: MHD_add_response_entry_no_check_: response=0x55e7a8c08820, kind=1, header=0x55e76d5bbaf5, header_len=17, content=0x55e76d5bbb07, content_len=7\nmalloc succeeded for header_malloced=0x55e7a8c08ac0 (size=18)\nabout to memcpy(header_malloced=0x55e7a8c08ac0, header=0x55e76d5bbaf5, header_len=17)\ncopied header -> header_malloced[17]=0\nmall\n</execution_log>\n\n<instruction>\nJudge whether the report is correct or not.\n</instruction>\n",
  "is_report_correct": true,
  "explanation": "The report is correct. Rule 21.17 forbids using string.h functions in a way that can access memory beyond the bounds of the objects referenced by their pointer parameters. In this function the destination buffers are allocated with content_len+1 and header_len+1 so the writes are safe, but the memcpy calls read from the caller-supplied source pointers (header and content) for header_len and content_len bytes without ensuring those pointers actually reference that many bytes (or are non-NULL). The only checks are mhd_assert on the lengths, which may be a macro that is disabled in production, and do not validate the source pointers or their object sizes. Thus memcpy(value_malloced, content, content_len) (and the header memcpy) can read beyond the source object (or dereference NULL) if the caller passes inconsistent arguments, violating MISRA C 2023 Rule 21.17."
}