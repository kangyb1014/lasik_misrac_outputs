{
  "user_message": "An agent A claimed that the following get_unquoted_param code violates the MISRA C 2023 rule 21.17.\n<misra_rule>\nMISRA C 2023 Rule 21.17 is Use of the string handling functions from <string.h> shall not result in accesses beyond the bounds of the objects referenced by their pointer parameters.\nThis rule strictly applies to the Standard Library functions in <string.h> such as memcpy, memmove, memset, memcmp, strcpy, strncpy, strcat, strncat, strlen, and strspn.\n</misra_rule>\n<target_code>\nHere is the original code of get_unquoted_param.\n```c\nstatic enum _MHD_GetUnqResult\nget_unquoted_param (const struct MHD_RqDAuthParam *param,\n                    char tmp1[_MHD_STATIC_UNQ_BUFFER_SIZE],\n                    char **ptmp2,\n                    size_t *ptmp2_size,\n                    struct _MHD_str_w_len *unquoted)\n{\n  char *str;\n  size_t len;\n  mhd_assert (NULL != param->value.str);\n  mhd_assert (0 != param->value.len);\n\n  if (! param->quoted)\n  {\n    unquoted->str = param->value.str;\n    unquoted->len = param->value.len;\n    return _MHD_UNQ_OK;\n  }\n  /* The value is present and is quoted, needs to be copied and unquoted */\n  str = get_buffer_for_size (tmp1, ptmp2, ptmp2_size, param->value.len);\n  if (NULL == str)\n    return (param->value.len > _MHD_AUTH_DIGEST_MAX_PARAM_SIZE) ?\n           _MHD_UNQ_TOO_LARGE : _MHD_UNQ_OUT_OF_MEM;\n\n  len = MHD_str_unquote (param->value.str, param->value.len, str);\n  unquoted->str = str;\n  unquoted->len = len;\n  mhd_assert (0 != unquoted->len);\n  mhd_assert (unquoted->len < param->value.len);\n  return _MHD_UNQ_OK;\n}\n```\n</target_code>\n<response format>\nProvide your answer with these fields.\n- explanation: your evaluation of the scenario provided by the agent A.\n- is_report_correct: whether the report is correct or not (true/false). True means there is a violation.\n</response format>\n<scenario>\nThe agent A provided the following violation scenario:\nPotential violation: MHD_str_unquote(param->value.str, param->value.len, str) may internally call standard <string.h> functions (e.g. memcpy/strcpy/strncpy) and either read or write out of bounds. Example specific scenario: get_buffer_for_size returns a buffer of size param->value.len (N). If MHD_str_unquote does memcpy(str, param->value.str, N) and then appends a terminating '\\0' it writes N+1 bytes into an N-sized buffer (write out-of-bounds). Or if MHD_str_unquote uses strcpy on a non-NUL-terminated source it can read beyond param->value.str + param->value.len (read out-of-bounds). Because the callee\u2019s behavior and its use of standard string.h functions are not shown, this call can lead to accesses beyond object bounds and thus violates MISRA C 2023 Rule 21.17 unless MHD_str_unquote is proven to respect both source and destination bounds.\n</scenario>\n\n<instruction>\nJudge whether the report is correct or not.\n</instruction>\n",
  "is_report_correct": false,
  "explanation": "Not proven. Rule 21.17 forbids use of <string.h> functions that can access memory outside the bounds of the objects passed to them. The code shown does not directly call any standard string.h function \u2014 it calls MHD_str_unquote and get_buffer_for_size. Whether a Rule 21.17 violation actually occurs depends entirely on the implementations (or guarantees/contracts) of those two functions: \u2022 If MHD_str_unquote internally uses bounded operations (or otherwise respects the provided source length and the destination buffer size returned by get_buffer_for_size), then no violation arises from this call site. \u2022 If MHD_str_unquote calls an unbounded function such as strcpy on a non-NUL-terminated source or copies param->value.len bytes and then writes an additional NUL into a destination buffer sized only param->value.len, then an out\u2011of\u2011bounds read or write could occur and Rule 21.17 would be violated. Because the callee implementations are not shown, you cannot conclude a definite violation from this call alone \u2014 only a potential one. To resolve this conclusively, inspect/verify MHD_str_unquote and get_buffer_for_size (their contracts and implementations) to ensure they do not call <string.h> functions in a way that reads or writes past the supplied bounds, or change the API to pass explicit destination sizes and use bounded functions."
}