{
  "user_message": "An agent A claimed that the following get_unquoted_param code violates the MISRA C 2023 rule 8.13.\n<misra_rule>\nMISRA C 2023 Rule 8.13 is A pointer should point to a const-qualified type whenever possible.\n\n</misra_rule>\n<target_code>\nHere is the original code of get_unquoted_param.\n```c\nstatic enum _MHD_GetUnqResult\nget_unquoted_param (const struct MHD_RqDAuthParam *param,\n                    char tmp1[_MHD_STATIC_UNQ_BUFFER_SIZE],\n                    char **ptmp2,\n                    size_t *ptmp2_size,\n                    struct _MHD_str_w_len *unquoted)\n{\n  char *str;\n  size_t len;\n  mhd_assert (NULL != param->value.str);\n  mhd_assert (0 != param->value.len);\n\n  if (! param->quoted)\n  {\n    unquoted->str = param->value.str;\n    unquoted->len = param->value.len;\n    return _MHD_UNQ_OK;\n  }\n  /* The value is present and is quoted, needs to be copied and unquoted */\n  str = get_buffer_for_size (tmp1, ptmp2, ptmp2_size, param->value.len);\n  if (NULL == str)\n    return (param->value.len > _MHD_AUTH_DIGEST_MAX_PARAM_SIZE) ?\n           _MHD_UNQ_TOO_LARGE : _MHD_UNQ_OUT_OF_MEM;\n\n  len = MHD_str_unquote (param->value.str, param->value.len, str);\n  unquoted->str = str;\n  unquoted->len = len;\n  mhd_assert (0 != unquoted->len);\n  mhd_assert (unquoted->len < param->value.len);\n  return _MHD_UNQ_OK;\n}\n```\n</target_code>\n<response format>\nProvide your answer with these fields.\n- explanation: your evaluation of the scenario provided by the agent A.\n- is_report_correct: whether the report is correct or not (true/false). True means there is a violation.\n</response format>\n<scenario>\nThe agent A provided the following violation scenario:\nViolation occurs if the member param->value.str is declared as \"char *\" (non-const) even though get_unquoted_param treats it as read-only and passes it to MHD_str_unquote for input-only use. In that case the pointer should be declared as \"const char *\" (and MHD_str_unquote's source parameter should be const-qualified) to comply with MISRA C 2023 Rule 8.13.\n</scenario>\n\n<instruction>\nJudge whether the report is correct or not.\n</instruction>\n",
  "is_report_correct": true,
  "explanation": "Agent A is correct in the scenario described. MISRA C 2023 Rule 8.13 requires that pointers should point to const-qualified types whenever the pointed-to object is not modified. In get_unquoted_param the function treats param->value.str as read-only (it does not write through that pointer) and passes it as an input to MHD_str_unquote. Declaring the member as \"char *\" (non-const) means the pointer\u2019s target is not const-qualified even though it is only read, which violates Rule 8.13. \n\nNotes and remediation:\n- Making the struct member a const-qualified pointer (e.g. \"const char *str\") and updating MHD_str_unquote\u2019s prototype to accept a const char * source parameter is the proper fix.\n- If other code legitimately mutates the pointed-to buffer, you cannot make it const; in that case no violation occurs because the pointer must remain mutable.\n- Avoid hiding the issue by casting away constness; prefer changing the declarations or document a justified deviation from the rule.\n"
}