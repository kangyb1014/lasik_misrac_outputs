{
  "user_message": "An agent A claimed that the following process_request_target code violates the MISRA C 2023 rule 2.2.\n<misra_rule>\nMISRA C 2023 Rule 2.2 is A project shall not contain dead code.\nAny operation that is executed but whose removal would not affect program behaviour constitutes dead code. Notes:\n1. The behaviour of an embedded sytem is often determined not just by the nature of its actions, but also by the time at which they occur.\n2. unreachable code is not dead code, as it cannot be executed.\n3.Initialization is not the same as an assignment operation and is therfore not a candidate for dead code.\n</misra_rule>\n<target_code>\nHere is the original code of process_request_target.\n```c\nstatic bool\nprocess_request_target (struct MHD_Connection *c)\n{\n#ifdef _DEBUG\n  size_t params_len;\n#endif /* _DEBUG */\n  mhd_assert (MHD_CONNECTION_REQ_LINE_RECEIVING == c->state);\n  mhd_assert (NULL == c->rq.url);\n  mhd_assert (0 == c->rq.url_len);\n  mhd_assert (NULL != c->rq.hdrs.rq_line.rq_tgt);\n  mhd_assert ((NULL == c->rq.hdrs.rq_line.rq_tgt_qmark) || \\\n              (c->rq.hdrs.rq_line.rq_tgt <= c->rq.hdrs.rq_line.rq_tgt_qmark));\n  mhd_assert ((NULL == c->rq.hdrs.rq_line.rq_tgt_qmark) || \\\n              (c->rq.req_target_len > \\\n               (size_t) (c->rq.hdrs.rq_line.rq_tgt_qmark \\\n                         - c->rq.hdrs.rq_line.rq_tgt)));\n\n  /* Log callback before the request-target is modified/decoded */\n  if (NULL != c->daemon->uri_log_callback)\n  {\n    c->rq.client_aware = true;\n    c->rq.client_context =\n      c->daemon->uri_log_callback (c->daemon->uri_log_callback_cls,\n                                   c->rq.hdrs.rq_line.rq_tgt,\n                                   c);\n  }\n\n  if (NULL != c->rq.hdrs.rq_line.rq_tgt_qmark)\n  {\n#ifdef _DEBUG\n    params_len =\n      c->rq.req_target_len\n      - (size_t) (c->rq.hdrs.rq_line.rq_tgt_qmark - c->rq.hdrs.rq_line.rq_tgt);\n#endif /* _DEBUG */\n    c->rq.hdrs.rq_line.rq_tgt_qmark[0] = 0; /* Replace '?' with zero termination */\n    if (MHD_NO == MHD_parse_arguments_ (c,\n                                        MHD_GET_ARGUMENT_KIND,\n                                        c->rq.hdrs.rq_line.rq_tgt_qmark + 1,\n                                        &connection_add_header,\n                                        c))\n    {\n      mhd_assert (MHD_CONNECTION_REQ_LINE_RECEIVING != c->state);\n      return false;\n    }\n  }\n#ifdef _DEBUG\n  else\n    params_len = 0;\n#endif /* _DEBUG */\n\n  mhd_assert (strlen (c->rq.hdrs.rq_line.rq_tgt) == \\\n              c->rq.req_target_len - params_len);\n\n  /* Finally unescape URI itself */\n  c->rq.url_len =\n    c->daemon->unescape_callback (c->daemon->unescape_callback_cls,\n                                  c,\n                                  c->rq.hdrs.rq_line.rq_tgt);\n  c->rq.url = c->rq.hdrs.rq_line.rq_tgt;\n\n  return true;\n}\n```\n</target_code>\n<response format>\nProvide your answer with these fields.\n- explanation: your evaluation of the scenario provided by the agent A.\n- is_report_correct: whether the report is correct or not (true/false). True means there is a violation.\n</response format>\n<scenario>\nThe agent A provided the following violation scenario:\nIf mhd_assert is a conventional assert-like macro that is a no-op in non-debug/production builds (i.e. it and the contained comparison are compiled out) and the condition (0 == c->rq.url_len) has no side-effects, then the statement is removable without affecting program behaviour. In that common configuration the assertion constitutes dead code and therefore violates MISRA C 2023 Rule 2.2. (If, instead, mhd_assert performs observable actions such as logging or aborting on failure, then it would not be dead code.)\n</scenario>\n\n<execution_log>\nThe agent A also provided the following output log:\n[process_request_target] entry - before asserts\n  c=0x55dcbe3ae270\n  state=1\n  rq.url=(nil), rq.url_len=0\n  rq.hdrs.rq_line.rq_tgt=0x55dcbe3ae4c4, rq_tgt_qmark=(nil), req_target_len=2\n  daemon=0x55dcbe3ab8d0, uri_log_callback=0x55dc95bd3220, unescape_callback=0x7ff76baa1210\n[process_request_target] uri_log_callback present - before calling\n  c=0x55dcbe3ae270\n  state=1\n  rq.url=(nil), rq.url_len=0\n  rq.hdrs.rq_line.rq_tgt=0x55dcbe3ae4c4, rq_tgt_qmark=(nil), req_target_len=2\n  daemon=0x55dcbe3ab8d0, uri_log_callback=0x55dc95bd3220, unescape_callback=0x7ff76baa1210\n[process_request_target] uri_log_callback returned\n  c=0x55dcbe3ae270\n  state=1\n  rq.url=(nil), rq.url_len=0\n  rq.hdrs.rq_line.rq_tgt=0x55dcbe3ae4c4, rq_tgt_qmark=(nil), req_target_len=2\n  daemon=0x55dcbe3ab8d0, uri_log_callback=0x55dc95bd3220, unescape_callback=0x7ff76baa1210\n[process_request_target] exit - after unescape\n  c=0x55dcbe3ae270\n  state=1\n  rq.url=0x55dcbe3ae4c4, rq.url_len=2\n  rq.hdrs.rq_line.rq_tgt=0x55dcbe3ae4c4, rq_tgt_qmark=(nil), req_target_len=2\n  daemon=0x55dcbe3ab8d0, uri_log_callback=0x55dc95bd3220, unescape_callback=0x7ff76baa1210\n[process_request_target] entry - before asserts\n  c=0x55dcbe3ae270\n  state=1\n  rq.url=(nil), rq.url_len=0\n  rq.hdrs.rq_line.rq_tgt=0x55dcbe3ae4c4, rq_tgt_qmark=(nil), req_target_len=2\n  daemon=0x55dcbe3ab8d0, uri_log_callback=0x55dc95bd3220, unescape_callback=0x7ff76baa1210\n[process_request_target] uri_log_callback present - before calling\n  c=0x55dcbe3ae270\n  state=1\n  rq.url=(nil), rq.url_len=0\n  rq.hdrs.rq_line.rq_tgt=0x55dcbe3ae4c4, rq_tgt_qmark=(nil), req_target_len=2\n  daemon=0x55dcbe3ab8d0, uri_log_callback=0x55dc95bd3220, unescape_callback=0x7ff76baa1210\n[process_request_target] uri_log_callback returned\n  c=0x55dcbe3ae270\n  state=1\n  rq.url=(nil), rq.url_len=0\n  rq.hdrs.rq_line.rq_tgt=0x55dcbe3ae4c4, rq_tgt_qmark=(nil), req_target_len=2\n  daemon=0x55dcbe3ab8d0, uri_log_callback=0x55dc95bd3220, unescape_callback=0x7ff76baa1210\n[process_request_target] exit - after unescape\n  c=0x55dcbe3ae270\n  state=1\n  rq.url=0x55dcbe3ae4c4, rq.url_len=2\n  rq.hdrs.rq_line.rq_tgt=0x55dcbe3ae4c4, rq_tgt_qmark=(nil), req_target_len=2\n  daemon=0x55dcbe3ab8d0, uri_log_callback=0x55dc95bd3220, unescape_callback=0x7ff76baa1210\n[process_request_target] entry - before asserts\n  c=0x55dcbe3ae270\n  state=1\n  rq.url=(nil), rq.url_len=0\n  rq.hdrs.rq_line.rq_tgt=0x55dcbe3ae4c4, rq_tgt_qmark=(nil), req_target_len=2\n  daemon=0x55dcbe3ab8d0, uri_log_callback=0x55dc95bd3220, unescape_callback=0x7ff76baa1210\n[process_request_target] uri_log_callback present - before calling\n  c=0x55dcbe3ae270\n  state=1\n  rq.url=(nil), rq.url_len=0\n  rq.hdrs.rq_line.rq_tgt=0x55dcbe3ae4c4, rq_tgt_qmark=(nil), req_target_len=2\n  daemon=0x55dcbe3ab8d0, uri_log_callback=0x55dc95bd3220, unescape_callback=0x7ff76baa1210\n[process_request_target] uri_log_callback returned\n  c=0x55dcbe3ae270\n  state=1\n  rq.url=(nil), rq.url_len=0\n  rq.hdrs.rq_line.rq_tgt=0x55dcbe3ae4c4, rq_tgt_qmark=(nil), req_target_len=2\n  daemon=0x55dcbe3ab8d0, uri_log_callback=0x55dc95bd3220, unescape_callback=0x7ff76baa1210\n[process_request_target] exit - after unescape\n  c=0x55dcbe3ae270\n  state=1\n  rq.url=0x55dcbe3ae4c4, rq.url_len=2\n  rq.hdrs.rq_line.rq_tgt=0x55dcbe3ae4c4, rq_tgt_qmark=(nil), req_target_len=2\n  daemon=0x55dcbe3ab8d0, uri_log_callback=0x55dc95bd3220, unescape_callback=0x7ff76baa1210\n[process_request_target] entry - before asserts\n  c=0x55dcbe3ae270\n  state=1\n  rq.url=(nil), rq.url_len=0\n  rq.hdrs.rq_line.rq_tgt=0x55dcbe3ae4c4, rq_tgt_qmark=(nil), req_target_len=2\n  daemon=0x55dcbe3ab8d0, uri_log_callback=0x55dc95bd3220, unescape_callback=0x7ff76baa1210\n[process_request_target] uri_log_callback present - before calling\n  c=0x55dcbe3ae270\n  state=1\n  rq.url=(nil), rq.url_len=0\n  rq.hdrs.rq_line.rq_tgt=0x55dcbe3ae4c4, rq_tgt_qmark=(nil), req_target_len=2\n  daemon=0x55dcbe3ab8d0, uri_log_callback=0x55dc95bd3220, unescape_callback=0x7ff76baa1210\n[process_request_target] uri_log_callback returned\n  c=0x55dcbe3ae270\n  state=1\n  rq.url=(nil), rq.url_len=0\n  rq.hdrs.rq_line.rq_tgt=0x5\n</execution_log>\n\n<instruction>\nJudge whether the report is correct or not.\n</instruction>\n",
  "is_report_correct": false,
  "explanation": "Not correct. MISRA Rule 2.2 defines dead code as an operation that is executed but whose removal would not affect program behaviour. Whether these mhd_assert lines are dead depends on how mhd_assert is defined and on the build configuration: \n\n- If mhd_assert expands to nothing (e.g. like assert() under NDEBUG), the assertion expressions are not present in the object code and therefore are not executed \u2014 they are not \"dead code\" by the rule's definition (dead code must be executed). \n\n- If mhd_assert expands to an observable action (logging/abort) then the code is clearly not dead. \n\n- Only in the narrow case where mhd_assert is present in the compiled object code, the assertion expression is executed at run-time, and its execution has no observable effect (i.e. removal would not change behaviour), would the statement meet the rule's definition of dead code. That is a property of the compiled build and of whether the assertion expression has side\u2011effects; it cannot be assumed from the source alone. \n\nAgent A's claim treats the assertion as universally dead in a typical configuration, but strictly speaking if the macro is compiled out the code is not executed and thus not dead; if it is compiled in it usually has observable behaviour (or at least could). Therefore the reported violation is not established from the information given."
}