{
  "user_message": "<misra_rule>\nMISRA C 2023 Rule 2.2 is: A project shall not contain dead code.\nAny operation that is executed but whose removal would not affect program behaviour constitutes dead code. Notes:\n1. The behaviour of an embedded sytem is often determined not just by the nature of its actions, but also by the time at which they occur.\n2. unreachable code is not dead code, as it cannot be executed.\n3.Initialization is not the same as an assignment operation and is therfore not a candidate for dead code.\n</misra_rule>\n\nAnother agent reported that the target code violated the Rule 2.2.\nHere is the comment from the agent.\n<violation scenario>\nThe sequence of redundant casts in the computation of out is executed but has no effect on observable behaviour and therefore constitutes dead code. Specifically: ((uint8_t)((unsigned int)h)) and ((uint8_t)((unsigned int)l)) (and the surrounding repeated uint8_t/unsigned char casts) are unnecessary given the preceding check that h and l are non\u2011negative and the eventual assignment to decoded[w]. Removing these extra casts (or simplifying the expression to something like (unsigned char)((h << 4) | l)) would not change program behaviour. Hence Rule 2.2 is violated.\n</violation scenario>\n\nYour job is to insert logging code to capture the control flow and state information of the program.\nInsert logging code so that other agents can reproduce and get evidence for the violation scenario.\n<response format>\n- test_code: a modified MHD_str_pct_decode_strict_n_ code that contains useful probe functions that print useful logs to a file \"/tmp/logs/1572.txt\". The logs should contain the control path and state information of the violation scenario. If test code is not required to validate the scenario, you can leave this blank.\nHere are the constraints for the test code:\n- The test code MUST preserve the original logic of MHD_str_pct_decode_strict_n_ as much as possible.\nYou CAN just insert probe functions to the original code.\n- DO NOT introduce new violations to demonstrate your scenario.\n- The test code MUST be compilable and executable.\n- The test code MUST include line breaks.\n- You MUST NOT define the main function.\n- You MUST NOT define macros.\n</response format>\n<target_code>\nHere is the code of MHD_str_pct_decode_strict_n_:\n```c\nsize_t\nMHD_str_pct_decode_strict_n_ (const char *pct_encoded,\n                              size_t pct_encoded_len,\n                              char *decoded,\n                              size_t buf_size)\n{\n#ifdef MHD_FAVOR_SMALL_CODE\n  bool broken;\n  size_t res;\n\n  res = MHD_str_pct_decode_lenient_n_ (pct_encoded, pct_encoded_len, decoded,\n                                       buf_size, &broken);\n  if (broken)\n    return 0;\n  return res;\n#else  /* ! MHD_FAVOR_SMALL_CODE */\n  size_t r;\n  size_t w;\n  r = 0;\n  w = 0;\n\n  if (buf_size >= pct_encoded_len)\n  {\n    while (r < pct_encoded_len)\n    {\n      const char chr = pct_encoded[r];\n      if ('%' == chr)\n      {\n        if (2 > pct_encoded_len - r)\n          return 0;\n        else\n        {\n          const int h = toxdigitvalue (pct_encoded[++r]);\n          const int l = toxdigitvalue (pct_encoded[++r]);\n          unsigned char out;\n          if ((0 > h) || (0 > l))\n            return 0;\n          out =\n            (unsigned char) (((uint8_t) (((uint8_t) ((unsigned int) h)) << 4))\n                             | ((uint8_t) ((unsigned int) l)));\n          decoded[w] = (char) out;\n        }\n      }\n      else\n        decoded[w] = chr;\n      ++r;\n      ++w;\n    }\n    return w;\n  }\n\n  while (r < pct_encoded_len)\n  {\n    const char chr = pct_encoded[r];\n    if (w >= buf_size)\n      return 0;\n    if ('%' == chr)\n    {\n      if (2 > pct_encoded_len - r)\n        return 0;\n      else\n      {\n        const int h = toxdigitvalue (pct_encoded[++r]);\n        const int l = toxdigitvalue (pct_encoded[++r]);\n        unsigned char out;\n        if ((0 > h) || (0 > l))\n          return 0;\n        out =\n          (unsigned char) (((uint8_t) (((uint8_t) ((unsigned int) h)) << 4))\n                           | ((uint8_t) ((unsigned int) l)));\n        decoded[w] = (char) out;\n      }\n    }\n    else\n      decoded[w] = chr;\n    ++r;\n    ++w;\n  }\n  return w;\n#endif /* ! MHD_FAVOR_SMALL_CODE */\n}\n```\n</target_code>\nPlease provide the modified MHD_str_pct_decode_strict_n_ code.\n",
  "test_code": "#include <stdio.h>\n#include <stdarg.h>\n#include <stdint.h>\n#include <stdbool.h>\n#include <stddef.h>\n#include <sys/stat.h>\n\n/* Probe logging helper that appends human-readable traces to /tmp/logs/1572.txt */\nstatic void mhd_log(const char *fmt, ...)\n{\n  /* Ensure directory exists (ignore errors) */\n  (void)mkdir(\"/tmp/logs\", 0777);\n  FILE *fp = fopen(\"/tmp/logs/1572.txt\", \"a\");\n  if (NULL == fp)\n    return;\n  va_list ap;\n  va_start(ap, fmt);\n  vfprintf(fp, fmt, ap);\n  va_end(ap);\n  fputs(\"\\n\", fp);\n  fflush(fp);\n  fclose(fp);\n}\n\n/*\n * Original function with inserted probes to capture control flow and\n * the intermediate values involved in the construction of `out` so the\n * redundant casts and their lack of effect can be observed.\n *\n * Note: The original logic is preserved as much as possible. The probes\n * only write to /tmp/logs/1572.txt and do not alter the return values\n * or the decoded buffer contents.\n */\nsize_t\nMHD_str_pct_decode_strict_n_ (const char *pct_encoded,\n                              size_t pct_encoded_len,\n                              char *decoded,\n                              size_t buf_size)\n{\n#ifdef MHD_FAVOR_SMALL_CODE\n  bool broken;\n  size_t res;\n\n  mhd_log(\"enter MHD_str_pct_decode_strict_n_: pct_encoded_len=%zu, buf_size=%zu (FAVOR_SMALL_CODE)\", pct_encoded_len, buf_size);\n  res = MHD_str_pct_decode_lenient_n_ (pct_encoded, pct_encoded_len, decoded,\n                                       buf_size, &broken);\n  mhd_log(\"returned from lenient: res=%zu, broken=%d\", res, broken);\n  if (broken)\n  {\n    mhd_log(\"early return: broken -> 0\");\n    return 0;\n  }\n  mhd_log(\"exit MHD_str_pct_decode_strict_n_: res=%zu\", res);\n  return res;\n#else  /* ! MHD_FAVOR_SMALL_CODE */\n  size_t r;\n  size_t w;\n  r = 0;\n  w = 0;\n\n  mhd_log(\"enter MHD_str_pct_decode_strict_n_: pct_encoded_len=%zu, buf_size=%zu\", pct_encoded_len, buf_size);\n\n  if (buf_size >= pct_encoded_len)\n  {\n    mhd_log(\"taking fast path: buf_size >= pct_encoded_len (%zu >= %zu)\", buf_size, pct_encoded_len);\n    while (r < pct_encoded_len)\n    {\n      const char chr = pct_encoded[r];\n      mhd_log(\"iter fast: r=%zu, w=%zu, chr='%c' (0x%02X)\", r, w, (chr >= 32 && chr <= 126) ? chr : '?', (unsigned char) chr);\n      if ('%' == chr)\n      {\n        if (2 > pct_encoded_len - r)\n        {\n          mhd_log(\"early return fast: insufficient remaining chars after %% at r=%zu (remaining=%zu)\", r, (size_t)(pct_encoded_len - r));\n          return 0;\n        }\n        else\n        {\n          const int h = toxdigitvalue (pct_encoded[++r]);\n          const int l = toxdigitvalue (pct_encoded[++r]);\n          unsigned char out;\n          mhd_log(\"pct fast: raw digits: h=%d, l=%d (chars '%c' '%c')\", h, l, pct_encoded[r-1], pct_encoded[r]);\n          if ((0 > h) || (0 > l))\n          {\n            mhd_log(\"early return fast: invalid hex digit (h=%d, l=%d)\", h, l);\n            return 0;\n          }\n\n          /* Recompute intermediate values mirroring the original nested casts\n           * so they can be logged and inspected. */\n          unsigned int ui_h = (unsigned int) h;\n          uint8_t u8_h1 = (uint8_t) ui_h; /* ((uint8_t) ((unsigned int) h)) */\n          uint8_t u8_h2 = (uint8_t) u8_h1; /* ((uint8_t) (((uint8_t) ((unsigned int) h)))) */\n          uint8_t shifted = (uint8_t) (u8_h2 << 4); /* (((uint8_t) (((uint8_t) ((unsigned int) h)) )) << 4) */\n\n          unsigned int ui_l = (unsigned int) l;\n          uint8_t u8_l1 = (uint8_t) ui_l; /* ((uint8_t) ((unsigned int) l)) */\n          uint8_t u8_l2 = (uint8_t) u8_l1;\n\n          uint8_t out_u8 = (uint8_t) (shifted | u8_l2);\n          out = (unsigned char) out_u8;\n\n          mhd_log(\"fast casts: ui_h=%u, u8_h1=0x%02X, u8_h2=0x%02X, shifted=0x%02X, ui_l=%u, u8_l1=0x%02X, out_u8=0x%02X, out=0x%02X (char '%c')\",\n                  ui_h, u8_h1, u8_h2, shifted, ui_l, u8_l1, out_u8, (unsigned char) out,\n                  ((out >= 32 && out <= 126) ? (char) out : '?'));\n\n          decoded[w] = (char) out;\n          mhd_log(\"fast assigned decoded[%zu] = 0x%02X (char '%c')\", w, (unsigned char) decoded[w], ((decoded[w] >= 32 && decoded[w] <= 126) ? decoded[w] : '?'));\n        }\n      }\n      else\n      {\n        decoded[w] = chr;\n        mhd_log(\"fast non-%% assigned decoded[%zu] = '%c' (0x%02X)\", w, (decoded[w] >= 32 && decoded[w] <= 126) ? decoded[w] : '?', (unsigned char) decoded[w]);\n      }\n      ++r;\n      ++w;\n    }\n    mhd_log(\"fast path complete: return w=%zu\", w);\n    return w;\n  }\n\n  mhd_log(\"taking safe path: buf_size < pct_encoded_len (%zu < %zu)\", buf_size, pct_encoded_len);\n\n  while (r < pct_encoded_len)\n  {\n    const char chr = pct_encoded[r];\n    mhd_log(\"iter safe: r=%zu, w=%zu, chr='%c' (0x%02X)\", r, w, (chr >= 32 && chr <= 126) ? chr : '?', (unsigned char) chr);\n    if (w >= buf_size)\n    {\n      mhd_log(\"early return safe: buffer full (w=%zu >= buf_size=%zu)\", w, buf_size);\n      return 0;\n    }\n    if ('%' == chr)\n    {\n      if (2 > pct_encoded_len - r)\n      {\n        mhd_log(\"early return safe: insufficient remaining chars after %% at r=%zu (remaining=%zu)\", r, (size_t)(pct_encoded_len - r));\n        return 0;\n      }\n      else\n      {\n        const int h = toxdigitvalue (pct_encoded[++r]);\n        const int l = toxdigitvalue (pct_encoded[++r]);\n        unsigned char out;\n        mhd_log(\"pct safe: raw digits: h=%d, l=%d (chars '%c' '%c')\", h, l, pct_encoded[r-1], pct_encoded[r]);\n        if ((0 > h) || (0 > l))\n        {\n          mhd_log(\"early return safe: invalid hex digit (h=%d, l=%d)\", h, l);\n          return 0;\n        }\n\n        /* Mirror the original nested casts to capture intermediate states */\n        unsigned int ui_h = (unsigned int) h;\n        uint8_t u8_h1 = (uint8_t) ui_h;\n        uint8_t u8_h2 = (uint8_t) u8_h1;\n        uint8_t shifted = (uint8_t) (u8_h2 << 4);\n\n        unsigned int ui_l = (unsigned int) l;\n        uint8_t u8_l1 = (uint8_t) ui_l;\n        uint8_t u8_l2 = (uint8_t) u8_l1;\n\n        uint8_t out_u8 = (uint8_t) (shifted | u8_l2);\n        out = (unsigned char) out_u8;\n\n        mhd_log(\"safe casts: ui_h=%u, u8_h1=0x%02X, u8_h2=0x%02X, shifted=0x%02X, ui_l=%u, u8_l1=0x%02X, out_u8=0x%02X, out=0x%02X (char '%c')\",\n                ui_h, u8_h1, u8_h2, shifted, ui_l, u8_l1, out_u8, (unsigned char) out,\n                ((out >= 32 && out <= 126) ? (char) out : '?'));\n\n        decoded[w] = (char) out;\n        mhd_log(\"safe assigned decoded[%zu] = 0x%02X (char '%c')\", w, (unsigned char) decoded[w], ((decoded[w] >= 32 && decoded[w] <= 126) ? decoded[w] : '?'));\n      }\n    }\n    else\n    {\n      decoded[w] = chr;\n      mhd_log(\"safe non-%% assigned decoded[%zu] = '%c' (0x%02X)\", w, (decoded[w] >= 32 && decoded[w] <= 126) ? decoded[w] : '?', (unsigned char) decoded[w]);\n    }\n    ++r;\n    ++w;\n  }\n  mhd_log(\"safe path complete: return w=%zu\", w);\n  return w;\n#endif /* ! MHD_FAVOR_SMALL_CODE */\n}\n"
}