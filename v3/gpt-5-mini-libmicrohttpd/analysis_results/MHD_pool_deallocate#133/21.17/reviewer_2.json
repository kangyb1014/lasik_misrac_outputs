{
  "user_message": "An agent A claimed that the following MHD_pool_deallocate code violates the MISRA C 2023 rule 21.17.\n<misra_rule>\nMISRA C 2023 Rule 21.17 is Use of the string handling functions from <string.h> shall not result in accesses beyond the bounds of the objects referenced by their pointer parameters.\nThis rule strictly applies to the Standard Library functions in <string.h> such as memcpy, memmove, memset, memcmp, strcpy, strncpy, strcat, strncat, strlen, and strspn.\n</misra_rule>\n<target_code>\nHere is the original code of MHD_pool_deallocate.\n```c\nvoid\nMHD_pool_deallocate (struct MemoryPool *pool,\n                     void *block,\n                     size_t block_size)\n{\n  mhd_assert (pool->end >= pool->pos);\n  mhd_assert (pool->size >= pool->end - pool->pos);\n  mhd_assert (block != NULL || block_size == 0);\n  mhd_assert (pool->size >= block_size);\n  mhd_assert (pool->pos == ROUND_TO_ALIGN (pool->pos));\n\n  if (NULL != block)\n  {   /* Have previously allocated data */\n    const size_t block_offset = mp_ptr_diff_ (block, pool->memory);\n    mhd_assert (mp_ptr_le_ (pool->memory, block));\n    mhd_assert (block_offset <= pool->size);\n    mhd_assert ((block_offset != pool->pos) || (block_size == 0));\n    /* Zero-out deallocated region */\n    if (0 != block_size)\n    {\n      memset (block, 0, block_size);\n      _MHD_POISON_MEMORY (block, block_size);\n    }\n#if ! defined(MHD_FAVOR_SMALL_CODE) && ! defined(MHD_ASAN_POISON_ACTIVE)\n    else\n      return; /* Zero size, no need to do anything */\n#endif /* ! MHD_FAVOR_SMALL_CODE && ! MHD_ASAN_POISON_ACTIVE */\n    if (block_offset <= pool->pos)\n    {\n      /* \"Normal\" block, not allocated \"from the end\". */\n      const size_t alg_end =\n        ROUND_TO_ALIGN_PLUS_RED_ZONE (block_offset + block_size);\n      mhd_assert (alg_end <= pool->pos);\n      if (alg_end == pool->pos)\n      {\n        /* The last allocated block, return deallocated block to the pool */\n        size_t alg_start = ROUND_TO_ALIGN (block_offset);\n        mhd_assert (alg_start >= block_offset);\n#if defined(MHD_ASAN_POISON_ACTIVE)\n        if (alg_start != block_offset)\n        {\n          _MHD_POISON_MEMORY (pool->memory + block_offset, \\\n                              alg_start - block_offset);\n        }\n        else if (0 != alg_start)\n        {\n          bool need_red_zone_before;\n          mhd_assert (_MHD_RED_ZONE_SIZE <= alg_start);\n#if defined(HAVE___ASAN_REGION_IS_POISONED)\n          need_red_zone_before =\n            (NULL == __asan_region_is_poisoned (pool->memory\n                                                + alg_start\n                                                - _MHD_RED_ZONE_SIZE,\n                                                _MHD_RED_ZONE_SIZE));\n#elif defined(HAVE___ASAN_ADDRESS_IS_POISONED)\n          need_red_zone_before =\n            (0 == __asan_address_is_poisoned (pool->memory + alg_start - 1));\n#else  /* ! HAVE___ASAN_ADDRESS_IS_POISONED */\n          need_red_zone_before = true; /* Unknown, assume new red zone needed */\n#endif /* ! HAVE___ASAN_ADDRESS_IS_POISONED */\n          if (need_red_zone_before)\n          {\n            _MHD_POISON_MEMORY (pool->memory + alg_start, _MHD_RED_ZONE_SIZE);\n            alg_start += _MHD_RED_ZONE_SIZE;\n          }\n        }\n#endif /* MHD_ASAN_POISON_ACTIVE */\n        mhd_assert (alg_start <= pool->pos);\n        mhd_assert (alg_start == ROUND_TO_ALIGN (alg_start));\n        pool->pos = alg_start;\n      }\n    }\n    else\n    {\n      /* Allocated \"from the end\" block. */\n      /* The size and the pointers of such block should not be manipulated by\n         MHD code (block split is disallowed). */\n      mhd_assert (block_offset >= pool->end);\n      mhd_assert (ROUND_TO_ALIGN (block_offset) == block_offset);\n      if (block_offset == pool->end)\n      {\n        /* The last allocated block, return deallocated block to the pool */\n        const size_t alg_end =\n          ROUND_TO_ALIGN_PLUS_RED_ZONE (block_offset + block_size);\n        pool->end = alg_end;\n      }\n    }\n  }\n}\n```\n</target_code>\n<response format>\nProvide your answer with these fields.\n- explanation: your evaluation of the scenario provided by the agent A.\n- is_report_correct: whether the report is correct or not (true/false). True means there is a violation.\n</response format>\n<scenario>\nThe agent A provided the following violation scenario:\nIf block points near the end of the pool memory such that block_offset + block_size > pool->size. Example: pool->memory has size 100, block = pool->memory + 90 (block_offset = 90) and block_size = 20. The earlier asserts allow this (pool->size >= block_size and block_offset <= pool->size) but memset(block,0,block_size) will write past pool->memory + 100 (writes bytes 90..109), accessing beyond the object bounds.\n</scenario>\n\n<execution_log>\nThe agent A also provided the following output log:\n---- MHD_pool_deallocate: enter_after_asserts ----\npool=0x55ca79808060, pool->memory=0x55ca79808090, pool->size=32768, pool->pos=16384, pool->end=32640\nblock=0x55ca798080c8, block_size=16328\nblock_offset=56\nblock_end=16384\npool->size=32768, block_end > pool->size ? NO\nblock_offset <= pool->pos ? YES\nblock_offset == pool->pos ? NO\nblock_offset >= pool->end ? NO\nblock_offset == pool->end ? NO\n---- end enter_after_asserts ----\n\n---- MHD_pool_deallocate: computed_block_offset ----\npool=0x55ca79808060, pool->memory=0x55ca79808090, pool->size=32768, pool->pos=16384, pool->end=32640\nblock=0x55ca798080c8, block_size=16328\nblock_offset=56\nblock_end=16384\npool->size=32768, block_end > pool->size ? NO\nblock_offset <= pool->pos ? YES\nblock_offset == pool->pos ? NO\nblock_offset >= pool->end ? NO\nblock_offset == pool->end ? NO\n---- end computed_block_offset ----\n\n---- MHD_pool_deallocate: before_memset ----\npool=0x55ca79808060, pool->memory=0x55ca79808090, pool->size=32768, pool->pos=16384, pool->end=32640\nblock=0x55ca798080c8, block_size=16328\nblock_offset=56\nblock_end=16384\npool->size=32768, block_end > pool->size ? NO\nblock_offset <= pool->pos ? YES\nblock_offset == pool->pos ? NO\nblock_offset >= pool->end ? NO\nblock_offset == pool->end ? NO\n---- end before_memset ----\n\n---- MHD_pool_deallocate: after_memset ----\npool=0x55ca79808060, pool->memory=0x55ca79808090, pool->size=32768, pool->pos=16384, pool->end=32640\nblock=0x55ca798080c8, block_size=16328\nblock_offset=56\nblock_end=16384\npool->size=32768, block_end > pool->size ? NO\nblock_offset <= pool->pos ? YES\nblock_offset == pool->pos ? NO\nblock_offset >= pool->end ? NO\nblock_offset == pool->end ? NO\n---- end after_memset ----\n\n---- MHD_pool_deallocate: returned_to_pos ----\npool=0x55ca79808060, pool->memory=0x55ca79808090, pool->size=32768, pool->pos=64, pool->end=32640\nblock=0x55ca798080c8, block_size=16328\nblock_offset=56\nblock_end=16384\npool->size=32768, block_end > pool->size ? NO\nblock_offset <= pool->pos ? YES\nblock_offset == pool->pos ? NO\nblock_offset >= pool->end ? NO\nblock_offset == pool->end ? NO\n---- end returned_to_pos ----\n\n---- MHD_pool_deallocate: enter_after_asserts ----\npool=0x55ca79808060, pool->memory=0x55ca79808090, pool->size=32768, pool->pos=16384, pool->end=32640\nblock=0x55ca798080c8, block_size=16328\nblock_offset=56\nblock_end=16384\npool->size=32768, block_end > pool->size ? NO\nblock_offset <= pool->pos ? YES\nblock_offset == pool->pos ? NO\nblock_offset >= pool->end ? NO\nblock_offset == pool->end ? NO\n---- end enter_after_asserts ----\n\n---- MHD_pool_deallocate: computed_block_offset ----\npool=0x55ca79808060, pool->memory=0x55ca79808090, pool->size=32768, pool->pos=16384, pool->end=32640\nblock=0x55ca798080c8, block_size=16328\nblock_offset=56\nblock_end=16384\npool->size=32768, block_end > pool->size ? NO\nblock_offset <= pool->pos ? YES\nblock_offset == pool->pos ? NO\nblock_offset >= pool->end ? NO\nblock_offset == pool->end ? NO\n---- end computed_block_offset ----\n\n---- MHD_pool_deallocate: before_memset ----\npool=0x55ca79808060, pool->memory=0x55ca79808090, pool->size=32768, pool->pos=16384, pool->end=32640\nblock=0x55ca798080c8, block_size=16328\nblock_offset=56\nblock_end=16384\npool->size=32768, block_end > pool->size ? NO\nblock_offset <= pool->pos ? YES\nblock_offset == pool->pos ? NO\nblock_offset >= pool->end ? NO\nblock_offset == pool->end ? NO\n---- end before_memset ----\n\n---- MHD_pool_deallocate: after_memset ----\npool=0x55ca79808060, pool->memory=0x55ca79808090, pool->size=32768, pool->pos=16384, pool->end=32640\nblock=0x55ca798080c8, block_size=16328\nblock_offset=56\nblock_end=16384\npool->size=32768, block_end > pool->size ? NO\nblock_offset <= pool->pos ? YES\nblock_offset == pool->pos ? NO\nblock_offset >= pool->end ? NO\nblock_offset == pool->end ? NO\n---- end after_memset ----\n\n---- MHD_pool_deallocate: returned_to_pos ----\npool=0x55ca79808060, pool->memory=0x55ca79808090, pool->size=32768, pool->pos=64, pool->end=32640\nblock=0x55ca798080c8, block_size=16328\nblock_offset=56\nblock_end=16384\npool->size=32768, block_end > pool->size ? NO\nblock_offset <= pool->pos ? \n</execution_log>\n\n<instruction>\nJudge whether the report is correct or not.\n</instruction>\n",
  "is_report_correct": true,
  "explanation": "Agent A is correct. Rule 21.17 forbids calling string/memory functions in a way that can access beyond the bounds of the object referenced by the pointer parameter. In this code memset(block, 0, block_size) is called with block pointing into pool->memory, but the code only asserts that pool->size >= block_size and that block_offset <= pool->size. Those two conditions do not imply block_offset + block_size <= pool->size, so the memset can legally write past the end of pool->memory. Example: pool->size = 100, block_offset = 90, block_size = 20 satisfies the existing asserts (100 >= 20 and 90 <= 100) but causes writes to bytes 90..109, which exceed the pool object. Assertions (mhd_assert) do not remove the out-of-bounds access in production builds (and MISRA requires the code itself to avoid such accesses). Therefore the scenario described correctly demonstrates a potential violation of MISRA C 2023 Rule 21.17. A proper fix is to ensure (before calling memset) that block_offset + block_size <= pool->size (and similarly for other branches) so the memset cannot write past the pool object."
}