{
  "user_message": "An agent A claimed that the following MHD_pool_is_resizable_inplace code violates the MISRA C 2023 rule 8.13.\n<misra_rule>\nMISRA C 2023 Rule 8.13 is A pointer should point to a const-qualified type whenever possible.\n\n</misra_rule>\n<target_code>\nHere is the original code of MHD_pool_is_resizable_inplace.\n```c\nbool\nMHD_pool_is_resizable_inplace (struct MemoryPool *pool,\n                               void *block,\n                               size_t block_size)\n{\n  mhd_assert (pool->end >= pool->pos);\n  mhd_assert (pool->size >= pool->end - pool->pos);\n  mhd_assert (block != NULL || block_size == 0);\n  mhd_assert (pool->size >= block_size);\n  if (NULL != block)\n  {\n    const size_t block_offset = mp_ptr_diff_ (block, pool->memory);\n    mhd_assert (mp_ptr_le_ (pool->memory, block));\n    mhd_assert (pool->size >= block_offset);\n    mhd_assert (pool->size >= block_offset + block_size);\n    return (pool->pos ==\n            ROUND_TO_ALIGN_PLUS_RED_ZONE (block_offset + block_size));\n  }\n  return false; /* Unallocated blocks cannot be resized in-place */\n}\n```\n</target_code>\n<response format>\nProvide your answer with these fields.\n- explanation: your evaluation of the scenario provided by the agent A.\n- is_report_correct: whether the report is correct or not (true/false). True means there is a violation.\n</response format>\n<scenario>\nThe agent A provided the following violation scenario:\nThe function parameters are non-const although the function only reads the pointed-to objects. Specifically, 'block' is declared as void * instead of const void * and 'pool' is declared as struct MemoryPool * instead of const struct MemoryPool *. Since the function does not modify *pool or *block (only reads their members/contents), these should be const-qualified (e.g. const struct MemoryPool *pool, const void *block).\n</scenario>\n\n<instruction>\nJudge whether the report is correct or not.\n</instruction>\n",
  "is_report_correct": true,
  "explanation": "Agent A's report is correct given the snippet. The function only reads the pointed-to objects (accesses pool members and inspects the memory pointed to by block) and does not modify *pool or the object pointed to by block, so both parameters are natural candidates for const-qualification (e.g. const struct MemoryPool *pool and const void *block). That is exactly what MISRA C 2023 Rule 8.13 encourages.\n\nCaveat: There are possible reasons the code may have been written this way (API compatibility, prototypes of mp_ptr_diff_/mp_ptr_le_ or other helper macros/functions that accept non-const pointers, or intentional intent to allow callers with non-const pointers without casting). If any of those external constraints force non-const parameter types, then adding const here may require broader changes or casts; in that case the code should document the rationale or adjust the other APIs. But based solely on the presented function body, the pointer parameters can and should be const-qualified, so the reported violation stands."
}