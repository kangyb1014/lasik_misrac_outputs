{
  "user_message": "An agent A claimed that the following process_request_body code violates the MISRA C 2023 rule 8.13.\n<misra_rule>\nMISRA C 2023 Rule 8.13 is A pointer should point to a const-qualified type whenever possible.\n\n</misra_rule>\n<target_code>\nHere is the original code of process_request_body.\n```c\nstatic void\nprocess_request_body (struct MHD_Connection *connection)\n{\n  struct MHD_Daemon *daemon = connection->daemon;\n  size_t available;\n  bool instant_retry;\n  char *buffer_head;\n  const int discp_lvl = daemon->client_discipline;\n  /* Treat bare LF as the end of the line.\n     RFC 9112, section 2.2-3\n     Note: MHD never replaces bare LF with space (RFC 9110, section 5.5-5).\n     Bare LF is processed as end of the line or rejected as broken request. */\n  const bool bare_lf_as_crlf = MHD_ALLOW_BARE_LF_AS_CRLF_ (discp_lvl);\n  /* Allow \"Bad WhiteSpace\" in chunk extension.\n     RFC 9112, Section 7.1.1, Paragraph 2 */\n  const bool allow_bws = (2 < discp_lvl);\n\n  mhd_assert (NULL == connection->rp.response);\n\n  buffer_head = connection->read_buffer;\n  available = connection->read_buffer_offset;\n  do\n  {\n    size_t to_be_processed;\n    size_t left_unprocessed;\n    size_t processed_size;\n\n    instant_retry = false;\n    if (connection->rq.have_chunked_upload)\n    {\n      mhd_assert (MHD_SIZE_UNKNOWN == connection->rq.remaining_upload_size);\n      if ( (connection->rq.current_chunk_offset ==\n            connection->rq.current_chunk_size) &&\n           (0 != connection->rq.current_chunk_size) )\n      {\n        size_t i;\n        mhd_assert (0 != available);\n        /* skip new line at the *end* of a chunk */\n        i = 0;\n        if ( (2 <= available) &&\n             ('\\r' == buffer_head[0]) &&\n             ('\\n' == buffer_head[1]) )\n          i += 2;                        /* skip CRLF */\n        else if (bare_lf_as_crlf && ('\\n' == buffer_head[0]))\n          i++;                           /* skip bare LF */\n        else if (2 > available)\n          break;                         /* need more upload data */\n        if (0 == i)\n        {\n          /* malformed encoding */\n          transmit_error_response_static (connection,\n                                          MHD_HTTP_BAD_REQUEST,\n                                          REQUEST_CHUNKED_MALFORMED);\n          return;\n        }\n        available -= i;\n        buffer_head += i;\n        connection->rq.current_chunk_offset = 0;\n        connection->rq.current_chunk_size = 0;\n        if (0 == available)\n          break;\n      }\n      if (0 != connection->rq.current_chunk_size)\n      {\n        uint64_t cur_chunk_left;\n        mhd_assert (connection->rq.current_chunk_offset < \\\n                    connection->rq.current_chunk_size);\n        /* we are in the middle of a chunk, give\n           as much as possible to the client (without\n           crossing chunk boundaries) */\n        cur_chunk_left\n          = connection->rq.current_chunk_size\n            - connection->rq.current_chunk_offset;\n        if (cur_chunk_left > available)\n          to_be_processed = available;\n        else\n        {         /* cur_chunk_left <= (size_t)available */\n          to_be_processed = (size_t) cur_chunk_left;\n          if (available > to_be_processed)\n            instant_retry = true;\n        }\n      }\n      else\n      { /* Need the parse the chunk size line */\n        /** The number of found digits in the chunk size number */\n        size_t num_dig;\n        uint64_t chunk_size;\n        bool broken;\n        bool overflow;\n\n        mhd_assert (0 != available);\n\n        overflow = false;\n        chunk_size = 0; /* Mute possible compiler warning.\n                           The real value will be set later. */\n\n        num_dig = MHD_strx_to_uint64_n_ (buffer_head,\n                                         available,\n                                         &chunk_size);\n        mhd_assert (num_dig <= available);\n        if (num_dig == available)\n          continue; /* Need line delimiter */\n\n        broken = (0 == num_dig);\n        if (broken)\n          /* Check whether result is invalid due to uint64_t overflow */\n          overflow = ((('0' <= buffer_head[0]) && ('9' >= buffer_head[0])) ||\n                      (('A' <= buffer_head[0]) && ('F' >= buffer_head[0])) ||\n                      (('a' <= buffer_head[0]) && ('f' >= buffer_head[0])));\n        else\n        {\n          /**\n           * The length of the string with the number of the chunk size,\n           * including chunk extension\n           */\n          size_t chunk_size_line_len;\n\n          chunk_size_line_len = 0;\n          if ((';' == buffer_head[num_dig]) ||\n              (allow_bws &&\n               ((' ' == buffer_head[num_dig]) ||\n                ('\\t' == buffer_head[num_dig]))))\n          { /* Chunk extension */\n            size_t i;\n\n            /* Skip bad whitespaces (if any) */\n            for (i = num_dig; i < available; ++i)\n            {\n              if ((' ' != buffer_head[i]) && ('\\t' != buffer_head[i]))\n                break;\n            }\n            if (i == available)\n              break; /* need more data */\n            if (';' == buffer_head[i])\n            {\n              for (++i; i < available; ++i)\n              {\n                if ('\\n' == buffer_head[i])\n                  break;\n              }\n              if (i == available)\n                break; /* need more data */\n              mhd_assert (i > num_dig);\n              mhd_assert (1 <= i);\n              /* Found LF position */\n              if (bare_lf_as_crlf)\n                chunk_size_line_len = i; /* Don't care about CR before LF */\n              else if ('\\r' == buffer_head[i - 1])\n                chunk_size_line_len = i;\n            }\n            else\n            { /* No ';' after \"bad whitespace\" */\n              mhd_assert (allow_bws);\n              mhd_assert (0 == chunk_size_line_len);\n            }\n          }\n          else\n          {\n            mhd_assert (available >= num_dig);\n            if ((2 <= (available - num_dig)) &&\n                ('\\r' == buffer_head[num_dig]) &&\n                ('\\n' == buffer_head[num_dig + 1]))\n              chunk_size_line_len = num_dig + 2;\n            else if (bare_lf_as_crlf &&\n                     ('\\n' == buffer_head[num_dig]))\n              chunk_size_line_len = num_dig + 1;\n            else if (2 > (available - num_dig))\n              break; /* need more data */\n          }\n\n          if (0 != chunk_size_line_len)\n          { /* Valid termination of the chunk size line */\n            mhd_assert (chunk_size_line_len <= available);\n            /* Start reading payload data of the chunk */\n            connection->rq.current_chunk_offset = 0;\n            connection->rq.current_chunk_size = chunk_size;\n\n            available -= chunk_size_line_len;\n            buffer_head += chunk_size_line_len;\n\n            if (0 == chunk_size)\n            { /* The final (termination) chunk */\n              connection->rq.remaining_upload_size = 0;\n              break;\n            }\n            if (available > 0)\n              instant_retry = true;\n            continue;\n          }\n          /* Invalid chunk size line */\n        }\n\n        if (! overflow)\n          transmit_error_response_static (connection,\n                                          MHD_HTTP_BAD_REQUEST,\n                                          REQUEST_CHUNKED_MALFORMED);\n        else\n          transmit_error_response_static (connection,\n                                          MHD_HTTP_CONTENT_TOO_LARGE,\n                                          REQUEST_CHUNK_TOO_LARGE);\n        return;\n      }\n    }\n    else\n    {\n      /* no chunked encoding, give all to the client */\n      mhd_assert (MHD_SIZE_UNKNOWN != connection->rq.remaining_upload_size);\n      mhd_assert (0 != connection->rq.remaining_upload_size);\n      if (connection->rq.remaining_upload_size < available)\n        to_be_processed = (size_t) connection->rq.remaining_upload_size;\n      else\n        to_be_processed = available;\n    }\n    left_unprocessed = to_be_processed;\n    connection->rq.client_aware = true;\n    connection->in_access_handler = true;\n    if (MHD_NO ==\n        daemon->default_handler (daemon->default_handler_cls,\n                                 connection,\n                                 connection->rq.url,\n                                 connection->rq.method,\n                                 connection->rq.version,\n                                 buffer_head,\n                                 &left_unprocessed,\n                                 &connection->rq.client_context))\n    {\n      connection->in_access_handler = false;\n      /* serious internal error, close connection */\n      CONNECTION_CLOSE_ERROR (connection,\n                              _ (\"Application reported internal error, \" \\\n                                 \"closing connection.\"));\n      return;\n    }\n    connection->in_access_handler = false;\n\n    if (left_unprocessed > to_be_processed)\n      MHD_PANIC (_ (\"libmicrohttpd API violation.\\n\"));\n\n    connection->rq.some_payload_processed =\n      (left_unprocessed != to_be_processed);\n\n    if (0 != left_unprocessed)\n    {\n      instant_retry = false; /* client did not process everything */\n#ifdef HAVE_MESSAGES\n      if ((! connection->rq.some_payload_processed) &&\n          (! connection->suspended))\n      {\n        /* client did not process any upload data, complain if\n           the setup was incorrect, which may prevent us from\n           handling the rest of the request */\n        if (MHD_D_IS_USING_THREADS_ (daemon))\n          MHD_DLOG (daemon,\n                    _ (\"WARNING: Access Handler Callback has not processed \" \\\n                       \"any upload data and connection is not suspended. \" \\\n                       \"This may result in hung connection.\\n\"));\n      }\n#endif /* HAVE_MESSAGES */\n    }\n    processed_size = to_be_processed - left_unprocessed;\n    /* dh left \"processed\" bytes in buffer for next time... */\n    buffer_head += processed_size;\n    available -= processed_size;\n    if (! connection->rq.have_chunked_upload)\n    {\n      mhd_assert (MHD_SIZE_UNKNOWN != connection->rq.remaining_upload_size);\n      connection->rq.remaining_upload_size -= processed_size;\n    }\n    else\n    {\n      mhd_assert (MHD_SIZE_UNKNOWN == connection->rq.remaining_upload_size);\n      connection->rq.current_chunk_offset += processed_size;\n    }\n  } while (instant_retry);\n  /* TODO: zero out reused memory region */\n  if ( (available > 0) &&\n       (buffer_head != connection->read_buffer) )\n    memmove (connection->read_buffer,\n             buffer_head,\n             available);\n  else\n    mhd_assert ((0 == available) || \\\n                (connection->read_buffer_offset == available));\n  connection->read_buffer_offset = available;\n}\n```\n</target_code>\n<response format>\nProvide your answer with these fields.\n- explanation: your evaluation of the scenario provided by the agent A.\n- is_report_correct: whether the report is correct or not (true/false). True means there is a violation.\n</response format>\n<scenario>\nThe agent A provided the following violation scenario:\nThe pointer variable 'buffer_head' is declared as 'char *buffer_head' but is only used for read-only operations in the shown fragment (indexing and comparisons: buffer_head[num_dig], buffer_head[0], etc.) and passed to functions that accept const data. According to MISRA C 2023 Rule 8.13 it should be declared to point to a const-qualified type (e.g. 'const char *buffer_head').\n</scenario>\n\n<execution_log>\nThe agent A also provided the following output log:\nENTER process_request_body: connection=0x5646b5dc9270 daemon=0x5646b5dc68d0\n[init] buffer=0x5646b5dc952f available=1 dump=1\n53\n[init] chars: S\ncalling default_handler: buffer_head=0x5646b5dc952f to_be_processed=1 left_unprocessed(before)=1\n[before-default-handler] buffer=0x5646b5dc952f available=1 dump=1\n53\n[before-default-handler] chars: S\ndefault_handler returned. left_unprocessed(after)=0 to_be_processed=1\nafter-processing: processed_size=1 new_buffer_head=0x5646b5dc9530 available=0\nEXIT process_request_body: final buffer_head=0x5646b5dc9530 available=0 read_buffer=0x5646b5dc952f read_buffer_offset=0\nENTER process_request_body: connection=0x5646b5dc9270 daemon=0x5646b5dc68d0\n[init] buffer=0x5646b5dc952f available=2 dump=2\n536f\n[init] chars: So\ncalling default_handler: buffer_head=0x5646b5dc952f to_be_processed=2 left_unprocessed(before)=2\n[before-default-handler] buffer=0x5646b5dc952f available=2 dump=2\n536f\n[before-default-handler] chars: So\ndefault_handler returned. left_unprocessed(after)=0 to_be_processed=2\nafter-processing: processed_size=2 new_buffer_head=0x5646b5dc9531 available=0\nEXIT process_request_body: final buffer_head=0x5646b5dc9531 available=0 read_buffer=0x5646b5dc952f read_buffer_offset=0\nENTER process_request_body: connection=0x5646b5dc9270 daemon=0x5646b5dc68d0\n[init] buffer=0x5646b5dc952f available=3 dump=3\n536f6d\n[init] chars: Som\ncalling default_handler: buffer_head=0x5646b5dc952f to_be_processed=3 left_unprocessed(before)=3\n[before-default-handler] buffer=0x5646b5dc952f available=3 dump=3\n536f6d\n[before-default-handler] chars: Som\ndefault_handler returned. left_unprocessed(after)=0 to_be_processed=3\nafter-processing: processed_size=3 new_buffer_head=0x5646b5dc9532 available=0\nEXIT process_request_body: final buffer_head=0x5646b5dc9532 available=0 read_buffer=0x5646b5dc952f read_buffer_offset=0\nENTER process_request_body: connection=0x5646b5dc9270 daemon=0x5646b5dc68d0\n[init] buffer=0x5646b5dc952f available=4 dump=4\n536f6d65\n[init] chars: Some\ncalling default_handler: buffer_head=0x5646b5dc952f to_be_processed=4 left_unprocessed(before)=4\n[before-default-handler] buffer=0x5646b5dc952f available=4 dump=4\n536f6d65\n[before-default-handler] chars: Some\ndefault_handler returned. left_unprocessed(after)=0 to_be_processed=4\nafter-processing: processed_size=4 new_buffer_head=0x5646b5dc9533 available=0\nEXIT process_request_body: final buffer_head=0x5646b5dc9533 available=0 read_buffer=0x5646b5dc952f read_buffer_offset=0\nENTER process_request_body: connection=0x5646b5dc9270 daemon=0x5646b5dc68d0\n[init] buffer=0x5646b5dc952f available=5 dump=5\n536f6d6520\n[init] chars: Some \ncalling default_handler: buffer_head=0x5646b5dc952f to_be_processed=5 left_unprocessed(before)=5\n[before-default-handler] buffer=0x5646b5dc952f available=5 dump=5\n536f6d6520\n[before-default-handler] chars: Some \ndefault_handler returned. left_unprocessed(after)=0 to_be_processed=5\nafter-processing: processed_size=5 new_buffer_head=0x5646b5dc9534 available=0\nEXIT process_request_body: final buffer_head=0x5646b5dc9534 available=0 read_buffer=0x5646b5dc952f read_buffer_offset=0\nENTER process_request_body: connection=0x5646b5dc9270 daemon=0x5646b5dc68d0\n[init] buffer=0x5646b5dc952f available=6 dump=6\n536f6d652063\n[init] chars: Some c\ncalling default_handler: buffer_head=0x5646b5dc952f to_be_processed=6 left_unprocessed(before)=6\n[before-default-handler] buffer=0x5646b5dc952f available=6 dump=6\n536f6d652063\n[before-default-handler] chars: Some c\ndefault_handler returned. left_unprocessed(after)=0 to_be_processed=6\nafter-processing: processed_size=6 new_buffer_head=0x5646b5dc9535 available=0\nEXIT process_request_body: final buffer_head=0x5646b5dc9535 available=0 read_buffer=0x5646b5dc952f read_buffer_offset=0\nENTER process_request_body: connection=0x5646b5dc9270 daemon=0x5646b5dc68d0\n[init] buffer=0x5646b5dc952f available=7 dump=7\n536f6d6520636f\n[init] chars: Some co\ncalling default_handler: buffer_head=0x5646b5dc952f to_be_processed=7 left_unprocessed(before)=7\n[before-default-handler] buffer=0x5646b5dc952f available=7 dump=7\n536f6d6520636f\n[\n</execution_log>\n\n<instruction>\nJudge whether the report is correct or not.\n</instruction>\n",
  "is_report_correct": true,
  "explanation": "Agent A is correct. The variable buffer_head is only used to read from the buffer (indexing and comparisons), is passed to helpers that accept const data (string-to-uint64 helper and the access/default handler in libmicrohttpd) and is used as the source argument to memmove (which accepts a const void *src). There is no write-through buffer_head anywhere in the shown code \u2014 only pointer arithmetic (advancing the pointer) is performed, which is compatible with declaring it as const char *. Under MISRA C 2023 Rule 8.13 the pointer should therefore be declared to point to a const-qualified type (e.g. const char *buffer_head). The only caveat would be if some called function actually requires a char * (non-const) parameter; in that case the declaration cannot be changed without either changing the callee or performing an explicit cast, but nothing in the provided fragment indicates such a need. Hence the reported violation is correct."
}