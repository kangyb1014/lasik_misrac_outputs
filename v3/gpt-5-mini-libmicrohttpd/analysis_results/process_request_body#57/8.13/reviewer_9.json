{
  "user_message": "An agent A claimed that the following process_request_body code violates the MISRA C 2023 rule 8.13.\n<misra_rule>\nMISRA C 2023 Rule 8.13 is A pointer should point to a const-qualified type whenever possible.\n\n</misra_rule>\n<target_code>\nHere is the original code of process_request_body.\n```c\nstatic void\nprocess_request_body (struct MHD_Connection *connection)\n{\n  struct MHD_Daemon *daemon = connection->daemon;\n  size_t available;\n  bool instant_retry;\n  char *buffer_head;\n  const int discp_lvl = daemon->client_discipline;\n  /* Treat bare LF as the end of the line.\n     RFC 9112, section 2.2-3\n     Note: MHD never replaces bare LF with space (RFC 9110, section 5.5-5).\n     Bare LF is processed as end of the line or rejected as broken request. */\n  const bool bare_lf_as_crlf = MHD_ALLOW_BARE_LF_AS_CRLF_ (discp_lvl);\n  /* Allow \"Bad WhiteSpace\" in chunk extension.\n     RFC 9112, Section 7.1.1, Paragraph 2 */\n  const bool allow_bws = (2 < discp_lvl);\n\n  mhd_assert (NULL == connection->rp.response);\n\n  buffer_head = connection->read_buffer;\n  available = connection->read_buffer_offset;\n  do\n  {\n    size_t to_be_processed;\n    size_t left_unprocessed;\n    size_t processed_size;\n\n    instant_retry = false;\n    if (connection->rq.have_chunked_upload)\n    {\n      mhd_assert (MHD_SIZE_UNKNOWN == connection->rq.remaining_upload_size);\n      if ( (connection->rq.current_chunk_offset ==\n            connection->rq.current_chunk_size) &&\n           (0 != connection->rq.current_chunk_size) )\n      {\n        size_t i;\n        mhd_assert (0 != available);\n        /* skip new line at the *end* of a chunk */\n        i = 0;\n        if ( (2 <= available) &&\n             ('\\r' == buffer_head[0]) &&\n             ('\\n' == buffer_head[1]) )\n          i += 2;                        /* skip CRLF */\n        else if (bare_lf_as_crlf && ('\\n' == buffer_head[0]))\n          i++;                           /* skip bare LF */\n        else if (2 > available)\n          break;                         /* need more upload data */\n        if (0 == i)\n        {\n          /* malformed encoding */\n          transmit_error_response_static (connection,\n                                          MHD_HTTP_BAD_REQUEST,\n                                          REQUEST_CHUNKED_MALFORMED);\n          return;\n        }\n        available -= i;\n        buffer_head += i;\n        connection->rq.current_chunk_offset = 0;\n        connection->rq.current_chunk_size = 0;\n        if (0 == available)\n          break;\n      }\n      if (0 != connection->rq.current_chunk_size)\n      {\n        uint64_t cur_chunk_left;\n        mhd_assert (connection->rq.current_chunk_offset < \\\n                    connection->rq.current_chunk_size);\n        /* we are in the middle of a chunk, give\n           as much as possible to the client (without\n           crossing chunk boundaries) */\n        cur_chunk_left\n          = connection->rq.current_chunk_size\n            - connection->rq.current_chunk_offset;\n        if (cur_chunk_left > available)\n          to_be_processed = available;\n        else\n        {         /* cur_chunk_left <= (size_t)available */\n          to_be_processed = (size_t) cur_chunk_left;\n          if (available > to_be_processed)\n            instant_retry = true;\n        }\n      }\n      else\n      { /* Need the parse the chunk size line */\n        /** The number of found digits in the chunk size number */\n        size_t num_dig;\n        uint64_t chunk_size;\n        bool broken;\n        bool overflow;\n\n        mhd_assert (0 != available);\n\n        overflow = false;\n        chunk_size = 0; /* Mute possible compiler warning.\n                           The real value will be set later. */\n\n        num_dig = MHD_strx_to_uint64_n_ (buffer_head,\n                                         available,\n                                         &chunk_size);\n        mhd_assert (num_dig <= available);\n        if (num_dig == available)\n          continue; /* Need line delimiter */\n\n        broken = (0 == num_dig);\n        if (broken)\n          /* Check whether result is invalid due to uint64_t overflow */\n          overflow = ((('0' <= buffer_head[0]) && ('9' >= buffer_head[0])) ||\n                      (('A' <= buffer_head[0]) && ('F' >= buffer_head[0])) ||\n                      (('a' <= buffer_head[0]) && ('f' >= buffer_head[0])));\n        else\n        {\n          /**\n           * The length of the string with the number of the chunk size,\n           * including chunk extension\n           */\n          size_t chunk_size_line_len;\n\n          chunk_size_line_len = 0;\n          if ((';' == buffer_head[num_dig]) ||\n              (allow_bws &&\n               ((' ' == buffer_head[num_dig]) ||\n                ('\\t' == buffer_head[num_dig]))))\n          { /* Chunk extension */\n            size_t i;\n\n            /* Skip bad whitespaces (if any) */\n            for (i = num_dig; i < available; ++i)\n            {\n              if ((' ' != buffer_head[i]) && ('\\t' != buffer_head[i]))\n                break;\n            }\n            if (i == available)\n              break; /* need more data */\n            if (';' == buffer_head[i])\n            {\n              for (++i; i < available; ++i)\n              {\n                if ('\\n' == buffer_head[i])\n                  break;\n              }\n              if (i == available)\n                break; /* need more data */\n              mhd_assert (i > num_dig);\n              mhd_assert (1 <= i);\n              /* Found LF position */\n              if (bare_lf_as_crlf)\n                chunk_size_line_len = i; /* Don't care about CR before LF */\n              else if ('\\r' == buffer_head[i - 1])\n                chunk_size_line_len = i;\n            }\n            else\n            { /* No ';' after \"bad whitespace\" */\n              mhd_assert (allow_bws);\n              mhd_assert (0 == chunk_size_line_len);\n            }\n          }\n          else\n          {\n            mhd_assert (available >= num_dig);\n            if ((2 <= (available - num_dig)) &&\n                ('\\r' == buffer_head[num_dig]) &&\n                ('\\n' == buffer_head[num_dig + 1]))\n              chunk_size_line_len = num_dig + 2;\n            else if (bare_lf_as_crlf &&\n                     ('\\n' == buffer_head[num_dig]))\n              chunk_size_line_len = num_dig + 1;\n            else if (2 > (available - num_dig))\n              break; /* need more data */\n          }\n\n          if (0 != chunk_size_line_len)\n          { /* Valid termination of the chunk size line */\n            mhd_assert (chunk_size_line_len <= available);\n            /* Start reading payload data of the chunk */\n            connection->rq.current_chunk_offset = 0;\n            connection->rq.current_chunk_size = chunk_size;\n\n            available -= chunk_size_line_len;\n            buffer_head += chunk_size_line_len;\n\n            if (0 == chunk_size)\n            { /* The final (termination) chunk */\n              connection->rq.remaining_upload_size = 0;\n              break;\n            }\n            if (available > 0)\n              instant_retry = true;\n            continue;\n          }\n          /* Invalid chunk size line */\n        }\n\n        if (! overflow)\n          transmit_error_response_static (connection,\n                                          MHD_HTTP_BAD_REQUEST,\n                                          REQUEST_CHUNKED_MALFORMED);\n        else\n          transmit_error_response_static (connection,\n                                          MHD_HTTP_CONTENT_TOO_LARGE,\n                                          REQUEST_CHUNK_TOO_LARGE);\n        return;\n      }\n    }\n    else\n    {\n      /* no chunked encoding, give all to the client */\n      mhd_assert (MHD_SIZE_UNKNOWN != connection->rq.remaining_upload_size);\n      mhd_assert (0 != connection->rq.remaining_upload_size);\n      if (connection->rq.remaining_upload_size < available)\n        to_be_processed = (size_t) connection->rq.remaining_upload_size;\n      else\n        to_be_processed = available;\n    }\n    left_unprocessed = to_be_processed;\n    connection->rq.client_aware = true;\n    connection->in_access_handler = true;\n    if (MHD_NO ==\n        daemon->default_handler (daemon->default_handler_cls,\n                                 connection,\n                                 connection->rq.url,\n                                 connection->rq.method,\n                                 connection->rq.version,\n                                 buffer_head,\n                                 &left_unprocessed,\n                                 &connection->rq.client_context))\n    {\n      connection->in_access_handler = false;\n      /* serious internal error, close connection */\n      CONNECTION_CLOSE_ERROR (connection,\n                              _ (\"Application reported internal error, \" \\\n                                 \"closing connection.\"));\n      return;\n    }\n    connection->in_access_handler = false;\n\n    if (left_unprocessed > to_be_processed)\n      MHD_PANIC (_ (\"libmicrohttpd API violation.\\n\"));\n\n    connection->rq.some_payload_processed =\n      (left_unprocessed != to_be_processed);\n\n    if (0 != left_unprocessed)\n    {\n      instant_retry = false; /* client did not process everything */\n#ifdef HAVE_MESSAGES\n      if ((! connection->rq.some_payload_processed) &&\n          (! connection->suspended))\n      {\n        /* client did not process any upload data, complain if\n           the setup was incorrect, which may prevent us from\n           handling the rest of the request */\n        if (MHD_D_IS_USING_THREADS_ (daemon))\n          MHD_DLOG (daemon,\n                    _ (\"WARNING: Access Handler Callback has not processed \" \\\n                       \"any upload data and connection is not suspended. \" \\\n                       \"This may result in hung connection.\\n\"));\n      }\n#endif /* HAVE_MESSAGES */\n    }\n    processed_size = to_be_processed - left_unprocessed;\n    /* dh left \"processed\" bytes in buffer for next time... */\n    buffer_head += processed_size;\n    available -= processed_size;\n    if (! connection->rq.have_chunked_upload)\n    {\n      mhd_assert (MHD_SIZE_UNKNOWN != connection->rq.remaining_upload_size);\n      connection->rq.remaining_upload_size -= processed_size;\n    }\n    else\n    {\n      mhd_assert (MHD_SIZE_UNKNOWN == connection->rq.remaining_upload_size);\n      connection->rq.current_chunk_offset += processed_size;\n    }\n  } while (instant_retry);\n  /* TODO: zero out reused memory region */\n  if ( (available > 0) &&\n       (buffer_head != connection->read_buffer) )\n    memmove (connection->read_buffer,\n             buffer_head,\n             available);\n  else\n    mhd_assert ((0 == available) || \\\n                (connection->read_buffer_offset == available));\n  connection->read_buffer_offset = available;\n}\n```\n</target_code>\n<response format>\nProvide your answer with these fields.\n- explanation: your evaluation of the scenario provided by the agent A.\n- is_report_correct: whether the report is correct or not (true/false). True means there is a violation.\n</response format>\n<scenario>\nThe agent A provided the following violation scenario:\nThe local pointer buffer_head is declared as char * but in this fragment it is only used for read access (buffer_head[0], buffer_head[1]). Since no modification of the pointed-to characters occurs via buffer_head, it could be declared const char *; therefore the current non-const pointer violates MISRA C 2023 Rule 8.13. (Fix: change declaration to const char *buffer_head.)\n</scenario>\n\n<execution_log>\nThe agent A also provided the following output log:\nENTER process_request_body: connection=0x55e163c7e270 daemon=0x55e163c7b8d0 read_buffer=0x55e163c7e52f read_buffer_offset=1 have_chunked_upload=0 remaining_upload_size=18\nbuffer_head assigned (char *): 0x55e163c7e52f\ninitial_buffer_head_preview: len=1 data=S\nnon-chunked upload: remaining_upload_size=18 available=1 to_be_processed=1\ncalling_default_handler_with_buffer: len=1 data=S\nafter processing: processed_size=1 buffer_head=0x55e163c7e530 available=0 left_unprocessed=0\nEXIT process_request_body: read_buffer_offset now=0 buffer_head=0x55e163c7e530\nENTER process_request_body: connection=0x55e163c7e270 daemon=0x55e163c7b8d0 read_buffer=0x55e163c7e52f read_buffer_offset=2 have_chunked_upload=0 remaining_upload_size=18\nbuffer_head assigned (char *): 0x55e163c7e52f\ninitial_buffer_head_preview: len=2 data=So\nnon-chunked upload: remaining_upload_size=18 available=2 to_be_processed=2\ncalling_default_handler_with_buffer: len=2 data=So\nafter processing: processed_size=2 buffer_head=0x55e163c7e531 available=0 left_unprocessed=0\nEXIT process_request_body: read_buffer_offset now=0 buffer_head=0x55e163c7e531\nENTER process_request_body: connection=0x55e163c7e270 daemon=0x55e163c7b8d0 read_buffer=0x55e163c7e52f read_buffer_offset=3 have_chunked_upload=0 remaining_upload_size=18\nbuffer_head assigned (char *): 0x55e163c7e52f\ninitial_buffer_head_preview: len=3 data=Som\nnon-chunked upload: remaining_upload_size=18 available=3 to_be_processed=3\ncalling_default_handler_with_buffer: len=3 data=Som\nafter processing: processed_size=3 buffer_head=0x55e163c7e532 available=0 left_unprocessed=0\nEXIT process_request_body: read_buffer_offset now=0 buffer_head=0x55e163c7e532\nENTER process_request_body: connection=0x55e163c7e270 daemon=0x55e163c7b8d0 read_buffer=0x55e163c7e52f read_buffer_offset=4 have_chunked_upload=0 remaining_upload_size=18\nbuffer_head assigned (char *): 0x55e163c7e52f\ninitial_buffer_head_preview: len=4 data=Some\nnon-chunked upload: remaining_upload_size=18 available=4 to_be_processed=4\ncalling_default_handler_with_buffer: len=4 data=Some\nafter processing: processed_size=4 buffer_head=0x55e163c7e533 available=0 left_unprocessed=0\nEXIT process_request_body: read_buffer_offset now=0 buffer_head=0x55e163c7e533\nENTER process_request_body: connection=0x55e163c7e270 daemon=0x55e163c7b8d0 read_buffer=0x55e163c7e52f read_buffer_offset=5 have_chunked_upload=0 remaining_upload_size=18\nbuffer_head assigned (char *): 0x55e163c7e52f\ninitial_buffer_head_preview: len=5 data=Some \nnon-chunked upload: remaining_upload_size=18 available=5 to_be_processed=5\ncalling_default_handler_with_buffer: len=5 data=Some \nafter processing: processed_size=5 buffer_head=0x55e163c7e534 available=0 left_unprocessed=0\nEXIT process_request_body: read_buffer_offset now=0 buffer_head=0x55e163c7e534\nENTER process_request_body: connection=0x55e163c7e270 daemon=0x55e163c7b8d0 read_buffer=0x55e163c7e52f read_buffer_offset=6 have_chunked_upload=0 remaining_upload_size=18\nbuffer_head assigned (char *): 0x55e163c7e52f\ninitial_buffer_head_preview: len=6 data=Some c\nnon-chunked upload: remaining_upload_size=18 available=6 to_be_processed=6\ncalling_default_handler_with_buffer: len=6 data=Some c\nafter processing: processed_size=6 buffer_head=0x55e163c7e535 available=0 left_unprocessed=0\nEXIT process_request_body: read_buffer_offset now=0 buffer_head=0x55e163c7e535\nENTER process_request_body: connection=0x55e163c7e270 daemon=0x55e163c7b8d0 read_buffer=0x55e163c7e52f read_buffer_offset=7 have_chunked_upload=0 remaining_upload_size=18\nbuffer_head assigned (char *): 0x55e163c7e52f\ninitial_buffer_head_preview: len=7 data=Some co\nnon-chunked upload: remaining_upload_size=18 available=7 to_be_processed=7\ncalling_default_handler_with_buffer: len=7 data=Some co\nafter processing: processed_size=7 buffer_head=0x55e163c7e536 available=0 left_unprocessed=0\nEXIT process_request_body: read_buffer_offset now=0 buffer_head=0x55e163c7e536\nENTER process_request_body: connection=0x55e163c7e270 daemon=0x55e163c7b8d0 read_buffer=0x55e163c7e52f read_buffer_offset=8 have_chunked_upload=0 remaining_upload\n</execution_log>\n\n<instruction>\nJudge whether the report is correct or not.\n</instruction>\n",
  "is_report_correct": true,
  "explanation": "Agent A is correct. In the shown function buffer_head is only used for reading from the buffer (indexing, parsing, pointer arithmetic) and is never used to modify the pointed-to characters. All calls that use it (parsing function, memmove source and the access handler upload_data) accept the data for read-only purposes. Therefore the pointer can and should be declared as pointing to a const-qualified type (const char *buffer_head) to comply with MISRA C 2023 Rule 8.13. Note: if any of the callee prototypes actually require a non-const char * (i.e. they intend to modify the buffer), then changing the declaration would not be possible without updating those prototypes; otherwise changing buffer_head to const char * is the appropriate fix."
}