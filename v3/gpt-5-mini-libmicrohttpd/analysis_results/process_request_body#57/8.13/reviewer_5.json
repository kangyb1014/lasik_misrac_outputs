{
  "user_message": "An agent A claimed that the following process_request_body code violates the MISRA C 2023 rule 8.13.\n<misra_rule>\nMISRA C 2023 Rule 8.13 is A pointer should point to a const-qualified type whenever possible.\n\n</misra_rule>\n<target_code>\nHere is the original code of process_request_body.\n```c\nstatic void\nprocess_request_body (struct MHD_Connection *connection)\n{\n  struct MHD_Daemon *daemon = connection->daemon;\n  size_t available;\n  bool instant_retry;\n  char *buffer_head;\n  const int discp_lvl = daemon->client_discipline;\n  /* Treat bare LF as the end of the line.\n     RFC 9112, section 2.2-3\n     Note: MHD never replaces bare LF with space (RFC 9110, section 5.5-5).\n     Bare LF is processed as end of the line or rejected as broken request. */\n  const bool bare_lf_as_crlf = MHD_ALLOW_BARE_LF_AS_CRLF_ (discp_lvl);\n  /* Allow \"Bad WhiteSpace\" in chunk extension.\n     RFC 9112, Section 7.1.1, Paragraph 2 */\n  const bool allow_bws = (2 < discp_lvl);\n\n  mhd_assert (NULL == connection->rp.response);\n\n  buffer_head = connection->read_buffer;\n  available = connection->read_buffer_offset;\n  do\n  {\n    size_t to_be_processed;\n    size_t left_unprocessed;\n    size_t processed_size;\n\n    instant_retry = false;\n    if (connection->rq.have_chunked_upload)\n    {\n      mhd_assert (MHD_SIZE_UNKNOWN == connection->rq.remaining_upload_size);\n      if ( (connection->rq.current_chunk_offset ==\n            connection->rq.current_chunk_size) &&\n           (0 != connection->rq.current_chunk_size) )\n      {\n        size_t i;\n        mhd_assert (0 != available);\n        /* skip new line at the *end* of a chunk */\n        i = 0;\n        if ( (2 <= available) &&\n             ('\\r' == buffer_head[0]) &&\n             ('\\n' == buffer_head[1]) )\n          i += 2;                        /* skip CRLF */\n        else if (bare_lf_as_crlf && ('\\n' == buffer_head[0]))\n          i++;                           /* skip bare LF */\n        else if (2 > available)\n          break;                         /* need more upload data */\n        if (0 == i)\n        {\n          /* malformed encoding */\n          transmit_error_response_static (connection,\n                                          MHD_HTTP_BAD_REQUEST,\n                                          REQUEST_CHUNKED_MALFORMED);\n          return;\n        }\n        available -= i;\n        buffer_head += i;\n        connection->rq.current_chunk_offset = 0;\n        connection->rq.current_chunk_size = 0;\n        if (0 == available)\n          break;\n      }\n      if (0 != connection->rq.current_chunk_size)\n      {\n        uint64_t cur_chunk_left;\n        mhd_assert (connection->rq.current_chunk_offset < \\\n                    connection->rq.current_chunk_size);\n        /* we are in the middle of a chunk, give\n           as much as possible to the client (without\n           crossing chunk boundaries) */\n        cur_chunk_left\n          = connection->rq.current_chunk_size\n            - connection->rq.current_chunk_offset;\n        if (cur_chunk_left > available)\n          to_be_processed = available;\n        else\n        {         /* cur_chunk_left <= (size_t)available */\n          to_be_processed = (size_t) cur_chunk_left;\n          if (available > to_be_processed)\n            instant_retry = true;\n        }\n      }\n      else\n      { /* Need the parse the chunk size line */\n        /** The number of found digits in the chunk size number */\n        size_t num_dig;\n        uint64_t chunk_size;\n        bool broken;\n        bool overflow;\n\n        mhd_assert (0 != available);\n\n        overflow = false;\n        chunk_size = 0; /* Mute possible compiler warning.\n                           The real value will be set later. */\n\n        num_dig = MHD_strx_to_uint64_n_ (buffer_head,\n                                         available,\n                                         &chunk_size);\n        mhd_assert (num_dig <= available);\n        if (num_dig == available)\n          continue; /* Need line delimiter */\n\n        broken = (0 == num_dig);\n        if (broken)\n          /* Check whether result is invalid due to uint64_t overflow */\n          overflow = ((('0' <= buffer_head[0]) && ('9' >= buffer_head[0])) ||\n                      (('A' <= buffer_head[0]) && ('F' >= buffer_head[0])) ||\n                      (('a' <= buffer_head[0]) && ('f' >= buffer_head[0])));\n        else\n        {\n          /**\n           * The length of the string with the number of the chunk size,\n           * including chunk extension\n           */\n          size_t chunk_size_line_len;\n\n          chunk_size_line_len = 0;\n          if ((';' == buffer_head[num_dig]) ||\n              (allow_bws &&\n               ((' ' == buffer_head[num_dig]) ||\n                ('\\t' == buffer_head[num_dig]))))\n          { /* Chunk extension */\n            size_t i;\n\n            /* Skip bad whitespaces (if any) */\n            for (i = num_dig; i < available; ++i)\n            {\n              if ((' ' != buffer_head[i]) && ('\\t' != buffer_head[i]))\n                break;\n            }\n            if (i == available)\n              break; /* need more data */\n            if (';' == buffer_head[i])\n            {\n              for (++i; i < available; ++i)\n              {\n                if ('\\n' == buffer_head[i])\n                  break;\n              }\n              if (i == available)\n                break; /* need more data */\n              mhd_assert (i > num_dig);\n              mhd_assert (1 <= i);\n              /* Found LF position */\n              if (bare_lf_as_crlf)\n                chunk_size_line_len = i; /* Don't care about CR before LF */\n              else if ('\\r' == buffer_head[i - 1])\n                chunk_size_line_len = i;\n            }\n            else\n            { /* No ';' after \"bad whitespace\" */\n              mhd_assert (allow_bws);\n              mhd_assert (0 == chunk_size_line_len);\n            }\n          }\n          else\n          {\n            mhd_assert (available >= num_dig);\n            if ((2 <= (available - num_dig)) &&\n                ('\\r' == buffer_head[num_dig]) &&\n                ('\\n' == buffer_head[num_dig + 1]))\n              chunk_size_line_len = num_dig + 2;\n            else if (bare_lf_as_crlf &&\n                     ('\\n' == buffer_head[num_dig]))\n              chunk_size_line_len = num_dig + 1;\n            else if (2 > (available - num_dig))\n              break; /* need more data */\n          }\n\n          if (0 != chunk_size_line_len)\n          { /* Valid termination of the chunk size line */\n            mhd_assert (chunk_size_line_len <= available);\n            /* Start reading payload data of the chunk */\n            connection->rq.current_chunk_offset = 0;\n            connection->rq.current_chunk_size = chunk_size;\n\n            available -= chunk_size_line_len;\n            buffer_head += chunk_size_line_len;\n\n            if (0 == chunk_size)\n            { /* The final (termination) chunk */\n              connection->rq.remaining_upload_size = 0;\n              break;\n            }\n            if (available > 0)\n              instant_retry = true;\n            continue;\n          }\n          /* Invalid chunk size line */\n        }\n\n        if (! overflow)\n          transmit_error_response_static (connection,\n                                          MHD_HTTP_BAD_REQUEST,\n                                          REQUEST_CHUNKED_MALFORMED);\n        else\n          transmit_error_response_static (connection,\n                                          MHD_HTTP_CONTENT_TOO_LARGE,\n                                          REQUEST_CHUNK_TOO_LARGE);\n        return;\n      }\n    }\n    else\n    {\n      /* no chunked encoding, give all to the client */\n      mhd_assert (MHD_SIZE_UNKNOWN != connection->rq.remaining_upload_size);\n      mhd_assert (0 != connection->rq.remaining_upload_size);\n      if (connection->rq.remaining_upload_size < available)\n        to_be_processed = (size_t) connection->rq.remaining_upload_size;\n      else\n        to_be_processed = available;\n    }\n    left_unprocessed = to_be_processed;\n    connection->rq.client_aware = true;\n    connection->in_access_handler = true;\n    if (MHD_NO ==\n        daemon->default_handler (daemon->default_handler_cls,\n                                 connection,\n                                 connection->rq.url,\n                                 connection->rq.method,\n                                 connection->rq.version,\n                                 buffer_head,\n                                 &left_unprocessed,\n                                 &connection->rq.client_context))\n    {\n      connection->in_access_handler = false;\n      /* serious internal error, close connection */\n      CONNECTION_CLOSE_ERROR (connection,\n                              _ (\"Application reported internal error, \" \\\n                                 \"closing connection.\"));\n      return;\n    }\n    connection->in_access_handler = false;\n\n    if (left_unprocessed > to_be_processed)\n      MHD_PANIC (_ (\"libmicrohttpd API violation.\\n\"));\n\n    connection->rq.some_payload_processed =\n      (left_unprocessed != to_be_processed);\n\n    if (0 != left_unprocessed)\n    {\n      instant_retry = false; /* client did not process everything */\n#ifdef HAVE_MESSAGES\n      if ((! connection->rq.some_payload_processed) &&\n          (! connection->suspended))\n      {\n        /* client did not process any upload data, complain if\n           the setup was incorrect, which may prevent us from\n           handling the rest of the request */\n        if (MHD_D_IS_USING_THREADS_ (daemon))\n          MHD_DLOG (daemon,\n                    _ (\"WARNING: Access Handler Callback has not processed \" \\\n                       \"any upload data and connection is not suspended. \" \\\n                       \"This may result in hung connection.\\n\"));\n      }\n#endif /* HAVE_MESSAGES */\n    }\n    processed_size = to_be_processed - left_unprocessed;\n    /* dh left \"processed\" bytes in buffer for next time... */\n    buffer_head += processed_size;\n    available -= processed_size;\n    if (! connection->rq.have_chunked_upload)\n    {\n      mhd_assert (MHD_SIZE_UNKNOWN != connection->rq.remaining_upload_size);\n      connection->rq.remaining_upload_size -= processed_size;\n    }\n    else\n    {\n      mhd_assert (MHD_SIZE_UNKNOWN == connection->rq.remaining_upload_size);\n      connection->rq.current_chunk_offset += processed_size;\n    }\n  } while (instant_retry);\n  /* TODO: zero out reused memory region */\n  if ( (available > 0) &&\n       (buffer_head != connection->read_buffer) )\n    memmove (connection->read_buffer,\n             buffer_head,\n             available);\n  else\n    mhd_assert ((0 == available) || \\\n                (connection->read_buffer_offset == available));\n  connection->read_buffer_offset = available;\n}\n```\n</target_code>\n<response format>\nProvide your answer with these fields.\n- explanation: your evaluation of the scenario provided by the agent A.\n- is_report_correct: whether the report is correct or not (true/false). True means there is a violation.\n</response format>\n<scenario>\nThe agent A provided the following violation scenario:\nThe pointer 'buffer_head' is declared as char * but is only used for read access in the shown fragment (accessing buffer_head[num_dig] and buffer_head[num_dig + 1]) and elsewhere passed as the source to memmove (which takes a const void *). According to MISRA C 2023 Rule 8.13, the pointer should point to a const-qualified type whenever possible. Therefore this is a violation. A simple fix is to declare buffer_head as 'const char *buffer_head' (and adjust any called functions that require non-const if necessary).\n</scenario>\n\n<execution_log>\nThe agent A also provided the following output log:\nENTER process_request_body: daemon=0x560b72f2e8d0, discp_lvl=0, bare_lf_as_crlf=1, allow_bws=0\ninitial buffer_head=0x560b72f3152f, available=1\ninitial_buffer: addr=0x560b72f3152f avail=1 dump_len=1\ninitial_buffer: bytes=S\nCalling default_handler: to_be_processed=1, buffer_head=0x560b72f3152f, available=1\nbuffer_before_handler: addr=0x560b72f3152f avail=1 dump_len=1\nbuffer_before_handler: bytes=S\nAfter handler: left_unprocessed=0 (to_be_processed=1)\nProcessed size=1, new buffer_head=0x560b72f31530, available=0\nEXIT process_request_body: final available=0, read_buffer_offset=0\nENTER process_request_body: daemon=0x560b72f2e8d0, discp_lvl=0, bare_lf_as_crlf=1, allow_bws=0\ninitial buffer_head=0x560b72f3152f, available=2\ninitial_buffer: addr=0x560b72f3152f avail=2 dump_len=2\ninitial_buffer: bytes=So\nCalling default_handler: to_be_processed=2, buffer_head=0x560b72f3152f, available=2\nbuffer_before_handler: addr=0x560b72f3152f avail=2 dump_len=2\nbuffer_before_handler: bytes=So\nAfter handler: left_unprocessed=0 (to_be_processed=2)\nProcessed size=2, new buffer_head=0x560b72f31531, available=0\nEXIT process_request_body: final available=0, read_buffer_offset=0\nENTER process_request_body: daemon=0x560b72f2e8d0, discp_lvl=0, bare_lf_as_crlf=1, allow_bws=0\ninitial buffer_head=0x560b72f3152f, available=3\ninitial_buffer: addr=0x560b72f3152f avail=3 dump_len=3\ninitial_buffer: bytes=Som\nCalling default_handler: to_be_processed=3, buffer_head=0x560b72f3152f, available=3\nbuffer_before_handler: addr=0x560b72f3152f avail=3 dump_len=3\nbuffer_before_handler: bytes=Som\nAfter handler: left_unprocessed=0 (to_be_processed=3)\nProcessed size=3, new buffer_head=0x560b72f31532, available=0\nEXIT process_request_body: final available=0, read_buffer_offset=0\nENTER process_request_body: daemon=0x560b72f2e8d0, discp_lvl=0, bare_lf_as_crlf=1, allow_bws=0\ninitial buffer_head=0x560b72f3152f, available=4\ninitial_buffer: addr=0x560b72f3152f avail=4 dump_len=4\ninitial_buffer: bytes=Some\nCalling default_handler: to_be_processed=4, buffer_head=0x560b72f3152f, available=4\nbuffer_before_handler: addr=0x560b72f3152f avail=4 dump_len=4\nbuffer_before_handler: bytes=Some\nAfter handler: left_unprocessed=0 (to_be_processed=4)\nProcessed size=4, new buffer_head=0x560b72f31533, available=0\nEXIT process_request_body: final available=0, read_buffer_offset=0\nENTER process_request_body: daemon=0x560b72f2e8d0, discp_lvl=0, bare_lf_as_crlf=1, allow_bws=0\ninitial buffer_head=0x560b72f3152f, available=5\ninitial_buffer: addr=0x560b72f3152f avail=5 dump_len=5\ninitial_buffer: bytes=Some \nCalling default_handler: to_be_processed=5, buffer_head=0x560b72f3152f, available=5\nbuffer_before_handler: addr=0x560b72f3152f avail=5 dump_len=5\nbuffer_before_handler: bytes=Some \nAfter handler: left_unprocessed=0 (to_be_processed=5)\nProcessed size=5, new buffer_head=0x560b72f31534, available=0\nEXIT process_request_body: final available=0, read_buffer_offset=0\nENTER process_request_body: daemon=0x560b72f2e8d0, discp_lvl=0, bare_lf_as_crlf=1, allow_bws=0\ninitial buffer_head=0x560b72f3152f, available=6\ninitial_buffer: addr=0x560b72f3152f avail=6 dump_len=6\ninitial_buffer: bytes=Some c\nCalling default_handler: to_be_processed=6, buffer_head=0x560b72f3152f, available=6\nbuffer_before_handler: addr=0x560b72f3152f avail=6 dump_len=6\nbuffer_before_handler: bytes=Some c\nAfter handler: left_unprocessed=0 (to_be_processed=6)\nProcessed size=6, new buffer_head=0x560b72f31535, available=0\nEXIT process_request_body: final available=0, read_buffer_offset=0\nENTER process_request_body: daemon=0x560b72f2e8d0, discp_lvl=0, bare_lf_as_crlf=1, allow_bws=0\ninitial buffer_head=0x560b72f3152f, available=7\ninitial_buffer: addr=0x560b72f3152f avail=7 dump_len=7\ninitial_buffer: bytes=Some co\nCalling default_handler: to_be_processed=7, buffer_head=0x560b72f3152f, available=7\nbuffer_before_handler: addr=0x560b72f3152f avail=7 dump_len=7\nbuffer_before_handler: bytes=Some co\nAfter handler: left_unprocessed=0 (to_be_processed=7)\nProcessed size=7, new buffer_head=0x560b72f31536, available=0\nEXIT process_request_body: final available=0, r\n</execution_log>\n\n<instruction>\nJudge whether the report is correct or not.\n</instruction>\n",
  "is_report_correct": true,
  "explanation": "Agent A's report is correct. The local variable buffer_head is only used for read-only access to the read buffer (indexing buffer_head[...]), for pointer arithmetic, and is passed to functions (e.g. MHD_strx_to_uint64_n_, the default handler and memmove) that accept const-qualified input (memmove takes a const void *src, the upload_data parameter in libmicrohttpd handlers is const char *). There are no writes through buffer_head (no *buffer_head = ...). Therefore buffer_head can and should be declared as const char * to satisfy MISRA C 2023 Rule 8.13. Changing the declaration to const char *buffer_head is safe here (assignment from connection->read_buffer, a char *, to const char * is allowed, and pointer arithmetic on a const pointer is permitted)."
}