{
  "user_message": "An agent A claimed that the following process_request_body code violates the MISRA C 2023 rule 8.13.\n<misra_rule>\nMISRA C 2023 Rule 8.13 is A pointer should point to a const-qualified type whenever possible.\n\n</misra_rule>\n<target_code>\nHere is the original code of process_request_body.\n```c\nstatic void\nprocess_request_body (struct MHD_Connection *connection)\n{\n  struct MHD_Daemon *daemon = connection->daemon;\n  size_t available;\n  bool instant_retry;\n  char *buffer_head;\n  const int discp_lvl = daemon->client_discipline;\n  /* Treat bare LF as the end of the line.\n     RFC 9112, section 2.2-3\n     Note: MHD never replaces bare LF with space (RFC 9110, section 5.5-5).\n     Bare LF is processed as end of the line or rejected as broken request. */\n  const bool bare_lf_as_crlf = MHD_ALLOW_BARE_LF_AS_CRLF_ (discp_lvl);\n  /* Allow \"Bad WhiteSpace\" in chunk extension.\n     RFC 9112, Section 7.1.1, Paragraph 2 */\n  const bool allow_bws = (2 < discp_lvl);\n\n  mhd_assert (NULL == connection->rp.response);\n\n  buffer_head = connection->read_buffer;\n  available = connection->read_buffer_offset;\n  do\n  {\n    size_t to_be_processed;\n    size_t left_unprocessed;\n    size_t processed_size;\n\n    instant_retry = false;\n    if (connection->rq.have_chunked_upload)\n    {\n      mhd_assert (MHD_SIZE_UNKNOWN == connection->rq.remaining_upload_size);\n      if ( (connection->rq.current_chunk_offset ==\n            connection->rq.current_chunk_size) &&\n           (0 != connection->rq.current_chunk_size) )\n      {\n        size_t i;\n        mhd_assert (0 != available);\n        /* skip new line at the *end* of a chunk */\n        i = 0;\n        if ( (2 <= available) &&\n             ('\\r' == buffer_head[0]) &&\n             ('\\n' == buffer_head[1]) )\n          i += 2;                        /* skip CRLF */\n        else if (bare_lf_as_crlf && ('\\n' == buffer_head[0]))\n          i++;                           /* skip bare LF */\n        else if (2 > available)\n          break;                         /* need more upload data */\n        if (0 == i)\n        {\n          /* malformed encoding */\n          transmit_error_response_static (connection,\n                                          MHD_HTTP_BAD_REQUEST,\n                                          REQUEST_CHUNKED_MALFORMED);\n          return;\n        }\n        available -= i;\n        buffer_head += i;\n        connection->rq.current_chunk_offset = 0;\n        connection->rq.current_chunk_size = 0;\n        if (0 == available)\n          break;\n      }\n      if (0 != connection->rq.current_chunk_size)\n      {\n        uint64_t cur_chunk_left;\n        mhd_assert (connection->rq.current_chunk_offset < \\\n                    connection->rq.current_chunk_size);\n        /* we are in the middle of a chunk, give\n           as much as possible to the client (without\n           crossing chunk boundaries) */\n        cur_chunk_left\n          = connection->rq.current_chunk_size\n            - connection->rq.current_chunk_offset;\n        if (cur_chunk_left > available)\n          to_be_processed = available;\n        else\n        {         /* cur_chunk_left <= (size_t)available */\n          to_be_processed = (size_t) cur_chunk_left;\n          if (available > to_be_processed)\n            instant_retry = true;\n        }\n      }\n      else\n      { /* Need the parse the chunk size line */\n        /** The number of found digits in the chunk size number */\n        size_t num_dig;\n        uint64_t chunk_size;\n        bool broken;\n        bool overflow;\n\n        mhd_assert (0 != available);\n\n        overflow = false;\n        chunk_size = 0; /* Mute possible compiler warning.\n                           The real value will be set later. */\n\n        num_dig = MHD_strx_to_uint64_n_ (buffer_head,\n                                         available,\n                                         &chunk_size);\n        mhd_assert (num_dig <= available);\n        if (num_dig == available)\n          continue; /* Need line delimiter */\n\n        broken = (0 == num_dig);\n        if (broken)\n          /* Check whether result is invalid due to uint64_t overflow */\n          overflow = ((('0' <= buffer_head[0]) && ('9' >= buffer_head[0])) ||\n                      (('A' <= buffer_head[0]) && ('F' >= buffer_head[0])) ||\n                      (('a' <= buffer_head[0]) && ('f' >= buffer_head[0])));\n        else\n        {\n          /**\n           * The length of the string with the number of the chunk size,\n           * including chunk extension\n           */\n          size_t chunk_size_line_len;\n\n          chunk_size_line_len = 0;\n          if ((';' == buffer_head[num_dig]) ||\n              (allow_bws &&\n               ((' ' == buffer_head[num_dig]) ||\n                ('\\t' == buffer_head[num_dig]))))\n          { /* Chunk extension */\n            size_t i;\n\n            /* Skip bad whitespaces (if any) */\n            for (i = num_dig; i < available; ++i)\n            {\n              if ((' ' != buffer_head[i]) && ('\\t' != buffer_head[i]))\n                break;\n            }\n            if (i == available)\n              break; /* need more data */\n            if (';' == buffer_head[i])\n            {\n              for (++i; i < available; ++i)\n              {\n                if ('\\n' == buffer_head[i])\n                  break;\n              }\n              if (i == available)\n                break; /* need more data */\n              mhd_assert (i > num_dig);\n              mhd_assert (1 <= i);\n              /* Found LF position */\n              if (bare_lf_as_crlf)\n                chunk_size_line_len = i; /* Don't care about CR before LF */\n              else if ('\\r' == buffer_head[i - 1])\n                chunk_size_line_len = i;\n            }\n            else\n            { /* No ';' after \"bad whitespace\" */\n              mhd_assert (allow_bws);\n              mhd_assert (0 == chunk_size_line_len);\n            }\n          }\n          else\n          {\n            mhd_assert (available >= num_dig);\n            if ((2 <= (available - num_dig)) &&\n                ('\\r' == buffer_head[num_dig]) &&\n                ('\\n' == buffer_head[num_dig + 1]))\n              chunk_size_line_len = num_dig + 2;\n            else if (bare_lf_as_crlf &&\n                     ('\\n' == buffer_head[num_dig]))\n              chunk_size_line_len = num_dig + 1;\n            else if (2 > (available - num_dig))\n              break; /* need more data */\n          }\n\n          if (0 != chunk_size_line_len)\n          { /* Valid termination of the chunk size line */\n            mhd_assert (chunk_size_line_len <= available);\n            /* Start reading payload data of the chunk */\n            connection->rq.current_chunk_offset = 0;\n            connection->rq.current_chunk_size = chunk_size;\n\n            available -= chunk_size_line_len;\n            buffer_head += chunk_size_line_len;\n\n            if (0 == chunk_size)\n            { /* The final (termination) chunk */\n              connection->rq.remaining_upload_size = 0;\n              break;\n            }\n            if (available > 0)\n              instant_retry = true;\n            continue;\n          }\n          /* Invalid chunk size line */\n        }\n\n        if (! overflow)\n          transmit_error_response_static (connection,\n                                          MHD_HTTP_BAD_REQUEST,\n                                          REQUEST_CHUNKED_MALFORMED);\n        else\n          transmit_error_response_static (connection,\n                                          MHD_HTTP_CONTENT_TOO_LARGE,\n                                          REQUEST_CHUNK_TOO_LARGE);\n        return;\n      }\n    }\n    else\n    {\n      /* no chunked encoding, give all to the client */\n      mhd_assert (MHD_SIZE_UNKNOWN != connection->rq.remaining_upload_size);\n      mhd_assert (0 != connection->rq.remaining_upload_size);\n      if (connection->rq.remaining_upload_size < available)\n        to_be_processed = (size_t) connection->rq.remaining_upload_size;\n      else\n        to_be_processed = available;\n    }\n    left_unprocessed = to_be_processed;\n    connection->rq.client_aware = true;\n    connection->in_access_handler = true;\n    if (MHD_NO ==\n        daemon->default_handler (daemon->default_handler_cls,\n                                 connection,\n                                 connection->rq.url,\n                                 connection->rq.method,\n                                 connection->rq.version,\n                                 buffer_head,\n                                 &left_unprocessed,\n                                 &connection->rq.client_context))\n    {\n      connection->in_access_handler = false;\n      /* serious internal error, close connection */\n      CONNECTION_CLOSE_ERROR (connection,\n                              _ (\"Application reported internal error, \" \\\n                                 \"closing connection.\"));\n      return;\n    }\n    connection->in_access_handler = false;\n\n    if (left_unprocessed > to_be_processed)\n      MHD_PANIC (_ (\"libmicrohttpd API violation.\\n\"));\n\n    connection->rq.some_payload_processed =\n      (left_unprocessed != to_be_processed);\n\n    if (0 != left_unprocessed)\n    {\n      instant_retry = false; /* client did not process everything */\n#ifdef HAVE_MESSAGES\n      if ((! connection->rq.some_payload_processed) &&\n          (! connection->suspended))\n      {\n        /* client did not process any upload data, complain if\n           the setup was incorrect, which may prevent us from\n           handling the rest of the request */\n        if (MHD_D_IS_USING_THREADS_ (daemon))\n          MHD_DLOG (daemon,\n                    _ (\"WARNING: Access Handler Callback has not processed \" \\\n                       \"any upload data and connection is not suspended. \" \\\n                       \"This may result in hung connection.\\n\"));\n      }\n#endif /* HAVE_MESSAGES */\n    }\n    processed_size = to_be_processed - left_unprocessed;\n    /* dh left \"processed\" bytes in buffer for next time... */\n    buffer_head += processed_size;\n    available -= processed_size;\n    if (! connection->rq.have_chunked_upload)\n    {\n      mhd_assert (MHD_SIZE_UNKNOWN != connection->rq.remaining_upload_size);\n      connection->rq.remaining_upload_size -= processed_size;\n    }\n    else\n    {\n      mhd_assert (MHD_SIZE_UNKNOWN == connection->rq.remaining_upload_size);\n      connection->rq.current_chunk_offset += processed_size;\n    }\n  } while (instant_retry);\n  /* TODO: zero out reused memory region */\n  if ( (available > 0) &&\n       (buffer_head != connection->read_buffer) )\n    memmove (connection->read_buffer,\n             buffer_head,\n             available);\n  else\n    mhd_assert ((0 == available) || \\\n                (connection->read_buffer_offset == available));\n  connection->read_buffer_offset = available;\n}\n```\n</target_code>\n<response format>\nProvide your answer with these fields.\n- explanation: your evaluation of the scenario provided by the agent A.\n- is_report_correct: whether the report is correct or not (true/false). True means there is a violation.\n</response format>\n<scenario>\nThe agent A provided the following violation scenario:\nThe pointer 'buffer_head' is declared as 'char *buffer_head' but is only used to read data (e.g. buffer_head[num_dig] == '\\n') and never used to modify the pointee via this pointer. According to MISRA C 2023 Rule 8.13 a pointer that is only used to access data should point to a const-qualified type. In this code fragment the non-const pointer is used for read-only access, so it should be declared as 'const char *buffer_head' (assigning from the existing 'char *' read buffer is permitted).\n</scenario>\n\n<execution_log>\nThe agent A also provided the following output log:\n[process_request_body] enter: initial buffer state\n  connection_ptr=0x56004026a270 available=1 highlight_index=0\n  sample_len=1\n  bytes(hex): 53\n  bytes(chr): S\n  highlighted byte @0: 0x53 ('S')\n\n[process_request_body] non-chunked: to_be_processed=1\n  connection_ptr=0x56004026a270 available=1 highlight_index=0\n  sample_len=1\n  bytes(hex): 53\n  bytes(chr): S\n  highlighted byte @0: 0x53 ('S')\n\n[process_request_body] before default_handler: to_be_processed=1 left_unprocessed=1\n  connection_ptr=0x56004026a270 available=1 highlight_index=0\n  sample_len=1\n  bytes(hex): 53\n  bytes(chr): S\n  highlighted byte @0: 0x53 ('S')\n\n[process_request_body] after default_handler: left_unprocessed=0 to_be_processed=1\n  connection_ptr=0x56004026a270 available=1 highlight_index=0\n  sample_len=1\n  bytes(hex): 53\n  bytes(chr): S\n  highlighted byte @0: 0x53 ('S')\n\n[process_request_body] processing progress: processed_size=1 available_before=1\n  connection_ptr=0x56004026a270 available=1 highlight_index=1\n  sample_len=1\n  bytes(hex): 53\n  bytes(chr): S\n  highlighted byte @1: (out of range)\n\n[process_request_body] exit: final buffer state\n  connection_ptr=0x56004026a270 available=0 highlight_index=0\n  sample_len=0\n  (no available bytes)\n  highlighted byte @0: (out of range)\n\n[process_request_body] enter: initial buffer state\n  connection_ptr=0x56004026a270 available=2 highlight_index=0\n  sample_len=2\n  bytes(hex): 53 6f\n  bytes(chr): S o\n  highlighted byte @0: 0x53 ('S')\n\n[process_request_body] non-chunked: to_be_processed=2\n  connection_ptr=0x56004026a270 available=2 highlight_index=0\n  sample_len=2\n  bytes(hex): 53 6f\n  bytes(chr): S o\n  highlighted byte @0: 0x53 ('S')\n\n[process_request_body] before default_handler: to_be_processed=2 left_unprocessed=2\n  connection_ptr=0x56004026a270 available=2 highlight_index=0\n  sample_len=2\n  bytes(hex): 53 6f\n  bytes(chr): S o\n  highlighted byte @0: 0x53 ('S')\n\n[process_request_body] after default_handler: left_unprocessed=0 to_be_processed=2\n  connection_ptr=0x56004026a270 available=2 highlight_index=0\n  sample_len=2\n  bytes(hex): 53 6f\n  bytes(chr): S o\n  highlighted byte @0: 0x53 ('S')\n\n[process_request_body] processing progress: processed_size=2 available_before=2\n  connection_ptr=0x56004026a270 available=2 highlight_index=2\n  sample_len=2\n  bytes(hex): 53 6f\n  bytes(chr): S o\n  highlighted byte @2: (out of range)\n\n[process_request_body] exit: final buffer state\n  connection_ptr=0x56004026a270 available=0 highlight_index=0\n  sample_len=0\n  (no available bytes)\n  highlighted byte @0: (out of range)\n\n[process_request_body] enter: initial buffer state\n  connection_ptr=0x56004026a270 available=3 highlight_index=0\n  sample_len=3\n  bytes(hex): 53 6f 6d\n  bytes(chr): S o m\n  highlighted byte @0: 0x53 ('S')\n\n[process_request_body] non-chunked: to_be_processed=3\n  connection_ptr=0x56004026a270 available=3 highlight_index=0\n  sample_len=3\n  bytes(hex): 53 6f 6d\n  bytes(chr): S o m\n  highlighted byte @0: 0x53 ('S')\n\n[process_request_body] before default_handler: to_be_processed=3 left_unprocessed=3\n  connection_ptr=0x56004026a270 available=3 highlight_index=0\n  sample_len=3\n  bytes(hex): 53 6f 6d\n  bytes(chr): S o m\n  highlighted byte @0: 0x53 ('S')\n\n[process_request_body] after default_handler: left_unprocessed=0 to_be_processed=3\n  connection_ptr=0x56004026a270 available=3 highlight_index=0\n  sample_len=3\n  bytes(hex): 53 6f 6d\n  bytes(chr): S o m\n  highlighted byte @0: 0x53 ('S')\n\n[process_request_body] processing progress: processed_size=3 available_before=3\n  connection_ptr=0x56004026a270 available=3 highlight_index=3\n  sample_len=3\n  bytes(hex): 53 6f 6d\n  bytes(chr): S o m\n  highlighted byte @3: (out of range)\n\n[process_request_body] exit: final buffer state\n  connection_ptr=0x56004026a270 available=0 highlight_index=0\n  sample_len=0\n  (no available bytes)\n  highlighted byte @0: (out of range)\n\n[process_request_body] enter: initial buffer state\n  connection_ptr=0x56004026a270 available=4 highlight_index=0\n  sample_len=4\n  bytes(hex): 53 6f 6d 65\n  bytes(chr): S o m e\n  highlighted byte @0: 0x53 ('S')\n\n[proce\n</execution_log>\n\n<instruction>\nJudge whether the report is correct or not.\n</instruction>\n",
  "is_report_correct": true,
  "explanation": "Agent A is correct: buffer_head is only used for read-only access in this function and therefore could (and per MISRA 8.13 should) be declared to point to a const-qualified type. In the snippet buffer_head is only indexed/read, passed to MHD_strx_to_uint64_n_ and passed as the upload-data argument to daemon->default_handler, and eventually used as the source argument to memmove (which takes a const void *). There are no writes through buffer_head (no assignments to *buffer_head). Assigning connection->read_buffer (char *) to a const char * is allowed, so changing the declaration to const char *buffer_head would remove the non-const pointer and satisfy Rule 8.13.\n\nCaveat: this conclusion assumes the prototypes of the called functions accept const-qualified input (typical for MHD_strx_to_uint64_n_ and memmove; the libmicrohttpd access-handler callback\u2019s upload_data parameter is conventionally const char * in modern APIs). If daemon->default_handler were declared to take a non-const char * for the upload_data argument, changing buffer_head to const char * would be incompatible and the rule could not be applied without changing that API. Given the typical API, however, the report that this code violates MISRA C 2023 Rule 8.13 is correct."
}