{
  "user_message": "<misra_rule>\nMISRA C 2023 Rule 2.2 is: A project shall not contain dead code.\nAny operation that is executed but whose removal would not affect program behaviour constitutes dead code. Notes:\n1. The behaviour of an embedded sytem is often determined not just by the nature of its actions, but also by the time at which they occur.\n2. unreachable code is not dead code, as it cannot be executed.\n3.Initialization is not the same as an assignment operation and is therfore not a candidate for dead code.\n</misra_rule>\n\nAnother agent reported that the target code violated the Rule 2.2.\nHere is the comment from the agent.\n<violation scenario>\nThis assertion is dead code if mhd_assert expands to a no-op in the delivered build (for example, if assertions are always disabled via a macro like NDEBUG so mhd_assert becomes ((void)0)). In that case the expression has no side\u2011effects, is not executed, and removing the call would not change program behaviour \u2014 so Rule 2.2 would be violated. (If, conversely, mhd_assert is implemented to perform a runtime check that can abort or log on failure, then the assertion is not dead because its removal could change behaviour when the condition fails.)\n</violation scenario>\n\nYour job is to insert logging code to capture the control flow and state information of the program.\nInsert logging code so that other agents can reproduce and get evidence for the violation scenario.\n<response format>\n- test_code: a modified MHD_pool_reset code that contains useful probe functions that print useful logs to a file \"/tmp/logs/1382.txt\". The logs should contain the control path and state information of the violation scenario. If test code is not required to validate the scenario, you can leave this blank.\nHere are the constraints for the test code:\n- The test code MUST preserve the original logic of MHD_pool_reset as much as possible.\nYou CAN just insert probe functions to the original code.\n- DO NOT introduce new violations to demonstrate your scenario.\n- The test code MUST be compilable and executable.\n- The test code MUST include line breaks.\n- You MUST NOT define the main function.\n- You MUST NOT define macros.\n</response format>\n<target_code>\nHere is the code of MHD_pool_reset:\n```c\nvoid *\nMHD_pool_reset (struct MemoryPool *pool,\n                void *keep,\n                size_t copy_bytes,\n                size_t new_size)\n{\n  mhd_assert (pool->end >= pool->pos);\n  mhd_assert (pool->size >= pool->end - pool->pos);\n  mhd_assert (copy_bytes <= new_size);\n  mhd_assert (copy_bytes <= pool->size);\n  mhd_assert (keep != NULL || copy_bytes == 0);\n  mhd_assert (keep == NULL || mp_ptr_le_ (pool->memory, keep));\n  /* (keep == NULL || pool->memory + pool->size >= (uint8_t*) keep + copy_bytes) */\n  mhd_assert ((keep == NULL) || \\\n              (pool->size >= mp_ptr_diff_ (keep, pool->memory) + copy_bytes));\n#if defined(MHD_ASAN_POISON_ACTIVE) && defined(HAVE___ASAN_REGION_IS_POISONED)\n  mhd_assert (NULL == __asan_region_is_poisoned (keep, copy_bytes));\n#endif /* MHD_ASAN_POISON_ACTIVE && HAVE___ASAN_REGION_IS_POISONED */\n  _MHD_UNPOISON_MEMORY (pool->memory, new_size);\n  if ( (NULL != keep) &&\n       (keep != pool->memory) )\n  {\n    if (0 != copy_bytes)\n      memmove (pool->memory,\n               keep,\n               copy_bytes);\n  }\n  /* technically not needed, but safer to zero out */\n  if (pool->size > copy_bytes)\n  {\n    size_t to_zero;   /** Size of area to zero-out */\n\n    to_zero = pool->size - copy_bytes;\n    _MHD_UNPOISON_MEMORY (pool->memory + copy_bytes, to_zero);\n#ifdef _WIN32\n    if (pool->is_mmap)\n    {\n      size_t to_recommit;     /** Size of decommitted and re-committed area. */\n      uint8_t *recommit_addr;\n      /* Round down to page size */\n      to_recommit = to_zero - to_zero % MHD_sys_page_size_;\n      recommit_addr = pool->memory + pool->size - to_recommit;\n\n      /* De-committing and re-committing again clear memory and make\n       * pages free / available for other needs until accessed. */\n      if (VirtualFree (recommit_addr,\n                       to_recommit,\n                       MEM_DECOMMIT))\n      {\n        to_zero -= to_recommit;\n\n        if (recommit_addr != VirtualAlloc (recommit_addr,\n                                           to_recommit,\n                                           MEM_COMMIT,\n                                           PAGE_READWRITE))\n          abort ();      /* Serious error, must never happen */\n      }\n    }\n#endif /* _WIN32 */\n    memset (&pool->memory[copy_bytes],\n            0,\n            to_zero);\n  }\n  pool->pos = ROUND_TO_ALIGN_PLUS_RED_ZONE (new_size);\n  pool->end = pool->size;\n  _MHD_POISON_MEMORY (((uint8_t *) pool->memory) + new_size, \\\n                      pool->size - new_size);\n  return pool->memory;\n}\n```\n</target_code>\nPlease provide the modified MHD_pool_reset code.\n",
  "test_code": "/* Logging-enhanced version of MHD_pool_reset - preserves original logic.\n * Writes control-flow and state information to /tmp/logs/1382.txt for debugging\n * the potential \"dead assertion\" scenario when mhd_assert is a no-op.\n */\n\n#include <stdio.h>\n#include <stdint.h>\n#include <stddef.h>\n#include <string.h>\n#include <inttypes.h>\n\n/* Probe logging helper: append a single record to the log file. */\nstatic void\nmhd_log_pool_state (const char *stage,\n                    struct MemoryPool *pool,\n                    void *keep,\n                    size_t copy_bytes,\n                    size_t new_size)\n{\n  FILE *f = fopen(\"/tmp/logs/1382.txt\", \"a\");\n  if (NULL == f)\n    return; /* Best-effort logging, do not change program flow on failure */\n\n  /* Compute a few derived values that mirror the assertions so their\n   * truth values can be recorded even if mhd_assert is compiled out. */\n  int end_ge_pos = (pool->end >= pool->pos) ? 1 : 0;\n  int size_ge_end_minus_pos = (pool->size >= (pool->end - pool->pos)) ? 1 : 0;\n  int copy_le_new = (copy_bytes <= new_size) ? 1 : 0;\n  int copy_le_pool = (copy_bytes <= pool->size) ? 1 : 0;\n  int keep_null_or_zero = (keep != NULL || copy_bytes == 0) ? 1 : 0;\n\n  /* Safe pointer-order checks using integer casts for logging only. */\n  uintptr_t mem_start = (uintptr_t) pool->memory;\n  uintptr_t keep_addr = (uintptr_t) keep;\n  int keep_ptr_ge_mem = (keep == NULL) ? 1 : (keep_addr >= mem_start) ? 1 : 0;\n\n  /* Compute a conservative size check: pool->size >= (keep - pool->memory) + copy_bytes\n   * expressed in unsigned arithmetic but guarded for keep == NULL. */\n  int size_suff_for_copy = 0;\n  if (keep == NULL)\n    size_suff_for_copy = 1;\n  else\n  {\n    /* Avoid signed under/overflow by doing arithmetic in uintptr_t */\n    uintptr_t diff = keep_addr - mem_start;\n    /* Check that diff + copy_bytes does not exceed pool->size */\n    size_suff_for_copy = (pool->size >= (size_t) diff + copy_bytes) ? 1 : 0;\n  }\n\n  fprintf (f,\n           \"[MHD_POOL_RESET] stage=%s pool=%p memory=%p pos=%zu end=%zu size=%zu keep=%p copy_bytes=%zu new_size=%zu\\n\"\n           \"  assertions_eval: end_ge_pos=%d size_ge_end_minus_pos=%d copy_le_new=%d copy_le_pool=%d keep_null_or_zero=%d keep_ptr_ge_mem=%d size_suff_for_copy=%d\\n\",\n           (stage ? stage : \"<null>\"),\n           (void *) pool,\n           (void *) pool->memory,\n           (size_t) pool->pos,\n           (size_t) pool->end,\n           (size_t) pool->size,\n           keep,\n           copy_bytes,\n           new_size,\n           end_ge_pos,\n           size_ge_end_minus_pos,\n           copy_le_new,\n           copy_le_pool,\n           keep_null_or_zero,\n           keep_ptr_ge_mem,\n           size_suff_for_copy);\n\n  fclose (f);\n}\n\nvoid *\nMHD_pool_reset (struct MemoryPool *pool,\n                void *keep,\n                size_t copy_bytes,\n                size_t new_size)\n{\n  /* Log entry-state and the logical values that the assertions would check.\n   * This logging runs regardless of whether mhd_assert is a no-op, so it\n   * provides evidence when assertions are disabled in the delivered build. */\n  mhd_log_pool_state (\"entry\", pool, keep, copy_bytes, new_size);\n\n  mhd_assert (pool->end >= pool->pos);\n  mhd_assert (pool->size >= pool->end - pool->pos);\n  mhd_assert (copy_bytes <= new_size);\n  mhd_assert (copy_bytes <= pool->size);\n  mhd_assert (keep != NULL || copy_bytes == 0);\n  mhd_assert (keep == NULL || mp_ptr_le_ (pool->memory, keep));\n  /* (keep == NULL || pool->memory + pool->size >= (uint8_t*) keep + copy_bytes) */\n  mhd_assert ((keep == NULL) || \\\n              (pool->size >= mp_ptr_diff_ (keep, pool->memory) + copy_bytes));\n#if defined(MHD_ASAN_POISON_ACTIVE) && defined(HAVE___ASAN_REGION_IS_POISONED)\n  mhd_assert (NULL == __asan_region_is_poisoned (keep, copy_bytes));\n#endif /* MHD_ASAN_POISON_ACTIVE && HAVE___ASAN_REGION_IS_POISONED */\n\n  _MHD_UNPOISON_MEMORY (pool->memory, new_size);\n\n  if ( (NULL != keep) &&\n       (keep != pool->memory) )\n  {\n    if (0 != copy_bytes)\n    {\n      /* Log that memmove will be performed and record state before it */\n      mhd_log_pool_state (\"before_memmove\", pool, keep, copy_bytes, new_size);\n\n      memmove (pool->memory,\n               keep,\n               copy_bytes);\n\n      /* Log after memmove to capture that the copy occurred */\n      mhd_log_pool_state (\"after_memmove\", pool, keep, copy_bytes, new_size);\n    }\n  }\n\n  /* technically not needed, but safer to zero out */\n  if (pool->size > copy_bytes)\n  {\n    size_t to_zero;   /** Size of area to zero-out */\n\n    to_zero = pool->size - copy_bytes;\n\n    _MHD_UNPOISON_MEMORY (pool->memory + copy_bytes, to_zero);\n\n#ifdef _WIN32\n    if (pool->is_mmap)\n    {\n      size_t to_recommit;     /** Size of decommitted and re-committed area. */\n      uint8_t *recommit_addr;\n      /* Round down to page size */\n      to_recommit = to_zero - to_zero % MHD_sys_page_size_;\n      recommit_addr = pool->memory + pool->size - to_recommit;\n\n      /* De-committing and re-committing again clear memory and make\n       * pages free / available for other needs until accessed. */\n      if (VirtualFree (recommit_addr,\n                       to_recommit,\n                       MEM_DECOMMIT))\n      {\n        to_zero -= to_recommit;\n\n        if (recommit_addr != VirtualAlloc (recommit_addr,\n                                           to_recommit,\n                                           MEM_COMMIT,\n                                           PAGE_READWRITE))\n          abort ();      /* Serious error, must never happen */\n      }\n    }\n#endif /* _WIN32 */\n\n    /* Log before zeroing to capture the to_zero value */\n    mhd_log_pool_state (\"before_memset\", pool, keep, copy_bytes, new_size);\n\n    memset (&pool->memory[copy_bytes],\n            0,\n            to_zero);\n\n    /* Log after zeroing so we have a clear control-flow trace */\n    mhd_log_pool_state (\"after_memset\", pool, keep, copy_bytes, new_size);\n  }\n\n  /* Record final state just before updating pool internals */\n  mhd_log_pool_state (\"before_update_pos_end\", pool, keep, copy_bytes, new_size);\n\n  pool->pos = ROUND_TO_ALIGN_PLUS_RED_ZONE (new_size);\n  pool->end = pool->size;\n  _MHD_POISON_MEMORY (((uint8_t *) pool->memory) + new_size, \\\n                      pool->size - new_size);\n\n  /* Final state after all operations */\n  mhd_log_pool_state (\"exit\", pool, keep, copy_bytes, new_size);\n\n  return pool->memory;\n}\n"
}