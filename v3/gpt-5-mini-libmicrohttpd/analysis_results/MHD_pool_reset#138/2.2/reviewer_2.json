{
  "user_message": "An agent A claimed that the following MHD_pool_reset code violates the MISRA C 2023 rule 2.2.\n<misra_rule>\nMISRA C 2023 Rule 2.2 is A project shall not contain dead code.\nAny operation that is executed but whose removal would not affect program behaviour constitutes dead code. Notes:\n1. The behaviour of an embedded sytem is often determined not just by the nature of its actions, but also by the time at which they occur.\n2. unreachable code is not dead code, as it cannot be executed.\n3.Initialization is not the same as an assignment operation and is therfore not a candidate for dead code.\n</misra_rule>\n<target_code>\nHere is the original code of MHD_pool_reset.\n```c\nvoid *\nMHD_pool_reset (struct MemoryPool *pool,\n                void *keep,\n                size_t copy_bytes,\n                size_t new_size)\n{\n  mhd_assert (pool->end >= pool->pos);\n  mhd_assert (pool->size >= pool->end - pool->pos);\n  mhd_assert (copy_bytes <= new_size);\n  mhd_assert (copy_bytes <= pool->size);\n  mhd_assert (keep != NULL || copy_bytes == 0);\n  mhd_assert (keep == NULL || mp_ptr_le_ (pool->memory, keep));\n  /* (keep == NULL || pool->memory + pool->size >= (uint8_t*) keep + copy_bytes) */\n  mhd_assert ((keep == NULL) || \\\n              (pool->size >= mp_ptr_diff_ (keep, pool->memory) + copy_bytes));\n#if defined(MHD_ASAN_POISON_ACTIVE) && defined(HAVE___ASAN_REGION_IS_POISONED)\n  mhd_assert (NULL == __asan_region_is_poisoned (keep, copy_bytes));\n#endif /* MHD_ASAN_POISON_ACTIVE && HAVE___ASAN_REGION_IS_POISONED */\n  _MHD_UNPOISON_MEMORY (pool->memory, new_size);\n  if ( (NULL != keep) &&\n       (keep != pool->memory) )\n  {\n    if (0 != copy_bytes)\n      memmove (pool->memory,\n               keep,\n               copy_bytes);\n  }\n  /* technically not needed, but safer to zero out */\n  if (pool->size > copy_bytes)\n  {\n    size_t to_zero;   /** Size of area to zero-out */\n\n    to_zero = pool->size - copy_bytes;\n    _MHD_UNPOISON_MEMORY (pool->memory + copy_bytes, to_zero);\n#ifdef _WIN32\n    if (pool->is_mmap)\n    {\n      size_t to_recommit;     /** Size of decommitted and re-committed area. */\n      uint8_t *recommit_addr;\n      /* Round down to page size */\n      to_recommit = to_zero - to_zero % MHD_sys_page_size_;\n      recommit_addr = pool->memory + pool->size - to_recommit;\n\n      /* De-committing and re-committing again clear memory and make\n       * pages free / available for other needs until accessed. */\n      if (VirtualFree (recommit_addr,\n                       to_recommit,\n                       MEM_DECOMMIT))\n      {\n        to_zero -= to_recommit;\n\n        if (recommit_addr != VirtualAlloc (recommit_addr,\n                                           to_recommit,\n                                           MEM_COMMIT,\n                                           PAGE_READWRITE))\n          abort ();      /* Serious error, must never happen */\n      }\n    }\n#endif /* _WIN32 */\n    memset (&pool->memory[copy_bytes],\n            0,\n            to_zero);\n  }\n  pool->pos = ROUND_TO_ALIGN_PLUS_RED_ZONE (new_size);\n  pool->end = pool->size;\n  _MHD_POISON_MEMORY (((uint8_t *) pool->memory) + new_size, \\\n                      pool->size - new_size);\n  return pool->memory;\n}\n```\n</target_code>\n<response format>\nProvide your answer with these fields.\n- explanation: your evaluation of the scenario provided by the agent A.\n- is_report_correct: whether the report is correct or not (true/false). True means there is a violation.\n</response format>\n<scenario>\nThe agent A provided the following violation scenario:\nThis assertion is dead code if mhd_assert expands to a no-op in the delivered build (for example, if assertions are always disabled via a macro like NDEBUG so mhd_assert becomes ((void)0)). In that case the expression has no side\u2011effects, is not executed, and removing the call would not change program behaviour \u2014 so Rule 2.2 would be violated. (If, conversely, mhd_assert is implemented to perform a runtime check that can abort or log on failure, then the assertion is not dead because its removal could change behaviour when the condition fails.)\n</scenario>\n\n<instruction>\nJudge whether the report is correct or not.\n</instruction>\n",
  "is_report_correct": false,
  "explanation": "MISRA Rule 2.2 defines dead code as an operation that is executed but whose removal would not affect program behaviour. In the scenario described, mhd_assert is a macro that in the delivered build expands to a no-op (for example ((void)0)). When that happens the assertion produces no emitted code and therefore is not executed at runtime. Because dead code per the Rule is specifically an executed operation that could be removed without changing behaviour, an assertion that is compiled away (i.e. never executed) is not \"dead code\" under the Rule's definition. \n\nTwo practical cases:\n- If mhd_assert is a no-op in the delivered build, there is no executed operation to be considered dead code; removal changes nothing because nothing was executed in the first place. This does not violate Rule 2.2. \n- If mhd_assert expands to actual runtime checking (abort/log), then it is executed and its removal could change behaviour on assertion failure, so it is not dead code either.\n\nThe agent A's argument incorrectly treats a compile-time-elided assertion as dead code. The only potential concern would be if the asserted expressions have side effects (function calls, modifications) that are relied upon in production but are compiled out; that would be a programming error but not an instance of Rule 2.2 as defined (it would be a different defect). \n\nTherefore the report that MHD_pool_reset violates MISRA C:2023 Rule 2.2 is not correct."
}