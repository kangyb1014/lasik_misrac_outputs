{
  "user_message": "<misra_rule>\nMISRA C 2023 Rule 2.2 is: A project shall not contain dead code.\nAny operation that is executed but whose removal would not affect program behaviour constitutes dead code. Notes:\n1. The behaviour of an embedded sytem is often determined not just by the nature of its actions, but also by the time at which they occur.\n2. unreachable code is not dead code, as it cannot be executed.\n3.Initialization is not the same as an assignment operation and is therfore not a candidate for dead code.\n</misra_rule>\n\nAnother agent reported that the target code violated the Rule 2.2.\nHere is the comment from the agent.\n<violation scenario>\nThe array p is zeroed with memset(&p, 0, sizeof(p)) before entries are populated. Therefore the statement p[poll_count].revents = 0; only re-writes a field that is already zero; removing that assignment would not change program behaviour. Consequently the assignment is redundant dead code in this context.\n</violation scenario>\n\nYour job is to insert logging code to capture the control flow and state information of the program.\nInsert logging code so that other agents can reproduce and get evidence for the violation scenario.\n<response format>\n- test_code: a modified MHD_poll_listen_socket code that contains useful probe functions that print useful logs to a file \"/tmp/logs/902.txt\". The logs should contain the control path and state information of the violation scenario. If test code is not required to validate the scenario, you can leave this blank.\nHere are the constraints for the test code:\n- The test code MUST preserve the original logic of MHD_poll_listen_socket as much as possible.\nYou CAN just insert probe functions to the original code.\n- DO NOT introduce new violations to demonstrate your scenario.\n- The test code MUST be compilable and executable.\n- The test code MUST include line breaks.\n- You MUST NOT define the main function.\n- You MUST NOT define macros.\n</response format>\n<target_code>\nHere is the code of MHD_poll_listen_socket:\n```c\nstatic enum MHD_Result\nMHD_poll_listen_socket (struct MHD_Daemon *daemon,\n                        int may_block)\n{\n  struct pollfd p[2];\n  int timeout;\n  unsigned int poll_count;\n  int poll_listen;\n  int poll_itc_idx;\n  MHD_socket ls;\n\n  mhd_assert (MHD_thread_handle_ID_is_valid_ID_ (daemon->tid));\n  mhd_assert (MHD_thread_handle_ID_is_current_thread_ (daemon->tid));\n\n  memset (&p,\n          0,\n          sizeof (p));\n  poll_count = 0;\n  poll_listen = -1;\n  poll_itc_idx = -1;\n  if ( (MHD_INVALID_SOCKET != (ls = daemon->listen_fd)) &&\n       (! daemon->was_quiesced) )\n\n  {\n    p[poll_count].fd = ls;\n    p[poll_count].events = POLLIN;\n    p[poll_count].revents = 0;\n    poll_listen = (int) poll_count;\n    poll_count++;\n  }\n  if (MHD_ITC_IS_VALID_ (daemon->itc))\n  {\n    p[poll_count].fd = MHD_itc_r_fd_ (daemon->itc);\n    p[poll_count].events = POLLIN;\n    p[poll_count].revents = 0;\n    poll_itc_idx = (int) poll_count;\n    poll_count++;\n  }\n\n  if (0 != (daemon->options & MHD_TEST_ALLOW_SUSPEND_RESUME))\n    (void) resume_suspended_connections (daemon);\n\n  if (MHD_NO == may_block)\n    timeout = 0;\n  else\n    timeout = -1;\n  if (0 == poll_count)\n    return MHD_YES;\n  if (MHD_sys_poll_ (p,\n                     poll_count,\n                     timeout) < 0)\n  {\n    const int err = MHD_socket_get_error_ ();\n\n    if (MHD_SCKT_ERR_IS_EINTR_ (err))\n      return MHD_YES;\n#ifdef HAVE_MESSAGES\n    MHD_DLOG (daemon,\n              _ (\"poll failed: %s\\n\"),\n              MHD_socket_strerr_ (err));\n#endif\n    return MHD_NO;\n  }\n  if ( (0 <= poll_itc_idx) &&\n       (0 != (p[poll_itc_idx].revents & POLLIN)) )\n    MHD_itc_clear_ (daemon->itc);\n\n  /* handle shutdown */\n  if (daemon->shutdown)\n    return MHD_NO;\n\n  /* Process externally added connection if any */\n  if (daemon->have_new)\n    new_connections_list_process_ (daemon);\n\n  if ( (0 <= poll_listen) &&\n       (0 != (p[poll_listen].revents & POLLIN)) )\n    (void) MHD_accept_connection (daemon);\n  return MHD_YES;\n}\n```\n</target_code>\nPlease provide the modified MHD_poll_listen_socket code.\n",
  "test_code": "#include <stdio.h>\n#include <stdarg.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <errno.h>\n#include <string.h>\n\n/* Probe logging helper: append log lines to /tmp/logs/902.txt. */\nstatic void\nmhd_probe_log (const char *fmt, ...)\n{\n  va_list ap;\n  FILE *fp;\n\n  /* try to ensure directory exists; ignore errors */\n  (void) mkdir (\"/tmp/logs\", 0777);\n\n  fp = fopen (\"/tmp/logs/902.txt\", \"a\");\n  if (!fp)\n    return;\n  va_start (ap, fmt);\n  vfprintf (fp, fmt, ap);\n  va_end (ap);\n  fprintf (fp, \"\\n\");\n  fclose (fp);\n}\n\nstatic enum MHD_Result\nMHD_poll_listen_socket (struct MHD_Daemon *daemon,\n                        int may_block)\n{\n  struct pollfd p[2];\n  int timeout;\n  unsigned int poll_count;\n  int poll_listen;\n  int poll_itc_idx;\n  MHD_socket ls;\n\n  mhd_assert (MHD_thread_handle_ID_is_valid_ID_ (daemon->tid));\n  mhd_assert (MHD_thread_handle_ID_is_current_thread_ (daemon->tid));\n\n  /* Log entry into function */\n  mhd_probe_log (\"MHD_poll_listen_socket: enter, may_block=%d, daemon=%p\", may_block, (void *) daemon);\n\n  memset (&p,\n          0,\n          sizeof (p));\n  /* After memset all bytes in p should be zero */\n  mhd_probe_log (\"after memset: p[0].fd=%d, p[0].events=%d, p[0].revents=%d, p[1].fd=%d, p[1].events=%d, p[1].revents=%d\",\n                 p[0].fd, p[0].events, p[0].revents,\n                 p[1].fd, p[1].events, p[1].revents);\n\n  poll_count = 0;\n  poll_listen = -1;\n  poll_itc_idx = -1;\n  if ( (MHD_INVALID_SOCKET != (ls = daemon->listen_fd)) &&\n       (! daemon->was_quiesced) )\n\n  {\n    /* Log state before populating entry for listen_fd */\n    mhd_probe_log (\"about to populate listen entry: poll_count=%u, ls=%d, was_quiesced=%d\", poll_count, ls, daemon->was_quiesced);\n\n    p[poll_count].fd = ls;\n    p[poll_count].events = POLLIN;\n\n    /* probe: read previous value then write zero and log both values */\n    mhd_probe_log (\"listen entry before setting revents: index=%u, prev_revents=%d\", poll_count, p[poll_count].revents);\n    p[poll_count].revents = 0;\n    mhd_probe_log (\"listen entry after setting revents: index=%u, new_revents=%d\", poll_count, p[poll_count].revents);\n\n    poll_listen = (int) poll_count;\n    poll_count++;\n\n    mhd_probe_log (\"listen entry populated: poll_listen=%d, poll_count=%u\", poll_listen, poll_count);\n  }\n  if (MHD_ITC_IS_VALID_ (daemon->itc))\n  {\n    /* Log state before populating entry for itc */\n    mhd_probe_log (\"about to populate itc entry: poll_count=%u, itc=%p\", poll_count, (void *) daemon->itc);\n\n    p[poll_count].fd = MHD_itc_r_fd_ (daemon->itc);\n    p[poll_count].events = POLLIN;\n\n    /* probe: read previous value then write zero and log both values */\n    mhd_probe_log (\"itc entry before setting revents: index=%u, prev_revents=%d\", poll_count, p[poll_count].revents);\n    p[poll_count].revents = 0;\n    mhd_probe_log (\"itc entry after setting revents: index=%u, new_revents=%d\", poll_count, p[poll_count].revents);\n\n    poll_itc_idx = (int) poll_count;\n    poll_count++;\n\n    mhd_probe_log (\"itc entry populated: poll_itc_idx=%d, poll_count=%u\", poll_itc_idx, poll_count);\n  }\n\n  if (0 != (daemon->options & MHD_TEST_ALLOW_SUSPEND_RESUME))\n    (void) resume_suspended_connections (daemon);\n\n  if (MHD_NO == may_block)\n    timeout = 0;\n  else\n    timeout = -1;\n  if (0 == poll_count)\n  {\n    mhd_probe_log (\"no fds to poll: poll_count=0, returning MHD_YES\");\n    return MHD_YES;\n  }\n\n  mhd_probe_log (\"calling poll: poll_count=%u, timeout=%d\", poll_count, timeout);\n  if (MHD_sys_poll_ (p,\n                     poll_count,\n                     timeout) < 0)\n  {\n    const int err = MHD_socket_get_error_ ();\n\n    mhd_probe_log (\"poll failed: err=%d\", err);\n    if (MHD_SCKT_ERR_IS_EINTR_ (err))\n    {\n      mhd_probe_log (\"poll interrupted by EINTR, returning MHD_YES\");\n      return MHD_YES;\n    }\n#ifdef HAVE_MESSAGES\n    MHD_DLOG (daemon,\n              _ (\"poll failed: %s\\n\"),\n              MHD_socket_strerr_ (err));\n#endif\n    mhd_probe_log (\"poll failed (non-EINTR), returning MHD_NO\");\n    return MHD_NO;\n  }\n\n  mhd_probe_log (\"poll returned, p[0].revents=%d, p[1].revents=%d\", p[0].revents, p[1].revents);\n  if ( (0 <= poll_itc_idx) &&\n       (0 != (p[poll_itc_idx].revents & POLLIN)) )\n  {\n    mhd_probe_log (\"itc has POLLIN, index=%d\", poll_itc_idx);\n    MHD_itc_clear_ (daemon->itc);\n  }\n\n  /* handle shutdown */\n  if (daemon->shutdown)\n  {\n    mhd_probe_log (\"daemon shutdown requested, returning MHD_NO\");\n    return MHD_NO;\n  }\n\n  /* Process externally added connection if any */\n  if (daemon->have_new)\n  {\n    mhd_probe_log (\"processing new connections list\");\n    new_connections_list_process_ (daemon);\n  }\n\n  if ( (0 <= poll_listen) &&\n       (0 != (p[poll_listen].revents & POLLIN)) )\n  {\n    mhd_probe_log (\"listen fd has POLLIN, accepting connection\");\n    (void) MHD_accept_connection (daemon);\n  }\n  mhd_probe_log (\"MHD_poll_listen_socket: exit, returning MHD_YES\");\n  return MHD_YES;\n}\n"
}