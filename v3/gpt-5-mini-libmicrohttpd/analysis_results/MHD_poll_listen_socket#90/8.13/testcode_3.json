{
  "user_message": "<misra_rule>\nMISRA C 2023 Rule 8.13 is: A pointer should point to a const-qualified type whenever possible.\n\n</misra_rule>\n\nAnother agent reported that the target code violated the Rule 8.13.\nHere is the comment from the agent.\n<violation scenario>\nThe call uses the return value of MHD_socket_strerr_(err) as a read\u2011only format argument. If MHD_socket_strerr_ is declared to return 'char *' (i.e. a non\u2011const pointer) while it actually returns a pointer to an immutable error string (or otherwise is not intended to be modified), that declaration violates MISRA C 2023 Rule 8.13. The correct design is for MHD_socket_strerr_ to return 'const char *' so the pointer points to a const\u2011qualified type.\n</violation scenario>\n\nYour job is to insert logging code to capture the control flow and state information of the program.\nInsert logging code so that other agents can reproduce and get evidence for the violation scenario.\n<response format>\n- test_code: a modified MHD_poll_listen_socket code that contains useful probe functions that print useful logs to a file \"/tmp/logs/903.txt\". The logs should contain the control path and state information of the violation scenario. If test code is not required to validate the scenario, you can leave this blank.\nHere are the constraints for the test code:\n- The test code MUST preserve the original logic of MHD_poll_listen_socket as much as possible.\nYou CAN just insert probe functions to the original code.\n- DO NOT introduce new violations to demonstrate your scenario.\n- The test code MUST be compilable and executable.\n- The test code MUST include line breaks.\n- You MUST NOT define the main function.\n- You MUST NOT define macros.\n</response format>\n<target_code>\nHere is the code of MHD_poll_listen_socket:\n```c\nstatic enum MHD_Result\nMHD_poll_listen_socket (struct MHD_Daemon *daemon,\n                        int may_block)\n{\n  struct pollfd p[2];\n  int timeout;\n  unsigned int poll_count;\n  int poll_listen;\n  int poll_itc_idx;\n  MHD_socket ls;\n\n  mhd_assert (MHD_thread_handle_ID_is_valid_ID_ (daemon->tid));\n  mhd_assert (MHD_thread_handle_ID_is_current_thread_ (daemon->tid));\n\n  memset (&p,\n          0,\n          sizeof (p));\n  poll_count = 0;\n  poll_listen = -1;\n  poll_itc_idx = -1;\n  if ( (MHD_INVALID_SOCKET != (ls = daemon->listen_fd)) &&\n       (! daemon->was_quiesced) )\n\n  {\n    p[poll_count].fd = ls;\n    p[poll_count].events = POLLIN;\n    p[poll_count].revents = 0;\n    poll_listen = (int) poll_count;\n    poll_count++;\n  }\n  if (MHD_ITC_IS_VALID_ (daemon->itc))\n  {\n    p[poll_count].fd = MHD_itc_r_fd_ (daemon->itc);\n    p[poll_count].events = POLLIN;\n    p[poll_count].revents = 0;\n    poll_itc_idx = (int) poll_count;\n    poll_count++;\n  }\n\n  if (0 != (daemon->options & MHD_TEST_ALLOW_SUSPEND_RESUME))\n    (void) resume_suspended_connections (daemon);\n\n  if (MHD_NO == may_block)\n    timeout = 0;\n  else\n    timeout = -1;\n  if (0 == poll_count)\n    return MHD_YES;\n  if (MHD_sys_poll_ (p,\n                     poll_count,\n                     timeout) < 0)\n  {\n    const int err = MHD_socket_get_error_ ();\n\n    if (MHD_SCKT_ERR_IS_EINTR_ (err))\n      return MHD_YES;\n#ifdef HAVE_MESSAGES\n    MHD_DLOG (daemon,\n              _ (\"poll failed: %s\\n\"),\n              MHD_socket_strerr_ (err));\n#endif\n    return MHD_NO;\n  }\n  if ( (0 <= poll_itc_idx) &&\n       (0 != (p[poll_itc_idx].revents & POLLIN)) )\n    MHD_itc_clear_ (daemon->itc);\n\n  /* handle shutdown */\n  if (daemon->shutdown)\n    return MHD_NO;\n\n  /* Process externally added connection if any */\n  if (daemon->have_new)\n    new_connections_list_process_ (daemon);\n\n  if ( (0 <= poll_listen) &&\n       (0 != (p[poll_listen].revents & POLLIN)) )\n    (void) MHD_accept_connection (daemon);\n  return MHD_YES;\n}\n```\n</target_code>\nPlease provide the modified MHD_poll_listen_socket code.\n",
  "test_code": "#include <stdio.h>\n#include <stdarg.h>\n#include <string.h>\n#include <sys/stat.h>\n#include <errno.h>\n#include <time.h>\n#include <stdint.h>\n\n/* Probe helpers: write runtime traces to /tmp/logs/903.txt. */\nstatic void\nMHD_probe_ensure_logdir (void)\n{\n  /* Try to create directory; ignore errors if it already exists. */\n  (void) mkdir (\"/tmp/logs\", S_IRWXU);\n}\n\nstatic void\nMHD_probe_log (const char *fmt, ...)\n{\n  FILE *f;\n  va_list ap;\n  MHD_probe_ensure_logdir ();\n  f = fopen (\"/tmp/logs/903.txt\", \"a\");\n  if (NULL == f)\n    return;\n  {\n    time_t t = time (NULL);\n    struct tm tm_buf;\n    (void) localtime_r (&t, &tm_buf);\n    char timestr[32];\n    (void) strftime (timestr, sizeof (timestr), \"%Y-%m-%d %H:%M:%S\", &tm_buf);\n    fprintf (f, \"%s \", timestr);\n  }\n  va_start (ap, fmt);\n  vfprintf (f, fmt, ap);\n  va_end (ap);\n  fputs (\"\\n\", f);\n  (void) fclose (f);\n}\n\n/* Forward declarations for external functions used in this file.  These\n   are not definitions, only references so the probe calls can compile\n   and link in the normal build environment where these functions exist. */\nextern int MHD_thread_handle_ID_is_valid_ID_ (int);\nextern int MHD_thread_handle_ID_is_current_thread_ (int);\nextern void mhd_assert (int);\nextern int MHD_sys_poll_ (struct pollfd *, unsigned int, int);\nextern int MHD_socket_get_error_ (void);\nextern int MHD_SCKT_ERR_IS_EINTR_ (int);\nextern char *MHD_socket_strerr_ (int);\nextern void MHD_DLOG (struct MHD_Daemon *, const char *, ...);\nextern void resume_suspended_connections (struct MHD_Daemon *);\nextern int MHD_ITC_IS_VALID_ (void *);\nextern int MHD_itc_r_fd_ (void *);\nextern void MHD_itc_clear_ (void *);\nextern void new_connections_list_process_ (struct MHD_Daemon *);\nextern int MHD_accept_connection (struct MHD_Daemon *);\n\n/* Keep original function signature and logic; only add logging probes. */\nstatic enum MHD_Result\nMHD_poll_listen_socket (struct MHD_Daemon *daemon,\n                        int may_block)\n{\n  struct pollfd p[2];\n  int timeout;\n  unsigned int poll_count;\n  int poll_listen;\n  int poll_itc_idx;\n  MHD_socket ls;\n\n  mhd_assert (MHD_thread_handle_ID_is_valid_ID_ (daemon->tid));\n  mhd_assert (MHD_thread_handle_ID_is_current_thread_ (daemon->tid));\n\n  MHD_probe_log (\"enter MHD_poll_listen_socket: daemon=%p may_block=%d tid=%d\", (void *) daemon, may_block, daemon->tid);\n\n  memset (&p,\n          0,\n          sizeof (p));\n  poll_count = 0;\n  poll_listen = -1;\n  poll_itc_idx = -1;\n  if ( (MHD_INVALID_SOCKET != (ls = daemon->listen_fd)) &&\n       (! daemon->was_quiesced) )\n\n  {\n    p[poll_count].fd = ls;\n    p[poll_count].events = POLLIN;\n    p[poll_count].revents = 0;\n    poll_listen = (int) poll_count;\n    MHD_probe_log (\"listen socket added: index=%u fd=%ld\", (unsigned) poll_count, (long) ls);\n    poll_count++;\n  }\n  if (MHD_ITC_IS_VALID_ (daemon->itc))\n  {\n    p[poll_count].fd = MHD_itc_r_fd_ (daemon->itc);\n    p[poll_count].events = POLLIN;\n    p[poll_count].revents = 0;\n    poll_itc_idx = (int) poll_count;\n    MHD_probe_log (\"itc fd added: index=%u fd=%d\", (unsigned) poll_count, p[poll_count].fd);\n    poll_count++;\n  }\n\n  if (0 != (daemon->options & MHD_TEST_ALLOW_SUSPEND_RESUME))\n    (void) resume_suspended_connections (daemon);\n\n  if (MHD_NO == may_block)\n    timeout = 0;\n  else\n    timeout = -1;\n\n  MHD_probe_log (\"poll_count=%u poll_listen=%d poll_itc_idx=%d timeout=%d\", poll_count, poll_listen, poll_itc_idx, timeout);\n\n  if (0 == poll_count)\n  {\n    MHD_probe_log (\"no fds to poll, returning MHD_YES\");\n    return MHD_YES;\n  }\n  if (MHD_sys_poll_ (p,\n                     poll_count,\n                     timeout) < 0)\n  {\n    const int err = MHD_socket_get_error_ ();\n\n    MHD_probe_log (\"poll failed: sys_poll returned <0, socket error=%d\", err);\n\n    if (MHD_SCKT_ERR_IS_EINTR_ (err))\n    {\n      MHD_probe_log (\"poll interrupted by EINTR, returning MHD_YES\");\n      return MHD_YES;\n    }\n#ifdef HAVE_MESSAGES\n    {\n      /* Probe: capture the raw pointer returned by MHD_socket_strerr_ and its content.\n         Cast to const char * for safe read-only access when logging. This does not\n         change the original function declaration or behaviour. */\n      char *raw_msg = MHD_socket_strerr_ (err);\n      const char *msg = (const char *) raw_msg;\n      MHD_probe_log (\"MHD_socket_strerr_ returned ptr=%p\", (void *) raw_msg);\n      if (msg != NULL)\n      {\n        /* Log the error string content in a safe read-only manner. */\n        MHD_probe_log (\"MHD_socket_strerr_ content='%s'\", msg);\n      }\n      else\n      {\n        MHD_probe_log (\"MHD_socket_strerr_ returned NULL\");\n      }\n      MHD_DLOG (daemon,\n                _ (\"poll failed: %s\\n\"),\n                raw_msg);\n    }\n#endif\n    MHD_probe_log (\"poll failed: returning MHD_NO\");\n    return MHD_NO;\n  }\n\n  if ( (0 <= poll_itc_idx) &&\n       (0 != (p[poll_itc_idx].revents & POLLIN)) )\n  {\n    MHD_probe_log (\"itc has POLLIN, clearing itc (index=%d)\", poll_itc_idx);\n    MHD_itc_clear_ (daemon->itc);\n  }\n\n  /* handle shutdown */\n  if (daemon->shutdown)\n  {\n    MHD_probe_log (\"daemon shutdown flag set, returning MHD_NO\");\n    return MHD_NO;\n  }\n\n  /* Process externally added connection if any */\n  if (daemon->have_new)\n  {\n    MHD_probe_log (\"daemon has_new is true, processing new connections\");\n    new_connections_list_process_ (daemon);\n  }\n\n  if ( (0 <= poll_listen) &&\n       (0 != (p[poll_listen].revents & POLLIN)) )\n  {\n    MHD_probe_log (\"listen fd has POLLIN, accepting connection\");\n    (void) MHD_accept_connection (daemon);\n  }\n  MHD_probe_log (\"exiting MHD_poll_listen_socket returning MHD_YES\");\n  return MHD_YES;\n}\n"
}