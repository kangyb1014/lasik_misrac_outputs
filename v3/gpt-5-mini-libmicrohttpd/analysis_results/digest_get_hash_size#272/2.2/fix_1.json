{
  "user_message": "<target code>Here is the code that failed to compile:\n```c\n#include <stdio.h>\n\n/* Probe helper: append a line to /tmp/logs/2722.txt with simple state info. */\nstatic void\nmhd_probe_log (const char *label, unsigned int algo3, size_t v1, size_t v2)\n{\n  FILE *f = fopen(\"/tmp/logs/2722.txt\", \"a\");\n  if (f)\n    {\n      /* Keep format simple and avoid heavy formatting to reduce risk of new issues. */\n      fprintf (f, \"%s: algo3=0x%X, v1=%zu, v2=%zu\\n\", label, (unsigned int) algo3, v1, v2);\n      fclose (f);\n    }\n}\n\n_MHD_static_inline size_t\ndigest_get_hash_size (enum MHD_DigestAuthAlgo3 algo3)\n{\n  /* Log entry with the raw algo3 value */\n  mhd_probe_log (\"ENTER\", (unsigned int) algo3, 0, 0);\n\n#ifdef MHD_MD5_SUPPORT\n  /* Log the values involved in the MD5 size assertion */\n  mhd_probe_log (\"ASSERT_MD5_EQ_CHECK\", (unsigned int) algo3,\n                 (size_t) MHD_MD5_DIGEST_SIZE, (size_t) MD5_DIGEST_SIZE);\n  mhd_assert (MHD_MD5_DIGEST_SIZE == MD5_DIGEST_SIZE);\n#endif /* MHD_MD5_SUPPORT */\n#ifdef MHD_SHA256_SUPPORT\n  /* Log the values involved in the SHA256 size assertion */\n  mhd_probe_log (\"ASSERT_SHA256_EQ_CHECK\", (unsigned int) algo3,\n                 (size_t) MHD_SHA256_DIGEST_SIZE, (size_t) SHA256_DIGEST_SIZE);\n  mhd_assert (MHD_SHA256_DIGEST_SIZE == SHA256_DIGEST_SIZE);\n#endif /* MHD_SHA256_SUPPORT */\n#ifdef MHD_SHA512_256_SUPPORT\n  /* Log the values involved in the SHA512/256 size assertion */\n  mhd_probe_log (\"ASSERT_SHA512_256_EQ_CHECK\", (unsigned int) algo3,\n                 (size_t) MHD_SHA512_256_DIGEST_SIZE, (size_t) SHA512_256_DIGEST_SIZE);\n  mhd_assert (MHD_SHA512_256_DIGEST_SIZE == SHA512_256_DIGEST_SIZE);\n#ifdef MHD_SHA256_SUPPORT\n  /* This is the specific comparison noted in the violation scenario: two compile-time\n     macros are compared. Log their values immediately before the assert so that\n     a run with both supports enabled records the constant values and the fact that\n     this check was executed at runtime. */\n  mhd_probe_log (\"ASSERT_SHA256_EQ_SHA512_256_CHECK\", (unsigned int) algo3,\n                 (size_t) SHA256_DIGEST_SIZE, (size_t) SHA512_256_DIGEST_SIZE);\n  mhd_assert (SHA256_DIGEST_SIZE == SHA512_256_DIGEST_SIZE);\n#endif /* MHD_SHA256_SUPPORT */\n#endif /* MHD_SHA512_256_SUPPORT */\n  /* Only one algorithm must be specified */\n  mhd_assert (1 == \\\n              (((0 != (algo3 & MHD_DIGEST_BASE_ALGO_MD5)) ? 1 : 0)   \\\n               + ((0 != (algo3 & MHD_DIGEST_BASE_ALGO_SHA256)) ? 1 : 0)   \\\n               + ((0 != (algo3 & MHD_DIGEST_BASE_ALGO_SHA512_256)) ? 1 : 0)));\n\n  /* Log the post-assert entry (algorithm bits) */\n  mhd_probe_log (\"POST_ASSERT_ALGO_BITS\", (unsigned int) algo3, 0, 0);\n\n#ifdef MHD_MD5_SUPPORT\n  if (0 != (((unsigned int) algo3)\n            & ((unsigned int) MHD_DIGEST_BASE_ALGO_MD5)))\n    {\n      mhd_probe_log (\"RETURN_MD5\", (unsigned int) algo3, (size_t) MHD_MD5_DIGEST_SIZE, 0);\n      return MHD_MD5_DIGEST_SIZE;\n    }\n  else\n#endif /* MHD_MD5_SUPPORT */\n#if defined(MHD_SHA256_SUPPORT) && defined(MHD_SHA512_256_SUPPORT)\n  if (0 != (((unsigned int) algo3)\n            & ( ((unsigned int) MHD_DIGEST_BASE_ALGO_SHA256)\n                | ((unsigned int) MHD_DIGEST_BASE_ALGO_SHA512_256))))\n    {\n      /* The same as SHA512_256_DIGEST_SIZE */\n      mhd_probe_log (\"RETURN_SHA256_OR_SHA512_256\", (unsigned int) algo3,\n                     (size_t) MHD_SHA256_DIGEST_SIZE, (size_t) MHD_SHA512_256_DIGEST_SIZE);\n      return MHD_SHA256_DIGEST_SIZE; /* The same as SHA512_256_DIGEST_SIZE */\n    }\n  else\n#elif defined(MHD_SHA256_SUPPORT)\n  if (0 != (((unsigned int) algo3)\n            & ((unsigned int) MHD_DIGEST_BASE_ALGO_SHA256)))\n    {\n      mhd_probe_log (\"RETURN_SHA256\", (unsigned int) algo3, (size_t) MHD_SHA256_DIGEST_SIZE, 0);\n      return MHD_SHA256_DIGEST_SIZE;\n    }\n  else\n#elif defined(MHD_SHA512_256_SUPPORT)\n  if (0 != (((unsigned int) algo3)\n            & ((unsigned int) MHD_DIGEST_BASE_ALGO_SHA512_256)))\n    {\n      mhd_probe_log (\"RETURN_SHA512_256\", (unsigned int) algo3, (size_t) MHD_SHA512_256_DIGEST_SIZE, 0);\n      return MHD_SHA512_256_DIGEST_SIZE;\n    }\n  else\n#endif /* MHD_SHA512_256_SUPPORT */\n    (void) 0; /* Unsupported algorithm */\n\n  mhd_probe_log (\"RETURN_0\", (unsigned int) algo3, 0, 0);\n  return 0; /* Wrong input or unsupported algorithm */\n}\n\n```\n</target code>\n<build error>\nThe build failed with the following error:\n```\nFailed to parse the test code.\n```\n</build error>\n<response format>\nProvide your answer with these answers.\n- fixed_test_code: the fixed test code that compiles successfully.\n- explanation: a brief explanation of the changes you made to fix the code.\nHere are the constraints for the test code:\n- The test code MUST be compilable and executable.\n- The test code MUST include line breaks.\n- The test code MUST preserve the original logic of digest_get_hash_size as much as possible.\n- You MUST not define the main function.\n- You MUST not define macros.\n- The test code MUST not contain any mock functions.\n</response format>\n<instruction>\nPlease fix the code so that it compiles successfully.\n</instruction>\n",
  "fixed_test_code": "#include <stdio.h>\n#include <stdlib.h>\n#include <stddef.h>\n#include <stdint.h>\n\n/* Probe helper: append a line to /tmp/logs/2722.txt with simple state info. */\nstatic void\nmhd_probe_log (const char *label, unsigned int algo3, size_t v1, size_t v2)\n{\n  FILE *f = fopen(\"/tmp/logs/2722.txt\", \"a\");\n  if (f)\n    {\n      /* Keep format simple and avoid heavy formatting to reduce risk of new issues. */\n      fprintf (f, \"%s: algo3=0x%X, v1=%zu, v2=%zu\\n\", label, (unsigned int) algo3, v1, v2);\n      fclose (f);\n    }\n}\n\n/* Simple assert implementation (was mhd_assert macro/function in original). */\nstatic void\nmhd_assert (int cond)\n{\n  if (!cond)\n    {\n      fprintf (stderr, \"mhd_assert failed\\n\");\n      abort ();\n    }\n}\n\n/* Define the digest algorithm bit flags and digest sizes as constants.\n   These replace the original macro-based configuration so the test code\n   is self-contained and compiles. */\nenum MHD_DigestAuthAlgo3\n  {\n    MHD_DIGEST_BASE_ALGO_MD5 = (1u << 0),\n    MHD_DIGEST_BASE_ALGO_SHA256 = (1u << 1),\n    MHD_DIGEST_BASE_ALGO_SHA512_256 = (1u << 2)\n  };\n\nstatic const size_t MHD_MD5_DIGEST_SIZE = 16;\nstatic const size_t MD5_DIGEST_SIZE = 16;\nstatic const size_t MHD_SHA256_DIGEST_SIZE = 32;\nstatic const size_t SHA256_DIGEST_SIZE = 32;\nstatic const size_t MHD_SHA512_256_DIGEST_SIZE = 32; /* SHA-512/256 is 32 bytes */\nstatic const size_t SHA512_256_DIGEST_SIZE = 32;\n\nstatic inline size_t\ndigest_get_hash_size (enum MHD_DigestAuthAlgo3 algo3)\n{\n  /* Log entry with the raw algo3 value */\n  mhd_probe_log (\"ENTER\", (unsigned int) algo3, 0, 0);\n\n  /* If the implementation compiled with all supports, these checks would\n     verify that the MHD_* sizes match the underlying library sizes. Here\n     we still perform the checks to preserve original logic. */\n  mhd_probe_log (\"ASSERT_MD5_EQ_CHECK\", (unsigned int) algo3,\n                 (size_t) MHD_MD5_DIGEST_SIZE, (size_t) MD5_DIGEST_SIZE);\n  mhd_assert (MHD_MD5_DIGEST_SIZE == MD5_DIGEST_SIZE);\n\n  mhd_probe_log (\"ASSERT_SHA256_EQ_CHECK\", (unsigned int) algo3,\n                 (size_t) MHD_SHA256_DIGEST_SIZE, (size_t) SHA256_DIGEST_SIZE);\n  mhd_assert (MHD_SHA256_DIGEST_SIZE == SHA256_DIGEST_SIZE);\n\n  mhd_probe_log (\"ASSERT_SHA512_256_EQ_CHECK\", (unsigned int) algo3,\n                 (size_t) MHD_SHA512_256_DIGEST_SIZE, (size_t) SHA512_256_DIGEST_SIZE);\n  mhd_assert (MHD_SHA512_256_DIGEST_SIZE == SHA512_256_DIGEST_SIZE);\n\n  /* Additional check that SHA256 and SHA512/256 digest sizes match (they do: 32) */\n  mhd_probe_log (\"ASSERT_SHA256_EQ_SHA512_256_CHECK\", (unsigned int) algo3,\n                 (size_t) SHA256_DIGEST_SIZE, (size_t) SHA512_256_DIGEST_SIZE);\n  mhd_assert (SHA256_DIGEST_SIZE == SHA512_256_DIGEST_SIZE);\n\n  /* Only one algorithm must be specified */\n  mhd_assert (1 == (((0 != (algo3 & MHD_DIGEST_BASE_ALGO_MD5)) ? 1 : 0)\n                    + ((0 != (algo3 & MHD_DIGEST_BASE_ALGO_SHA256)) ? 1 : 0)\n                    + ((0 != (algo3 & MHD_DIGEST_BASE_ALGO_SHA512_256)) ? 1 : 0)));\n\n  /* Log the post-assert entry (algorithm bits) */\n  mhd_probe_log (\"POST_ASSERT_ALGO_BITS\", (unsigned int) algo3, 0, 0);\n\n  if (0 != (((unsigned int) algo3) & ((unsigned int) MHD_DIGEST_BASE_ALGO_MD5)))\n    {\n      mhd_probe_log (\"RETURN_MD5\", (unsigned int) algo3, (size_t) MHD_MD5_DIGEST_SIZE, 0);\n      return MHD_MD5_DIGEST_SIZE;\n    }\n\n  if (0 != (((unsigned int) algo3) & ((unsigned int) MHD_DIGEST_BASE_ALGO_SHA256)))\n    {\n      mhd_probe_log (\"RETURN_SHA256\", (unsigned int) algo3, (size_t) MHD_SHA256_DIGEST_SIZE, 0);\n      return MHD_SHA256_DIGEST_SIZE;\n    }\n\n  if (0 != (((unsigned int) algo3) & ((unsigned int) MHD_DIGEST_BASE_ALGO_SHA512_256)))\n    {\n      mhd_probe_log (\"RETURN_SHA512_256\", (unsigned int) algo3, (size_t) MHD_SHA512_256_DIGEST_SIZE, 0);\n      return MHD_SHA512_256_DIGEST_SIZE;\n    }\n\n  mhd_probe_log (\"RETURN_0\", (unsigned int) algo3, 0, 0);\n  return 0; /* Wrong input or unsupported algorithm */\n}\n",
  "explanation": "Problems fixed:\n- Replaced the unknown `_MHD_static_inline` token with standard `static inline` so the function declaration parses.\n- Provided concrete definitions for the digest algorithm flags (enum MHD_DigestAuthAlgo3) and the various digest-size constants as const variables instead of macros so the code is self-contained and compiles.\n- Implemented a small mhd_assert function to replace the missing assert macro/definition.\n- Kept the mhd_probe_log helper and preserved the original branching, assertions and logging behavior as closely as possible.\n\nNo macros or main function were added; all changes are simple definitions and function implementations to make the compilation succeed while preserving the original logic."
}