{
  "user_message": "An agent A claimed that the following setup_epoll_to_listen code violates the MISRA C 2023 rule 8.13.\n<misra_rule>\nMISRA C 2023 Rule 8.13 is A pointer should point to a const-qualified type whenever possible.\n\n</misra_rule>\n<target_code>\nHere is the original code of setup_epoll_to_listen.\n```c\nstatic enum MHD_Result\nsetup_epoll_to_listen (struct MHD_Daemon *daemon)\n{\n  struct epoll_event event;\n  MHD_socket ls;\n\n  mhd_assert (MHD_D_IS_USING_EPOLL_ (daemon));\n  mhd_assert (0 == (daemon->options & MHD_USE_THREAD_PER_CONNECTION));\n  mhd_assert ( (! MHD_D_IS_USING_THREADS_ (daemon)) || \\\n               (MHD_INVALID_SOCKET != (ls = daemon->listen_fd)) || \\\n               MHD_ITC_IS_VALID_ (daemon->itc) );\n  daemon->epoll_fd = setup_epoll_fd (daemon);\n  if (! MHD_D_IS_USING_THREADS_ (daemon)\n      && (0 != (daemon->options & MHD_USE_AUTO)))\n  {\n    /* Application requested \"MHD_USE_AUTO\", probably MHD_get_fdset() will be\n       used.\n       Make sure that epoll FD is suitable for fd_set.\n       Actually, MHD_get_fdset() is allowed for MHD_USE_EPOLL direct,\n       but most probably direct requirement for MHD_USE_EPOLL means that\n       epoll FD will be used directly. This logic is fuzzy, but better\n       than nothing with current MHD API. */\n    if (! MHD_D_DOES_SCKT_FIT_FDSET_ (daemon->epoll_fd, daemon))\n    {\n#ifdef HAVE_MESSAGES\n      MHD_DLOG (daemon,\n                _ (\"The epoll FD is too large to be used with fd_set.\\n\"));\n#endif /* HAVE_MESSAGES */\n      return MHD_NO;\n    }\n  }\n  if (-1 == daemon->epoll_fd)\n    return MHD_NO;\n#if defined(HTTPS_SUPPORT) && defined(UPGRADE_SUPPORT)\n  if (0 != (MHD_ALLOW_UPGRADE & daemon->options))\n  {\n    daemon->epoll_upgrade_fd = setup_epoll_fd (daemon);\n    if (MHD_INVALID_SOCKET == daemon->epoll_upgrade_fd)\n      return MHD_NO;\n  }\n#endif /* HTTPS_SUPPORT && UPGRADE_SUPPORT */\n  if ( (MHD_INVALID_SOCKET != (ls = daemon->listen_fd)) &&\n       (! daemon->was_quiesced) )\n  {\n    event.events = EPOLLIN | EPOLLRDHUP;\n    event.data.ptr = daemon;\n    if (0 != epoll_ctl (daemon->epoll_fd,\n                        EPOLL_CTL_ADD,\n                        ls,\n                        &event))\n    {\n#ifdef HAVE_MESSAGES\n      MHD_DLOG (daemon,\n                _ (\"Call to epoll_ctl failed: %s\\n\"),\n                MHD_socket_last_strerr_ ());\n#endif\n      return MHD_NO;\n    }\n    daemon->listen_socket_in_epoll = true;\n  }\n\n  if (MHD_ITC_IS_VALID_ (daemon->itc))\n  {\n    event.events = EPOLLIN | EPOLLRDHUP;\n    event.data.ptr = _MHD_DROP_CONST (epoll_itc_marker);\n    if (0 != epoll_ctl (daemon->epoll_fd,\n                        EPOLL_CTL_ADD,\n                        MHD_itc_r_fd_ (daemon->itc),\n                        &event))\n    {\n#ifdef HAVE_MESSAGES\n      MHD_DLOG (daemon,\n                _ (\"Call to epoll_ctl failed: %s\\n\"),\n                MHD_socket_last_strerr_ ());\n#endif\n      return MHD_NO;\n    }\n  }\n  return MHD_YES;\n}\n```\n</target_code>\n<response format>\nProvide your answer with these fields.\n- explanation: your evaluation of the scenario provided by the agent A.\n- is_report_correct: whether the report is correct or not (true/false). True means there is a violation.\n</response format>\n<scenario>\nThe agent A provided the following violation scenario:\nThe code assigns the daemon pointer (type: struct MHD_Daemon *) to event.data.ptr (type: void *). Rule 8.13 expects pointers to point to a const-qualified type when possible. Here the stored pointer is not const-qualified even though the daemon object is only used as a read-only marker in the epoll data; the epoll_event API exposes a non-const void * which forces storing a non-const pointer and thus violates the intent of 8.13 (unless an explicit, justified deviation is documented).\n</scenario>\n\n<execution_log>\nThe agent A also provided the following output log:\n[mhd_epoll_probe] stage=before_assign_listen_marker\n  daemon=0x55cfab072a40\n  epoll_fd=4\n  listen_fd=3\n  daemon->options=0x209\n  event.data.ptr=(nil)\n----------------------------------------------------\n[mhd_epoll_probe] stage=after_assign_listen_marker\n  daemon=0x55cfab072a40\n  epoll_fd=4\n  listen_fd=3\n  daemon->options=0x209\n  event.data.ptr=0x55cfab072a40\n----------------------------------------------------\n[mhd_epoll_probe] stage=before_assign_listen_marker\n  daemon=0x55cfab073060\n  epoll_fd=4\n  listen_fd=3\n  daemon->options=0x209\n  event.data.ptr=(nil)\n----------------------------------------------------\n[mhd_epoll_probe] stage=after_assign_listen_marker\n  daemon=0x55cfab073060\n  epoll_fd=4\n  listen_fd=3\n  daemon->options=0x209\n  event.data.ptr=0x55cfab073060\n----------------------------------------------------\n[mhd_epoll_probe] stage=before_assign_listen_marker\n  daemon=0x55cfab073308\n  epoll_fd=5\n  listen_fd=3\n  daemon->options=0x209\n  event.data.ptr=(nil)\n----------------------------------------------------\n[mhd_epoll_probe] stage=after_assign_listen_marker\n  daemon=0x55cfab073308\n  epoll_fd=5\n  listen_fd=3\n  daemon->options=0x209\n  event.data.ptr=0x55cfab073308\n----------------------------------------------------\n[mhd_epoll_probe] stage=before_assign_listen_marker\n  daemon=0x559f067f3600\n  epoll_fd=5\n  listen_fd=4\n  daemon->options=0x1a601\n  event.data.ptr=(nil)\n----------------------------------------------------\n[mhd_epoll_probe] stage=after_assign_listen_marker\n  daemon=0x559f067f3600\n  epoll_fd=5\n  listen_fd=4\n  daemon->options=0x1a601\n  event.data.ptr=0x559f067f3600\n----------------------------------------------------\n[mhd_epoll_probe] stage=before_assign_itc_marker\n  daemon=0x559f067f3600\n  epoll_fd=5\n  listen_fd=4\n  daemon->options=0x1a601\n  event.data.ptr=0x7fef32649b24\n----------------------------------------------------\n[mhd_epoll_probe] stage=after_assign_itc_marker\n  daemon=0x559f067f3600\n  epoll_fd=5\n  listen_fd=4\n  daemon->options=0x1a601\n  event.data.ptr=0x7fef32649b24\n----------------------------------------------------\n[mhd_epoll_probe] stage=before_assign_listen_marker\n  daemon=0x559f067f3e10\n  epoll_fd=5\n  listen_fd=4\n  daemon->options=0xa601\n  event.data.ptr=(nil)\n----------------------------------------------------\n[mhd_epoll_probe] stage=after_assign_listen_marker\n  daemon=0x559f067f3e10\n  epoll_fd=5\n  listen_fd=4\n  daemon->options=0xa601\n  event.data.ptr=0x559f067f3e10\n----------------------------------------------------\n[mhd_epoll_probe] stage=before_assign_itc_marker\n  daemon=0x559f067f3e10\n  epoll_fd=5\n  listen_fd=4\n  daemon->options=0xa601\n  event.data.ptr=0x7fef32649b24\n----------------------------------------------------\n[mhd_epoll_probe] stage=after_assign_itc_marker\n  daemon=0x559f067f3e10\n  epoll_fd=5\n  listen_fd=4\n  daemon->options=0xa601\n  event.data.ptr=0x7fef32649b24\n----------------------------------------------------\n[mhd_epoll_probe] stage=before_assign_listen_marker\n  daemon=0x559f067ec420\n  epoll_fd=5\n  listen_fd=4\n  daemon->options=0x1a609\n  event.data.ptr=(nil)\n----------------------------------------------------\n[mhd_epoll_probe] stage=after_assign_listen_marker\n  daemon=0x559f067ec420\n  epoll_fd=5\n  listen_fd=4\n  daemon->options=0x1a609\n  event.data.ptr=0x559f067ec420\n----------------------------------------------------\n[mhd_epoll_probe] stage=before_assign_itc_marker\n  daemon=0x559f067ec420\n  epoll_fd=5\n  listen_fd=4\n  daemon->options=0x1a609\n  event.data.ptr=0x7fef32649b24\n----------------------------------------------------\n[mhd_epoll_probe] stage=after_assign_itc_marker\n  daemon=0x559f067ec420\n  epoll_fd=5\n  listen_fd=4\n  daemon->options=0x1a609\n  event.data.ptr=0x7fef32649b24\n----------------------------------------------------\n[mhd_epoll_probe] stage=before_assign_listen_marker\n  daemon=0x559f067ec860\n  epoll_fd=5\n  listen_fd=3\n  daemon->options=0x1a609\n  event.data.ptr=(nil)\n----------------------------------------------------\n[mhd_epoll_probe] stage=after_assign_listen_marker\n  daemon=0x559f067ec860\n  epoll_fd=5\n  listen_fd=3\n  daemon->options=0x1a609\n  event.\n</execution_log>\n\n<instruction>\nJudge whether the report is correct or not.\n</instruction>\n",
  "is_report_correct": false,
  "explanation": "The report is not correct. MISRA C 2023 Rule 8.13 concerns the declaration of pointer types: a pointer type should be const\u2011qualified where that is possible. In this code the value assigned to epoll_event.data.ptr is a struct MHD_Daemon * (a non\u2011const pointer) and epoll_event.data.ptr itself is prescribed by the system epoll API as void * (non\u2011const) in a system header. There is no implicit loss of const qualification here (the daemon pointer is not declared const), and you cannot change the type of the kernel API field. Therefore there is no violation of 8.13 in the shown assignment. (Note: the code does use a _MHD_DROP_CONST macro to cast away const for another marker; casting away const may be relevant to other MISRA rules and should be justified or documented as a deviation, but that is a different issue than rule 8.13.)"
}