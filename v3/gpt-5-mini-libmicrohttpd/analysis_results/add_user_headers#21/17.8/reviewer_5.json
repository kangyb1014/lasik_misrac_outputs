{
  "user_message": "An agent A claimed that the following add_user_headers code violates the MISRA C 2023 rule 17.8.\n<misra_rule>\nMISRA C 2023 Rule 17.8 is A function parameter should not be modified.\nNote that the object referred to by a pointer parameter may be modified, but the pointer itself shall not be modified.\n</misra_rule>\n<target_code>\nHere is the original code of add_user_headers.\n```c\nstatic bool\nadd_user_headers (char *buf,\n                  size_t *ppos,\n                  size_t buf_size,\n                  struct MHD_Response *response,\n                  bool filter_transf_enc,\n                  bool filter_content_len,\n                  bool add_close,\n                  bool add_keep_alive)\n{\n  struct MHD_Response *const r = response; /**< a short alias */\n  struct MHD_HTTP_Res_Header *hdr; /**< Iterates through User-specified headers */\n  size_t el_size; /**< the size of current element to be added to the @a buf */\n\n  mhd_assert (! add_close || ! add_keep_alive);\n\n  if (0 == (r->flags_auto & MHD_RAF_HAS_TRANS_ENC_CHUNKED))\n    filter_transf_enc = false;   /* No such header */\n  if (0 == (r->flags_auto & MHD_RAF_HAS_CONTENT_LENGTH))\n    filter_content_len = false;  /* No such header */\n  if (0 == (r->flags_auto & MHD_RAF_HAS_CONNECTION_HDR))\n  {\n    add_close = false;          /* No such header */\n    add_keep_alive = false;     /* No such header */\n  }\n  else if (0 != (r->flags_auto & MHD_RAF_HAS_CONNECTION_CLOSE))\n    add_close = false;          /* \"close\" token was already set */\n\n  for (hdr = r->first_header; NULL != hdr; hdr = hdr->next)\n  {\n    size_t initial_pos = *ppos;\n    if (MHD_HEADER_KIND != hdr->kind)\n      continue;\n    if (filter_transf_enc)\n    { /* Need to filter-out \"Transfer-Encoding\" */\n      if ((MHD_STATICSTR_LEN_ (MHD_HTTP_HEADER_TRANSFER_ENCODING) ==\n           hdr->header_size) &&\n          (MHD_str_equal_caseless_bin_n_ (MHD_HTTP_HEADER_TRANSFER_ENCODING,\n                                          hdr->header, hdr->header_size)) )\n      {\n        filter_transf_enc = false; /* There is the only one such header */\n        continue; /* Skip \"Transfer-Encoding\" header */\n      }\n    }\n    if (filter_content_len)\n    { /* Need to filter-out \"Content-Length\" */\n      if ((MHD_STATICSTR_LEN_ (MHD_HTTP_HEADER_CONTENT_LENGTH) ==\n           hdr->header_size) &&\n          (MHD_str_equal_caseless_bin_n_ (MHD_HTTP_HEADER_CONTENT_LENGTH,\n                                          hdr->header, hdr->header_size)) )\n      {\n        /* Reset filter flag if only one header is allowed */\n        filter_transf_enc =\n          (0 == (r->flags & MHD_RF_INSANITY_HEADER_CONTENT_LENGTH));\n        continue; /* Skip \"Content-Length\" header */\n      }\n    }\n\n    /* Add user header */\n    el_size = hdr->header_size + 2 + hdr->value_size + 2;\n    if (buf_size < *ppos + el_size)\n      return false;\n    memcpy (buf + *ppos, hdr->header, hdr->header_size);\n    (*ppos) += hdr->header_size;\n    buf[(*ppos)++] = ':';\n    buf[(*ppos)++] = ' ';\n    if (add_close || add_keep_alive)\n    {\n      /* \"Connection:\" header must be always the first one */\n      mhd_assert (MHD_str_equal_caseless_n_ (hdr->header, \\\n                                             MHD_HTTP_HEADER_CONNECTION, \\\n                                             hdr->header_size));\n\n      if (add_close)\n      {\n        el_size += MHD_STATICSTR_LEN_ (\"close, \");\n        if (buf_size < initial_pos + el_size)\n          return false;\n        memcpy (buf + *ppos, \"close, \",\n                MHD_STATICSTR_LEN_ (\"close, \"));\n        *ppos += MHD_STATICSTR_LEN_ (\"close, \");\n      }\n      else\n      {\n        el_size += MHD_STATICSTR_LEN_ (\"Keep-Alive, \");\n        if (buf_size < initial_pos + el_size)\n          return false;\n        memcpy (buf + *ppos, \"Keep-Alive, \",\n                MHD_STATICSTR_LEN_ (\"Keep-Alive, \"));\n        *ppos += MHD_STATICSTR_LEN_ (\"Keep-Alive, \");\n      }\n      add_close = false;\n      add_keep_alive = false;\n    }\n    if (0 != hdr->value_size)\n      memcpy (buf + *ppos, hdr->value, hdr->value_size);\n    *ppos += hdr->value_size;\n    buf[(*ppos)++] = '\\r';\n    buf[(*ppos)++] = '\\n';\n    mhd_assert (initial_pos + el_size == (*ppos));\n  }\n  return true;\n}\n```\n</target_code>\n<response format>\nProvide your answer with these fields.\n- explanation: your evaluation of the scenario provided by the agent A.\n- is_report_correct: whether the report is correct or not (true/false). True means there is a violation.\n</response format>\n<scenario>\nThe agent A provided the following violation scenario:\nThe statement 'add_keep_alive = false;' assigns to the parameter add_keep_alive, which is a non\u2011pointer function parameter passed by value. Modifying a value parameter violates MISRA C 2023 Rule 17.8 (a function parameter should not be modified).\n</scenario>\n\n<execution_log>\nThe agent A also provided the following output log:\nLOC=enter EXTRA=function entry add_keep_alive=0 add_close=0 filter_transf_enc=1 filter_content_len=1 ppos=71 buf_size=32576 initial_pos=0 hdr_h_size=0 hdr_v_size=0 flags_auto=0x1 flags=0x0\nLOC=filter_transf_enc_reset EXTRA=no TRANS_ENC_CHUNKED flag add_keep_alive=0 add_close=0 filter_transf_enc=1 filter_content_len=1 ppos=71 buf_size=32576 initial_pos=0 hdr_h_size=0 hdr_v_size=0 flags_auto=0x1 flags=0x0\nLOC=filter_transf_enc_reset_after EXTRA=filter_transf_enc set false add_keep_alive=0 add_close=0 filter_transf_enc=0 filter_content_len=1 ppos=71 buf_size=32576 initial_pos=0 hdr_h_size=0 hdr_v_size=0 flags_auto=0x1 flags=0x0\nLOC=filter_content_len_reset EXTRA=no CONTENT_LENGTH flag add_keep_alive=0 add_close=0 filter_transf_enc=0 filter_content_len=1 ppos=71 buf_size=32576 initial_pos=0 hdr_h_size=0 hdr_v_size=0 flags_auto=0x1 flags=0x0\nLOC=filter_content_len_reset_after EXTRA=filter_content_len set false add_keep_alive=0 add_close=0 filter_transf_enc=0 filter_content_len=0 ppos=71 buf_size=32576 initial_pos=0 hdr_h_size=0 hdr_v_size=0 flags_auto=0x1 flags=0x0\nLOC=loop_iter_start EXTRA=header iteration start add_keep_alive=0 add_close=0 filter_transf_enc=0 filter_content_len=0 ppos=71 buf_size=32576 initial_pos=71 hdr_h_size=10 hdr_v_size=7 flags_auto=0x1 flags=0x0\nLOC=loop_iter_end EXTRA=header iteration end add_keep_alive=0 add_close=0 filter_transf_enc=0 filter_content_len=0 ppos=92 buf_size=32576 initial_pos=71 hdr_h_size=10 hdr_v_size=7 flags_auto=0x1 flags=0x0\nLOC=loop_iter_start EXTRA=header iteration start add_keep_alive=0 add_close=0 filter_transf_enc=0 filter_content_len=0 ppos=92 buf_size=32576 initial_pos=92 hdr_h_size=7 hdr_v_size=20 flags_auto=0x1 flags=0x0\nLOC=loop_iter_end EXTRA=header iteration end add_keep_alive=0 add_close=0 filter_transf_enc=0 filter_content_len=0 ppos=123 buf_size=32576 initial_pos=92 hdr_h_size=7 hdr_v_size=20 flags_auto=0x1 flags=0x0\nLOC=exit EXTRA=function exit returning true add_keep_alive=0 add_close=0 filter_transf_enc=0 filter_content_len=0 ppos=123 buf_size=32576 initial_pos=0 hdr_h_size=0 hdr_v_size=0 flags_auto=0x1 flags=0x0\nLOC=enter EXTRA=function entry add_keep_alive=0 add_close=0 filter_transf_enc=1 filter_content_len=1 ppos=71 buf_size=32576 initial_pos=0 hdr_h_size=0 hdr_v_size=0 flags_auto=0x1 flags=0x0\nLOC=filter_transf_enc_reset EXTRA=no TRANS_ENC_CHUNKED flag add_keep_alive=0 add_close=0 filter_transf_enc=1 filter_content_len=1 ppos=71 buf_size=32576 initial_pos=0 hdr_h_size=0 hdr_v_size=0 flags_auto=0x1 flags=0x0\nLOC=filter_transf_enc_reset_after EXTRA=filter_transf_enc set false add_keep_alive=0 add_close=0 filter_transf_enc=0 filter_content_len=1 ppos=71 buf_size=32576 initial_pos=0 hdr_h_size=0 hdr_v_size=0 flags_auto=0x1 flags=0x0\nLOC=filter_content_len_reset EXTRA=no CONTENT_LENGTH flag add_keep_alive=0 add_close=0 filter_transf_enc=0 filter_content_len=1 ppos=71 buf_size=32576 initial_pos=0 hdr_h_size=0 hdr_v_size=0 flags_auto=0x1 flags=0x0\nLOC=filter_content_len_reset_after EXTRA=filter_content_len set false add_keep_alive=0 add_close=0 filter_transf_enc=0 filter_content_len=0 ppos=71 buf_size=32576 initial_pos=0 hdr_h_size=0 hdr_v_size=0 flags_auto=0x1 flags=0x0\nLOC=loop_iter_start EXTRA=header iteration start add_keep_alive=0 add_close=0 filter_transf_enc=0 filter_content_len=0 ppos=71 buf_size=32576 initial_pos=71 hdr_h_size=10 hdr_v_size=7 flags_auto=0x1 flags=0x0\nLOC=loop_iter_end EXTRA=header iteration end add_keep_alive=0 add_close=0 filter_transf_enc=0 filter_content_len=0 ppos=92 buf_size=32576 initial_pos=71 hdr_h_size=10 hdr_v_size=7 flags_auto=0x1 flags=0x0\nLOC=loop_iter_start EXTRA=header iteration start add_keep_alive=0 add_close=0 filter_transf_enc=0 filter_content_len=0 ppos=92 buf_size=32576 initial_pos=92 hdr_h_size=7 hdr_v_size=20 flags_auto=0x1 flags=0x0\nLOC=loop_iter_end EXTRA=header iteration end add_keep_alive=0 add_close=0 filter_transf_enc=0 filter_content_len=0 ppos=123 buf_size=32576 initial_pos=92 hdr_h_size=7 hdr_v_size=20 flags_auto=0x1 flags=0x0\nLOC=exit EXTRA=function exit returning true add_keep_alive=0 add_close=0 filter_t\n</execution_log>\n\n<instruction>\nJudge whether the report is correct or not.\n</instruction>\n",
  "is_report_correct": true,
  "explanation": "Agent A is correct. MISRA C 2023 Rule 17.8 prohibits modifying function parameters (except modifying the object pointed-to via a pointer parameter \u2014 not applicable here). In add_user_headers several non\u2011pointer parameters are assigned to: e.g. filter_transf_enc = false; filter_content_len = false; add_close = false; add_keep_alive = false; and later add_close = false; add_keep_alive = false; inside the loop. Those assignments modify value parameters and thus violate Rule 17.8. The usual fix is to copy parameter values into local variables and modify the locals instead of the parameters."
}