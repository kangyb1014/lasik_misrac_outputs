{
  "user_message": "An agent A claimed that the following add_user_headers code violates the MISRA C 2023 rule 17.8.\n<misra_rule>\nMISRA C 2023 Rule 17.8 is A function parameter should not be modified.\nNote that the object referred to by a pointer parameter may be modified, but the pointer itself shall not be modified.\n</misra_rule>\n<target_code>\nHere is the original code of add_user_headers.\n```c\nstatic bool\nadd_user_headers (char *buf,\n                  size_t *ppos,\n                  size_t buf_size,\n                  struct MHD_Response *response,\n                  bool filter_transf_enc,\n                  bool filter_content_len,\n                  bool add_close,\n                  bool add_keep_alive)\n{\n  struct MHD_Response *const r = response; /**< a short alias */\n  struct MHD_HTTP_Res_Header *hdr; /**< Iterates through User-specified headers */\n  size_t el_size; /**< the size of current element to be added to the @a buf */\n\n  mhd_assert (! add_close || ! add_keep_alive);\n\n  if (0 == (r->flags_auto & MHD_RAF_HAS_TRANS_ENC_CHUNKED))\n    filter_transf_enc = false;   /* No such header */\n  if (0 == (r->flags_auto & MHD_RAF_HAS_CONTENT_LENGTH))\n    filter_content_len = false;  /* No such header */\n  if (0 == (r->flags_auto & MHD_RAF_HAS_CONNECTION_HDR))\n  {\n    add_close = false;          /* No such header */\n    add_keep_alive = false;     /* No such header */\n  }\n  else if (0 != (r->flags_auto & MHD_RAF_HAS_CONNECTION_CLOSE))\n    add_close = false;          /* \"close\" token was already set */\n\n  for (hdr = r->first_header; NULL != hdr; hdr = hdr->next)\n  {\n    size_t initial_pos = *ppos;\n    if (MHD_HEADER_KIND != hdr->kind)\n      continue;\n    if (filter_transf_enc)\n    { /* Need to filter-out \"Transfer-Encoding\" */\n      if ((MHD_STATICSTR_LEN_ (MHD_HTTP_HEADER_TRANSFER_ENCODING) ==\n           hdr->header_size) &&\n          (MHD_str_equal_caseless_bin_n_ (MHD_HTTP_HEADER_TRANSFER_ENCODING,\n                                          hdr->header, hdr->header_size)) )\n      {\n        filter_transf_enc = false; /* There is the only one such header */\n        continue; /* Skip \"Transfer-Encoding\" header */\n      }\n    }\n    if (filter_content_len)\n    { /* Need to filter-out \"Content-Length\" */\n      if ((MHD_STATICSTR_LEN_ (MHD_HTTP_HEADER_CONTENT_LENGTH) ==\n           hdr->header_size) &&\n          (MHD_str_equal_caseless_bin_n_ (MHD_HTTP_HEADER_CONTENT_LENGTH,\n                                          hdr->header, hdr->header_size)) )\n      {\n        /* Reset filter flag if only one header is allowed */\n        filter_transf_enc =\n          (0 == (r->flags & MHD_RF_INSANITY_HEADER_CONTENT_LENGTH));\n        continue; /* Skip \"Content-Length\" header */\n      }\n    }\n\n    /* Add user header */\n    el_size = hdr->header_size + 2 + hdr->value_size + 2;\n    if (buf_size < *ppos + el_size)\n      return false;\n    memcpy (buf + *ppos, hdr->header, hdr->header_size);\n    (*ppos) += hdr->header_size;\n    buf[(*ppos)++] = ':';\n    buf[(*ppos)++] = ' ';\n    if (add_close || add_keep_alive)\n    {\n      /* \"Connection:\" header must be always the first one */\n      mhd_assert (MHD_str_equal_caseless_n_ (hdr->header, \\\n                                             MHD_HTTP_HEADER_CONNECTION, \\\n                                             hdr->header_size));\n\n      if (add_close)\n      {\n        el_size += MHD_STATICSTR_LEN_ (\"close, \");\n        if (buf_size < initial_pos + el_size)\n          return false;\n        memcpy (buf + *ppos, \"close, \",\n                MHD_STATICSTR_LEN_ (\"close, \"));\n        *ppos += MHD_STATICSTR_LEN_ (\"close, \");\n      }\n      else\n      {\n        el_size += MHD_STATICSTR_LEN_ (\"Keep-Alive, \");\n        if (buf_size < initial_pos + el_size)\n          return false;\n        memcpy (buf + *ppos, \"Keep-Alive, \",\n                MHD_STATICSTR_LEN_ (\"Keep-Alive, \"));\n        *ppos += MHD_STATICSTR_LEN_ (\"Keep-Alive, \");\n      }\n      add_close = false;\n      add_keep_alive = false;\n    }\n    if (0 != hdr->value_size)\n      memcpy (buf + *ppos, hdr->value, hdr->value_size);\n    *ppos += hdr->value_size;\n    buf[(*ppos)++] = '\\r';\n    buf[(*ppos)++] = '\\n';\n    mhd_assert (initial_pos + el_size == (*ppos));\n  }\n  return true;\n}\n```\n</target_code>\n<response format>\nProvide your answer with these fields.\n- explanation: your evaluation of the scenario provided by the agent A.\n- is_report_correct: whether the report is correct or not (true/false). True means there is a violation.\n</response format>\n<scenario>\nThe agent A provided the following violation scenario:\nThe boolean parameter 'filter_transf_enc' (a function parameter passed by value) is assigned to inside the function: 'filter_transf_enc = false;'. MISRA C 2023 Rule 17.8 states that function parameters should not be modified. This assignment modifies the parameter variable and therefore violates Rule 17.8. (Fix: copy the parameter to a local variable and modify that local.)\n</scenario>\n\n<execution_log>\nThe agent A also provided the following output log:\nmhd_log_state: entry | r=0x55d87d4dc0c0 | flags_auto=0x1 | flags=0x0 | filter_transf_enc=1 | filter_content_len=1 | add_close=0 | add_keep_alive=0 | ppos=71\nmhd_log_state: before_clear_has_trans_enc | r=0x55d87d4dc0c0 | flags_auto=0x1 | flags=0x0 | filter_transf_enc=1 | filter_content_len=1 | add_close=0 | add_keep_alive=0 | ppos=71\nmhd_log_state: after_clear_has_trans_enc | r=0x55d87d4dc0c0 | flags_auto=0x1 | flags=0x0 | filter_transf_enc=0 | filter_content_len=1 | add_close=0 | add_keep_alive=0 | ppos=71\nmhd_log_state: before_clear_has_content_len | r=0x55d87d4dc0c0 | flags_auto=0x1 | flags=0x0 | filter_transf_enc=0 | filter_content_len=1 | add_close=0 | add_keep_alive=0 | ppos=71\nmhd_log_state: after_clear_has_content_len | r=0x55d87d4dc0c0 | flags_auto=0x1 | flags=0x0 | filter_transf_enc=0 | filter_content_len=0 | add_close=0 | add_keep_alive=0 | ppos=71\nmhd_log_state: after_adding_header | r=0x55d87d4dc0c0 | flags_auto=0x1 | flags=0x0 | filter_transf_enc=0 | filter_content_len=0 | add_close=0 | add_keep_alive=0 | ppos=92\nmhd_log_state: after_adding_header | r=0x55d87d4dc0c0 | flags_auto=0x1 | flags=0x0 | filter_transf_enc=0 | filter_content_len=0 | add_close=0 | add_keep_alive=0 | ppos=123\nmhd_log_state: exit | r=0x55d87d4dc0c0 | flags_auto=0x1 | flags=0x0 | filter_transf_enc=0 | filter_content_len=0 | add_close=0 | add_keep_alive=0 | ppos=123\nmhd_log_state: entry | r=0x55d87d4dccd0 | flags_auto=0x1 | flags=0x0 | filter_transf_enc=1 | filter_content_len=1 | add_close=0 | add_keep_alive=0 | ppos=71\nmhd_log_state: before_clear_has_trans_enc | r=0x55d87d4dccd0 | flags_auto=0x1 | flags=0x0 | filter_transf_enc=1 | filter_content_len=1 | add_close=0 | add_keep_alive=0 | ppos=71\nmhd_log_state: after_clear_has_trans_enc | r=0x55d87d4dccd0 | flags_auto=0x1 | flags=0x0 | filter_transf_enc=0 | filter_content_len=1 | add_close=0 | add_keep_alive=0 | ppos=71\nmhd_log_state: before_clear_has_content_len | r=0x55d87d4dccd0 | flags_auto=0x1 | flags=0x0 | filter_transf_enc=0 | filter_content_len=1 | add_close=0 | add_keep_alive=0 | ppos=71\nmhd_log_state: after_clear_has_content_len | r=0x55d87d4dccd0 | flags_auto=0x1 | flags=0x0 | filter_transf_enc=0 | filter_content_len=0 | add_close=0 | add_keep_alive=0 | ppos=71\nmhd_log_state: after_adding_header | r=0x55d87d4dccd0 | flags_auto=0x1 | flags=0x0 | filter_transf_enc=0 | filter_content_len=0 | add_close=0 | add_keep_alive=0 | ppos=92\nmhd_log_state: after_adding_header | r=0x55d87d4dccd0 | flags_auto=0x1 | flags=0x0 | filter_transf_enc=0 | filter_content_len=0 | add_close=0 | add_keep_alive=0 | ppos=123\nmhd_log_state: exit | r=0x55d87d4dccd0 | flags_auto=0x1 | flags=0x0 | filter_transf_enc=0 | filter_content_len=0 | add_close=0 | add_keep_alive=0 | ppos=123\nmhd_log_state: entry | r=0x55d87d4dd290 | flags_auto=0x1 | flags=0x0 | filter_transf_enc=1 | filter_content_len=1 | add_close=0 | add_keep_alive=0 | ppos=71\nmhd_log_state: before_clear_has_trans_enc | r=0x55d87d4dd290 | flags_auto=0x1 | flags=0x0 | filter_transf_enc=1 | filter_content_len=1 | add_close=0 | add_keep_alive=0 | ppos=71\nmhd_log_state: after_clear_has_trans_enc | r=0x55d87d4dd290 | flags_auto=0x1 | flags=0x0 | filter_transf_enc=0 | filter_content_len=1 | add_close=0 | add_keep_alive=0 | ppos=71\nmhd_log_state: before_clear_has_content_len | r=0x55d87d4dd290 | flags_auto=0x1 | flags=0x0 | filter_transf_enc=0 | filter_content_len=1 | add_close=0 | add_keep_alive=0 | ppos=71\nmhd_log_state: after_clear_has_content_len | r=0x55d87d4dd290 | flags_auto=0x1 | flags=0x0 | filter_transf_enc=0 | filter_content_len=0 | add_close=0 | add_keep_alive=0 | ppos=71\nmhd_log_state: after_adding_header | r=0x55d87d4dd290 | flags_auto=0x1 | flags=0x0 | filter_transf_enc=0 | filter_content_len=0 | add_close=0 | add_keep_alive=0 | ppos=92\nmhd_log_state: after_adding_header | r=0x55d87d4dd290 | flags_auto=0x1 | flags=0x0 | filter_transf_enc=0 | filter_content_len=0 | add_close=0 | add_keep_alive=0 | ppos=123\nmhd_log_state: exit | r=0x55d87d4dd290 | flags_auto=0x1 | flags=0x0 | filter_transf_enc=0 | filter_content_len=0 | add_close=0 | add_keep_al\n</execution_log>\n\n<instruction>\nJudge whether the report is correct or not.\n</instruction>\n",
  "is_report_correct": true,
  "explanation": "Agent A is correct. MISRA C 2023 Rule 17.8 states that function parameters should not be modified (the object referred to by a pointer parameter may be modified, but the pointer itself shall not be modified). In add_user_headers the boolean parameters passed by value (filter_transf_enc, filter_content_len, add_close, add_keep_alive) are assigned to within the function (e.g. filter_transf_enc = false; filter_transf_enc = (\u2026) ; add_close = false; add_keep_alive = false;). These are direct modifications of value parameters and therefore violate Rule 17.8. Note: modifying *ppos (the object pointed to) is allowed by the rule, and the code correctly uses a const alias for the response pointer, but that does not negate the violations of modifying the scalar value parameters. The usual corrective action is to copy the incoming parameters to local variables and modify those locals instead."
}