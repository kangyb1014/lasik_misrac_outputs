{
  "user_message": "An agent A claimed that the following add_user_headers code violates the MISRA C 2023 rule 21.17.\n<misra_rule>\nMISRA C 2023 Rule 21.17 is Use of the string handling functions from <string.h> shall not result in accesses beyond the bounds of the objects referenced by their pointer parameters.\nThis rule strictly applies to the Standard Library functions in <string.h> such as memcpy, memmove, memset, memcmp, strcpy, strncpy, strcat, strncat, strlen, and strspn.\n</misra_rule>\n<target_code>\nHere is the original code of add_user_headers.\n```c\nstatic bool\nadd_user_headers (char *buf,\n                  size_t *ppos,\n                  size_t buf_size,\n                  struct MHD_Response *response,\n                  bool filter_transf_enc,\n                  bool filter_content_len,\n                  bool add_close,\n                  bool add_keep_alive)\n{\n  struct MHD_Response *const r = response; /**< a short alias */\n  struct MHD_HTTP_Res_Header *hdr; /**< Iterates through User-specified headers */\n  size_t el_size; /**< the size of current element to be added to the @a buf */\n\n  mhd_assert (! add_close || ! add_keep_alive);\n\n  if (0 == (r->flags_auto & MHD_RAF_HAS_TRANS_ENC_CHUNKED))\n    filter_transf_enc = false;   /* No such header */\n  if (0 == (r->flags_auto & MHD_RAF_HAS_CONTENT_LENGTH))\n    filter_content_len = false;  /* No such header */\n  if (0 == (r->flags_auto & MHD_RAF_HAS_CONNECTION_HDR))\n  {\n    add_close = false;          /* No such header */\n    add_keep_alive = false;     /* No such header */\n  }\n  else if (0 != (r->flags_auto & MHD_RAF_HAS_CONNECTION_CLOSE))\n    add_close = false;          /* \"close\" token was already set */\n\n  for (hdr = r->first_header; NULL != hdr; hdr = hdr->next)\n  {\n    size_t initial_pos = *ppos;\n    if (MHD_HEADER_KIND != hdr->kind)\n      continue;\n    if (filter_transf_enc)\n    { /* Need to filter-out \"Transfer-Encoding\" */\n      if ((MHD_STATICSTR_LEN_ (MHD_HTTP_HEADER_TRANSFER_ENCODING) ==\n           hdr->header_size) &&\n          (MHD_str_equal_caseless_bin_n_ (MHD_HTTP_HEADER_TRANSFER_ENCODING,\n                                          hdr->header, hdr->header_size)) )\n      {\n        filter_transf_enc = false; /* There is the only one such header */\n        continue; /* Skip \"Transfer-Encoding\" header */\n      }\n    }\n    if (filter_content_len)\n    { /* Need to filter-out \"Content-Length\" */\n      if ((MHD_STATICSTR_LEN_ (MHD_HTTP_HEADER_CONTENT_LENGTH) ==\n           hdr->header_size) &&\n          (MHD_str_equal_caseless_bin_n_ (MHD_HTTP_HEADER_CONTENT_LENGTH,\n                                          hdr->header, hdr->header_size)) )\n      {\n        /* Reset filter flag if only one header is allowed */\n        filter_transf_enc =\n          (0 == (r->flags & MHD_RF_INSANITY_HEADER_CONTENT_LENGTH));\n        continue; /* Skip \"Content-Length\" header */\n      }\n    }\n\n    /* Add user header */\n    el_size = hdr->header_size + 2 + hdr->value_size + 2;\n    if (buf_size < *ppos + el_size)\n      return false;\n    memcpy (buf + *ppos, hdr->header, hdr->header_size);\n    (*ppos) += hdr->header_size;\n    buf[(*ppos)++] = ':';\n    buf[(*ppos)++] = ' ';\n    if (add_close || add_keep_alive)\n    {\n      /* \"Connection:\" header must be always the first one */\n      mhd_assert (MHD_str_equal_caseless_n_ (hdr->header, \\\n                                             MHD_HTTP_HEADER_CONNECTION, \\\n                                             hdr->header_size));\n\n      if (add_close)\n      {\n        el_size += MHD_STATICSTR_LEN_ (\"close, \");\n        if (buf_size < initial_pos + el_size)\n          return false;\n        memcpy (buf + *ppos, \"close, \",\n                MHD_STATICSTR_LEN_ (\"close, \"));\n        *ppos += MHD_STATICSTR_LEN_ (\"close, \");\n      }\n      else\n      {\n        el_size += MHD_STATICSTR_LEN_ (\"Keep-Alive, \");\n        if (buf_size < initial_pos + el_size)\n          return false;\n        memcpy (buf + *ppos, \"Keep-Alive, \",\n                MHD_STATICSTR_LEN_ (\"Keep-Alive, \"));\n        *ppos += MHD_STATICSTR_LEN_ (\"Keep-Alive, \");\n      }\n      add_close = false;\n      add_keep_alive = false;\n    }\n    if (0 != hdr->value_size)\n      memcpy (buf + *ppos, hdr->value, hdr->value_size);\n    *ppos += hdr->value_size;\n    buf[(*ppos)++] = '\\r';\n    buf[(*ppos)++] = '\\n';\n    mhd_assert (initial_pos + el_size == (*ppos));\n  }\n  return true;\n}\n```\n</target_code>\n<response format>\nProvide your answer with these fields.\n- explanation: your evaluation of the scenario provided by the agent A.\n- is_report_correct: whether the report is correct or not (true/false). True means there is a violation.\n</response format>\n<scenario>\nThe agent A provided the following violation scenario:\nThe comparison uses addition which can overflow size_t. If hdr->header_size, hdr->value_size or *ppos are large enough that initial_pos + el_size (or earlier *ppos + el_size) wraps around, the test buf_size < initial_pos + el_size can be false even though there is not enough space. In that case the subsequent memcpy calls (e.g. memcpy(buf + *ppos, \"close, \", ...) or memcpy(buf + *ppos, hdr->value, ...)) can write past the end of buf, violating Rule 21.17. For example, if el_size is crafted to cause initial_pos + el_size to overflow, the bounds check is bypassed and an out-of-bounds access occurs.\n</scenario>\n\n<execution_log>\nThe agent A also provided the following output log:\n[add_user_headers] entry\n  response=0x55fb52c750c0 flags_auto=0x1 flags=0x0\n  buf_size=32576 *ppos=71 initial_pos=0 el_size=0 add_close=0 add_keep_alive=0\n  computed: *ppos + el_size = 71 (may have wrapped), initial_pos + el_size = 0\n[add_user_headers] hdr_loop_start\n  response=0x55fb52c750c0 flags_auto=0x1 flags=0x0\n  hdr=0x55fb52c751a0 header_size=10 value_size=7 kind=1\n  buf_size=32576 *ppos=71 initial_pos=71 el_size=0 add_close=0 add_keep_alive=0\n  computed: *ppos + el_size = 71 (may have wrapped), initial_pos + el_size = 71\n[add_user_headers] computed_el_size\n  response=0x55fb52c750c0 flags_auto=0x1 flags=0x0\n  hdr=0x55fb52c751a0 header_size=10 value_size=7 kind=1\n  buf_size=32576 *ppos=71 initial_pos=71 el_size=21 add_close=0 add_keep_alive=0\n  computed: *ppos + el_size = 92 (may have wrapped), initial_pos + el_size = 92\n[add_user_headers] before_first_bounds_check\n  response=0x55fb52c750c0 flags_auto=0x1 flags=0x0\n  hdr=0x55fb52c751a0 header_size=10 value_size=7 kind=1\n  buf_size=32576 *ppos=71 initial_pos=71 el_size=21 add_close=0 add_keep_alive=0\n  computed: *ppos + el_size = 92 (may have wrapped), initial_pos + el_size = 92\n[add_user_headers] before_memcpy_header\n  response=0x55fb52c750c0 flags_auto=0x1 flags=0x0\n  hdr=0x55fb52c751a0 header_size=10 value_size=7 kind=1\n  buf_size=32576 *ppos=71 initial_pos=71 el_size=21 add_close=0 add_keep_alive=0\n  computed: *ppos + el_size = 92 (may have wrapped), initial_pos + el_size = 92\n[add_user_headers] before_memcpy_value\n  response=0x55fb52c750c0 flags_auto=0x1 flags=0x0\n  hdr=0x55fb52c751a0 header_size=10 value_size=7 kind=1\n  buf_size=32576 *ppos=83 initial_pos=71 el_size=21 add_close=0 add_keep_alive=0\n  computed: *ppos + el_size = 104 (may have wrapped), initial_pos + el_size = 92\n[add_user_headers] after_header_written\n  response=0x55fb52c750c0 flags_auto=0x1 flags=0x0\n  hdr=0x55fb52c751a0 header_size=10 value_size=7 kind=1\n  buf_size=32576 *ppos=92 initial_pos=71 el_size=21 add_close=0 add_keep_alive=0\n  computed: *ppos + el_size = 113 (may have wrapped), initial_pos + el_size = 92\n[add_user_headers] hdr_loop_start\n  response=0x55fb52c750c0 flags_auto=0x1 flags=0x0\n  hdr=0x55fb52c75240 header_size=7 value_size=20 kind=1\n  buf_size=32576 *ppos=92 initial_pos=92 el_size=0 add_close=0 add_keep_alive=0\n  computed: *ppos + el_size = 92 (may have wrapped), initial_pos + el_size = 92\n[add_user_headers] computed_el_size\n  response=0x55fb52c750c0 flags_auto=0x1 flags=0x0\n  hdr=0x55fb52c75240 header_size=7 value_size=20 kind=1\n  buf_size=32576 *ppos=92 initial_pos=92 el_size=31 add_close=0 add_keep_alive=0\n  computed: *ppos + el_size = 123 (may have wrapped), initial_pos + el_size = 123\n[add_user_headers] before_first_bounds_check\n  response=0x55fb52c750c0 flags_auto=0x1 flags=0x0\n  hdr=0x55fb52c75240 header_size=7 value_size=20 kind=1\n  buf_size=32576 *ppos=92 initial_pos=92 el_size=31 add_close=0 add_keep_alive=0\n  computed: *ppos + el_size = 123 (may have wrapped), initial_pos + el_size = 123\n[add_user_headers] before_memcpy_header\n  response=0x55fb52c750c0 flags_auto=0x1 flags=0x0\n  hdr=0x55fb52c75240 header_size=7 value_size=20 kind=1\n  buf_size=32576 *ppos=92 initial_pos=92 el_size=31 add_close=0 add_keep_alive=0\n  computed: *ppos + el_size = 123 (may have wrapped), initial_pos + el_size = 123\n[add_user_headers] before_memcpy_value\n  response=0x55fb52c750c0 flags_auto=0x1 flags=0x0\n  hdr=0x55fb52c75240 header_size=7 value_size=20 kind=1\n  buf_size=32576 *ppos=101 initial_pos=92 el_size=31 add_close=0 add_keep_alive=0\n  computed: *ppos + el_size = 132 (may have wrapped), initial_pos + el_size = 123\n[add_user_headers] after_header_written\n  response=0x55fb52c750c0 flags_auto=0x1 flags=0x0\n  hdr=0x55fb52c75240 header_size=7 value_size=20 kind=1\n  buf_size=32576 *ppos=123 initial_pos=92 el_size=31 add_close=0 add_keep_alive=0\n  computed: *ppos + el_size = 154 (may have wrapped), initial_pos + el_size = 123\n[add_user_headers] exit_true\n  response=0x55fb52c750c0 flags_auto=0x1 flags=0x0\n  buf_size=32576 *ppos=123 initial_pos=0 el_size=0 add_close=0 add_keep_alive=0\n  comp\n</execution_log>\n\n<instruction>\nJudge whether the report is correct or not.\n</instruction>\n",
  "is_report_correct": true,
  "explanation": "Agent A is correct. The function performs multiple additions of size_t values (el_size = hdr->header_size + 2 + hdr->value_size + 2 and later el_size += MHD_STATICSTR_LEN_(\"close, \") or similar) and uses those sums in comparisons like if (buf_size < *ppos + el_size) and if (buf_size < initial_pos + el_size) to decide whether it is safe to call memcpy. These additions are not checked for overflow. If any of the summed terms (hdr->header_size, hdr->value_size, *ppos, or el_size after increments) are large enough to cause wraparound, the comparisons can be bypassed and subsequent memcpy calls (which copy hdr->header, the literal tokens, or hdr->value using hdr->header_size / hdr->value_size) can write past the end of buf. That is exactly the kind of out-of-bounds access of string/memory functions that MISRA C 2023 Rule 21.17 forbids. The posted execution log only shows a normal non-wrapping run; it does not refute the theoretical overflow. To conform, the code must perform overflow-checked additions (e.g. verify each addition does not exceed SIZE_MAX or rewrite checks to avoid wrapping) before using the results in bounds comparisons and memcpy calls. Therefore the reported violation is correct."
}