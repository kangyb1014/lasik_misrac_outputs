{
  "user_message": "An agent A claimed that the following add_user_headers code violates the MISRA C 2023 rule 8.13.\n<misra_rule>\nMISRA C 2023 Rule 8.13 is A pointer should point to a const-qualified type whenever possible.\n\n</misra_rule>\n<target_code>\nHere is the original code of add_user_headers.\n```c\nstatic bool\nadd_user_headers (char *buf,\n                  size_t *ppos,\n                  size_t buf_size,\n                  struct MHD_Response *response,\n                  bool filter_transf_enc,\n                  bool filter_content_len,\n                  bool add_close,\n                  bool add_keep_alive)\n{\n  struct MHD_Response *const r = response; /**< a short alias */\n  struct MHD_HTTP_Res_Header *hdr; /**< Iterates through User-specified headers */\n  size_t el_size; /**< the size of current element to be added to the @a buf */\n\n  mhd_assert (! add_close || ! add_keep_alive);\n\n  if (0 == (r->flags_auto & MHD_RAF_HAS_TRANS_ENC_CHUNKED))\n    filter_transf_enc = false;   /* No such header */\n  if (0 == (r->flags_auto & MHD_RAF_HAS_CONTENT_LENGTH))\n    filter_content_len = false;  /* No such header */\n  if (0 == (r->flags_auto & MHD_RAF_HAS_CONNECTION_HDR))\n  {\n    add_close = false;          /* No such header */\n    add_keep_alive = false;     /* No such header */\n  }\n  else if (0 != (r->flags_auto & MHD_RAF_HAS_CONNECTION_CLOSE))\n    add_close = false;          /* \"close\" token was already set */\n\n  for (hdr = r->first_header; NULL != hdr; hdr = hdr->next)\n  {\n    size_t initial_pos = *ppos;\n    if (MHD_HEADER_KIND != hdr->kind)\n      continue;\n    if (filter_transf_enc)\n    { /* Need to filter-out \"Transfer-Encoding\" */\n      if ((MHD_STATICSTR_LEN_ (MHD_HTTP_HEADER_TRANSFER_ENCODING) ==\n           hdr->header_size) &&\n          (MHD_str_equal_caseless_bin_n_ (MHD_HTTP_HEADER_TRANSFER_ENCODING,\n                                          hdr->header, hdr->header_size)) )\n      {\n        filter_transf_enc = false; /* There is the only one such header */\n        continue; /* Skip \"Transfer-Encoding\" header */\n      }\n    }\n    if (filter_content_len)\n    { /* Need to filter-out \"Content-Length\" */\n      if ((MHD_STATICSTR_LEN_ (MHD_HTTP_HEADER_CONTENT_LENGTH) ==\n           hdr->header_size) &&\n          (MHD_str_equal_caseless_bin_n_ (MHD_HTTP_HEADER_CONTENT_LENGTH,\n                                          hdr->header, hdr->header_size)) )\n      {\n        /* Reset filter flag if only one header is allowed */\n        filter_transf_enc =\n          (0 == (r->flags & MHD_RF_INSANITY_HEADER_CONTENT_LENGTH));\n        continue; /* Skip \"Content-Length\" header */\n      }\n    }\n\n    /* Add user header */\n    el_size = hdr->header_size + 2 + hdr->value_size + 2;\n    if (buf_size < *ppos + el_size)\n      return false;\n    memcpy (buf + *ppos, hdr->header, hdr->header_size);\n    (*ppos) += hdr->header_size;\n    buf[(*ppos)++] = ':';\n    buf[(*ppos)++] = ' ';\n    if (add_close || add_keep_alive)\n    {\n      /* \"Connection:\" header must be always the first one */\n      mhd_assert (MHD_str_equal_caseless_n_ (hdr->header, \\\n                                             MHD_HTTP_HEADER_CONNECTION, \\\n                                             hdr->header_size));\n\n      if (add_close)\n      {\n        el_size += MHD_STATICSTR_LEN_ (\"close, \");\n        if (buf_size < initial_pos + el_size)\n          return false;\n        memcpy (buf + *ppos, \"close, \",\n                MHD_STATICSTR_LEN_ (\"close, \"));\n        *ppos += MHD_STATICSTR_LEN_ (\"close, \");\n      }\n      else\n      {\n        el_size += MHD_STATICSTR_LEN_ (\"Keep-Alive, \");\n        if (buf_size < initial_pos + el_size)\n          return false;\n        memcpy (buf + *ppos, \"Keep-Alive, \",\n                MHD_STATICSTR_LEN_ (\"Keep-Alive, \"));\n        *ppos += MHD_STATICSTR_LEN_ (\"Keep-Alive, \");\n      }\n      add_close = false;\n      add_keep_alive = false;\n    }\n    if (0 != hdr->value_size)\n      memcpy (buf + *ppos, hdr->value, hdr->value_size);\n    *ppos += hdr->value_size;\n    buf[(*ppos)++] = '\\r';\n    buf[(*ppos)++] = '\\n';\n    mhd_assert (initial_pos + el_size == (*ppos));\n  }\n  return true;\n}\n```\n</target_code>\n<response format>\nProvide your answer with these fields.\n- explanation: your evaluation of the scenario provided by the agent A.\n- is_report_correct: whether the report is correct or not (true/false). True means there is a violation.\n</response format>\n<scenario>\nThe agent A provided the following violation scenario:\nThe code passes hdr->header (a pointer to header name data used only for read-only comparisons) to a case-insensitive compare against the string literal MHD_HTTP_HEADER_CONNECTION. If hdr->header is declared as char * (non-const) in struct MHD_HTTP_Res_Header, this violates MISRA C 2023 Rule 8.13 because the pointer should be const-qualified when the pointed-to characters are not modified. The correct approach is to declare the header field (and other read-only string pointers such as value if appropriate) as const char * (and ensure MHD_str_equal_caseless_n_ takes const char * parameters).\n</scenario>\n\n<execution_log>\nThe agent A also provided the following output log:\nadd_user_headers ENTRY: response=0x55e8897ce0c0 flags_auto=0x1 flags=0x0 filter_transf_enc=1 filter_content_len=1 add_close=0 add_keep_alive=0 buf=0x55e8897c60d0 *ppos=71 buf_size=32576\nITER header=0x55e8897ce1e0 kind=1 header_size=10 value_size=7 header_preview='Connection' next=0x55e8897ce240\nAPPENDED header at initial_pos=71 new_pos=92 el_size=21 header=0x55e8897ce1e0 value=0x55e8897ce180\nITER header=0x55e8897ce200 kind=1 header_size=7 value_size=20 header_preview='Upgrade' next=(nil)\nAPPENDED header at initial_pos=92 new_pos=123 el_size=31 header=0x55e8897ce200 value=0x55e8897ce220\nadd_user_headers EXIT: *ppos=123\nadd_user_headers ENTRY: response=0x55e8897cecd0 flags_auto=0x1 flags=0x0 filter_transf_enc=1 filter_content_len=1 add_close=0 add_keep_alive=0 buf=0x55e8897c60d0 *ppos=71 buf_size=32576\nITER header=0x55e8897ce200 kind=1 header_size=10 value_size=7 header_preview='Connection' next=0x55e8897cedd0\nAPPENDED header at initial_pos=71 new_pos=92 el_size=21 header=0x55e8897ce200 value=0x55e8897ce220\nITER header=0x55e8897ce180 kind=1 header_size=7 value_size=20 header_preview='Upgrade' next=(nil)\nAPPENDED header at initial_pos=92 new_pos=123 el_size=31 header=0x55e8897ce180 value=0x55e8897ce1e0\nadd_user_headers EXIT: *ppos=123\nadd_user_headers ENTRY: response=0x55e8897cf290 flags_auto=0x1 flags=0x0 filter_transf_enc=1 filter_content_len=1 add_close=0 add_keep_alive=0 buf=0x55e8897cf4f0 *ppos=71 buf_size=32576\nITER header=0x55e8897ce180 kind=1 header_size=10 value_size=7 header_preview='Connection' next=0x55e8897cf390\nAPPENDED header at initial_pos=71 new_pos=92 el_size=21 header=0x55e8897ce180 value=0x55e8897ce1e0\nITER header=0x55e8897ce220 kind=1 header_size=7 value_size=20 header_preview='Upgrade' next=(nil)\nAPPENDED header at initial_pos=92 new_pos=123 el_size=31 header=0x55e8897ce220 value=0x55e8897ce200\nadd_user_headers EXIT: *ppos=123\nadd_user_headers ENTRY: response=0x7fbbcc000b90 flags_auto=0x1 flags=0x0 filter_transf_enc=1 filter_content_len=1 add_close=0 add_keep_alive=0 buf=0x7fbbc4000e50 *ppos=71 buf_size=32576\nITER header=0x7fbbcc000c90 kind=1 header_size=10 value_size=7 header_preview='Connection' next=0x7fbbcc000cf0\nAPPENDED header at initial_pos=71 new_pos=92 el_size=21 header=0x7fbbcc000c90 value=0x7fbbcc000b70\nITER header=0x7fbbcc000cb0 kind=1 header_size=7 value_size=20 header_preview='Upgrade' next=(nil)\nAPPENDED header at initial_pos=92 new_pos=123 el_size=31 header=0x7fbbcc000cb0 value=0x7fbbcc000cd0\nadd_user_headers EXIT: *ppos=123\nadd_user_headers ENTRY: response=0x7fbbc0000b90 flags_auto=0x1 flags=0x0 filter_transf_enc=1 filter_content_len=1 add_close=0 add_keep_alive=0 buf=0x7fbbc4000e50 *ppos=71 buf_size=32576\nITER header=0x7fbbc0000c90 kind=1 header_size=10 value_size=7 header_preview='Connection' next=0x7fbbc0000cf0\nAPPENDED header at initial_pos=71 new_pos=92 el_size=21 header=0x7fbbc0000c90 value=0x7fbbc0000b70\nITER header=0x7fbbc0000cb0 kind=1 header_size=7 value_size=20 header_preview='Upgrade' next=(nil)\nAPPENDED header at initial_pos=92 new_pos=123 el_size=31 header=0x7fbbc0000cb0 value=0x7fbbc0000cd0\nadd_user_headers EXIT: *ppos=123\nadd_user_headers ENTRY: response=0x7fbbc0000b90 flags_auto=0x1 flags=0x0 filter_transf_enc=1 filter_content_len=1 add_close=0 add_keep_alive=0 buf=0x7fbbc4000e50 *ppos=71 buf_size=32576\nITER header=0x7fbbc0000f30 kind=1 header_size=10 value_size=7 header_preview='Connection' next=0x7fbbc0000d30\nAPPENDED header at initial_pos=71 new_pos=92 el_size=21 header=0x7fbbc0000f30 value=0x7fbbc0000f10\nITER header=0x7fbbc0000c90 kind=1 header_size=7 value_size=20 header_preview='Upgrade' next=(nil)\nAPPENDED header at initial_pos=92 new_pos=123 el_size=31 header=0x7fbbc0000c90 value=0x7fbbc0000cd0\nadd_user_headers EXIT: *ppos=123\nadd_user_headers ENTRY: response=0x7fbbc4008f40 flags_auto=0x1 flags=0x0 filter_transf_enc=1 filter_content_len=1 add_close=0 add_keep_alive=0 buf=0x7fbbc4000e50 *ppos=71 buf_size=32576\nITER header=0x7fbbc4009060 kind=1 header_size=10 value_size=7 header_preview='Connection' next=0x7fbbc40090c0\nAPPENDED header at initial_pos=71 new_pos=92\n</execution_log>\n\n<instruction>\nJudge whether the report is correct or not.\n</instruction>\n",
  "is_report_correct": false,
  "explanation": "Agent A points out a plausible issue: the code only treats hdr->header (and hdr->value) as read\u2011only (comparisons, memcpy), so if the struct member(s) are declared as plain char * rather than const char * then, per MISRA C 2023 Rule 8.13 (\u201cA pointer should point to a const\u2011qualified type whenever possible\u201d), the declaration of those members could be non\u2011compliant. However, Rule 8.13 is about the declarations of pointers, not about each use site. The snippet shown does not include the definition of struct MHD_HTTP_Res_Header, nor the global usage of those members elsewhere; therefore you cannot conclude a violation from this function alone. If the struct actually declares header (and value) as char * and those buffers are never modified anywhere in the program, then the struct declarations would be a MISRA 8.13 violation and should be changed to const char *. If, however, those members are modified elsewhere (or must be mutable for other valid reasons), the non\u2011const declaration is justified and no violation occurs. Also note that passing a char * to a function parameter declared as const char * is allowed in C and does not itself indicate non\u2011compliance \u2014 the issue is the declaration site. In summary: the report is a plausible concern but is not proven from the provided code alone; you must inspect the struct definition and all write sites to those members to determine whether they can be const-qualified."
}