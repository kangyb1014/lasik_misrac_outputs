{
  "user_message": "<target code>Here is the code that failed to compile:\n```c\nstatic void mhd_assert (int cond)\n{\n  /* Keep the behavior minimal and side-effect free. */\n  (void) cond;\n}\nstatic void\nlog_probe (const char *fmt, ...)\n{\n  FILE *f = fopen(\"/tmp/logs/2832.txt\", \"a\");\n  if (NULL == f)\n  {\n    return;\n  }\n\n  va_list ap;\n  va_start (ap, fmt);\n  vfprintf (f, fmt, ap);\n  va_end (ap);\n  fputc('\\n', f);\n  fclose (f);\n}\n\nstatic size_t\nget_rq_param_unquoted_copy_z (const struct MHD_RqDAuthParam *param, char *buf)\n{\n  size_t len;\n\n  /* Entry probe: capture pointer and length state */\n  log_probe (\"enter: param=%p value.str=%p value.len=%zu quoted=%d buf=%p\",\n             (void *) param,\n             (void *) (param ? param->value.str : NULL),\n             (param ? param->value.len : (size_t)0u),\n             (param ? param->quoted : 0),\n             (void *) buf);\n\n  /* Original assertion: log before and after to detect no-op assertions. */\n  log_probe (\"before assert: NULL != param->value.str\");\n  mhd_assert (NULL != param->value.str);\n  log_probe (\"after assert: NULL != param->value.str (execution continued)\");\n\n  if (! param->quoted)\n  {\n    log_probe (\"branch: unquoted path taken. memcpy len=%zu\", param->value.len);\n    memcpy (buf, param->value.str, param->value.len);\n    buf [param->value.len] = 0;\n    log_probe (\"exit: returning %zu (unquoted)\", param->value.len);\n    return param->value.len;\n  }\n\n  /* Quoted path: capture the result of unquoting. */\n  len = MHD_str_unquote (param->value.str, param->value.len, buf);\n  log_probe (\"after MHD_str_unquote: len=%zu original_len=%zu\",\n             len, param->value.len);\n\n  log_probe (\"before assert: 0 != len\");\n  mhd_assert (0 != len);\n  log_probe (\"after assert: 0 != len (execution continued)\");\n\n  log_probe (\"before assert: len < param->value.len (len=%zu param_len=%zu)\",\n             len, param->value.len);\n  mhd_assert (len < param->value.len);\n  log_probe (\"after assert: len < param->value.len (execution continued)\");\n\n  buf[len] = 0;\n  log_probe (\"exit: returning %zu (quoted)\", len);\n  return len;\n}\n\n```\n</target code>\n<build error>\nThe build failed with the following error:\n```\ndigestauth.c:1030:13: error: expected identifier or '('\n 1030 | static void mhd_assert (int cond)\n      |             ^\n./mhd_assert.h:45:32: note: expanded from macro 'mhd_assert'\n   45 | #  define mhd_assert(ignore) ((void) 0)\n      |                                ^\ndigestauth.c:1030:13: error: expected ')'\n./mhd_assert.h:45:32: note: expanded from macro 'mhd_assert'\n   45 | #  define mhd_assert(ignore) ((void) 0)\n      |                                ^\ndigestauth.c:1030:13: note: to match this '('\n./mhd_assert.h:45:31: note: expanded from macro 'mhd_assert'\n   45 | #  define mhd_assert(ignore) ((void) 0)\n      |                               ^\ndigestauth.c:1030:13: error: expected ')'\n 1030 | static void mhd_assert (int cond)\n      |             ^\n./mhd_assert.h:45:38: note: expanded from macro 'mhd_assert'\n   45 | #  define mhd_assert(ignore) ((void) 0)\n      |                                      ^\ndigestauth.c:1030:13: note: to match this '('\n./mhd_assert.h:45:30: note: expanded from macro 'mhd_assert'\n   45 | #  define mhd_assert(ignore) ((void) 0)\n      |                              ^\n3 errors generated.\nmake[3]: *** [Makefile:2224: libmicrohttpd_la-digestauth.lo] Error 1\nmake[2]: *** [Makefile:449: all-recursive] Error 1\nmake[1]: *** [Makefile:788: all-recursive] Error 1\nmake: *** [Makefile:693: all] Error 2\n```\n</build error>\n<response format>\nProvide your answer with these answers.\n- fixed_test_code: the fixed test code that compiles successfully.\n- explanation: a brief explanation of the changes you made to fix the code.\nHere are the constraints for the test code:\n- The test code MUST be compilable and executable.\n- The test code MUST include line breaks.\n- The test code MUST preserve the original logic of get_rq_param_unquoted_copy_z as much as possible.\n- You MUST not define the main function.\n- You MUST not define macros.\n- The test code MUST not contain any mock functions.\n</response format>\n<instruction>\nPlease fix the code so that it compiles successfully.\n</instruction>\n",
  "fixed_test_code": "#include <stdio.h>\n#include <stdarg.h>\n#include <string.h>\n#include <stddef.h>\n\n/* Minimal definitions to allow this compilation unit to build. */\nstruct {\n    const char *str;\n    size_t len;\n};\n\nstruct MHD_RqDAuthParam_value {\n    const char *str;\n    size_t len;\n};\n\nstruct MHD_RqDAuthParam {\n    struct MHD_RqDAuthParam_value value;\n    int quoted;\n};\n\n/* Prototype for the external function used by the code. No implementation here. */\nsize_t MHD_str_unquote(const char *src, size_t srclen, char *dst);\n\n/* Rename the assert wrapper to avoid collision with an external macro named\n   mhd_assert that some builds provide via headers. */\nstatic void mhd_assert_local(int cond)\n{\n    /* Keep the behavior minimal and side-effect free. */\n    (void) cond;\n}\n\nstatic void\nlog_probe (const char *fmt, ...)\n{\n    FILE *f = fopen(\"/tmp/logs/2832.txt\", \"a\");\n    if (NULL == f)\n    {\n        return;\n    }\n\n    va_list ap;\n    va_start (ap, fmt);\n    vfprintf (f, fmt, ap);\n    va_end (ap);\n    fputc('\\n', f);\n    fclose (f);\n}\n\nstatic size_t\nget_rq_param_unquoted_copy_z (const struct MHD_RqDAuthParam *param, char *buf)\n{\n    size_t len;\n\n    /* Entry probe: capture pointer and length state */\n    log_probe (\"enter: param=%p value.str=%p value.len=%zu quoted=%d buf=%p\",\n               (void *) param,\n               (void *) (param ? param->value.str : NULL),\n               (param ? param->value.len : (size_t)0u),\n               (param ? param->quoted : 0),\n               (void *) buf);\n\n    /* Original assertion: log before and after to detect no-op assertions. */\n    log_probe (\"before assert: NULL != param->value.str\");\n    mhd_assert_local (NULL != param->value.str);\n    log_probe (\"after assert: NULL != param->value.str (execution continued)\");\n\n    if (! param->quoted)\n    {\n        log_probe (\"branch: unquoted path taken. memcpy len=%zu\", param->value.len);\n        memcpy (buf, param->value.str, param->value.len);\n        buf [param->value.len] = 0;\n        log_probe (\"exit: returning %zu (unquoted)\", param->value.len);\n        return param->value.len;\n    }\n\n    /* Quoted path: capture the result of unquoting. */\n    len = MHD_str_unquote (param->value.str, param->value.len, buf);\n    log_probe (\"after MHD_str_unquote: len=%zu original_len=%zu\",\n               len, param->value.len);\n\n    log_probe (\"before assert: 0 != len\");\n    mhd_assert_local (0 != len);\n    log_probe (\"after assert: 0 != len (execution continued)\");\n\n    log_probe (\"before assert: len < param->value.len (len=%zu param_len=%zu)\",\n               len, param->value.len);\n    mhd_assert_local (len < param->value.len);\n    log_probe (\"after assert: len < param->value.len (execution continued)\");\n\n    buf[len] = 0;\n    log_probe (\"exit: returning %zu (quoted)\", len);\n    return len;\n}\n",
  "explanation": "The build error was caused by a name collision with a macro named mhd_assert (from an included header). Defining a function with the same name led to macro expansion and syntax errors. I renamed the local assert wrapper to mhd_assert_local and updated all calls to use the new name. I also added minimal type declarations and a prototype for MHD_str_unquote plus necessary includes so the translation unit compiles on its own. The original logic of get_rq_param_unquoted_copy_z is otherwise unchanged."
}