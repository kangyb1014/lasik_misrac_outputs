{
  "user_message": "An agent A claimed that the following get_rq_param_unquoted_copy_z code violates the MISRA C 2023 rule 21.17.\n<misra_rule>\nMISRA C 2023 Rule 21.17 is Use of the string handling functions from <string.h> shall not result in accesses beyond the bounds of the objects referenced by their pointer parameters.\nThis rule strictly applies to the Standard Library functions in <string.h> such as memcpy, memmove, memset, memcmp, strcpy, strncpy, strcat, strncat, strlen, and strspn.\n</misra_rule>\n<target_code>\nHere is the original code of get_rq_param_unquoted_copy_z.\n```c\nstatic size_t\nget_rq_param_unquoted_copy_z (const struct MHD_RqDAuthParam *param, char *buf)\n{\n  size_t len;\n  mhd_assert (NULL != param->value.str);\n  if (! param->quoted)\n  {\n    memcpy (buf, param->value.str, param->value.len);\n    buf [param->value.len] = 0;\n    return param->value.len;\n  }\n\n  len = MHD_str_unquote (param->value.str, param->value.len, buf);\n  mhd_assert (0 != len);\n  mhd_assert (len < param->value.len);\n  buf[len] = 0;\n  return len;\n}\n```\n</target_code>\n<response format>\nProvide your answer with these fields.\n- explanation: your evaluation of the scenario provided by the agent A.\n- is_report_correct: whether the report is correct or not (true/false). True means there is a violation.\n</response format>\n<scenario>\nThe agent A provided the following violation scenario:\nViolation: memcpy copies param->value.len bytes into buf without any information or check of buf\u2019s allocated size (the function has no buf length parameter). If the caller provides a buffer smaller than param->value.len + 1, the memcpy (and the subsequent buf[param->value.len] = 0) will write beyond buf. Likewise, if param->value.str is shorter than param->value.len, memcpy will read beyond the source. Because bounds are not guaranteed/checked, this use can result in out-of-bounds accesses.\n</scenario>\n\n<execution_log>\nThe agent A also provided the following output log:\nENTER: get_rq_param_unquoted_copy_z: param=0x7f6c7c008a78 value.str=0x7f6c7c000e7d value.len=8 quoted=0 buf=0x7f6c7c009230\nBRANCH: unquoted: about to memcpy(buf, value.str, value.len) with value.len=8\nACTION: memcpy done: attempted copy_len=8 wrote_nul_at_index=8 returning=8\nENTER: get_rq_param_unquoted_copy_z: param=0x7fa530008c38 value.str=0x7fa530000e4a value.len=8 quoted=0 buf=0x7fa530009250\nBRANCH: unquoted: about to memcpy(buf, value.str, value.len) with value.len=8\nACTION: memcpy done: attempted copy_len=8 wrote_nul_at_index=8 returning=8\n\n</execution_log>\n\n<instruction>\nJudge whether the report is correct or not.\n</instruction>\n",
  "is_report_correct": true,
  "explanation": "The report is correct. The function calls memcpy(buf, param->value.str, param->value.len) and then writes buf[param->value.len] = 0 without any check or parameter that guarantees buf is large enough to receive param->value.len + 1 bytes. Likewise, memcpy reads param->value.len bytes from param->value.str without any check that the source object actually contains that many bytes. The only protections in the code are mhd_assert checks (and an assert in the quoted branch that only applies after unquoting); assertions are not a static or production guarantee and do not eliminate the potential for out\u2011of\u2011bounds accesses. Absent an external, provable contract that the caller always supplies a buffer of at least param->value.len+1 bytes and that param->value.len reflects the actual allocated size of value.str, this use of memcpy/array write can result in accesses beyond object bounds and therefore violates MISRA C 2023 Rule 21.17."
}