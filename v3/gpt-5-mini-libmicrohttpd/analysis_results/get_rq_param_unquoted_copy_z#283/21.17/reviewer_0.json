{
  "user_message": "An agent A claimed that the following get_rq_param_unquoted_copy_z code violates the MISRA C 2023 rule 21.17.\n<misra_rule>\nMISRA C 2023 Rule 21.17 is Use of the string handling functions from <string.h> shall not result in accesses beyond the bounds of the objects referenced by their pointer parameters.\nThis rule strictly applies to the Standard Library functions in <string.h> such as memcpy, memmove, memset, memcmp, strcpy, strncpy, strcat, strncat, strlen, and strspn.\n</misra_rule>\n<target_code>\nHere is the original code of get_rq_param_unquoted_copy_z.\n```c\nstatic size_t\nget_rq_param_unquoted_copy_z (const struct MHD_RqDAuthParam *param, char *buf)\n{\n  size_t len;\n  mhd_assert (NULL != param->value.str);\n  if (! param->quoted)\n  {\n    memcpy (buf, param->value.str, param->value.len);\n    buf [param->value.len] = 0;\n    return param->value.len;\n  }\n\n  len = MHD_str_unquote (param->value.str, param->value.len, buf);\n  mhd_assert (0 != len);\n  mhd_assert (len < param->value.len);\n  buf[len] = 0;\n  return len;\n}\n```\n</target_code>\n<response format>\nProvide your answer with these fields.\n- explanation: your evaluation of the scenario provided by the agent A.\n- is_report_correct: whether the report is correct or not (true/false). True means there is a violation.\n</response format>\n<scenario>\nThe agent A provided the following violation scenario:\nThe code calls memcpy(buf, param->value.str, param->value.len) and then writes buf[param->value.len] = 0 without any guarantee that buf has space for an additional NUL. If buf refers to an object sized exactly param->value.len (or smaller), the subsequent write (and possibly the memcpy itself if buf is smaller than param->value.len) will access beyond the bounds of the object. Since memcpy (from <string.h>) is used, this can violate MISRA C 2023 Rule 21.17.\n</scenario>\n\n<instruction>\nJudge whether the report is correct or not.\n</instruction>\n",
  "is_report_correct": true,
  "explanation": "The report is correct. The function copies param->value.len bytes into buf with memcpy and then writes a terminating NUL at buf[param->value.len] without any parameter or check that buf has space for param->value.len+1 bytes. MISRA C 2023 Rule 21.17 prohibits uses of string.h functions that may access beyond object bounds; here memcpy (and the subsequent NUL store) can overrun buf if the caller supplied a buffer of size param->value.len (or smaller). The quoted branch does not alleviate the problem: it asserts that the unquoted length is less than param->value.len, which means a buffer of size param->value.len would be sufficient in the quoted case but not in the unquoted case, so the function is inconsistent and unsafe unless an external contract (not shown) guarantees buf has at least param->value.len+1 bytes. To fix: pass the buffer size to the function and check it before memcpy (or otherwise guarantee the required size)."
}