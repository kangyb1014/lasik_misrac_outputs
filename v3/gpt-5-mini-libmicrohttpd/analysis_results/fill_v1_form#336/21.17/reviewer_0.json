{
  "user_message": "An agent A claimed that the following fill_v1_form code violates the MISRA C 2023 rule 21.17.\n<misra_rule>\nMISRA C 2023 Rule 21.17 is Use of the string handling functions from <string.h> shall not result in accesses beyond the bounds of the objects referenced by their pointer parameters.\nThis rule strictly applies to the Standard Library functions in <string.h> such as memcpy, memmove, memset, memcmp, strcpy, strncpy, strcat, strncat, strlen, and strspn.\n</misra_rule>\n<target_code>\nHere is the original code of fill_v1_form.\n```c\nstatic enum MHD_Result\nfill_v1_form (const void *cls,\n              const char *mime,\n              struct Session *session,\n              struct MHD_Connection *connection)\n{\n  enum MHD_Result ret;\n  size_t slen;\n  char *reply;\n  struct MHD_Response *response;\n  (void) cls; /* Unused. Silent compiler warning. */\n\n  slen = strlen (MAIN_PAGE) + strlen (session->value_1);\n  reply = malloc (slen + 1);\n  if (NULL == reply)\n    return MHD_NO;\n  snprintf (reply,\n            slen + 1,\n            MAIN_PAGE,\n            session->value_1);\n  /* return static form */\n  response =\n    MHD_create_response_from_buffer_with_free_callback (slen,\n                                                        (void *) reply,\n                                                        &free);\n  if (NULL == response)\n  {\n    free (reply);\n    return MHD_NO;\n  }\n  add_session_cookie (session, response);\n  if (MHD_YES !=\n      MHD_add_response_header (response,\n                               MHD_HTTP_HEADER_CONTENT_ENCODING,\n                               mime))\n  {\n    fprintf (stderr,\n             \"Failed to set content encoding header!\\n\");\n  }\n  ret = MHD_queue_response (connection,\n                            MHD_HTTP_OK,\n                            response);\n  MHD_destroy_response (response);\n  return ret;\n}\n```\n</target_code>\n<response format>\nProvide your answer with these fields.\n- explanation: your evaluation of the scenario provided by the agent A.\n- is_report_correct: whether the report is correct or not (true/false). True means there is a violation.\n</response format>\n<scenario>\nThe agent A provided the following violation scenario:\nThe allocation size is computed as strlen(MAIN_PAGE) + strlen(session->value_1) + 1, but snprintf is used with MAIN_PAGE as a format string. If MAIN_PAGE contains more than one %s (or other format specifiers that expand), the allocated buffer can be too small. Example: MAIN_PAGE = \"%s %s\" (strlen = 5), session->value_1 = \"ABCDEFG\" (strlen = 7). slen = 5 + 7 = 12, allocation = slen + 1 = 13 bytes, but the formatted result needs 15 bytes for content + 1 for NUL = 16 bytes, so snprintf will write beyond the allocated buffer \u2014 violating Rule 21.17.\n</scenario>\n\n<instruction>\nJudge whether the report is correct or not.\n</instruction>\n",
  "is_report_correct": false,
  "explanation": "Agent A correctly identified a real bug (the code computes the allocation as strlen(MAIN_PAGE) + strlen(session->value_1) but then treats MAIN_PAGE as a printf-style format: if MAIN_PAGE contains additional or different format specifiers the produced output length can differ from that sum, and if MAIN_PAGE expects more arguments the call is undefined behavior). However, MISRA C:2023 Rule 21.17 as quoted applies to the string-handling functions in <string.h> (the rule text explicitly lists functions such as memcpy, strcpy, strlen, etc.). The actual out\u2011of\u2011bounds risk here would be caused by snprintf (a <stdio.h> function) writing more characters than the allocated buffer or by the undefined behavior of mismatched format arguments \u2014 not by a <string.h> function accessing beyond an object\u2019s bounds. Therefore blaming Rule 21.17 is not correct. The report is incorrect in its choice of MISRA rule, even though the code does contain a distinct safety/undefined\u2011behavior bug. Recommended fixes: ensure MAIN_PAGE is not used as a format string (e.g. use a literal format \"%s\" and treat MAIN_PAGE as data), or determine the required formatted length safely (e.g. call snprintf(NULL,0,...) to obtain needed length or use a safe allocation API) and then allocate that size before producing the formatted output."
}