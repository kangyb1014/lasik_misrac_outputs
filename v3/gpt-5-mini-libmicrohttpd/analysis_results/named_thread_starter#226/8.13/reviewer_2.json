{
  "user_message": "An agent A claimed that the following named_thread_starter code violates the MISRA C 2023 rule 8.13.\n<misra_rule>\nMISRA C 2023 Rule 8.13 is A pointer should point to a const-qualified type whenever possible.\n\n</misra_rule>\n<target_code>\nHere is the original code of named_thread_starter.\n```c\nstatic MHD_THRD_RTRN_TYPE_ MHD_THRD_CALL_SPEC_\nnamed_thread_starter (void *data)\n{\n  struct MHD_named_helper_param_ *const param =\n    (struct MHD_named_helper_param_ *) data;\n  void *arg;\n  MHD_THREAD_START_ROUTINE_ thr_func;\n\n  if (NULL == data)\n    return (MHD_THRD_RTRN_TYPE_) 0;\n\n  MHD_set_cur_thread_name_ (param->name);\n\n  arg = param->arg;\n  thr_func = param->start_routine;\n  free (data);\n\n  return thr_func (arg);\n}\n```\n</target_code>\n<response format>\nProvide your answer with these fields.\n- explanation: your evaluation of the scenario provided by the agent A.\n- is_report_correct: whether the report is correct or not (true/false). True means there is a violation.\n</response format>\n<scenario>\nThe agent A provided the following violation scenario:\nThe parameter 'data' is declared as void * but the function only reads the pointed-to object's fields (param->name, param->arg, param->start_routine) and does not modify its contents. According to MISRA C 2023 Rule 8.13, the pointer should point to a const-qualified type whenever possible \u2014 e.g. const void *data (and use a pointer to const struct). Declaring it non-const therefore violates the rule. Note: if the function's intent is to take ownership and free the allocation (as it does), keeping a non-const parameter may be justified, but the presented code as written (no modification of object contents before free) still violates the \u201cpointer should be const when possible\u201d guidance.\n</scenario>\n\n<instruction>\nJudge whether the report is correct or not.\n</instruction>\n",
  "is_report_correct": false,
  "explanation": "The report is not correct. MISRA C 2023 R8.13 recommends using pointers to const when the pointed-to object is only inspected. In this function the parameter is used to take ownership of a heap allocation and free it (free(data)). Because the function frees the allocation (and potentially passes the non-const pointer to interfaces that expect void *), the pointed-to object cannot be treated as const without forcing a cast-away-const when calling free \u2014 which would be inappropriate. Thus marking the pointer non-const here is justified and the rule is not violated in this context."
}