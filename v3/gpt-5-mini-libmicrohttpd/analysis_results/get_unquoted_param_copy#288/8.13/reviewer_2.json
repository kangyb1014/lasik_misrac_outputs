{
  "user_message": "An agent A claimed that the following get_unquoted_param_copy code violates the MISRA C 2023 rule 8.13.\n<misra_rule>\nMISRA C 2023 Rule 8.13 is A pointer should point to a const-qualified type whenever possible.\n\n</misra_rule>\n<target_code>\nHere is the original code of get_unquoted_param_copy.\n```c\nstatic enum _MHD_GetUnqResult\nget_unquoted_param_copy (const struct MHD_RqDAuthParam *param,\n                         char tmp1[_MHD_STATIC_UNQ_BUFFER_SIZE],\n                         char **ptmp2,\n                         size_t *ptmp2_size,\n                         struct _MHD_mstr_w_len *unquoted)\n{\n  mhd_assert (NULL != param->value.str);\n  mhd_assert (0 != param->value.len);\n\n  /* The value is present and is quoted, needs to be copied and unquoted */\n  /* Allocate buffer with one more additional byte for zero-termination */\n  unquoted->str =\n    get_buffer_for_size (tmp1, ptmp2, ptmp2_size, param->value.len + 1);\n\n  if (NULL == unquoted->str)\n    return (param->value.len + 1 > _MHD_AUTH_DIGEST_MAX_PARAM_SIZE) ?\n           _MHD_UNQ_TOO_LARGE : _MHD_UNQ_OUT_OF_MEM;\n\n  if (! param->quoted)\n  {\n    memcpy (unquoted->str, param->value.str, param->value.len);\n    unquoted->len = param->value.len;\n    return _MHD_UNQ_OK;\n  }\n\n  unquoted->len =\n    MHD_str_unquote (param->value.str, param->value.len, unquoted->str);\n  mhd_assert (0 != unquoted->len);\n  mhd_assert (unquoted->len < param->value.len);\n  return _MHD_UNQ_OK;\n}\n```\n</target_code>\n<response format>\nProvide your answer with these fields.\n- explanation: your evaluation of the scenario provided by the agent A.\n- is_report_correct: whether the report is correct or not (true/false). True means there is a violation.\n</response format>\n<scenario>\nThe agent A provided the following violation scenario:\nIf the member param->value.str is declared as 'char *' (not 'const char *') and it is used only as an input to MHD_str_unquote (i.e. the function does not modify the source), then Rule 8.13 is violated: the pointer should be to a const-qualified type (const char *) because the data is only read. For example, with struct MHD_RqDAuthParam { char *str; size_t len; } and MHD_str_unquote(src, len, dst) reading from src, passing param->value.str should use const char * to satisfy MISRA C 2023 Rule 8.13.\n</scenario>\n\n<instruction>\nJudge whether the report is correct or not.\n</instruction>\n",
  "is_report_correct": false,
  "explanation": "The claim is speculative and cannot be confirmed from the shown function alone. The function receives a pointer to const struct MHD_RqDAuthParam (good), and it only reads param->value.str; that use does not itself violate MISRA 8.13. MISRA Rule 8.13 concerns how pointers are declared. If the struct member value.str is actually declared as char * but the pointed data is never modified anywhere (i.e. it is only read), then the declaration of the member should indeed be const char * and that declaration would violate 8.13. However, the reported violation lies in the definition of MHD_RqDAuthParam (not in get_unquoted_param_copy as shown), and you must inspect that type and all uses of value.str to decide whether it can be const. If value.str is written to elsewhere (or must be mutable for other reasons), declaring it const would be incorrect. Therefore the agent\u2019s claim is not provably correct based on the provided code; it is only potentially correct if the struct member is non-const and never modified."
}