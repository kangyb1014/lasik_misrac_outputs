{
  "user_message": "An agent A claimed that the following get_unquoted_param_copy code violates the MISRA C 2023 rule 2.2.\n<misra_rule>\nMISRA C 2023 Rule 2.2 is A project shall not contain dead code.\nAny operation that is executed but whose removal would not affect program behaviour constitutes dead code. Notes:\n1. The behaviour of an embedded sytem is often determined not just by the nature of its actions, but also by the time at which they occur.\n2. unreachable code is not dead code, as it cannot be executed.\n3.Initialization is not the same as an assignment operation and is therfore not a candidate for dead code.\n</misra_rule>\n<target_code>\nHere is the original code of get_unquoted_param_copy.\n```c\nstatic enum _MHD_GetUnqResult\nget_unquoted_param_copy (const struct MHD_RqDAuthParam *param,\n                         char tmp1[_MHD_STATIC_UNQ_BUFFER_SIZE],\n                         char **ptmp2,\n                         size_t *ptmp2_size,\n                         struct _MHD_mstr_w_len *unquoted)\n{\n  mhd_assert (NULL != param->value.str);\n  mhd_assert (0 != param->value.len);\n\n  /* The value is present and is quoted, needs to be copied and unquoted */\n  /* Allocate buffer with one more additional byte for zero-termination */\n  unquoted->str =\n    get_buffer_for_size (tmp1, ptmp2, ptmp2_size, param->value.len + 1);\n\n  if (NULL == unquoted->str)\n    return (param->value.len + 1 > _MHD_AUTH_DIGEST_MAX_PARAM_SIZE) ?\n           _MHD_UNQ_TOO_LARGE : _MHD_UNQ_OUT_OF_MEM;\n\n  if (! param->quoted)\n  {\n    memcpy (unquoted->str, param->value.str, param->value.len);\n    unquoted->len = param->value.len;\n    return _MHD_UNQ_OK;\n  }\n\n  unquoted->len =\n    MHD_str_unquote (param->value.str, param->value.len, unquoted->str);\n  mhd_assert (0 != unquoted->len);\n  mhd_assert (unquoted->len < param->value.len);\n  return _MHD_UNQ_OK;\n}\n```\n</target_code>\n<response format>\nProvide your answer with these fields.\n- explanation: your evaluation of the scenario provided by the agent A.\n- is_report_correct: whether the report is correct or not (true/false). True means there is a violation.\n</response format>\n<scenario>\nThe agent A provided the following violation scenario:\nThe assertion mhd_assert(0 != param->value.len) can constitute dead code if mhd_assert is a side\u2011effect\u2011free check (e.g. expands to an expression that only tests the condition or to (void)0 in some builds). In that case the statement is executed only to verify an invariant and has no effect on normal program behaviour; removing it would not change the program\u2019s behaviour (except removing the runtime check), so it meets the definition of dead code and thus violates Rule 2.2. (If, conversely, mhd_assert is implemented to produce a visible effect on failure\u2014terminate, log, etc.\u2014then its removal would change behaviour and it would not be dead code.)\n</scenario>\n\n<instruction>\nJudge whether the report is correct or not.\n</instruction>\n",
  "is_report_correct": false,
  "explanation": "The report is not conclusively correct. MISRA Rule 2.2 targets executed operations whose removal would not affect program behaviour. Whether the assertions are \u201cdead code\u201d depends entirely on how mhd_assert is defined:\n\n- If mhd_assert expands to a runtime check that performs a visible effect on failure (abort, log, trap, call a handler), then the assertion is an executed operation that can alter behaviour on failure and is not dead code. Removing it would change behaviour in failure paths.\n- If mhd_assert expands to nothing in production builds (e.g. ((void)0)), then the assertion statement is not executed at all; per the rule notes unreachable/not-executed code is not considered dead code in this sense.\n- If mhd_assert expands to an expression that merely evaluates the condition at runtime but has no observable side effects (for example ((void)(cond))), then it would be an executed operation whose removal would not change normal program behaviour, and that would meet the definition of dead code.\n\nGiven only the excerpt, the definition of mhd_assert is unknown, so you cannot determine a Rule 2.2 violation from the code alone. To decide, inspect the mhd_assert macro/implementation in the build/configuration used. If it is side-effect-free and executed, then Agent A\u2019s scenario would be correct; otherwise the report is incorrect."
}