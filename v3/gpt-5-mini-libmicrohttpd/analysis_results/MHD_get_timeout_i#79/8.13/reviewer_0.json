{
  "user_message": "An agent A claimed that the following MHD_get_timeout_i code violates the MISRA C 2023 rule 8.13.\n<misra_rule>\nMISRA C 2023 Rule 8.13 is A pointer should point to a const-qualified type whenever possible.\n\n</misra_rule>\n<target_code>\nHere is the original code of MHD_get_timeout_i.\n```c\n_MHD_EXTERN int\nMHD_get_timeout_i (struct MHD_Daemon *daemon)\n{\n#if SIZEOF_INT >= SIZEOF_INT64_T\n  return MHD_get_timeout64s (daemon);\n#else  /* SIZEOF_INT < SIZEOF_INT64_T */\n  const int64_t to64 = MHD_get_timeout64s (daemon);\n  if (INT_MAX >= to64)\n    return (int) to64;\n  return INT_MAX;\n#endif /* SIZEOF_INT < SIZEOF_INT64_T */\n}\n```\n</target_code>\n<response format>\nProvide your answer with these fields.\n- explanation: your evaluation of the scenario provided by the agent A.\n- is_report_correct: whether the report is correct or not (true/false). True means there is a violation.\n</response format>\n<scenario>\nThe agent A provided the following violation scenario:\nThe function parameter is declared as a non-const pointer: 'struct MHD_Daemon *daemon', yet in the body the parameter is only read (passed to MHD_get_timeout64s and never modified). Therefore the pointer could be declared 'const struct MHD_Daemon *daemon'. As written, Rule 8.13 is violated unless there is an external reason (e.g. MHD_get_timeout64s requires a non-const pointer) preventing adding const.\n</scenario>\n\n<instruction>\nJudge whether the report is correct or not.\n</instruction>\n",
  "is_report_correct": false,
  "explanation": "MISRA C 2023 Rule 8.13 says a pointer should point to a const-qualified type whenever possible. In the shown body, the parameter daemon is only read (it is passed to MHD_get_timeout64s and never modified), so superficially the parameter could be const. However, from the snippet alone you cannot determine whether changing the parameter to const is possible: if the declared prototype of MHD_get_timeout64s accepts a (non-const) struct MHD_Daemon * then making MHD_get_timeout_i\u2019s parameter const would prevent a direct call (you would have to cast away const or change the callee signature). If MHD_get_timeout64s already accepts a const struct MHD_Daemon * (or if you can safely change the public API), then the current non-const parameter is inconsistent with 8.13 and should be made const. Because the provided code alone does not include the declaration of MHD_get_timeout64s or information about API compatibility, the agent\u2019s definitive claim of a violation is not proven. You must inspect the prototype of MHD_get_timeout64s and the intended public API to decide whether the parameter can (and should) be const."
}