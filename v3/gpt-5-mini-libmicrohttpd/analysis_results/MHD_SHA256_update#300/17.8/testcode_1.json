{
  "user_message": "<misra_rule>\nMISRA C 2023 Rule 17.8 is: A function parameter should not be modified.\nNote that the object referred to by a pointer parameter may be modified, but the pointer itself shall not be modified.\n</misra_rule>\n\nAnother agent reported that the target code violated the Rule 17.8.\nHere is the comment from the agent.\n<violation scenario>\nThe statement 'length -= bytes_left;' modifies the function parameter 'length'. MISRA C 2023 Rule 17.8 requires that function parameters not be modified (pointer objects pointed-to may be modified but the parameter itself shall not). Therefore this line violates Rule 17.8.\n</violation scenario>\n\nYour job is to insert logging code to capture the control flow and state information of the program.\nInsert logging code so that other agents can reproduce and get evidence for the violation scenario.\n<response format>\n- test_code: a modified MHD_SHA256_update code that contains useful probe functions that print useful logs to a file \"/tmp/logs/3007.txt\". The logs should contain the control path and state information of the violation scenario. If test code is not required to validate the scenario, you can leave this blank.\nHere are the constraints for the test code:\n- The test code MUST preserve the original logic of MHD_SHA256_update as much as possible.\nYou CAN just insert probe functions to the original code.\n- DO NOT introduce new violations to demonstrate your scenario.\n- The test code MUST be compilable and executable.\n- The test code MUST include line breaks.\n- You MUST NOT define the main function.\n- You MUST NOT define macros.\n</response format>\n<target_code>\nHere is the code of MHD_SHA256_update:\n```c\nvoid\nMHD_SHA256_update (struct Sha256Ctx *ctx,\n                   const uint8_t *data,\n                   size_t length)\n{\n  unsigned bytes_have; /**< Number of bytes in buffer */\n\n  mhd_assert ((data != NULL) || (length == 0));\n\n#ifndef MHD_FAVOR_SMALL_CODE\n  if (0 == length)\n    return; /* Shortcut, do nothing */\n#endif /* MHD_FAVOR_SMALL_CODE */\n\n  /* Note: (count & (SHA256_BLOCK_SIZE-1))\n           equals (count % SHA256_BLOCK_SIZE) for this block size. */\n  bytes_have = (unsigned) (ctx->count & (SHA256_BLOCK_SIZE - 1));\n  ctx->count += length;\n\n  if (0 != bytes_have)\n  {\n    unsigned bytes_left = SHA256_BLOCK_SIZE - bytes_have;\n    if (length >= bytes_left)\n    {     /* Combine new data with data in the buffer and\n             process full block. */\n      memcpy (((uint8_t *) ctx->buffer) + bytes_have,\n              data,\n              bytes_left);\n      data += bytes_left;\n      length -= bytes_left;\n      sha256_transform (ctx->H, ctx->buffer);\n      bytes_have = 0;\n    }\n  }\n\n  while (SHA256_BLOCK_SIZE <= length)\n  {   /* Process any full blocks of new data directly,\n         without copying to the buffer. */\n    sha256_transform (ctx->H, data);\n    data += SHA256_BLOCK_SIZE;\n    length -= SHA256_BLOCK_SIZE;\n  }\n\n  if (0 != length)\n  {   /* Copy incomplete block of new data (if any)\n         to the buffer. */\n    memcpy (((uint8_t *) ctx->buffer) + bytes_have, data, length);\n  }\n}\n```\n</target_code>\nPlease provide the modified MHD_SHA256_update code.\n",
  "test_code": "#include <stdio.h>\n#include <stdarg.h>\n#include <stdint.h>\n#include <stddef.h>\n#include <string.h>\n\n/* Helper probe function: append a formatted log message to the required file. */\nstatic void mhd_log_probe(const char *fmt, ...)\n{\n    FILE *f = fopen(\"/tmp/logs/3007.txt\", \"a\");\n    if (f == NULL)\n    {\n        /* If logging cannot be opened, silently return to avoid side-effects. */\n        return;\n    }\n    va_list ap;\n    va_start(ap, fmt);\n    vfprintf(f, fmt, ap);\n    va_end(ap);\n    fputs(\"\\n\", f);\n    fclose(f);\n}\n\nvoid\nMHD_SHA256_update (struct Sha256Ctx *ctx,\n                   const uint8_t *data,\n                   size_t length)\n{\n  unsigned bytes_have; /**< Number of bytes in buffer */\n\n  /* Log entry with initial state */\n  mhd_log_probe(\"ENTER MHD_SHA256_update: ctx=%p, data=%p, length=%zu, ctx->count=%llu\",\n                (void *)ctx, (const void *)data, length, (unsigned long long)ctx->count);\n\n  mhd_assert ((data != NULL) || (length == 0));\n\n#ifndef MHD_FAVOR_SMALL_CODE\n  if (0 == length)\n  {\n    mhd_log_probe(\"EARLY RETURN: length == 0\");\n    return; /* Shortcut, do nothing */\n  }\n#endif /* MHD_FAVOR_SMALL_CODE */\n\n  /* Note: (count & (SHA256_BLOCK_SIZE-1))\n           equals (count % SHA256_BLOCK_SIZE) for this block size. */\n  bytes_have = (unsigned) (ctx->count & (SHA256_BLOCK_SIZE - 1));\n\n  /* Log before modifying ctx->count */\n  mhd_log_probe(\"BEFORE ctx->count += length: ctx->count=%llu, length=%zu\",\n                (unsigned long long)ctx->count, length);\n\n  ctx->count += length;\n\n  /* Log after modifying ctx->count */\n  mhd_log_probe(\"AFTER ctx->count += length: ctx->count=%llu, length=%zu\",\n                (unsigned long long)ctx->count, length);\n\n  if (0 != bytes_have)\n  {\n    unsigned bytes_left = SHA256_BLOCK_SIZE - bytes_have;\n    mhd_log_probe(\"INCOMPLETE BUFFER: bytes_have=%u, bytes_left=%u, length=%zu\",\n                  bytes_have, bytes_left, length);\n    if (length >= bytes_left)\n    {     /* Combine new data with data in the buffer and\n             process full block. */\n      mhd_log_probe(\"FILL BUFFER: will copy bytes_left=%u from data=%p to buffer+%u\",\n                    bytes_left, (const void *)data, bytes_have);\n      memcpy (((uint8_t *) ctx->buffer) + bytes_have,\n              data,\n              bytes_left);\n\n      /* Log state immediately before modifying data and length */\n      mhd_log_probe(\"BEFORE modify parameters: data=%p, length=%zu\",\n                    (const void *)data, length);\n\n      data += bytes_left;\n\n      /* Record previous length for clearer log */\n      {\n        size_t prev_length = length;\n        length -= bytes_left; /* <-- This is the modification of the parameter of interest */\n        mhd_log_probe(\"AFTER length -= bytes_left: previous_length=%zu, bytes_left=%u, new_length=%zu\",\n                      prev_length, bytes_left, length);\n      }\n\n      sha256_transform (ctx->H, ctx->buffer);\n      bytes_have = 0;\n    }\n    else\n    {\n      mhd_log_probe(\"NOT ENOUGH TO FILL BUFFER: bytes_left=%u, length=%zu\",\n                    bytes_left, length);\n    }\n  }\n\n  /* Process any full blocks of new data directly, without copying to the buffer. */\n  {\n    unsigned loop_count = 0;\n    while (SHA256_BLOCK_SIZE <= length)\n    {\n      mhd_log_probe(\"WHILE_ITER %u: length=%zu, data=%p: calling sha256_transform\",\n                    loop_count, length, (const void *)data);\n      sha256_transform (ctx->H, data);\n      data += SHA256_BLOCK_SIZE;\n\n      /* Record previous length and then subtract to make the log explicit */\n      {\n        size_t prev_length = length;\n        length -= SHA256_BLOCK_SIZE;\n        mhd_log_probe(\"WHILE_AFTER_ITER %u: prev_length=%zu, subtracted=%d, new_length=%zu\",\n                      loop_count, prev_length, SHA256_BLOCK_SIZE, length);\n      }\n      loop_count++;\n    }\n  }\n\n  if (0 != length)\n  {   /* Copy incomplete block of new data (if any)\n         to the buffer. */\n    mhd_log_probe(\"FINAL COPY: bytes_have=%u, remaining length=%zu, data=%p -> buffer+%u\",\n                  bytes_have, length, (const void *)data, bytes_have);\n    memcpy (((uint8_t *) ctx->buffer) + bytes_have, data, length);\n  }\n\n  mhd_log_probe(\"EXIT MHD_SHA256_update: ctx=%p, final length=%zu, ctx->count=%llu\",\n                (void *)ctx, length, (unsigned long long)ctx->count);\n}\n"
}