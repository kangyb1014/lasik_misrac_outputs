{
  "user_message": "An agent A claimed that the following MHD_SHA256_update code violates the MISRA C 2023 rule 17.8.\n<misra_rule>\nMISRA C 2023 Rule 17.8 is A function parameter should not be modified.\nNote that the object referred to by a pointer parameter may be modified, but the pointer itself shall not be modified.\n</misra_rule>\n<target_code>\nHere is the original code of MHD_SHA256_update.\n```c\nvoid\nMHD_SHA256_update (struct Sha256Ctx *ctx,\n                   const uint8_t *data,\n                   size_t length)\n{\n  unsigned bytes_have; /**< Number of bytes in buffer */\n\n  mhd_assert ((data != NULL) || (length == 0));\n\n#ifndef MHD_FAVOR_SMALL_CODE\n  if (0 == length)\n    return; /* Shortcut, do nothing */\n#endif /* MHD_FAVOR_SMALL_CODE */\n\n  /* Note: (count & (SHA256_BLOCK_SIZE-1))\n           equals (count % SHA256_BLOCK_SIZE) for this block size. */\n  bytes_have = (unsigned) (ctx->count & (SHA256_BLOCK_SIZE - 1));\n  ctx->count += length;\n\n  if (0 != bytes_have)\n  {\n    unsigned bytes_left = SHA256_BLOCK_SIZE - bytes_have;\n    if (length >= bytes_left)\n    {     /* Combine new data with data in the buffer and\n             process full block. */\n      memcpy (((uint8_t *) ctx->buffer) + bytes_have,\n              data,\n              bytes_left);\n      data += bytes_left;\n      length -= bytes_left;\n      sha256_transform (ctx->H, ctx->buffer);\n      bytes_have = 0;\n    }\n  }\n\n  while (SHA256_BLOCK_SIZE <= length)\n  {   /* Process any full blocks of new data directly,\n         without copying to the buffer. */\n    sha256_transform (ctx->H, data);\n    data += SHA256_BLOCK_SIZE;\n    length -= SHA256_BLOCK_SIZE;\n  }\n\n  if (0 != length)\n  {   /* Copy incomplete block of new data (if any)\n         to the buffer. */\n    memcpy (((uint8_t *) ctx->buffer) + bytes_have, data, length);\n  }\n}\n```\n</target_code>\n<response format>\nProvide your answer with these fields.\n- explanation: your evaluation of the scenario provided by the agent A.\n- is_report_correct: whether the report is correct or not (true/false). True means there is a violation.\n</response format>\n<scenario>\nThe agent A provided the following violation scenario:\nThe statement 'length -= bytes_left;' modifies the function parameter 'length'. MISRA C 2023 Rule 17.8 requires that function parameters not be modified (pointer objects pointed-to may be modified but the parameter itself shall not). Therefore this line violates Rule 17.8.\n</scenario>\n\n<execution_log>\nThe agent A also provided the following output log:\nENTER MHD_SHA256_update: ctx=0x7ffd34d26470, data=0x55a05a6e101b, length=3, ctx->count=0\nBEFORE ctx->count += length: ctx->count=0, length=3\nAFTER ctx->count += length: ctx->count=3, length=3\nFINAL COPY: bytes_have=0, remaining length=3, data=0x55a05a6e101b -> buffer+0\nEXIT MHD_SHA256_update: ctx=0x7ffd34d26470, final length=3, ctx->count=3\nENTER MHD_SHA256_update: ctx=0x7ffd34d26470, data=0x55a05a6e101f, length=56, ctx->count=0\nBEFORE ctx->count += length: ctx->count=0, length=56\nAFTER ctx->count += length: ctx->count=56, length=56\nFINAL COPY: bytes_have=0, remaining length=56, data=0x55a05a6e101f -> buffer+0\nEXIT MHD_SHA256_update: ctx=0x7ffd34d26470, final length=56, ctx->count=56\nENTER MHD_SHA256_update: ctx=0x7ffd34d26470, data=0x55a05a6e2ded, length=0, ctx->count=0\nEARLY RETURN: length == 0\nENTER MHD_SHA256_update: ctx=0x7ffd34d26470, data=0x55a05a6e1058, length=28, ctx->count=0\nBEFORE ctx->count += length: ctx->count=0, length=28\nAFTER ctx->count += length: ctx->count=28, length=28\nFINAL COPY: bytes_have=0, remaining length=28, data=0x55a05a6e1058 -> buffer+0\nEXIT MHD_SHA256_update: ctx=0x7ffd34d26470, final length=28, ctx->count=28\nENTER MHD_SHA256_update: ctx=0x7ffd34d26470, data=0x55a05a6e1075, length=14, ctx->count=0\nBEFORE ctx->count += length: ctx->count=0, length=14\nAFTER ctx->count += length: ctx->count=14, length=14\nFINAL COPY: bytes_have=0, remaining length=14, data=0x55a05a6e1075 -> buffer+0\nEXIT MHD_SHA256_update: ctx=0x7ffd34d26470, final length=14, ctx->count=14\nENTER MHD_SHA256_update: ctx=0x7ffd34d26470, data=0x55a05a6e1084, length=26, ctx->count=0\nBEFORE ctx->count += length: ctx->count=0, length=26\nAFTER ctx->count += length: ctx->count=26, length=26\nFINAL COPY: bytes_have=0, remaining length=26, data=0x55a05a6e1084 -> buffer+0\nEXIT MHD_SHA256_update: ctx=0x7ffd34d26470, final length=26, ctx->count=26\nENTER MHD_SHA256_update: ctx=0x7ffd34d26470, data=0x55a05a6e10ed, length=26, ctx->count=0\nBEFORE ctx->count += length: ctx->count=0, length=26\nAFTER ctx->count += length: ctx->count=26, length=26\nFINAL COPY: bytes_have=0, remaining length=26, data=0x55a05a6e10ed -> buffer+0\nEXIT MHD_SHA256_update: ctx=0x7ffd34d26470, final length=26, ctx->count=26\nENTER MHD_SHA256_update: ctx=0x7ffd34d26470, data=0x55a05a6e109f, length=104, ctx->count=0\nBEFORE ctx->count += length: ctx->count=0, length=104\nAFTER ctx->count += length: ctx->count=104, length=104\nWHILE_ITER 0: length=104, data=0x55a05a6e109f: calling sha256_transform\nWHILE_AFTER_ITER 0: prev_length=104, subtracted=64, new_length=40\nFINAL COPY: bytes_have=0, remaining length=40, data=0x55a05a6e10df -> buffer+0\nEXIT MHD_SHA256_update: ctx=0x7ffd34d26470, final length=40, ctx->count=104\nENTER MHD_SHA256_update: ctx=0x7ffd34d26470, data=0x55a05a6e1108, length=378, ctx->count=0\nBEFORE ctx->count += length: ctx->count=0, length=378\nAFTER ctx->count += length: ctx->count=378, length=378\nWHILE_ITER 0: length=378, data=0x55a05a6e1108: calling sha256_transform\nWHILE_AFTER_ITER 0: prev_length=378, subtracted=64, new_length=314\nWHILE_ITER 1: length=314, data=0x55a05a6e1148: calling sha256_transform\nWHILE_AFTER_ITER 1: prev_length=314, subtracted=64, new_length=250\nWHILE_ITER 2: length=250, data=0x55a05a6e1188: calling sha256_transform\nWHILE_AFTER_ITER 2: prev_length=250, subtracted=64, new_length=186\nWHILE_ITER 3: length=186, data=0x55a05a6e11c8: calling sha256_transform\nWHILE_AFTER_ITER 3: prev_length=186, subtracted=64, new_length=122\nWHILE_ITER 4: length=122, data=0x55a05a6e1208: calling sha256_transform\nWHILE_AFTER_ITER 4: prev_length=122, subtracted=64, new_length=58\nFINAL COPY: bytes_have=0, remaining length=58, data=0x55a05a6e1248 -> buffer+0\nEXIT MHD_SHA256_update: ctx=0x7ffd34d26470, final length=58, ctx->count=378\nENTER MHD_SHA256_update: ctx=0x7ffd34d26470, data=0x55a05a6e1380, length=26, ctx->count=0\nBEFORE ctx->count += length: ctx->count=0, length=26\nAFTER ctx->count += length: ctx->count=26, length=26\nFINAL COPY: bytes_have=0, remaining length=26, data=0x55a05a6e1380 -> buffer+0\nEXIT MHD_SHA256_update: ctx=0x7ffd34d26470, final length=26, ctx->count\n</execution_log>\n\n<instruction>\nJudge whether the report is correct or not.\n</instruction>\n",
  "is_report_correct": true,
  "explanation": "Agent A is correct. MISRA C 2023 Rule 17.8 states that function parameters shall not be modified (the pointer target may be modified but not the pointer itself). In MHD_SHA256_update the parameter 'length' is modified (e.g. length -= bytes_left; length -= SHA256_BLOCK_SIZE; and in the while loop), which violates the rule. Additionally, the pointer parameter 'data' is also modified via pointer arithmetic (data += bytes_left; data += SHA256_BLOCK_SIZE;), which likewise violates the rule (the pointer itself must not be modified). To comply, the function should copy parameters into local variables (for example: size_t rem = length; const uint8_t *p = data;) and operate on those locals instead."
}