{
  "user_message": "An agent A claimed that the following MHD_SHA256_update code violates the MISRA C 2023 rule 17.8.\n<misra_rule>\nMISRA C 2023 Rule 17.8 is A function parameter should not be modified.\nNote that the object referred to by a pointer parameter may be modified, but the pointer itself shall not be modified.\n</misra_rule>\n<target_code>\nHere is the original code of MHD_SHA256_update.\n```c\nvoid\nMHD_SHA256_update (struct Sha256Ctx *ctx,\n                   const uint8_t *data,\n                   size_t length)\n{\n  unsigned bytes_have; /**< Number of bytes in buffer */\n\n  mhd_assert ((data != NULL) || (length == 0));\n\n#ifndef MHD_FAVOR_SMALL_CODE\n  if (0 == length)\n    return; /* Shortcut, do nothing */\n#endif /* MHD_FAVOR_SMALL_CODE */\n\n  /* Note: (count & (SHA256_BLOCK_SIZE-1))\n           equals (count % SHA256_BLOCK_SIZE) for this block size. */\n  bytes_have = (unsigned) (ctx->count & (SHA256_BLOCK_SIZE - 1));\n  ctx->count += length;\n\n  if (0 != bytes_have)\n  {\n    unsigned bytes_left = SHA256_BLOCK_SIZE - bytes_have;\n    if (length >= bytes_left)\n    {     /* Combine new data with data in the buffer and\n             process full block. */\n      memcpy (((uint8_t *) ctx->buffer) + bytes_have,\n              data,\n              bytes_left);\n      data += bytes_left;\n      length -= bytes_left;\n      sha256_transform (ctx->H, ctx->buffer);\n      bytes_have = 0;\n    }\n  }\n\n  while (SHA256_BLOCK_SIZE <= length)\n  {   /* Process any full blocks of new data directly,\n         without copying to the buffer. */\n    sha256_transform (ctx->H, data);\n    data += SHA256_BLOCK_SIZE;\n    length -= SHA256_BLOCK_SIZE;\n  }\n\n  if (0 != length)\n  {   /* Copy incomplete block of new data (if any)\n         to the buffer. */\n    memcpy (((uint8_t *) ctx->buffer) + bytes_have, data, length);\n  }\n}\n```\n</target_code>\n<response format>\nProvide your answer with these fields.\n- explanation: your evaluation of the scenario provided by the agent A.\n- is_report_correct: whether the report is correct or not (true/false). True means there is a violation.\n</response format>\n<scenario>\nThe agent A provided the following violation scenario:\nThe statement 'data += SHA256_BLOCK_SIZE;' modifies the function parameter 'data' (a pointer parameter declared as 'const uint8_t *data'). MISRA C 2023 Rule 17.8 prohibits modifying function parameters\u2014the pointer itself shall not be changed (only the object it points to may be modified). This is a violation. A compliant fix is to use a local pointer copy (e.g. 'const uint8_t *p = data;') and advance 'p' instead of modifying the parameter.\n</scenario>\n\n<execution_log>\nThe agent A also provided the following output log:\nENTER MHD_SHA256_update: ctx=0x7ffd440f6520 data=0x55d19a01801b length=3\nbytes_have=0 ctx->count_before=0 length=3\nctx->count_after=3\nfinal partial copy: bytes_have=0 length=3 data=0x55d19a01801b -> memcpy to buffer+0\nfinal memcpy done\nEXIT MHD_SHA256_update: ctx=0x7ffd440f6520 final_length=3 final_data=0x55d19a01801b\nENTER MHD_SHA256_update: ctx=0x7ffd440f6520 data=0x55d19a01801f length=56\nbytes_have=0 ctx->count_before=0 length=56\nctx->count_after=56\nfinal partial copy: bytes_have=0 length=56 data=0x55d19a01801f -> memcpy to buffer+0\nfinal memcpy done\nEXIT MHD_SHA256_update: ctx=0x7ffd440f6520 final_length=56 final_data=0x55d19a01801f\nENTER MHD_SHA256_update: ctx=0x7ffd440f6520 data=0x55d19a019dfd length=0\nSHORTCUT: length == 0 -> return\nENTER MHD_SHA256_update: ctx=0x7ffd440f6520 data=0x55d19a018058 length=28\nbytes_have=0 ctx->count_before=0 length=28\nctx->count_after=28\nfinal partial copy: bytes_have=0 length=28 data=0x55d19a018058 -> memcpy to buffer+0\nfinal memcpy done\nEXIT MHD_SHA256_update: ctx=0x7ffd440f6520 final_length=28 final_data=0x55d19a018058\nENTER MHD_SHA256_update: ctx=0x7ffd440f6520 data=0x55d19a018075 length=14\nbytes_have=0 ctx->count_before=0 length=14\nctx->count_after=14\nfinal partial copy: bytes_have=0 length=14 data=0x55d19a018075 -> memcpy to buffer+0\nfinal memcpy done\nEXIT MHD_SHA256_update: ctx=0x7ffd440f6520 final_length=14 final_data=0x55d19a018075\nENTER MHD_SHA256_update: ctx=0x7ffd440f6520 data=0x55d19a018084 length=26\nbytes_have=0 ctx->count_before=0 length=26\nctx->count_after=26\nfinal partial copy: bytes_have=0 length=26 data=0x55d19a018084 -> memcpy to buffer+0\nfinal memcpy done\nEXIT MHD_SHA256_update: ctx=0x7ffd440f6520 final_length=26 final_data=0x55d19a018084\nENTER MHD_SHA256_update: ctx=0x7ffd440f6520 data=0x55d19a0180ed length=26\nbytes_have=0 ctx->count_before=0 length=26\nctx->count_after=26\nfinal partial copy: bytes_have=0 length=26 data=0x55d19a0180ed -> memcpy to buffer+0\nfinal memcpy done\nEXIT MHD_SHA256_update: ctx=0x7ffd440f6520 final_length=26 final_data=0x55d19a0180ed\nENTER MHD_SHA256_update: ctx=0x7ffd440f6520 data=0x55d19a01809f length=104\nbytes_have=0 ctx->count_before=0 length=104\nctx->count_after=104\nprocessing full block: data=0x55d19a01809f length=104\nafter processing block: data=0x55d19a0180df length=40\nfinal partial copy: bytes_have=0 length=40 data=0x55d19a0180df -> memcpy to buffer+0\nfinal memcpy done\nEXIT MHD_SHA256_update: ctx=0x7ffd440f6520 final_length=40 final_data=0x55d19a0180df\nENTER MHD_SHA256_update: ctx=0x7ffd440f6520 data=0x55d19a018108 length=378\nbytes_have=0 ctx->count_before=0 length=378\nctx->count_after=378\nprocessing full block: data=0x55d19a018108 length=378\nafter processing block: data=0x55d19a018148 length=314\nprocessing full block: data=0x55d19a018148 length=314\nafter processing block: data=0x55d19a018188 length=250\nprocessing full block: data=0x55d19a018188 length=250\nafter processing block: data=0x55d19a0181c8 length=186\nprocessing full block: data=0x55d19a0181c8 length=186\nafter processing block: data=0x55d19a018208 length=122\nprocessing full block: data=0x55d19a018208 length=122\nafter processing block: data=0x55d19a018248 length=58\nfinal partial copy: bytes_have=0 length=58 data=0x55d19a018248 -> memcpy to buffer+0\nfinal memcpy done\nEXIT MHD_SHA256_update: ctx=0x7ffd440f6520 final_length=58 final_data=0x55d19a018248\nENTER MHD_SHA256_update: ctx=0x7ffd440f6520 data=0x55d19a018380 length=26\nbytes_have=0 ctx->count_before=0 length=26\nctx->count_after=26\nfinal partial copy: bytes_have=0 length=26 data=0x55d19a018380 -> memcpy to buffer+0\nfinal memcpy done\nEXIT MHD_SHA256_update: ctx=0x7ffd440f6520 final_length=26 final_data=0x55d19a018380\nENTER MHD_SHA256_update: ctx=0x7ffd440f6520 data=0x55d19a0185a8 length=72\nbytes_have=0 ctx->count_before=0 length=72\nctx->count_after=72\nprocessing full block: data=0x55d19a0185a8 length=72\nafter processing block: data=0x55d19a0185e8 length=8\nfinal partial copy: bytes_have=0 length=8 data=0x55d19a0185e8 -> memcpy to buffer+0\nfinal memcpy done\nEXIT MHD_SHA256_update: ctx=0x7ffd440f6520 final_length=8 final_data\n</execution_log>\n\n<instruction>\nJudge whether the report is correct or not.\n</instruction>\n",
  "is_report_correct": true,
  "explanation": "The report is correct. MISRA C 2023 Rule 17.8 forbids modifying function parameters (the pointer object itself shall not be changed; modifying the object pointed-to is permitted). In MHD_SHA256_update the code updates the parameter variables: e.g. data += bytes_left; data += SHA256_BLOCK_SIZE; and length -= ... \u2014 these statements modify the parameter variables data and length. Even though data is a pointer-to-const (const uint8_t *), that only prevents modifying the pointee, not the pointer value; Rule 17.8 nevertheless disallows changing the parameter pointer. A compliant fix is to make local copies up front (e.g. const uint8_t *p = data; size_t len = length;) and operate on p and len instead of modifying the parameters."
}