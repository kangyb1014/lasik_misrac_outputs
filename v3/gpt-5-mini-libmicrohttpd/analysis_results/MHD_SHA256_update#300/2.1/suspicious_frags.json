{
  "user_message": "<misra_rule>\nThe target MISRA C 2023 Rule 2.1 is: A project shall not contain unreachable code.\n\n</misra_rule>\n<instruction>\nOther agents will judge whether the code follows the MISRA C 2023 guidelines.\nThey will investigate the code fragments you give.\nYour job is to find code fragments in the code that should be investigated to check whether the code follows the MISRA C rule.\n</instruction>\n<response format>\nProvide your answer with these fields.\n- suspicious_frags: The list of suspicious code fragments in the code.\nIt should contain only the code fragments exists in the code. If you do not find any suspicious code fragments, return an empty list for suspicious_frags\n- explanation: The explanation of why other code fragments should NOT be investigated.\nIt is very important to not miss any suspicious code fragments, so please give a sufficient explanation why other code fragments should not be investigated.\nDO NOT give any explanation for the selected suspicious code fragments.\n</response format>\n<target_code>\nHere is the code of MHD_SHA256_update:\n```c\nvoid\nMHD_SHA256_update (struct Sha256Ctx *ctx,\n                   const uint8_t *data,\n                   size_t length)\n{\n  unsigned bytes_have; /**< Number of bytes in buffer */\n\n  mhd_assert ((data != NULL) || (length == 0));\n\n#ifndef MHD_FAVOR_SMALL_CODE\n  if (0 == length)\n    return; /* Shortcut, do nothing */\n#endif /* MHD_FAVOR_SMALL_CODE */\n\n  /* Note: (count & (SHA256_BLOCK_SIZE-1))\n           equals (count % SHA256_BLOCK_SIZE) for this block size. */\n  bytes_have = (unsigned) (ctx->count & (SHA256_BLOCK_SIZE - 1));\n  ctx->count += length;\n\n  if (0 != bytes_have)\n  {\n    unsigned bytes_left = SHA256_BLOCK_SIZE - bytes_have;\n    if (length >= bytes_left)\n    {     /* Combine new data with data in the buffer and\n             process full block. */\n      memcpy (((uint8_t *) ctx->buffer) + bytes_have,\n              data,\n              bytes_left);\n      data += bytes_left;\n      length -= bytes_left;\n      sha256_transform (ctx->H, ctx->buffer);\n      bytes_have = 0;\n    }\n  }\n\n  while (SHA256_BLOCK_SIZE <= length)\n  {   /* Process any full blocks of new data directly,\n         without copying to the buffer. */\n    sha256_transform (ctx->H, data);\n    data += SHA256_BLOCK_SIZE;\n    length -= SHA256_BLOCK_SIZE;\n  }\n\n  if (0 != length)\n  {   /* Copy incomplete block of new data (if any)\n         to the buffer. */\n    memcpy (((uint8_t *) ctx->buffer) + bytes_have, data, length);\n  }\n}\n```\n</target_code>\nPlease find suspicious code fragments in the code and report them. Other agents can not investigate other fragments that you do not report, so it is very important to find all suspicious fragments without missing any. Report the suspicious fragments AS MUCH AS POSSIBLE.",
  "suspicious_frags": [],
  "explanation": "No code fragments in MHD_SHA256_update appear to be unreachable under the normal semantics of C and reasonable build configurations. Specific points reviewed and reasons they do not indicate unreachable code:\n\n- The preprocessor block (#ifndef MHD_FAVOR_SMALL_CODE ... return;) is conditional compilation, not unreachable code. When MHD_FAVOR_SMALL_CODE is not defined, the early return is reachable for the concrete input length == 0; when MHD_FAVOR_SMALL_CODE is defined, that code is simply not present in the translation unit. This is a compile-time inclusion choice, not an instance of code that can never execute in any build.\n\n- The mhd_assert((data != NULL) || (length == 0)); line may expand to nothing in non-debug builds, but that is a configurable assertion macro behavior, not unreachable code. The assertion itself does not create unreachable branches.\n\n- The if (0 != bytes_have) { ... } branch and its inner conditional (if (length >= bytes_left)) are reachable for inputs where ctx->count has a non-zero partial block and length is of the appropriate size. There is no code path that makes these branches impossible for all inputs.\n\n- The while (SHA256_BLOCK_SIZE <= length) loop and the final if (0 != length) memcpy are standard processing of full and partial blocks and are reachable depending on the runtime value of length.\n\n- No dead switches, empty return-after-labels, unconditional gotos, or mutually exclusive compile-time/execution constructs were found which would create code that cannot be reached in any possible build or runtime input.\n\nGiven the above, there are no fragments that need to be investigated for MISRA C 2023 Rule 2.1 (unreachable code) in the supplied function."
}