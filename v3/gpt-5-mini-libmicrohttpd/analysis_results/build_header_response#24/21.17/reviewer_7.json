{
  "user_message": "An agent A claimed that the following build_header_response code violates the MISRA C 2023 rule 21.17.\n<misra_rule>\nMISRA C 2023 Rule 21.17 is Use of the string handling functions from <string.h> shall not result in accesses beyond the bounds of the objects referenced by their pointer parameters.\nThis rule strictly applies to the Standard Library functions in <string.h> such as memcpy, memmove, memset, memcmp, strcpy, strncpy, strcat, strncat, strlen, and strspn.\n</misra_rule>\n<target_code>\nHere is the original code of build_header_response.\n```c\nstatic enum MHD_Result\nbuild_header_response (struct MHD_Connection *connection)\n{\n  struct MHD_Connection *const c = connection; /**< a short alias */\n  struct MHD_Response *const r = c->rp.response; /**< a short alias */\n  char *buf;                                     /**< the output buffer */\n  size_t pos;                                    /**< append offset in the @a buf */\n  size_t buf_size;                               /**< the size of the @a buf */\n  size_t el_size;                                /**< the size of current element to be added to the @a buf */\n  unsigned rcode;                                /**< the response code */\n  bool use_conn_close;                           /**< Use \"Connection: close\" header */\n  bool use_conn_k_alive;                         /**< Use \"Connection: Keep-Alive\" header */\n\n  mhd_assert (NULL != r);\n\n  /* ** Adjust response properties ** */\n  setup_reply_properties (c);\n\n  mhd_assert (c->rp.props.set);\n  mhd_assert ((MHD_CONN_MUST_CLOSE == c->keepalive) || \\\n              (MHD_CONN_USE_KEEPALIVE == c->keepalive) || \\\n              (MHD_CONN_MUST_UPGRADE == c->keepalive));\n#ifdef UPGRADE_SUPPORT\n  mhd_assert ((NULL == r->upgrade_handler) || \\\n              (MHD_CONN_MUST_UPGRADE == c->keepalive));\n#else  /* ! UPGRADE_SUPPORT */\n  mhd_assert (MHD_CONN_MUST_UPGRADE != c->keepalive);\n#endif /* ! UPGRADE_SUPPORT */\n  mhd_assert ((! c->rp.props.chunked) || c->rp.props.use_reply_body_headers);\n  mhd_assert ((! c->rp.props.send_reply_body) || \\\n              c->rp.props.use_reply_body_headers);\n#ifdef UPGRADE_SUPPORT\n  mhd_assert (NULL == r->upgrade_handler || \\\n              ! c->rp.props.use_reply_body_headers);\n#endif /* UPGRADE_SUPPORT */\n\n  check_connection_reply (c);\n\n  rcode = (unsigned) c->rp.responseCode;\n  if (MHD_CONN_MUST_CLOSE == c->keepalive)\n  {\n    /* The closure of connection must be always indicated by header\n     * to avoid hung connections */\n    use_conn_close = true;\n    use_conn_k_alive = false;\n  }\n  else if (MHD_CONN_USE_KEEPALIVE == c->keepalive)\n  {\n    use_conn_close = false;\n    /* Add \"Connection: keep-alive\" if request is HTTP/1.0 or\n     * if reply is HTTP/1.0\n     * For HTTP/1.1 add header only if explicitly requested by app\n     * (by response flag), as \"Keep-Alive\" is default for HTTP/1.1. */\n    if ((0 != (r->flags & MHD_RF_SEND_KEEP_ALIVE_HEADER)) ||\n        (MHD_HTTP_VER_1_0 == c->rq.http_ver) ||\n        (0 != (r->flags & MHD_RF_HTTP_1_0_SERVER)))\n      use_conn_k_alive = true;\n    else\n      use_conn_k_alive = false;\n  }\n  else\n  {\n    use_conn_close = false;\n    use_conn_k_alive = false;\n  }\n\n  /* ** Actually build the response header ** */\n\n  /* Get all space available */\n  connection_maximize_write_buffer (c);\n  buf = c->write_buffer;\n  pos = c->write_buffer_append_offset;\n  buf_size = c->write_buffer_size;\n  if (0 == buf_size)\n    return MHD_NO;\n  mhd_assert (NULL != buf);\n\n  /* * The status line * */\n\n  /* The HTTP version */\n  if (! c->rp.responseIcy)\n  { /* HTTP reply */\n    if (0 == (r->flags & MHD_RF_HTTP_1_0_SERVER))\n    { /* HTTP/1.1 reply */\n      /* Use HTTP/1.1 responses for HTTP/1.0 clients.\n       * See https://datatracker.ietf.org/doc/html/rfc7230#section-2.6 */\n      if (! buffer_append_s (buf, &pos, buf_size, MHD_HTTP_VERSION_1_1))\n        return MHD_NO;\n    }\n    else\n    { /* HTTP/1.0 reply */\n      if (! buffer_append_s (buf, &pos, buf_size, MHD_HTTP_VERSION_1_0))\n        return MHD_NO;\n    }\n  }\n  else\n  { /* ICY reply */\n    if (! buffer_append_s (buf, &pos, buf_size, \"ICY\"))\n      return MHD_NO;\n  }\n\n  /* The response code */\n  if (buf_size < pos + 5) /* space + code + space */\n    return MHD_NO;\n  buf[pos++] = ' ';\n  pos += MHD_uint16_to_str ((uint16_t) rcode, buf + pos,\n                            buf_size - pos);\n  buf[pos++] = ' ';\n\n  /* The reason phrase */\n  el_size = MHD_get_reason_phrase_len_for (rcode);\n  if (0 == el_size)\n  {\n    if (! buffer_append_s (buf, &pos, buf_size, \"Non-Standard Status\"))\n      return MHD_NO;\n  }\n  else if (! buffer_append (buf, &pos, buf_size,\n                            MHD_get_reason_phrase_for (rcode),\n                            el_size))\n    return MHD_NO;\n\n  /* The linefeed */\n  if (buf_size < pos + 2)\n    return MHD_NO;\n  buf[pos++] = '\\r';\n  buf[pos++] = '\\n';\n\n  /* * The headers * */\n\n  /* Main automatic headers */\n\n  /* The \"Date:\" header */\n  if ( (0 == (r->flags_auto & MHD_RAF_HAS_DATE_HDR)) &&\n       (0 == (c->daemon->options & MHD_USE_SUPPRESS_DATE_NO_CLOCK)) )\n  {\n    /* Additional byte for unused zero-termination */\n    if (buf_size < pos + 38)\n      return MHD_NO;\n    if (get_date_header (buf + pos))\n      pos += 37;\n  }\n  /* The \"Connection:\" header */\n  mhd_assert (! use_conn_close || ! use_conn_k_alive);\n  mhd_assert (! use_conn_k_alive || ! use_conn_close);\n  if (0 == (r->flags_auto & MHD_RAF_HAS_CONNECTION_HDR))\n  {\n    if (use_conn_close)\n    {\n      if (! buffer_append_s (buf, &pos, buf_size,\n                             MHD_HTTP_HEADER_CONNECTION \": close\\r\\n\"))\n        return MHD_NO;\n    }\n    else if (use_conn_k_alive)\n    {\n      if (! buffer_append_s (buf, &pos, buf_size,\n                             MHD_HTTP_HEADER_CONNECTION \": Keep-Alive\\r\\n\"))\n        return MHD_NO;\n    }\n  }\n\n  /* User-defined headers */\n\n  if (! add_user_headers (buf, &pos, buf_size, r,\n                          ! c->rp.props.chunked,\n                          (! c->rp.props.use_reply_body_headers) &&\n                          (0 ==\n                           (r->flags & MHD_RF_INSANITY_HEADER_CONTENT_LENGTH)),\n                          use_conn_close,\n                          use_conn_k_alive))\n    return MHD_NO;\n\n  /* Other automatic headers */\n\n  if ( (c->rp.props.use_reply_body_headers) &&\n       (0 == (r->flags & MHD_RF_HEAD_ONLY_RESPONSE)) )\n  {\n    /* Body-specific headers */\n\n    if (c->rp.props.chunked)\n    { /* Chunked encoding is used */\n      if (0 == (r->flags_auto & MHD_RAF_HAS_TRANS_ENC_CHUNKED))\n      { /* No chunked encoding header set by user */\n        if (! buffer_append_s (buf, &pos, buf_size,\n                               MHD_HTTP_HEADER_TRANSFER_ENCODING \": \" \\\n                               \"chunked\\r\\n\"))\n          return MHD_NO;\n      }\n    }\n    else /* Chunked encoding is not used */\n    {\n      if (MHD_SIZE_UNKNOWN != r->total_size)\n      { /* The size is known */\n        if (0 == (r->flags_auto & MHD_RAF_HAS_CONTENT_LENGTH))\n        { /* The response does not have \"Content-Length\" header */\n          if (! buffer_append_s (buf, &pos, buf_size,\n                                 MHD_HTTP_HEADER_CONTENT_LENGTH \": \"))\n            return MHD_NO;\n          el_size = MHD_uint64_to_str (r->total_size, buf + pos,\n                                       buf_size - pos);\n          if (0 == el_size)\n            return MHD_NO;\n          pos += el_size;\n\n          if (buf_size < pos + 2)\n            return MHD_NO;\n          buf[pos++] = '\\r';\n          buf[pos++] = '\\n';\n        }\n      }\n    }\n  }\n\n  /* * Header termination * */\n  if (buf_size < pos + 2)\n    return MHD_NO;\n  buf[pos++] = '\\r';\n  buf[pos++] = '\\n';\n\n  c->write_buffer_append_offset = pos;\n  return MHD_YES;\n}\n```\n</target_code>\n<response format>\nProvide your answer with these fields.\n- explanation: your evaluation of the scenario provided by the agent A.\n- is_report_correct: whether the report is correct or not (true/false). True means there is a violation.\n</response format>\n<scenario>\nThe agent A provided the following violation scenario:\nPotential buffer overflow if buffer_append_s internally uses standard string functions without checking remaining space. The code does not verify that (buf_size - pos) is large enough to hold \"ICY\" before calling buffer_append_s. If c->write_buffer_append_offset (pos) is close to buf_size (for example pos == buf_size or buf_size - pos < 3 or < 4 if a NUL/terminator is copied), an internal strcpy/memcpy/strcat used by buffer_append_s would write past buf end, violating MISRA C 2023 Rule 21.17.\n</scenario>\n\n<instruction>\nJudge whether the report is correct or not.\n</instruction>\n",
  "is_report_correct": false,
  "explanation": "Not proven. Rule 21.17 prohibits uses of <string.h> functions that may access beyond object bounds. The code shown does not directly call any <string.h> functions; it delegates string operations to helper routines (buffer_append_s, buffer_append, MHD_uint16_to_str, etc.) that are passed the current pos and buf_size so they can enforce bounds. The agent's scenario assumes buffer_append_s uses unsafe standard string functions without checking remaining space \u2014 but that is speculative and would be a defect in buffer_append_s itself, not in build_header_response. build_header_response also contains explicit pre-checks before raw writes (e.g. checks of buf_size < pos + N) where it writes bytes directly. To establish a MISRA 21.17 violation you must show one of the helper functions uses memcpy/strcpy/... in a way that can write past buf + buf_size; that evidence is not present here. Recommendation: inspect/verify the implementations of buffer_append_s, buffer_append and any other helpers to ensure they perform bounds checking or use size-limited safe functions. If they do, then build_header_response complies with Rule 21.17."
}