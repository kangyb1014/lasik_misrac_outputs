{
  "user_message": "An agent A claimed that the following MHD_monotonic_sec_counter_init code violates the MISRA C 2023 rule 2.1.\n<misra_rule>\nMISRA C 2023 Rule 2.1 is A project shall not contain unreachable code.\n\n</misra_rule>\n<target_code>\nHere is the original code of MHD_monotonic_sec_counter_init.\n```c\nvoid\nMHD_monotonic_sec_counter_init (void)\n{\n#ifdef HAVE_CLOCK_GET_TIME\n  mach_timespec_t cur_time;\n#endif /* HAVE_CLOCK_GET_TIME */\n  enum _MHD_mono_clock_source mono_clock_source = _MHD_CLOCK_NO_SOURCE;\n#ifdef HAVE_CLOCK_GETTIME\n  struct timespec ts;\n\n  mono_clock_id = _MHD_UNWANTED_CLOCK;\n#endif /* HAVE_CLOCK_GETTIME */\n#ifdef HAVE_CLOCK_GET_TIME\n  mono_clock_service = _MHD_INVALID_CLOCK_SERV;\n#endif /* HAVE_CLOCK_GET_TIME */\n\n  /* just a little syntactic trick to get the\n     various following ifdef's to work out nicely */\n  if (0)\n  {\n    (void) 0; /* Mute possible compiler warning */\n  }\n  else\n#ifdef HAVE_CLOCK_GETTIME\n#ifdef CLOCK_MONOTONIC_COARSE\n  /* Linux-specific fast value-getting clock */\n  /* Can be affected by frequency adjustment and don't count time in suspend, */\n  /* but preferred since it's fast */\n  if (0 == clock_gettime (CLOCK_MONOTONIC_COARSE,\n                          &ts))\n  {\n    mono_clock_id = CLOCK_MONOTONIC_COARSE;\n    mono_clock_start = ts.tv_sec;\n    mono_clock_source = _MHD_CLOCK_GETTIME;\n  }\n  else\n#endif /* CLOCK_MONOTONIC_COARSE */\n#ifdef CLOCK_MONOTONIC_FAST\n  /* FreeBSD/DragonFly fast value-getting clock */\n  /* Can be affected by frequency adjustment, but preferred since it's fast */\n  if (0 == clock_gettime (CLOCK_MONOTONIC_FAST,\n                          &ts))\n  {\n    mono_clock_id = CLOCK_MONOTONIC_FAST;\n    mono_clock_start = ts.tv_sec;\n    mono_clock_source = _MHD_CLOCK_GETTIME;\n  }\n  else\n#endif /* CLOCK_MONOTONIC_COARSE */\n#ifdef CLOCK_MONOTONIC_RAW_APPROX\n  /* Darwin-specific clock */\n  /* Not affected by frequency adjustment, returns clock value cached at\n   * context switch. Can be \"milliseconds old\", but it's fast. */\n  if (0 == clock_gettime (CLOCK_MONOTONIC_RAW_APPROX,\n                          &ts))\n  {\n    mono_clock_id = CLOCK_MONOTONIC_RAW_APPROX;\n    mono_clock_start = ts.tv_sec;\n    mono_clock_source = _MHD_CLOCK_GETTIME;\n  }\n  else\n#endif /* CLOCK_MONOTONIC_RAW */\n#ifdef CLOCK_MONOTONIC_RAW\n  /* Linux and Darwin clock */\n  /* Not affected by frequency adjustment,\n   * on Linux don't count time in suspend */\n  if (0 == clock_gettime (CLOCK_MONOTONIC_RAW,\n                          &ts))\n  {\n    mono_clock_id = CLOCK_MONOTONIC_RAW;\n    mono_clock_start = ts.tv_sec;\n    mono_clock_source = _MHD_CLOCK_GETTIME;\n  }\n  else\n#endif /* CLOCK_MONOTONIC_RAW */\n#ifdef CLOCK_BOOTTIME\n  /* Count time in suspend on Linux so it's real monotonic, */\n  /* but can be slower value-getting than other clocks */\n  if (0 == clock_gettime (CLOCK_BOOTTIME,\n                          &ts))\n  {\n    mono_clock_id = CLOCK_BOOTTIME;\n    mono_clock_start = ts.tv_sec;\n    mono_clock_source = _MHD_CLOCK_GETTIME;\n  }\n  else\n#endif /* CLOCK_BOOTTIME */\n#ifdef CLOCK_MONOTONIC\n  /* Monotonic clock */\n  /* Widely supported, may be affected by frequency adjustment */\n  /* On Linux it's not truly monotonic as it doesn't count time in suspend */\n  if (0 == clock_gettime (CLOCK_MONOTONIC,\n                          &ts))\n  {\n    mono_clock_id = CLOCK_MONOTONIC;\n    mono_clock_start = ts.tv_sec;\n    mono_clock_source = _MHD_CLOCK_GETTIME;\n  }\n  else\n#endif /* CLOCK_MONOTONIC */\n#ifdef CLOCK_UPTIME\n  /* non-Linux clock */\n  /* Doesn't count time in suspend */\n  if (0 == clock_gettime (CLOCK_UPTIME,\n                          &ts))\n  {\n    mono_clock_id = CLOCK_UPTIME;\n    mono_clock_start = ts.tv_sec;\n    mono_clock_source = _MHD_CLOCK_GETTIME;\n  }\n  else\n#endif /* CLOCK_BOOTTIME */\n#endif /* HAVE_CLOCK_GETTIME */\n#ifdef HAVE_CLOCK_GET_TIME\n  /* Darwin-specific monotonic clock */\n  /* Should be monotonic as clock_set_time function always unconditionally */\n  /* failed on latest kernels */\n  if ( (KERN_SUCCESS == host_get_clock_service (mach_host_self (),\n                                                SYSTEM_CLOCK,\n                                                &mono_clock_service)) &&\n       (KERN_SUCCESS == clock_get_time (mono_clock_service,\n                                        &cur_time)) )\n  {\n    mono_clock_start = cur_time.tv_sec;\n    mono_clock_source = _MHD_CLOCK_GET_TIME;\n  }\n  else\n#endif /* HAVE_CLOCK_GET_TIME */\n#ifdef _WIN32\n#if _WIN32_WINNT >= 0x0600\n  /* W32 Vista or later specific monotonic clock */\n  /* Available since Vista, ~15ms accuracy */\n  if (1)\n  {\n    tick_start = GetTickCount64 ();\n    mono_clock_source = _MHD_CLOCK_GETTICKCOUNT64;\n  }\n  else\n#else  /* _WIN32_WINNT < 0x0600 */\n  /* W32 specific monotonic clock */\n  /* Available on Windows 2000 and later */\n  if (1)\n  {\n    LARGE_INTEGER freq;\n    LARGE_INTEGER perf_counter;\n\n    QueryPerformanceFrequency (&freq);       /* never fail on XP and later */\n    QueryPerformanceCounter (&perf_counter); /* never fail on XP and later */\n    perf_freq = (uint64_t) freq.QuadPart;\n    perf_start = (uint64_t) perf_counter.QuadPart;\n    mono_clock_source = _MHD_CLOCK_PERFCOUNTER;\n  }\n  else\n#endif /* _WIN32_WINNT < 0x0600 */\n#endif /* _WIN32 */\n#ifdef HAVE_CLOCK_GETTIME\n#ifdef CLOCK_HIGHRES\n  /* Solaris-specific monotonic high-resolution clock */\n  /* Not preferred due to be potentially resource-hungry */\n  if (0 == clock_gettime (CLOCK_HIGHRES,\n                          &ts))\n  {\n    mono_clock_id = CLOCK_HIGHRES;\n    mono_clock_start = ts.tv_sec;\n    mono_clock_source = _MHD_CLOCK_GETTIME;\n  }\n  else\n#endif /* CLOCK_HIGHRES */\n#endif /* HAVE_CLOCK_GETTIME */\n#ifdef HAVE_GETHRTIME\n  /* HP-UX and Solaris monotonic clock */\n  /* Not preferred due to be potentially resource-hungry */\n  if (1)\n  {\n    hrtime_start = gethrtime ();\n    mono_clock_source = _MHD_CLOCK_GETHRTIME;\n  }\n  else\n#endif /* HAVE_GETHRTIME */\n  {\n    /* no suitable clock source was found */\n    mono_clock_source = _MHD_CLOCK_NO_SOURCE;\n  }\n\n#ifdef HAVE_CLOCK_GET_TIME\n  if ( (_MHD_CLOCK_GET_TIME != mono_clock_source) &&\n       (_MHD_INVALID_CLOCK_SERV != mono_clock_service) )\n  {\n    /* clock service was initialised but clock_get_time failed */\n    mach_port_deallocate (mach_task_self (),\n                          mono_clock_service);\n    mono_clock_service = _MHD_INVALID_CLOCK_SERV;\n  }\n#else\n  (void) mono_clock_source; /* avoid compiler warning */\n#endif /* HAVE_CLOCK_GET_TIME */\n\n#ifdef HAVE_TIMESPEC_GET\n  if (1)\n  {\n    struct timespec tsg;\n    if (TIME_UTC == timespec_get (&tsg, TIME_UTC))\n      gettime_start = tsg.tv_sec;\n    else\n      gettime_start = 0;\n  }\n#elif defined(HAVE_GETTIMEOFDAY)\n  if (1)\n  {\n    struct timeval tv;\n    if (0 == gettimeofday (&tv, NULL))\n      gettime_start = tv.tv_sec;\n    else\n      gettime_start = 0;\n  }\n#endif /* HAVE_GETTIMEOFDAY */\n  sys_clock_start = time (NULL);\n}\n```\n</target_code>\n<response format>\nProvide your answer with these fields.\n- explanation: your evaluation of the scenario provided by the agent A.\n- is_report_correct: whether the report is correct or not (true/false). True means there is a violation.\n</response format>\n<scenario>\nThe agent A provided the following violation scenario:\nWhen building for Windows Vista or later (_WIN32 and _WIN32_WINNT >= 0x0600) the code contains `if (1) { tick_start = GetTickCount64 (); ... } else` so the else-path (and all subsequent chained else/else-if branches in that big if/else chain) can never be taken. That produces unreachable code at compile/run time and therefore violates MISRA C 2023 Rule 2.1.\n</scenario>\n\n<execution_log>\nThe agent A also provided the following output log:\nMHD_monotonic_sec_counter_init: entry, initial mono_clock_source=0, mono_clock_id=0\nbranch: CLOCK_MONOTONIC_COARSE taken, id=6 start=10956609 source=1\ntimespec_get: gettime_start=1756198159\nexit: sys_clock_start=1756198159 final mono_clock_source=1\nMHD_monotonic_sec_counter_init: entry, initial mono_clock_source=0, mono_clock_id=0\nbranch: CLOCK_MONOTONIC_COARSE taken, id=6 start=10956609 source=1\ntimespec_get: gettime_start=1756198159\nexit: sys_clock_start=1756198159 final mono_clock_source=1\nMHD_monotonic_sec_counter_init: entry, initial mono_clock_source=0, mono_clock_id=0\nbranch: CLOCK_MONOTONIC_COARSE taken, id=6 start=10956609 source=1\ntimespec_get: gettime_start=1756198159\nexit: sys_clock_start=1756198159 final mono_clock_source=1\nMHD_monotonic_sec_counter_init: entry, initial mono_clock_source=0, mono_clock_id=0\nbranch: CLOCK_MONOTONIC_COARSE taken, id=6 start=10956610 source=1\ntimespec_get: gettime_start=1756198160\nexit: sys_clock_start=1756198160 final mono_clock_source=1\nMHD_monotonic_sec_counter_init: entry, initial mono_clock_source=0, mono_clock_id=0\nbranch: CLOCK_MONOTONIC_COARSE taken, id=6 start=10956610 source=1\ntimespec_get: gettime_start=1756198160\nexit: sys_clock_start=1756198160 final mono_clock_source=1\nMHD_monotonic_sec_counter_init: entry, initial mono_clock_source=0, mono_clock_id=0\nbranch: CLOCK_MONOTONIC_COARSE taken, id=6 start=10956610 source=1\ntimespec_get: gettime_start=1756198160\nexit: sys_clock_start=1756198160 final mono_clock_source=1\nMHD_monotonic_sec_counter_init: entry, initial mono_clock_source=0, mono_clock_id=0\nbranch: CLOCK_MONOTONIC_COARSE taken, id=6 start=10956613 source=1\ntimespec_get: gettime_start=1756198163\nexit: sys_clock_start=1756198163 final mono_clock_source=1\nMHD_monotonic_sec_counter_init: entry, initial mono_clock_source=0, mono_clock_id=0\nbranch: CLOCK_MONOTONIC_COARSE taken, id=6 start=10956614 source=1\ntimespec_get: gettime_start=1756198164\nexit: sys_clock_start=1756198164 final mono_clock_source=1\nMHD_monotonic_sec_counter_init: entry, initial mono_clock_source=0, mono_clock_id=0\nbranch: CLOCK_MONOTONIC_COARSE taken, id=6 start=10956615 source=1\ntimespec_get: gettime_start=1756198165\nexit: sys_clock_start=1756198165 final mono_clock_source=1\nMHD_monotonic_sec_counter_init: entry, initial mono_clock_source=0, mono_clock_id=0\nbranch: CLOCK_MONOTONIC_COARSE taken, id=6 start=10956618 source=1\ntimespec_get: gettime_start=1756198168\nexit: sys_clock_start=1756198168 final mono_clock_source=1\nMHD_monotonic_sec_counter_init: entry, initial mono_clock_source=0, mono_clock_id=0\nbranch: CLOCK_MONOTONIC_COARSE taken, id=6 start=10956618 source=1\ntimespec_get: gettime_start=1756198168\nexit: sys_clock_start=1756198168 final mono_clock_source=1\nMHD_monotonic_sec_counter_init: entry, initial mono_clock_source=0, mono_clock_id=0\nbranch: CLOCK_MONOTONIC_COARSE taken, id=6 start=10956618 source=1\ntimespec_get: gettime_start=1756198168\nexit: sys_clock_start=1756198168 final mono_clock_source=1\nMHD_monotonic_sec_counter_init: entry, initial mono_clock_source=0, mono_clock_id=0\nbranch: CLOCK_MONOTONIC_COARSE taken, id=6 start=10956622 source=1\ntimespec_get: gettime_start=1756198172\nexit: sys_clock_start=1756198172 final mono_clock_source=1\nMHD_monotonic_sec_counter_init: entry, initial mono_clock_source=0, mono_clock_id=0\nbranch: CLOCK_MONOTONIC_COARSE taken, id=6 start=10956622 source=1\ntimespec_get: gettime_start=1756198172\nexit: sys_clock_start=1756198172 final mono_clock_source=1\nMHD_monotonic_sec_counter_init: entry, initial mono_clock_source=0, mono_clock_id=0\nbranch: CLOCK_MONOTONIC_COARSE taken, id=6 start=10956623 source=1\ntimespec_get: gettime_start=1756198173\nexit: sys_clock_start=1756198173 final mono_clock_source=1\nMHD_monotonic_sec_counter_init: entry, initial mono_clock_source=0, mono_clock_id=0\nbranch: CLOCK_MONOTONIC_COARSE taken, id=6 start=10956626 source=1\ntimespec_get: gettime_start=1756198176\nexit: sys_clock_start=1756198176 final mono_clock_source=1\nMHD_monotonic_sec_counter_init: entry, initial mono_clock_source=0, mono_clock_id=0\nbranch: CLOCK_MONOTONIC_COAR\n</execution_log>\n\n<instruction>\nJudge whether the report is correct or not.\n</instruction>\n",
  "is_report_correct": true,
  "explanation": "The report is correct. In the Windows Vista+ configuration (_WIN32 and _WIN32_WINNT >= 0x0600) the code contains an if (1) { ... } else construct inside the large if/else chain. Because the controlling expression is a compile-time constant true, the corresponding else path (and the subsequent chained alternatives that rely on that else) can never be executed at run-time and therefore constitutes unreachable code. MISRA C 2023 Rule 2.1 forbids unreachable code in the project; this pattern (if(1) \u2026 else \u2026) produces unreachable branches in that build configuration and thus violates Rule 2.1."
}