{
  "user_message": "An agent A claimed that the following MHD_monotonic_sec_counter_init code violates the MISRA C 2023 rule 2.1.\n<misra_rule>\nMISRA C 2023 Rule 2.1 is A project shall not contain unreachable code.\n\n</misra_rule>\n<target_code>\nHere is the original code of MHD_monotonic_sec_counter_init.\n```c\nvoid\nMHD_monotonic_sec_counter_init (void)\n{\n#ifdef HAVE_CLOCK_GET_TIME\n  mach_timespec_t cur_time;\n#endif /* HAVE_CLOCK_GET_TIME */\n  enum _MHD_mono_clock_source mono_clock_source = _MHD_CLOCK_NO_SOURCE;\n#ifdef HAVE_CLOCK_GETTIME\n  struct timespec ts;\n\n  mono_clock_id = _MHD_UNWANTED_CLOCK;\n#endif /* HAVE_CLOCK_GETTIME */\n#ifdef HAVE_CLOCK_GET_TIME\n  mono_clock_service = _MHD_INVALID_CLOCK_SERV;\n#endif /* HAVE_CLOCK_GET_TIME */\n\n  /* just a little syntactic trick to get the\n     various following ifdef's to work out nicely */\n  if (0)\n  {\n    (void) 0; /* Mute possible compiler warning */\n  }\n  else\n#ifdef HAVE_CLOCK_GETTIME\n#ifdef CLOCK_MONOTONIC_COARSE\n  /* Linux-specific fast value-getting clock */\n  /* Can be affected by frequency adjustment and don't count time in suspend, */\n  /* but preferred since it's fast */\n  if (0 == clock_gettime (CLOCK_MONOTONIC_COARSE,\n                          &ts))\n  {\n    mono_clock_id = CLOCK_MONOTONIC_COARSE;\n    mono_clock_start = ts.tv_sec;\n    mono_clock_source = _MHD_CLOCK_GETTIME;\n  }\n  else\n#endif /* CLOCK_MONOTONIC_COARSE */\n#ifdef CLOCK_MONOTONIC_FAST\n  /* FreeBSD/DragonFly fast value-getting clock */\n  /* Can be affected by frequency adjustment, but preferred since it's fast */\n  if (0 == clock_gettime (CLOCK_MONOTONIC_FAST,\n                          &ts))\n  {\n    mono_clock_id = CLOCK_MONOTONIC_FAST;\n    mono_clock_start = ts.tv_sec;\n    mono_clock_source = _MHD_CLOCK_GETTIME;\n  }\n  else\n#endif /* CLOCK_MONOTONIC_COARSE */\n#ifdef CLOCK_MONOTONIC_RAW_APPROX\n  /* Darwin-specific clock */\n  /* Not affected by frequency adjustment, returns clock value cached at\n   * context switch. Can be \"milliseconds old\", but it's fast. */\n  if (0 == clock_gettime (CLOCK_MONOTONIC_RAW_APPROX,\n                          &ts))\n  {\n    mono_clock_id = CLOCK_MONOTONIC_RAW_APPROX;\n    mono_clock_start = ts.tv_sec;\n    mono_clock_source = _MHD_CLOCK_GETTIME;\n  }\n  else\n#endif /* CLOCK_MONOTONIC_RAW */\n#ifdef CLOCK_MONOTONIC_RAW\n  /* Linux and Darwin clock */\n  /* Not affected by frequency adjustment,\n   * on Linux don't count time in suspend */\n  if (0 == clock_gettime (CLOCK_MONOTONIC_RAW,\n                          &ts))\n  {\n    mono_clock_id = CLOCK_MONOTONIC_RAW;\n    mono_clock_start = ts.tv_sec;\n    mono_clock_source = _MHD_CLOCK_GETTIME;\n  }\n  else\n#endif /* CLOCK_MONOTONIC_RAW */\n#ifdef CLOCK_BOOTTIME\n  /* Count time in suspend on Linux so it's real monotonic, */\n  /* but can be slower value-getting than other clocks */\n  if (0 == clock_gettime (CLOCK_BOOTTIME,\n                          &ts))\n  {\n    mono_clock_id = CLOCK_BOOTTIME;\n    mono_clock_start = ts.tv_sec;\n    mono_clock_source = _MHD_CLOCK_GETTIME;\n  }\n  else\n#endif /* CLOCK_BOOTTIME */\n#ifdef CLOCK_MONOTONIC\n  /* Monotonic clock */\n  /* Widely supported, may be affected by frequency adjustment */\n  /* On Linux it's not truly monotonic as it doesn't count time in suspend */\n  if (0 == clock_gettime (CLOCK_MONOTONIC,\n                          &ts))\n  {\n    mono_clock_id = CLOCK_MONOTONIC;\n    mono_clock_start = ts.tv_sec;\n    mono_clock_source = _MHD_CLOCK_GETTIME;\n  }\n  else\n#endif /* CLOCK_MONOTONIC */\n#ifdef CLOCK_UPTIME\n  /* non-Linux clock */\n  /* Doesn't count time in suspend */\n  if (0 == clock_gettime (CLOCK_UPTIME,\n                          &ts))\n  {\n    mono_clock_id = CLOCK_UPTIME;\n    mono_clock_start = ts.tv_sec;\n    mono_clock_source = _MHD_CLOCK_GETTIME;\n  }\n  else\n#endif /* CLOCK_BOOTTIME */\n#endif /* HAVE_CLOCK_GETTIME */\n#ifdef HAVE_CLOCK_GET_TIME\n  /* Darwin-specific monotonic clock */\n  /* Should be monotonic as clock_set_time function always unconditionally */\n  /* failed on latest kernels */\n  if ( (KERN_SUCCESS == host_get_clock_service (mach_host_self (),\n                                                SYSTEM_CLOCK,\n                                                &mono_clock_service)) &&\n       (KERN_SUCCESS == clock_get_time (mono_clock_service,\n                                        &cur_time)) )\n  {\n    mono_clock_start = cur_time.tv_sec;\n    mono_clock_source = _MHD_CLOCK_GET_TIME;\n  }\n  else\n#endif /* HAVE_CLOCK_GET_TIME */\n#ifdef _WIN32\n#if _WIN32_WINNT >= 0x0600\n  /* W32 Vista or later specific monotonic clock */\n  /* Available since Vista, ~15ms accuracy */\n  if (1)\n  {\n    tick_start = GetTickCount64 ();\n    mono_clock_source = _MHD_CLOCK_GETTICKCOUNT64;\n  }\n  else\n#else  /* _WIN32_WINNT < 0x0600 */\n  /* W32 specific monotonic clock */\n  /* Available on Windows 2000 and later */\n  if (1)\n  {\n    LARGE_INTEGER freq;\n    LARGE_INTEGER perf_counter;\n\n    QueryPerformanceFrequency (&freq);       /* never fail on XP and later */\n    QueryPerformanceCounter (&perf_counter); /* never fail on XP and later */\n    perf_freq = (uint64_t) freq.QuadPart;\n    perf_start = (uint64_t) perf_counter.QuadPart;\n    mono_clock_source = _MHD_CLOCK_PERFCOUNTER;\n  }\n  else\n#endif /* _WIN32_WINNT < 0x0600 */\n#endif /* _WIN32 */\n#ifdef HAVE_CLOCK_GETTIME\n#ifdef CLOCK_HIGHRES\n  /* Solaris-specific monotonic high-resolution clock */\n  /* Not preferred due to be potentially resource-hungry */\n  if (0 == clock_gettime (CLOCK_HIGHRES,\n                          &ts))\n  {\n    mono_clock_id = CLOCK_HIGHRES;\n    mono_clock_start = ts.tv_sec;\n    mono_clock_source = _MHD_CLOCK_GETTIME;\n  }\n  else\n#endif /* CLOCK_HIGHRES */\n#endif /* HAVE_CLOCK_GETTIME */\n#ifdef HAVE_GETHRTIME\n  /* HP-UX and Solaris monotonic clock */\n  /* Not preferred due to be potentially resource-hungry */\n  if (1)\n  {\n    hrtime_start = gethrtime ();\n    mono_clock_source = _MHD_CLOCK_GETHRTIME;\n  }\n  else\n#endif /* HAVE_GETHRTIME */\n  {\n    /* no suitable clock source was found */\n    mono_clock_source = _MHD_CLOCK_NO_SOURCE;\n  }\n\n#ifdef HAVE_CLOCK_GET_TIME\n  if ( (_MHD_CLOCK_GET_TIME != mono_clock_source) &&\n       (_MHD_INVALID_CLOCK_SERV != mono_clock_service) )\n  {\n    /* clock service was initialised but clock_get_time failed */\n    mach_port_deallocate (mach_task_self (),\n                          mono_clock_service);\n    mono_clock_service = _MHD_INVALID_CLOCK_SERV;\n  }\n#else\n  (void) mono_clock_source; /* avoid compiler warning */\n#endif /* HAVE_CLOCK_GET_TIME */\n\n#ifdef HAVE_TIMESPEC_GET\n  if (1)\n  {\n    struct timespec tsg;\n    if (TIME_UTC == timespec_get (&tsg, TIME_UTC))\n      gettime_start = tsg.tv_sec;\n    else\n      gettime_start = 0;\n  }\n#elif defined(HAVE_GETTIMEOFDAY)\n  if (1)\n  {\n    struct timeval tv;\n    if (0 == gettimeofday (&tv, NULL))\n      gettime_start = tv.tv_sec;\n    else\n      gettime_start = 0;\n  }\n#endif /* HAVE_GETTIMEOFDAY */\n  sys_clock_start = time (NULL);\n}\n```\n</target_code>\n<response format>\nProvide your answer with these fields.\n- explanation: your evaluation of the scenario provided by the agent A.\n- is_report_correct: whether the report is correct or not (true/false). True means there is a violation.\n</response format>\n<scenario>\nThe agent A provided the following violation scenario:\nThe 'if (0) { (void)0; }' branch is statically unreachable because the condition is a constant false. MISRA C:2023 Rule 2.1 forbids unreachable code, so the always-dead then-branch (and its statement) constitutes a violation. The construct was used as a preprocessor/`else` trick, but that does not remove the fact the `if (0)` branch is unreachable at compile time.\n</scenario>\n\n<execution_log>\nThe agent A also provided the following output log:\nMHD_monotonic_sec_counter_init: entered\ninitial_if_condition_value=0 (compile-time constant)\nclock_gettime(CLOCK_MONOTONIC_COARSE) succeeded: id=6 start=10955869 source=1\ntimespec_get: gettime_start=1756197419\nfinal selection: mono_clock_source=1 mono_clock_id=6 mono_clock_start=10955869 sys_clock_start=1756197419\nMHD_monotonic_sec_counter_init: entered\ninitial_if_condition_value=0 (compile-time constant)\nclock_gettime(CLOCK_MONOTONIC_COARSE) succeeded: id=6 start=10955870 source=1\ntimespec_get: gettime_start=1756197420\nfinal selection: mono_clock_source=1 mono_clock_id=6 mono_clock_start=10955870 sys_clock_start=1756197420\nMHD_monotonic_sec_counter_init: entered\ninitial_if_condition_value=0 (compile-time constant)\nclock_gettime(CLOCK_MONOTONIC_COARSE) succeeded: id=6 start=10955870 source=1\ntimespec_get: gettime_start=1756197420\nfinal selection: mono_clock_source=1 mono_clock_id=6 mono_clock_start=10955870 sys_clock_start=1756197420\nMHD_monotonic_sec_counter_init: entered\ninitial_if_condition_value=0 (compile-time constant)\nclock_gettime(CLOCK_MONOTONIC_COARSE) succeeded: id=6 start=10955870 source=1\ntimespec_get: gettime_start=1756197420\nfinal selection: mono_clock_source=1 mono_clock_id=6 mono_clock_start=10955870 sys_clock_start=1756197420\nMHD_monotonic_sec_counter_init: entered\ninitial_if_condition_value=0 (compile-time constant)\nclock_gettime(CLOCK_MONOTONIC_COARSE) succeeded: id=6 start=10955871 source=1\ntimespec_get: gettime_start=1756197421\nfinal selection: mono_clock_source=1 mono_clock_id=6 mono_clock_start=10955871 sys_clock_start=1756197421\nMHD_monotonic_sec_counter_init: entered\ninitial_if_condition_value=0 (compile-time constant)\nclock_gettime(CLOCK_MONOTONIC_COARSE) succeeded: id=6 start=10955871 source=1\ntimespec_get: gettime_start=1756197421\nfinal selection: mono_clock_source=1 mono_clock_id=6 mono_clock_start=10955871 sys_clock_start=1756197421\nMHD_monotonic_sec_counter_init: entered\ninitial_if_condition_value=0 (compile-time constant)\nclock_gettime(CLOCK_MONOTONIC_COARSE) succeeded: id=6 start=10955874 source=1\ntimespec_get: gettime_start=1756197424\nfinal selection: mono_clock_source=1 mono_clock_id=6 mono_clock_start=10955874 sys_clock_start=1756197424\nMHD_monotonic_sec_counter_init: entered\ninitial_if_condition_value=0 (compile-time constant)\nclock_gettime(CLOCK_MONOTONIC_COARSE) succeeded: id=6 start=10955875 source=1\ntimespec_get: gettime_start=1756197425\nfinal selection: mono_clock_source=1 mono_clock_id=6 mono_clock_start=10955875 sys_clock_start=1756197425\nMHD_monotonic_sec_counter_init: entered\ninitial_if_condition_value=0 (compile-time constant)\nclock_gettime(CLOCK_MONOTONIC_COARSE) succeeded: id=6 start=10955875 source=1\ntimespec_get: gettime_start=1756197425\nfinal selection: mono_clock_source=1 mono_clock_id=6 mono_clock_start=10955875 sys_clock_start=1756197425\nMHD_monotonic_sec_counter_init: entered\ninitial_if_condition_value=0 (compile-time constant)\nclock_gettime(CLOCK_MONOTONIC_COARSE) succeeded: id=6 start=10955878 source=1\ntimespec_get: gettime_start=1756197428\nfinal selection: mono_clock_source=1 mono_clock_id=6 mono_clock_start=10955878 sys_clock_start=1756197428\nMHD_monotonic_sec_counter_init: entered\ninitial_if_condition_value=0 (compile-time constant)\nclock_gettime(CLOCK_MONOTONIC_COARSE) succeeded: id=6 start=10955879 source=1\ntimespec_get: gettime_start=1756197429\nfinal selection: mono_clock_source=1 mono_clock_id=6 mono_clock_start=10955879 sys_clock_start=1756197429\nMHD_monotonic_sec_counter_init: entered\ninitial_if_condition_value=0 (compile-time constant)\nclock_gettime(CLOCK_MONOTONIC_COARSE) succeeded: id=6 start=10955879 source=1\ntimespec_get: gettime_start=1756197429\nfinal selection: mono_clock_source=1 mono_clock_id=6 mono_clock_start=10955879 sys_clock_start=1756197429\n\n</execution_log>\n\n<instruction>\nJudge whether the report is correct or not.\n</instruction>\n",
  "is_report_correct": true,
  "explanation": "MISRA C:2023 Rule 2.1 forbids unreachable code. In the presented function the construct\n\n  if (0)\n  {\n    (void) 0; /* Mute possible compiler warning */\n  }\n  else\n  {\n    ...\n  }\n\ncontains a then-branch that is provably unreachable because the constant expression 0 is always false. Even though the if(0)/else is being used as a preprocessor/else syntactic trick to combine with subsequent #ifdef blocks, that does not change the fact that the then-branch statement exists in the translation unit and cannot be executed. Therefore the report that this code violates MISRA C 2023 Rule 2.1 is correct.\n\nIf compliance is required, remove the dead then-branch (for example restructure using preprocessor conditionals (#if/#elif/.../#else) or arrange the conditional compilation so no always-false if remains), or replace the construct with an approach that does not introduce a compile-time-constant false branch."
}