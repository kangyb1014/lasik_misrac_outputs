{
  "user_message": "<target code>Here is the code that failed to compile:\n```c\nstatic void\nprobe_log (const char *fmt, ...)\n{\n  FILE *f = fopen(\"/tmp/logs/1065.txt\", \"a\");\n  if (!f)\n    return;\n  va_list ap;\n  va_start (ap, fmt);\n  vfprintf (f, fmt, ap);\n  va_end (ap);\n  fprintf (f, \"\\n\");\n  fclose (f);\n}\n\nstatic void\nclose_all_connections (struct MHD_Daemon *daemon)\n{\n  struct MHD_Connection *pos;\n  const bool used_thr_p_c = MHD_D_IS_USING_THREAD_PER_CONN_ (daemon);\n#ifdef UPGRADE_SUPPORT\n  const bool upg_allowed = (0 != (daemon->options & MHD_ALLOW_UPGRADE));\n#endif /* UPGRADE_SUPPORT */\n#if defined(HTTPS_SUPPORT) && defined(UPGRADE_SUPPORT)\n  struct MHD_UpgradeResponseHandle *urh;\n  struct MHD_UpgradeResponseHandle *urhn;\n  const bool used_tls = (0 != (daemon->options & MHD_USE_TLS));\n#endif /* HTTPS_SUPPORT && UPGRADE_SUPPORT */\n\n  /* Log entry and basic state */\n  probe_log (\"enter close_all_connections: daemon=%p, used_thr_p_c=%d\",\n              (void *) daemon, (int) used_thr_p_c);\n#ifdef UPGRADE_SUPPORT\n  probe_log (\"daemon->options=0x%lx, upg_allowed=%d\",\n              (unsigned long) daemon->options, (int) upg_allowed);\n#endif\n#if defined(HTTPS_SUPPORT) && defined(UPGRADE_SUPPORT)\n  probe_log (\"used_tls=%d\", (int) used_tls);\n#endif\n\n#ifdef MHD_USE_THREADS\n  mhd_assert ( (! MHD_D_IS_USING_THREADS_ (daemon)) || \\\n               MHD_D_IS_USING_THREAD_PER_CONN_ (daemon) || \\\n               MHD_thread_handle_ID_is_current_thread_ (daemon->tid) );\n  mhd_assert (NULL == daemon->worker_pool);\n  probe_log (\"MHD_USE_THREADS: worker_pool=%p, tid=%p\",\n              (void *) daemon->worker_pool, (void *) daemon->tid);\n#endif /* MHD_USE_THREADS */\n  mhd_assert (daemon->shutdown);\n  probe_log (\"daemon->shutdown=%d\", (int) daemon->shutdown);\n\n#ifdef MHD_USE_THREADS\n/* Remove externally added new connections that are\n   * not processed by the daemon thread. */\n  MHD_mutex_lock_chk_ (&daemon->new_connections_mutex);\n  probe_log (\"locked new_connections_mutex, new_connections_tail=%p\",\n              (void *) daemon->new_connections_tail);\n  while (NULL != (pos = daemon->new_connections_tail))\n  {\n    mhd_assert (MHD_D_IS_USING_THREADS_ (daemon));\n    probe_log (\"removing new connection pos=%p\", (void *) pos);\n    DLL_remove (daemon->new_connections_head,\n                daemon->new_connections_tail,\n                pos);\n    new_connection_close_ (daemon, pos);\n  }\n  MHD_mutex_unlock_chk_ (&daemon->new_connections_mutex);\n  probe_log (\"unlocked new_connections_mutex\");\n#endif /* MHD_USE_THREADS */\n\n#if defined(HTTPS_SUPPORT) && defined(UPGRADE_SUPPORT)\n  /* give upgraded HTTPS connections a chance to finish */\n  /* 'daemon->urh_head' is not used in thread-per-connection mode. */\n  for (urh = daemon->urh_tail; NULL != urh; urh = urhn)\n  {\n    mhd_assert (! used_thr_p_c);\n    urhn = urh->prev;\n    probe_log (\"processing urh=%p, connection=%p, urh->clean_ready=%d\",\n               (void *) urh, (void *) urh->connection,\n               (int) urh->clean_ready);\n    /* call generic forwarding function for passing data\n       with chance to detect that application is done. */\n    process_urh (urh);\n    MHD_connection_finish_forward_ (urh->connection);\n    urh->clean_ready = true;\n    /* Resuming will move connection to cleanup list. */\n    MHD_resume_connection (urh->connection);\n  }\n#endif /* HTTPS_SUPPORT && UPGRADE_SUPPORT */\n\n  /* Give suspended connections a chance to resume to avoid\n     running into the check for there not being any suspended\n     connections left in case of a tight race with a recently\n     resumed connection. */\n  if (0 != (MHD_TEST_ALLOW_SUSPEND_RESUME & daemon->options))\n  {\n    daemon->resuming = true;   /* Force check for pending resume. */\n    probe_log (\"forcing resume: daemon->resuming=%d\",\n                (int) daemon->resuming);\n    resume_suspended_connections (daemon);\n  }\n  /* first, make sure all threads are aware of shutdown; need to\n     traverse DLLs in peace... */\n#if defined(MHD_USE_POSIX_THREADS) || defined(MHD_USE_W32_THREADS)\n  MHD_mutex_lock_chk_ (&daemon->cleanup_connection_mutex);\n  probe_log (\"locked cleanup_connection_mutex\");\n#endif\n#ifdef UPGRADE_SUPPORT\n  probe_log (\"evaluating upgraded-connections branch: upg_allowed=%d\",\n              (int) upg_allowed);\n  if (upg_allowed)\n  {\n    struct MHD_Connection *susp;\n\n    susp = daemon->suspended_connections_tail;\n    probe_log (\"enter upgraded suspended loop: suspended_tail=%p\",\n               (void *) susp);\n    while (NULL != susp)\n    {\n      probe_log (\"susp=%p, susp->urh=%p\", (void *) susp, (void *) susp->urh);\n      if (NULL == susp->urh)     /* \"Upgraded\" connection? */\n        MHD_PANIC (_ (\"MHD_stop_daemon() called while we have \" \\\n                      \"suspended connections.\\n\"));\n#ifdef HTTPS_SUPPORT\n      else if (used_tls &&\n               used_thr_p_c &&\n               (! susp->urh->clean_ready) )\n      {\n        probe_log (\"shutting down socket for susp->urh=%p (not clean_ready)\",\n                   (void *) susp->urh);\n        shutdown (susp->urh->app.socket,\n                  SHUT_RDWR);     /* Wake thread by shutdown of app socket. */\n      }\n#endif /* HTTPS_SUPPORT */\n      else\n      {\n#ifdef HAVE_MESSAGES\n        if (! susp->urh->was_closed)\n          MHD_DLOG (daemon,\n                    _ (\"Initiated daemon shutdown while \\\"upgraded\\\" \" \\\n                       \"connection was not closed.\\n\"));\n#endif\n        probe_log (\"marking urh=%p was_closed (previous=%d)\",\n                   (void *) susp->urh, (int) susp->urh->was_closed);\n        susp->urh->was_closed = true;\n        /* If thread-per-connection is used, connection's thread\n         * may still processing \"upgrade\" (exiting). */\n        if (! used_thr_p_c)\n          MHD_connection_finish_forward_ (susp);\n        /* Do not use MHD_resume_connection() as mutex is\n         * already locked. */\n        susp->resuming = true;\n        daemon->resuming = true;\n        probe_log (\"susp->resuming set, daemon->resuming=%d\",\n                   (int) daemon->resuming);\n      }\n      susp = susp->prev;\n    }\n  }\n  else /* This 'else' is combined with next 'if' */\n#endif /* UPGRADE_SUPPORT */\n  if (NULL != daemon->suspended_connections_head)\n  {\n    probe_log (\"suspended_connections_head present: %p -> PANIC\",\n               (void *) daemon->suspended_connections_head);\n    MHD_PANIC (_ (\"MHD_stop_daemon() called while we have \" \\\n                  \"suspended connections.\\n\"));\n  }\n#if defined(UPGRADE_SUPPORT) && defined(HTTPS_SUPPORT)\n#ifdef MHD_USE_THREADS\n  if (upg_allowed && used_tls && used_thr_p_c)\n  {\n    /* \"Upgraded\" threads may be running in parallel. Connection will not be\n     * moved to the \"cleanup list\" until connection's thread finishes.\n     * We must ensure that all \"upgraded\" connections are finished otherwise\n     * connection may stay in \"suspended\" list and will not be cleaned. */\n    for (pos = daemon->suspended_connections_tail; NULL != pos; pos = pos->prev)\n    {\n      /* Any connection found here is \"upgraded\" connection, normal suspended\n       * connections are already removed from this list. */\n      mhd_assert (NULL != pos->urh);\n      probe_log (\"checking upgraded thread pos=%p, thread_joined=%d\",\n                 (void *) pos, (int) pos->thread_joined);\n      if (! pos->thread_joined)\n      {\n        /* While \"cleanup\" list is not manipulated by \"upgraded\"\n         * connection, \"cleanup\" mutex is required for call of\n         * MHD_resume_connection() during finishing of \"upgraded\"\n         * thread. */\n        MHD_mutex_unlock_chk_ (&daemon->cleanup_connection_mutex);\n        probe_log (\"unlocked cleanup_connection_mutex to join thread tid=%p\",\n                   (void *) pos->tid);\n        if (! MHD_thread_handle_ID_join_thread_ (pos->tid))\n          MHD_PANIC (_ (\"Failed to join a thread.\\n\"));\n        pos->thread_joined = true;\n        MHD_mutex_lock_chk_ (&daemon->cleanup_connection_mutex);\n        probe_log (\"joined thread and relocked cleanup_connection_mutex for pos=%p\",\n                   (void *) pos);\n      }\n    }\n  }\n#endif /* MHD_USE_THREADS */\n#endif\n  for (pos = daemon->connections_tail; NULL != pos; pos = pos->prev)\n  {\n    probe_log (\"shutdown connection pos=%p, socket_fd=%d\",\n               (void *) pos, (int) pos->socket_fd);\n    shutdown (pos->socket_fd,\n              SHUT_RDWR);\n#ifdef MHD_WINSOCK_SOCKETS\n    if (MHD_D_IS_USING_THREAD_PER_CONN_ (daemon) &&\n        (MHD_ITC_IS_VALID_ (daemon->itc)) &&\n        (! MHD_itc_activate_ (daemon->itc, \"e\")) )\n      MHD_PANIC (_ (\"Failed to signal shutdown via inter-thread \" \\\n                    \"communication channel.\\n\"));\n#endif\n  }\n\n#if defined(MHD_USE_POSIX_THREADS) || defined(MHD_USE_W32_THREADS)\n  /* now, collect per-connection threads */\n  if (used_thr_p_c)\n  {\n    pos = daemon->connections_tail;\n    while (NULL != pos)\n    {\n      if (! pos->thread_joined)\n      {\n        probe_log (\"joining per-connection thread pos=%p, tid=%p\",\n                   (void *) pos, (void *) pos->tid);\n        MHD_mutex_unlock_chk_ (&daemon->cleanup_connection_mutex);\n        if (! MHD_thread_handle_ID_join_thread_ (pos->tid))\n          MHD_PANIC (_ (\"Failed to join a thread.\\n\"));\n        MHD_mutex_lock_chk_ (&daemon->cleanup_connection_mutex);\n        pos->thread_joined = true;\n        /* The thread may have concurrently modified the DLL,\n           need to restart from the beginning */\n        pos = daemon->connections_tail;\n        probe_log (\"restarting scan of connections after join, new tail=%p\",\n                   (void *) pos);\n        continue;\n      }\n      pos = pos->prev;\n    }\n  }\n  MHD_mutex_unlock_chk_ (&daemon->cleanup_connection_mutex);\n  probe_log (\"unlocked cleanup_connection_mutex after joining threads\");\n#endif\n\n#ifdef UPGRADE_SUPPORT\n  /* Finished threads with \"upgraded\" connections need to be moved\n   * to cleanup list by resume_suspended_connections(). */\n  /* \"Upgraded\" connections that were not closed explicitly by\n   * application should be moved to cleanup list too. */\n  if (upg_allowed)\n  {\n    daemon->resuming = true;   /* Force check for pending resume. */\n    probe_log (\"final resume pass forced: daemon->resuming=%d\",\n               (int) daemon->resuming);\n    resume_suspended_connections (daemon);\n  }\n#endif /* UPGRADE_SUPPORT */\n\n  mhd_assert (NULL == daemon->suspended_connections_head);\n  probe_log (\"after cleanup: suspended_connections_head=%p\",\n             (void *) daemon->suspended_connections_head);\n  /* now that we're alone, move everyone to cleanup */\n  while (NULL != (pos = daemon->connections_tail))\n  {\n#if defined(MHD_USE_POSIX_THREADS) || defined(MHD_USE_W32_THREADS)\n    if (MHD_D_IS_USING_THREAD_PER_CONN_ (daemon) &&\n        (! pos->thread_joined) )\n      MHD_PANIC (_ (\"Failed to join a thread.\\n\"));\n#endif\n    probe_log (\"closing connection pos=%p\", (void *) pos);\n    close_connection (pos);\n  }\n  MHD_cleanup_connections (daemon);\n  probe_log (\"exit close_all_connections: daemon=%p\", (void *) daemon);\n}\n\n```\n</target code>\n<build error>\nThe build failed with the following error:\n```\ndaemon.c:9108:54: error: operand of type 'MHD_thread_handle_ID_' (aka 'struct _MHD_thread_handle_ID_') where arithmetic or pointer type is required\n 9108 |               (void *) daemon->worker_pool, (void *) daemon->tid);\n      |                                                      ^~~~~~~~~~~\ndaemon.c:9290:43: error: operand of type 'MHD_thread_handle_ID_' (aka 'struct _MHD_thread_handle_ID_') where arithmetic or pointer type is required\n 9290 |                    (void *) pos, (void *) pos->tid);\n      |                                           ^~~~~~~~\n2 errors generated.\nmake[3]: *** [Makefile:2112: libmicrohttpd_la-daemon.lo] Error 1\nmake[2]: *** [Makefile:449: all-recursive] Error 1\nmake[1]: *** [Makefile:788: all-recursive] Error 1\nmake: *** [Makefile:693: all] Error 2\n```\n</build error>\n<response format>\nProvide your answer with these answers.\n- fixed_test_code: the fixed test code that compiles successfully.\n- explanation: a brief explanation of the changes you made to fix the code.\nHere are the constraints for the test code:\n- The test code MUST be compilable and executable.\n- The test code MUST include line breaks.\n- The test code MUST preserve the original logic of close_all_connections as much as possible.\n- You MUST not define the main function.\n- You MUST not define macros.\n- The test code MUST not contain any mock functions.\n</response format>\n<instruction>\nPlease fix the code so that it compiles successfully.\n</instruction>\n",
  "fixed_test_code": "#include <stdio.h>\n#include <stdarg.h>\n#include <stdbool.h>\n\nstatic void\nprobe_log (const char *fmt, ...)\n{\n  FILE *f = fopen(\"/tmp/logs/1065.txt\", \"a\");\n  if (!f)\n    return;\n  va_list ap;\n  va_start (ap, fmt);\n  vfprintf (f, fmt, ap);\n  va_end (ap);\n  fprintf (f, \"\\n\");\n  fclose (f);\n}\n\nstatic void\nclose_all_connections (struct MHD_Daemon *daemon)\n{\n  struct MHD_Connection *pos;\n  const bool used_thr_p_c = MHD_D_IS_USING_THREAD_PER_CONN_ (daemon);\n#ifdef UPGRADE_SUPPORT\n  const bool upg_allowed = (0 != (daemon->options & MHD_ALLOW_UPGRADE));\n#endif /* UPGRADE_SUPPORT */\n#if defined(HTTPS_SUPPORT) && defined(UPGRADE_SUPPORT)\n  struct MHD_UpgradeResponseHandle *urh;\n  struct MHD_UpgradeResponseHandle *urhn;\n  const bool used_tls = (0 != (daemon->options & MHD_USE_TLS));\n#endif /* HTTPS_SUPPORT && UPGRADE_SUPPORT */\n\n  /* Log entry and basic state */\n  probe_log (\"enter close_all_connections: daemon=%p, used_thr_p_c=%d\",\n              (void *) daemon, (int) used_thr_p_c);\n#ifdef UPGRADE_SUPPORT\n  probe_log (\"daemon->options=0x%lx, upg_allowed=%d\",\n              (unsigned long) daemon->options, (int) upg_allowed);\n#endif\n#if defined(HTTPS_SUPPORT) && defined(UPGRADE_SUPPORT)\n  probe_log (\"used_tls=%d\", (int) used_tls);\n#endif\n\n#ifdef MHD_USE_THREADS\n  mhd_assert ( (! MHD_D_IS_USING_THREADS_ (daemon)) || \\\n               MHD_D_IS_USING_THREAD_PER_CONN_ (daemon) || \\\n               MHD_thread_handle_ID_is_current_thread_ (daemon->tid) );\n  mhd_assert (NULL == daemon->worker_pool);\n  /* Fix: take the address of the tid structure for printing instead of\n     attempting to cast the struct itself to (void *), which is illegal. */\n  probe_log (\"MHD_USE_THREADS: worker_pool=%p, tid=%p\",\n              (void *) daemon->worker_pool, (void *) &daemon->tid);\n#endif /* MHD_USE_THREADS */\n  mhd_assert (daemon->shutdown);\n  probe_log (\"daemon->shutdown=%d\", (int) daemon->shutdown);\n\n#ifdef MHD_USE_THREADS\n/* Remove externally added new connections that are\n   * not processed by the daemon thread. */\n  MHD_mutex_lock_chk_ (&daemon->new_connections_mutex);\n  probe_log (\"locked new_connections_mutex, new_connections_tail=%p\",\n              (void *) daemon->new_connections_tail);\n  while (NULL != (pos = daemon->new_connections_tail))\n  {\n    mhd_assert (MHD_D_IS_USING_THREADS_ (daemon));\n    probe_log (\"removing new connection pos=%p\", (void *) pos);\n    DLL_remove (daemon->new_connections_head,\n                daemon->new_connections_tail,\n                pos);\n    new_connection_close_ (daemon, pos);\n  }\n  MHD_mutex_unlock_chk_ (&daemon->new_connections_mutex);\n  probe_log (\"unlocked new_connections_mutex\");\n#endif /* MHD_USE_THREADS */\n\n#if defined(HTTPS_SUPPORT) && defined(UPGRADE_SUPPORT)\n  /* give upgraded HTTPS connections a chance to finish */\n  /* 'daemon->urh_head' is not used in thread-per-connection mode. */\n  for (urh = daemon->urh_tail; NULL != urh; urh = urhn)\n  {\n    mhd_assert (! used_thr_p_c);\n    urhn = urh->prev;\n    probe_log (\"processing urh=%p, connection=%p, urh->clean_ready=%d\",\n               (void *) urh, (void *) urh->connection,\n               (int) urh->clean_ready);\n    /* call generic forwarding function for passing data\n       with chance to detect that application is done. */\n    process_urh (urh);\n    MHD_connection_finish_forward_ (urh->connection);\n    urh->clean_ready = true;\n    /* Resuming will move connection to cleanup list. */\n    MHD_resume_connection (urh->connection);\n  }\n#endif /* HTTPS_SUPPORT && UPGRADE_SUPPORT */\n\n  /* Give suspended connections a chance to resume to avoid\n     running into the check for there not being any suspended\n     connections left in case of a tight race with a recently\n     resumed connection. */\n  if (0 != (MHD_TEST_ALLOW_SUSPEND_RESUME & daemon->options))\n  {\n    daemon->resuming = true;   /* Force check for pending resume. */\n    probe_log (\"forcing resume: daemon->resuming=%d\",\n                (int) daemon->resuming);\n    resume_suspended_connections (daemon);\n  }\n  /* first, make sure all threads are aware of shutdown; need to\n     traverse DLLs in peace... */\n#if defined(MHD_USE_POSIX_THREADS) || defined(MHD_USE_W32_THREADS)\n  MHD_mutex_lock_chk_ (&daemon->cleanup_connection_mutex);\n  probe_log (\"locked cleanup_connection_mutex\");\n#endif\n#ifdef UPGRADE_SUPPORT\n  probe_log (\"evaluating upgraded-connections branch: upg_allowed=%d\",\n              (int) upg_allowed);\n  if (upg_allowed)\n  {\n    struct MHD_Connection *susp;\n\n    susp = daemon->suspended_connections_tail;\n    probe_log (\"enter upgraded suspended loop: suspended_tail=%p\",\n               (void *) susp);\n    while (NULL != susp)\n    {\n      probe_log (\"susp=%p, susp->urh=%p\", (void *) susp, (void *) susp->urh);\n      if (NULL == susp->urh)     /* \"Upgraded\" connection? */\n        MHD_PANIC (_ (\"MHD_stop_daemon() called while we have \" \\\n                      \"suspended connections.\\n\"));\n#ifdef HTTPS_SUPPORT\n      else if (used_tls &&\n               used_thr_p_c &&\n               (! susp->urh->clean_ready) )\n      {\n        probe_log (\"shutting down socket for susp->urh=%p (not clean_ready)\",\n                   (void *) susp->urh);\n        shutdown (susp->urh->app.socket,\n                  SHUT_RDWR);     /* Wake thread by shutdown of app socket. */\n      }\n#endif /* HTTPS_SUPPORT */\n      else\n      {\n#ifdef HAVE_MESSAGES\n        if (! susp->urh->was_closed)\n          MHD_DLOG (daemon,\n                    _ (\"Initiated daemon shutdown while \\\"upgraded\\\" \" \\\n                       \"connection was not closed.\\n\"));\n#endif\n        probe_log (\"marking urh=%p was_closed (previous=%d)\",\n                   (void *) susp->urh, (int) susp->urh->was_closed);\n        susp->urh->was_closed = true;\n        /* If thread-per-connection is used, connection's thread\n         * may still processing \"upgrade\" (exiting). */\n        if (! used_thr_p_c)\n          MHD_connection_finish_forward_ (susp);\n        /* Do not use MHD_resume_connection() as mutex is\n         * already locked. */\n        susp->resuming = true;\n        daemon->resuming = true;\n        probe_log (\"susp->resuming set, daemon->resuming=%d\",\n                   (int) daemon->resuming);\n      }\n      susp = susp->prev;\n    }\n  }\n  else /* This 'else' is combined with next 'if' */\n#endif /* UPGRADE_SUPPORT */\n  if (NULL != daemon->suspended_connections_head)\n  {\n    probe_log (\"suspended_connections_head present: %p -> PANIC\",\n               (void *) daemon->suspended_connections_head);\n    MHD_PANIC (_ (\"MHD_stop_daemon() called while we have \" \\\n                  \"suspended connections.\\n\"));\n  }\n#if defined(UPGRADE_SUPPORT) && defined(HTTPS_SUPPORT)\n#ifdef MHD_USE_THREADS\n  if (upg_allowed && used_tls && used_thr_p_c)\n  {\n    /* \"Upgraded\" threads may be running in parallel. Connection will not be\n     * moved to the \"cleanup list\" until connection's thread finishes.\n     * We must ensure that all \"upgraded\" connections are finished otherwise\n     * connection may stay in \"suspended\" list and will not be cleaned. */\n    for (pos = daemon->suspended_connections_tail; NULL != pos; pos = pos->prev)\n    {\n      /* Any connection found here is \"upgraded\" connection, normal suspended\n       * connections are already removed from this list. */\n      mhd_assert (NULL != pos->urh);\n      probe_log (\"checking upgraded thread pos=%p, thread_joined=%d\",\n                 (void *) pos, (int) pos->thread_joined);\n      if (! pos->thread_joined)\n      {\n        /* While \"cleanup\" list is not manipulated by \"upgraded\"\n         * connection, \"cleanup\" mutex is required for call of\n         * MHD_resume_connection() during finishing of \"upgraded\"\n         * thread. */\n        MHD_mutex_unlock_chk_ (&daemon->cleanup_connection_mutex);\n        probe_log (\"unlocked cleanup_connection_mutex to join thread tid=%p\",\n                   (void *) pos->tid);\n        if (! MHD_thread_handle_ID_join_thread_ (pos->tid))\n          MHD_PANIC (_ (\"Failed to join a thread.\\n\"));\n        pos->thread_joined = true;\n        MHD_mutex_lock_chk_ (&daemon->cleanup_connection_mutex);\n        probe_log (\"joined thread and relocked cleanup_connection_mutex for pos=%p\",\n                   (void *) pos);\n      }\n    }\n  }\n#endif /* MHD_USE_THREADS */\n#endif\n  for (pos = daemon->connections_tail; NULL != pos; pos = pos->prev)\n  {\n    probe_log (\"shutdown connection pos=%p, socket_fd=%d\",\n               (void *) pos, (int) pos->socket_fd);\n    shutdown (pos->socket_fd,\n              SHUT_RDWR);\n#ifdef MHD_WINSOCK_SOCKETS\n    if (MHD_D_IS_USING_THREAD_PER_CONN_ (daemon) &&\n        (MHD_ITC_IS_VALID_ (daemon->itc)) &&\n        (! MHD_itc_activate_ (daemon->itc, \"e\")) )\n      MHD_PANIC (_ (\"Failed to signal shutdown via inter-thread \" \\\n                    \"communication channel.\\n\"));\n#endif\n  }\n\n#if defined(MHD_USE_POSIX_THREADS) || defined(MHD_USE_W32_THREADS)\n  /* now, collect per-connection threads */\n  if (used_thr_p_c)\n  {\n    pos = daemon->connections_tail;\n    while (NULL != pos)\n    {\n      if (! pos->thread_joined)\n      {\n        probe_log (\"joining per-connection thread pos=%p, tid=%p\",\n                   (void *) pos, (void *) &pos->tid);\n        MHD_mutex_unlock_chk_ (&daemon->cleanup_connection_mutex);\n        if (! MHD_thread_handle_ID_join_thread_ (pos->tid))\n          MHD_PANIC (_ (\"Failed to join a thread.\\n\"));\n        MHD_mutex_lock_chk_ (&daemon->cleanup_connection_mutex);\n        pos->thread_joined = true;\n        /* The thread may have concurrently modified the DLL,\n           need to restart from the beginning */\n        pos = daemon->connections_tail;\n        probe_log (\"restarting scan of connections after join, new tail=%p\",\n                   (void *) pos);\n        continue;\n      }\n      pos = pos->prev;\n    }\n  }\n  MHD_mutex_unlock_chk_ (&daemon->cleanup_connection_mutex);\n  probe_log (\"unlocked cleanup_connection_mutex after joining threads\");\n#endif\n\n#ifdef UPGRADE_SUPPORT\n  /* Finished threads with \"upgraded\" connections need to be moved\n   * to cleanup list by resume_suspended_connections(). */\n  /* \"Upgraded\" connections that were not closed explicitly by\n   * application should be moved to cleanup list too. */\n  if (upg_allowed)\n  {\n    daemon->resuming = true;   /* Force check for pending resume. */\n    probe_log (\"final resume pass forced: daemon->resuming=%d\",\n               (int) daemon->resuming);\n    resume_suspended_connections (daemon);\n  }\n#endif /* UPGRADE_SUPPORT */\n\n  mhd_assert (NULL == daemon->suspended_connections_head);\n  probe_log (\"after cleanup: suspended_connections_head=%p\",\n             (void *) daemon->suspended_connections_head);\n  /* now that we're alone, move everyone to cleanup */\n  while (NULL != (pos = daemon->connections_tail))\n  {\n#if defined(MHD_USE_POSIX_THREADS) || defined(MHD_USE_W32_THREADS)\n    if (MHD_D_IS_USING_THREAD_PER_CONN_ (daemon) &&\n        (! pos->thread_joined) )\n      MHD_PANIC (_ (\"Failed to join a thread.\\n\"));\n#endif\n    probe_log (\"closing connection pos=%p\", (void *) pos);\n    close_connection (pos);\n  }\n  MHD_cleanup_connections (daemon);\n  probe_log (\"exit close_all_connections: daemon=%p\", (void *) daemon);\n}\n",
  "explanation": "The build errors were caused by attempts to cast a struct (MHD_thread_handle_ID_) directly to (void *), which is invalid in C. I changed those log calls to take the address of the tid structure and cast that pointer to (void *): using (void *)&daemon->tid and (void *)&pos->tid. This preserves the original intent (printing an identifier for the thread handle) while avoiding illegal casts. No other logic was changed."
}