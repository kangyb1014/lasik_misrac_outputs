{
  "user_message": "An agent A claimed that the following MHD_set_connection_value code violates the MISRA C 2023 rule 21.17.\n<misra_rule>\nMISRA C 2023 Rule 21.17 is Use of the string handling functions from <string.h> shall not result in accesses beyond the bounds of the objects referenced by their pointer parameters.\nThis rule strictly applies to the Standard Library functions in <string.h> such as memcpy, memmove, memset, memcmp, strcpy, strncpy, strcat, strncat, strlen, and strspn.\n</misra_rule>\n<target_code>\nHere is the original code of MHD_set_connection_value.\n```c\n_MHD_EXTERN enum MHD_Result\nMHD_set_connection_value (struct MHD_Connection *connection,\n                          enum MHD_ValueKind kind,\n                          const char *key,\n                          const char *value)\n{\n  return MHD_set_connection_value_n_nocheck_ (connection,\n                                              kind,\n                                              key,\n                                              NULL != key\n                                              ? strlen (key)\n                                              : 0,\n                                              value,\n                                              NULL != value\n                                              ? strlen (value)\n                                              : 0);\n}\n```\n</target_code>\n<response format>\nProvide your answer with these fields.\n- explanation: your evaluation of the scenario provided by the agent A.\n- is_report_correct: whether the report is correct or not (true/false). True means there is a violation.\n</response format>\n<scenario>\nThe agent A provided the following violation scenario:\nThe code calls strlen(key) after only checking key != NULL. If key is non-NULL but does not point to a NUL-terminated object (for example caller passes a pointer to a char buffer without a terminating '\\0', or a pointer into an object where no '\\0' occurs before the object end), strlen will read past the object's bounds. Thus the use of strlen can result in out\u2011of\u2011bounds access.\n</scenario>\n\n<instruction>\nJudge whether the report is correct or not.\n</instruction>\n",
  "is_report_correct": true,
  "explanation": "The call to strlen(key) and strlen(value) is only guarded against NULL pointers. strlen() requires that the pointer reference a NUL\u2011terminated character array; if a caller passes a non\u2011NUL\u2011terminated buffer (or a pointer into an object with no '\\0' before the object end), strlen will continue reading and may access memory beyond the object bounds. MISRA C 2023 Rule 21.17 forbids uses of <string.h> functions that can result in accesses beyond the bounds of the referenced objects. Therefore, unless there is an externally enforced and verifiable API precondition that key and value are guaranteed to be NUL\u2011terminated C strings, this code can violate Rule 21.17. In the absence of such a documented and enforced contract, the agent A report is correct. Recommended fixes: require caller to pass lengths (already provided by the underlying _nocheck_ variant), validate/obtain lengths safely, or document and enforce the NUL\u2011termination precondition."
}