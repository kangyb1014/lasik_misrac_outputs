{
  "user_message": "An agent A claimed that the following internal_run_from_select code violates the MISRA C 2023 rule 8.13.\n<misra_rule>\nMISRA C 2023 Rule 8.13 is A pointer should point to a const-qualified type whenever possible.\n\n</misra_rule>\n<target_code>\nHere is the original code of internal_run_from_select.\n```c\nstatic enum MHD_Result\ninternal_run_from_select (struct MHD_Daemon *daemon,\n                          const fd_set *read_fd_set,\n                          const fd_set *write_fd_set,\n                          const fd_set *except_fd_set,\n                          int fd_setsize)\n{\n  MHD_socket ds;\n#if defined(HTTPS_SUPPORT) && defined(UPGRADE_SUPPORT)\n  struct MHD_UpgradeResponseHandle *urh;\n  struct MHD_UpgradeResponseHandle *urhn;\n#endif /* HTTPS_SUPPORT && UPGRADE_SUPPORT */\n\n  mhd_assert ((0 == (daemon->options & MHD_USE_SELECT_INTERNALLY)) || \\\n              (MHD_thread_handle_ID_is_valid_ID_ (daemon->tid)));\n  mhd_assert ((0 != (daemon->options & MHD_USE_SELECT_INTERNALLY)) || \\\n              (! MHD_thread_handle_ID_is_valid_ID_ (daemon->tid)));\n  mhd_assert ((0 == (daemon->options & MHD_USE_SELECT_INTERNALLY)) || \\\n              (MHD_thread_handle_ID_is_current_thread_ (daemon->tid)));\n\n  mhd_assert (0 < fd_setsize);\n  (void) fd_setsize; /* Mute compiler warning */\n#ifndef HAS_FD_SETSIZE_OVERRIDABLE\n  (void) fd_setsize; /* Mute compiler warning */\n  mhd_assert (((int) FD_SETSIZE) <= fd_setsize);\n  fd_setsize = FD_SETSIZE; /* Help compiler to optimise */\n#endif /* ! HAS_FD_SETSIZE_OVERRIDABLE */\n\n  /* Clear ITC to avoid spinning select */\n  /* Do it before any other processing so new signals\n     will trigger select again and will be processed */\n  if (MHD_ITC_IS_VALID_ (daemon->itc))\n  { /* Have ITC */\n    bool need_to_clear_itc = true; /* ITC is always non-blocking, it is safe to clear even if ITC not activated */\n    if (MHD_SCKT_FD_FITS_FDSET_SETSIZE_ (MHD_itc_r_fd_ (daemon->itc),\n                                         NULL, fd_setsize))\n      need_to_clear_itc = FD_ISSET (MHD_itc_r_fd_ (daemon->itc), \\\n                                    (fd_set *) _MHD_DROP_CONST (read_fd_set)); /* Skip clearing, if not needed */\n    if (need_to_clear_itc)\n      MHD_itc_clear_ (daemon->itc);\n  }\n\n  /* Reset. New value will be set when connections are processed. */\n  /* Note: no-op for thread-per-connection as it is always false in that mode. */\n  daemon->data_already_pending = false;\n\n  /* Process externally added connection if any */\n  if (daemon->have_new)\n    new_connections_list_process_ (daemon);\n\n  /* select connection thread handling type */\n  ds = daemon->listen_fd;\n  if ( (MHD_INVALID_SOCKET != ds) &&\n       (! daemon->was_quiesced) )\n  {\n    bool need_to_accept;\n    if (MHD_SCKT_FD_FITS_FDSET_SETSIZE_ (ds, NULL, fd_setsize))\n      need_to_accept = FD_ISSET (ds,\n                                 (fd_set *) _MHD_DROP_CONST (read_fd_set));\n    else                                       /* Cannot check whether new connection are pending */\n      need_to_accept = daemon->listen_nonblk;  /* Try to accept if non-blocking */\n\n    if (need_to_accept)\n      (void) MHD_accept_connection (daemon);\n  }\n\n  if (! MHD_D_IS_USING_THREAD_PER_CONN_ (daemon))\n  {\n    /* do not have a thread per connection, process all connections now */\n    struct MHD_Connection *pos;\n    for (pos = daemon->connections_tail; NULL != pos; pos = pos->prev)\n    {\n      MHD_socket cs;\n      bool r_ready;\n      bool w_ready;\n      bool has_err;\n\n      cs = pos->socket_fd;\n      if (MHD_INVALID_SOCKET == cs)\n        continue;\n\n      if (MHD_SCKT_FD_FITS_FDSET_SETSIZE_ (cs, NULL, fd_setsize))\n      {\n        r_ready = FD_ISSET (cs,\n                            (fd_set *) _MHD_DROP_CONST (read_fd_set));\n        w_ready = FD_ISSET (cs,\n                            (fd_set *) _MHD_DROP_CONST (write_fd_set));\n        has_err = (NULL != except_fd_set) &&\n                  FD_ISSET (cs,\n                            (fd_set *) _MHD_DROP_CONST (except_fd_set));\n      }\n      else\n      { /* Cannot check the real readiness */\n        r_ready = pos->sk_nonblck;\n        w_ready = r_ready;\n        has_err = false;\n      }\n      call_handlers (pos,\n                     r_ready,\n                     w_ready,\n                     has_err);\n    }\n  }\n\n#if defined(HTTPS_SUPPORT) && defined(UPGRADE_SUPPORT)\n  /* handle upgraded HTTPS connections */\n  for (urh = daemon->urh_tail; NULL != urh; urh = urhn)\n  {\n    urhn = urh->prev;\n    /* update urh state based on select() output */\n    urh_from_fdset (urh,\n                    read_fd_set,\n                    write_fd_set,\n                    except_fd_set,\n                    fd_setsize);\n    /* call generic forwarding function for passing data */\n    process_urh (urh);\n    /* Finished forwarding? */\n    if ( (0 == urh->in_buffer_size) &&\n         (0 == urh->out_buffer_size) &&\n         (0 == urh->in_buffer_used) &&\n         (0 == urh->out_buffer_used) )\n    {\n      MHD_connection_finish_forward_ (urh->connection);\n      urh->clean_ready = true;\n      /* Resuming will move connection to cleanup list. */\n      MHD_resume_connection (urh->connection);\n    }\n  }\n#endif /* HTTPS_SUPPORT && UPGRADE_SUPPORT */\n  MHD_cleanup_connections (daemon);\n  return MHD_YES;\n}\n```\n</target_code>\n<response format>\nProvide your answer with these fields.\n- explanation: your evaluation of the scenario provided by the agent A.\n- is_report_correct: whether the report is correct or not (true/false). True means there is a violation.\n</response format>\n<scenario>\nThe agent A provided the following violation scenario:\nThe code casts away the const qualifier on read_fd_set when calling FD_ISSET: need_to_accept = FD_ISSET(ds, (fd_set *) _MHD_DROP_CONST(read_fd_set)); The parameter read_fd_set is declared as const fd_set * but is forcibly converted to fd_set * (non-const) before being passed to FD_ISSET. This defeats the const qualification that is available and thus violates the requirement that pointers should point to const-qualified types whenever possible.\n</scenario>\n\n<execution_log>\nThe agent A also provided the following output log:\n[internal_run_from_select] listen fd check: listen_fd=3, read_fd_set=0x7ffcb1429068, fd_setsize=1024 - calling FD_ISSET with cast to non-const\n[internal_run_from_select] listen FD_ISSET result: need_to_accept=0\n[internal_run_from_select] exit: daemon=0x55c5fdb18de0, fd_setsize=1024\n[internal_run_from_select] listen fd check: listen_fd=3, read_fd_set=0x7ffcb1429068, fd_setsize=1024 - calling FD_ISSET with cast to non-const\n[internal_run_from_select] listen FD_ISSET result: need_to_accept=0\n[internal_run_from_select] exit: daemon=0x55c5fdb18de0, fd_setsize=1024\n[internal_run_from_select] listen fd check: listen_fd=3, read_fd_set=0x7ffcb1429068, fd_setsize=1024 - calling FD_ISSET with cast to non-const\n[internal_run_from_select] listen FD_ISSET result: need_to_accept=0\n[internal_run_from_select] exit: daemon=0x55c5fdb18de0, fd_setsize=1024\n[internal_run_from_select] listen fd check: listen_fd=3, read_fd_set=0x7ffcb1429068, fd_setsize=1024 - calling FD_ISSET with cast to non-const\n[internal_run_from_select] listen FD_ISSET result: need_to_accept=0\n[internal_run_from_select] exit: daemon=0x55c5fdb18de0, fd_setsize=1024\n[internal_run_from_select] listen fd check: listen_fd=3, read_fd_set=0x7ffcb1429068, fd_setsize=1024 - calling FD_ISSET with cast to non-const\n[internal_run_from_select] listen FD_ISSET result: need_to_accept=0\n[internal_run_from_select] exit: daemon=0x55c5fdb18de0, fd_setsize=1024\n[internal_run_from_select] listen fd check: listen_fd=3, read_fd_set=0x7ffcb1429068, fd_setsize=1024 - calling FD_ISSET with cast to non-const\n[internal_run_from_select] listen FD_ISSET result: need_to_accept=0\n[internal_run_from_select] exit: daemon=0x55c5fdb18de0, fd_setsize=1024\n[internal_run_from_select] listen fd check: listen_fd=3, read_fd_set=0x7ffcb1429068, fd_setsize=1024 - calling FD_ISSET with cast to non-const\n[internal_run_from_select] listen FD_ISSET result: need_to_accept=0\n[internal_run_from_select] exit: daemon=0x55c5fdb18de0, fd_setsize=1024\n[internal_run_from_select] listen fd check: listen_fd=3, read_fd_set=0x7ffcb1429068, fd_setsize=1024 - calling FD_ISSET with cast to non-const\n[internal_run_from_select] listen FD_ISSET result: need_to_accept=0\n[internal_run_from_select] exit: daemon=0x55c5fdb18de0, fd_setsize=1024\n[internal_run_from_select] listen fd check: listen_fd=3, read_fd_set=0x7ffcb1429068, fd_setsize=1024 - calling FD_ISSET with cast to non-const\n[internal_run_from_select] listen FD_ISSET result: need_to_accept=0\n[internal_run_from_select] exit: daemon=0x55c5fdb18de0, fd_setsize=1024\n[internal_run_from_select] listen fd check: listen_fd=3, read_fd_set=0x7ffcb1429068, fd_setsize=1024 - calling FD_ISSET with cast to non-const\n[internal_run_from_select] listen FD_ISSET result: need_to_accept=0\n[internal_run_from_select] exit: daemon=0x55c5fdb18de0, fd_setsize=1024\n[internal_run_from_select] listen fd check: listen_fd=3, read_fd_set=0x7ffcb1429068, fd_setsize=1024 - calling FD_ISSET with cast to non-const\n[internal_run_from_select] listen FD_ISSET result: need_to_accept=0\n[internal_run_from_select] exit: daemon=0x55c5fdb18de0, fd_setsize=1024\n[internal_run_from_select] listen fd check: listen_fd=3, read_fd_set=0x7ffcb1429068, fd_setsize=1024 - calling FD_ISSET with cast to non-const\n[internal_run_from_select] listen FD_ISSET result: need_to_accept=0\n[internal_run_from_select] exit: daemon=0x55c5fdb18de0, fd_setsize=1024\n[internal_run_from_select] listen fd check: listen_fd=3, read_fd_set=0x7ffcb1429068, fd_setsize=1024 - calling FD_ISSET with cast to non-const\n[internal_run_from_select] listen FD_ISSET result: need_to_accept=0\n[internal_run_from_select] exit: daemon=0x55c5fdb18de0, fd_setsize=1024\n[internal_run_from_select] listen fd check: listen_fd=3, read_fd_set=0x7ffcb1429068, fd_setsize=1024 - calling FD_ISSET with cast to non-const\n[internal_run_from_select] listen FD_ISSET result: need_to_accept=0\n[internal_run_from_select] exit: daemon=0x55c5fdb18de0, fd_setsize=1024\n[internal_run_from_select] listen fd check: listen_fd=3, read_fd_set=0x7ffcb1429068, fd_setsize=1024 - calling FD_ISSET with cast to n\n</execution_log>\n\n<instruction>\nJudge whether the report is correct or not.\n</instruction>\n",
  "is_report_correct": false,
  "explanation": "Agent A is incorrect about Rule 8.13. Rule 8.13 is about declaring pointers to point to const-qualified types where possible. In internal_run_from_select the fd_set pointers are declared const (const fd_set *read_fd_set, ...), so the code as declared conforms to the intent of 8.13. The problematic code is that it casts away the const qualifier when calling FD_ISSET (via (fd_set *) _MHD_DROP_CONST(read_fd_set)). That is a separate issue (casting away const/qualifier removal) and would be a potential violation of MISRA rules that forbid removing qualifiers by cast, not Rule 8.13 itself. In other words: the declaration follows 8.13; the cast away of const is a different concern. Therefore the report that this code violates MISRA C 2023 Rule 8.13 is not correct."
}