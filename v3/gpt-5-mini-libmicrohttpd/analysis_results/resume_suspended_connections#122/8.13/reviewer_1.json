{
  "user_message": "An agent A claimed that the following resume_suspended_connections code violates the MISRA C 2023 rule 8.13.\n<misra_rule>\nMISRA C 2023 Rule 8.13 is A pointer should point to a const-qualified type whenever possible.\n\n</misra_rule>\n<target_code>\nHere is the original code of resume_suspended_connections.\n```c\nstatic enum MHD_Result\nresume_suspended_connections (struct MHD_Daemon *daemon)\n{\n  struct MHD_Connection *pos;\n  struct MHD_Connection *prev = NULL;\n  enum MHD_Result ret;\n  const bool used_thr_p_c = (0 != (daemon->options\n                                   & MHD_USE_THREAD_PER_CONNECTION));\n#if defined(MHD_USE_POSIX_THREADS) || defined(MHD_USE_W32_THREADS)\n  mhd_assert (NULL == daemon->worker_pool);\n  mhd_assert ( (! MHD_D_IS_USING_THREADS_ (daemon)) || \\\n               MHD_thread_handle_ID_is_current_thread_ (daemon->tid) );\n#endif\n\n  ret = MHD_NO;\n#if defined(MHD_USE_POSIX_THREADS) || defined(MHD_USE_W32_THREADS)\n  MHD_mutex_lock_chk_ (&daemon->cleanup_connection_mutex);\n#endif\n\n  if (daemon->resuming)\n  {\n    prev = daemon->suspended_connections_tail;\n    /* During shutdown check for resuming is forced. */\n    mhd_assert ((NULL != prev) || (daemon->shutdown) || \\\n                (0 != (daemon->options & MHD_ALLOW_UPGRADE)));\n  }\n\n  daemon->resuming = false;\n\n  while (NULL != (pos = prev))\n  {\n#ifdef UPGRADE_SUPPORT\n    struct MHD_UpgradeResponseHandle *const urh = pos->urh;\n#else  /* ! UPGRADE_SUPPORT */\n    static const void *const urh = NULL;\n#endif /* ! UPGRADE_SUPPORT */\n    prev = pos->prev;\n    if ( (! pos->resuming)\n#ifdef UPGRADE_SUPPORT\n         || ( (NULL != urh) &&\n              ( (! urh->was_closed) ||\n                (! urh->clean_ready) ) )\n#endif /* UPGRADE_SUPPORT */\n         )\n      continue;\n    ret = MHD_YES;\n    mhd_assert (pos->suspended);\n    DLL_remove (daemon->suspended_connections_head,\n                daemon->suspended_connections_tail,\n                pos);\n    pos->suspended = false;\n    if (NULL == urh)\n    {\n      DLL_insert (daemon->connections_head,\n                  daemon->connections_tail,\n                  pos);\n      if (! used_thr_p_c)\n      {\n        /* Reset timeout timer on resume. */\n        if (0 != pos->connection_timeout_ms)\n          pos->last_activity = MHD_monotonic_msec_counter ();\n\n        if (pos->connection_timeout_ms == daemon->connection_timeout_ms)\n          XDLL_insert (daemon->normal_timeout_head,\n                       daemon->normal_timeout_tail,\n                       pos);\n        else\n          XDLL_insert (daemon->manual_timeout_head,\n                       daemon->manual_timeout_tail,\n                       pos);\n      }\n#ifdef EPOLL_SUPPORT\n      if (MHD_D_IS_USING_EPOLL_ (daemon))\n      {\n        if (0 != (pos->epoll_state & MHD_EPOLL_STATE_IN_EREADY_EDLL))\n          MHD_PANIC (\"Resumed connection was already in EREADY set.\\n\");\n        /* we always mark resumed connections as ready, as we\n           might have missed the edge poll event during suspension */\n        EDLL_insert (daemon->eready_head,\n                     daemon->eready_tail,\n                     pos);\n        pos->epoll_state |= MHD_EPOLL_STATE_IN_EREADY_EDLL   \\\n                            | MHD_EPOLL_STATE_READ_READY\n                            | MHD_EPOLL_STATE_WRITE_READY;\n        pos->epoll_state &= ~((enum MHD_EpollState) MHD_EPOLL_STATE_SUSPENDED);\n      }\n#endif\n    }\n#ifdef UPGRADE_SUPPORT\n    else\n    {\n      /* Data forwarding was finished (for TLS connections) AND\n       * application was closed upgraded connection.\n       * Insert connection into cleanup list. */\n\n      if ( (NULL != daemon->notify_completed) &&\n           (! MHD_D_IS_USING_THREAD_PER_CONN_ (daemon)) &&\n           (pos->rq.client_aware) )\n      {\n        daemon->notify_completed (daemon->notify_completed_cls,\n                                  pos,\n                                  &pos->rq.client_context,\n                                  MHD_REQUEST_TERMINATED_COMPLETED_OK);\n        pos->rq.client_aware = false;\n      }\n      DLL_insert (daemon->cleanup_head,\n                  daemon->cleanup_tail,\n                  pos);\n      daemon->data_already_pending = true;\n    }\n#endif /* UPGRADE_SUPPORT */\n    pos->resuming = false;\n  }\n#if defined(MHD_USE_POSIX_THREADS) || defined(MHD_USE_W32_THREADS)\n  MHD_mutex_unlock_chk_ (&daemon->cleanup_connection_mutex);\n#endif\n  if ( (used_thr_p_c) &&\n       (MHD_NO != ret) )\n  {   /* Wake up suspended connections. */\n    if (! MHD_itc_activate_ (daemon->itc,\n                             \"w\"))\n    {\n#ifdef HAVE_MESSAGES\n      MHD_DLOG (daemon,\n                _ (\"Failed to signal resume of connection via \" \\\n                   \"inter-thread communication channel.\\n\"));\n#endif\n    }\n  }\n  return ret;\n}\n```\n</target_code>\n<response format>\nProvide your answer with these fields.\n- explanation: your evaluation of the scenario provided by the agent A.\n- is_report_correct: whether the report is correct or not (true/false). True means there is a violation.\n</response format>\n<scenario>\nThe agent A provided the following violation scenario:\nUnder UPGRADE_SUPPORT the local variable is declared as:\n  struct MHD_UpgradeResponseHandle *const urh = pos->urh;\nThe pointer itself is const but the pointed-to type is not. In the fragment urh is only read (checked for NULL and fields urh->was_closed / urh->clean_ready), so the pointee could and should be const-qualified (e.g. const struct MHD_UpgradeResponseHandle *const urh = pos->urh). Therefore this violates MISRA C 2023 Rule 8.13.\n</scenario>\n\n<execution_log>\nThe agent A also provided the following output log:\n[1756197296] enter resume_suspended_connections: daemon=0x55c6e3193830 used_thr_p_c=0 options=0x0000a401 resuming=0 shutdown=0\n[1756197296] exit resume_suspended_connections: ret=0\n[1756197296] enter resume_suspended_connections: daemon=0x55c6e3193830 used_thr_p_c=0 options=0x0000a401 resuming=0 shutdown=0\n[1756197296] exit resume_suspended_connections: ret=0\n[1756197296] enter resume_suspended_connections: daemon=0x55c6e3193830 used_thr_p_c=0 options=0x0000a401 resuming=1 shutdown=0\n[1756197296] resuming true: suspended_tail=0x55c6e3193fd0\n[1756197296] conn pos=0x55c6e3193fd0 prev=(nil) urh=0x55c6e319c4a0 pos->resuming=1 urh->was_closed=1 urh->clean_ready=1\n[1756197296] resuming connection: pos=0x55c6e3193fd0 setting ret=MHD_YES\n[1756197296] inserting resumed upgraded connection into cleanup list: pos=0x55c6e3193fd0 urh=0x55c6e319c4a0 was_closed=1 clean_ready=1\n[1756197296] calling notify_completed for pos=0x55c6e3193fd0\n[1756197296] finished handling pos=0x55c6e3193fd0 resuming cleared\n[1756197296] exit resume_suspended_connections: ret=1\n[1756197296] enter resume_suspended_connections: daemon=0x55c6e3193830 used_thr_p_c=0 options=0x0000a401 resuming=1 shutdown=1\n[1756197296] resuming true: suspended_tail=(nil)\n[1756197296] exit resume_suspended_connections: ret=0\n[1756197296] enter resume_suspended_connections: daemon=0x55c6e3193830 used_thr_p_c=0 options=0x0000a401 resuming=1 shutdown=1\n[1756197296] resuming true: suspended_tail=(nil)\n[1756197296] exit resume_suspended_connections: ret=0\n[1756197296] enter resume_suspended_connections: daemon=0x55c6e319c600 used_thr_p_c=0 options=0x0001a601 resuming=0 shutdown=0\n[1756197296] exit resume_suspended_connections: ret=0\n[1756197296] enter resume_suspended_connections: daemon=0x55c6e319c600 used_thr_p_c=0 options=0x0001a601 resuming=0 shutdown=0\n[1756197296] exit resume_suspended_connections: ret=0\n[1756197296] enter resume_suspended_connections: daemon=0x55c6e319c600 used_thr_p_c=0 options=0x0001a601 resuming=0 shutdown=0\n[1756197296] exit resume_suspended_connections: ret=0\n[1756197296] enter resume_suspended_connections: daemon=0x55c6e319c600 used_thr_p_c=0 options=0x0001a601 resuming=1 shutdown=0\n[1756197296] resuming true: suspended_tail=0x55c6e319ca80\n[1756197296] conn pos=0x55c6e319ca80 prev=(nil) urh=0x55c6e3193cb0 pos->resuming=1 urh->was_closed=1 urh->clean_ready=1\n[1756197296] resuming connection: pos=0x55c6e319ca80 setting ret=MHD_YES\n[1756197296] inserting resumed upgraded connection into cleanup list: pos=0x55c6e319ca80 urh=0x55c6e3193cb0 was_closed=1 clean_ready=1\n[1756197296] calling notify_completed for pos=0x55c6e319ca80\n[1756197296] finished handling pos=0x55c6e319ca80 resuming cleared\n[1756197296] exit resume_suspended_connections: ret=1\n[1756197296] enter resume_suspended_connections: daemon=0x55c6e319c600 used_thr_p_c=0 options=0x0001a601 resuming=1 shutdown=1\n[1756197296] resuming true: suspended_tail=(nil)\n[1756197296] exit resume_suspended_connections: ret=0\n[1756197296] enter resume_suspended_connections: daemon=0x55c6e319c600 used_thr_p_c=0 options=0x0001a601 resuming=1 shutdown=1\n[1756197296] resuming true: suspended_tail=(nil)\n[1756197296] exit resume_suspended_connections: ret=0\n[1756197296] enter resume_suspended_connections: daemon=0x55c6e319ce10 used_thr_p_c=0 options=0x0000a601 resuming=0 shutdown=0\n[1756197296] exit resume_suspended_connections: ret=0\n[1756197296] enter resume_suspended_connections: daemon=0x55c6e319ce10 used_thr_p_c=0 options=0x0000a601 resuming=0 shutdown=0\n[1756197296] exit resume_suspended_connections: ret=0\n[1756197296] enter resume_suspended_connections: daemon=0x55c6e319ce10 used_thr_p_c=0 options=0x0000a601 resuming=0 shutdown=0\n[1756197296] exit resume_suspended_connections: ret=0\n[1756197296] enter resume_suspended_connections: daemon=0x55c6e319ce10 used_thr_p_c=0 options=0x0000a601 resuming=1 shutdown=0\n[1756197296] resuming true: suspended_tail=0x55c6e3194270\n[1756197296] conn pos=0x55c6e3194270 prev=(nil) urh=0x55c6e3194220 pos->resuming=1 urh->was_closed=1 urh->clean_ready=1\n[1756197296] resuming connection:\n</execution_log>\n\n<instruction>\nJudge whether the report is correct or not.\n</instruction>\n",
  "is_report_correct": true,
  "explanation": "Agent A is correct. In the UPGRADE_SUPPORT branch the local variable is declared as\n  struct MHD_UpgradeResponseHandle *const urh = pos->urh;\nwhich makes the pointer itself const but not the pointed-to type. The code only reads urh (checks for NULL and reads fields urh->was_closed and urh->clean_ready), so the pointed-to object could and should be treated as const. MISRA C 2023 Rule 8.13 recommends that a pointer should point to a const-qualified type whenever possible; therefore declaring the variable as\n  const struct MHD_UpgradeResponseHandle *const urh = pos->urh;\nwould satisfy the recommendation. Note that this is a \u201cshould\u201d style rule (a recommendation) rather than an absolute prohibition, but by the rule wording the current declaration does violate the guidance. Assignment from pos->urh (non-const) to a pointer-to-const is allowed, so making this change is safe and appropriate."
}