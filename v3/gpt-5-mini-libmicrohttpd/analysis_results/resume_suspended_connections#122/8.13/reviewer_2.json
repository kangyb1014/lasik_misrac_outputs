{
  "user_message": "An agent A claimed that the following resume_suspended_connections code violates the MISRA C 2023 rule 8.13.\n<misra_rule>\nMISRA C 2023 Rule 8.13 is A pointer should point to a const-qualified type whenever possible.\n\n</misra_rule>\n<target_code>\nHere is the original code of resume_suspended_connections.\n```c\nstatic enum MHD_Result\nresume_suspended_connections (struct MHD_Daemon *daemon)\n{\n  struct MHD_Connection *pos;\n  struct MHD_Connection *prev = NULL;\n  enum MHD_Result ret;\n  const bool used_thr_p_c = (0 != (daemon->options\n                                   & MHD_USE_THREAD_PER_CONNECTION));\n#if defined(MHD_USE_POSIX_THREADS) || defined(MHD_USE_W32_THREADS)\n  mhd_assert (NULL == daemon->worker_pool);\n  mhd_assert ( (! MHD_D_IS_USING_THREADS_ (daemon)) || \\\n               MHD_thread_handle_ID_is_current_thread_ (daemon->tid) );\n#endif\n\n  ret = MHD_NO;\n#if defined(MHD_USE_POSIX_THREADS) || defined(MHD_USE_W32_THREADS)\n  MHD_mutex_lock_chk_ (&daemon->cleanup_connection_mutex);\n#endif\n\n  if (daemon->resuming)\n  {\n    prev = daemon->suspended_connections_tail;\n    /* During shutdown check for resuming is forced. */\n    mhd_assert ((NULL != prev) || (daemon->shutdown) || \\\n                (0 != (daemon->options & MHD_ALLOW_UPGRADE)));\n  }\n\n  daemon->resuming = false;\n\n  while (NULL != (pos = prev))\n  {\n#ifdef UPGRADE_SUPPORT\n    struct MHD_UpgradeResponseHandle *const urh = pos->urh;\n#else  /* ! UPGRADE_SUPPORT */\n    static const void *const urh = NULL;\n#endif /* ! UPGRADE_SUPPORT */\n    prev = pos->prev;\n    if ( (! pos->resuming)\n#ifdef UPGRADE_SUPPORT\n         || ( (NULL != urh) &&\n              ( (! urh->was_closed) ||\n                (! urh->clean_ready) ) )\n#endif /* UPGRADE_SUPPORT */\n         )\n      continue;\n    ret = MHD_YES;\n    mhd_assert (pos->suspended);\n    DLL_remove (daemon->suspended_connections_head,\n                daemon->suspended_connections_tail,\n                pos);\n    pos->suspended = false;\n    if (NULL == urh)\n    {\n      DLL_insert (daemon->connections_head,\n                  daemon->connections_tail,\n                  pos);\n      if (! used_thr_p_c)\n      {\n        /* Reset timeout timer on resume. */\n        if (0 != pos->connection_timeout_ms)\n          pos->last_activity = MHD_monotonic_msec_counter ();\n\n        if (pos->connection_timeout_ms == daemon->connection_timeout_ms)\n          XDLL_insert (daemon->normal_timeout_head,\n                       daemon->normal_timeout_tail,\n                       pos);\n        else\n          XDLL_insert (daemon->manual_timeout_head,\n                       daemon->manual_timeout_tail,\n                       pos);\n      }\n#ifdef EPOLL_SUPPORT\n      if (MHD_D_IS_USING_EPOLL_ (daemon))\n      {\n        if (0 != (pos->epoll_state & MHD_EPOLL_STATE_IN_EREADY_EDLL))\n          MHD_PANIC (\"Resumed connection was already in EREADY set.\\n\");\n        /* we always mark resumed connections as ready, as we\n           might have missed the edge poll event during suspension */\n        EDLL_insert (daemon->eready_head,\n                     daemon->eready_tail,\n                     pos);\n        pos->epoll_state |= MHD_EPOLL_STATE_IN_EREADY_EDLL   \\\n                            | MHD_EPOLL_STATE_READ_READY\n                            | MHD_EPOLL_STATE_WRITE_READY;\n        pos->epoll_state &= ~((enum MHD_EpollState) MHD_EPOLL_STATE_SUSPENDED);\n      }\n#endif\n    }\n#ifdef UPGRADE_SUPPORT\n    else\n    {\n      /* Data forwarding was finished (for TLS connections) AND\n       * application was closed upgraded connection.\n       * Insert connection into cleanup list. */\n\n      if ( (NULL != daemon->notify_completed) &&\n           (! MHD_D_IS_USING_THREAD_PER_CONN_ (daemon)) &&\n           (pos->rq.client_aware) )\n      {\n        daemon->notify_completed (daemon->notify_completed_cls,\n                                  pos,\n                                  &pos->rq.client_context,\n                                  MHD_REQUEST_TERMINATED_COMPLETED_OK);\n        pos->rq.client_aware = false;\n      }\n      DLL_insert (daemon->cleanup_head,\n                  daemon->cleanup_tail,\n                  pos);\n      daemon->data_already_pending = true;\n    }\n#endif /* UPGRADE_SUPPORT */\n    pos->resuming = false;\n  }\n#if defined(MHD_USE_POSIX_THREADS) || defined(MHD_USE_W32_THREADS)\n  MHD_mutex_unlock_chk_ (&daemon->cleanup_connection_mutex);\n#endif\n  if ( (used_thr_p_c) &&\n       (MHD_NO != ret) )\n  {   /* Wake up suspended connections. */\n    if (! MHD_itc_activate_ (daemon->itc,\n                             \"w\"))\n    {\n#ifdef HAVE_MESSAGES\n      MHD_DLOG (daemon,\n                _ (\"Failed to signal resume of connection via \" \\\n                   \"inter-thread communication channel.\\n\"));\n#endif\n    }\n  }\n  return ret;\n}\n```\n</target_code>\n<response format>\nProvide your answer with these fields.\n- explanation: your evaluation of the scenario provided by the agent A.\n- is_report_correct: whether the report is correct or not (true/false). True means there is a violation.\n</response format>\n<scenario>\nThe agent A provided the following violation scenario:\nWhen UPGRADE_SUPPORT is defined, the local variable is declared as: struct MHD_UpgradeResponseHandle *const urh = pos->urh; In the fragment urh is only read (urh->was_closed, urh->clean_ready) and never used to modify the pointed-to object, so the pointed-to type could (and should) be const-qualified: const struct MHD_UpgradeResponseHandle *const urh = pos->urh; Therefore Rule 8.13 is violated when UPGRADE_SUPPORT is enabled.\n</scenario>\n\n<execution_log>\nThe agent A also provided the following output log:\nenter resume_suspended_connections: daemon=0x56241e9d1830 resuming=0 suspended_tail=(nil) options=0x0000a401 used_thr_p_c=0\nexit resume_suspended_connections: daemon=0x56241e9d1830 ret=0\nenter resume_suspended_connections: daemon=0x56241e9d1830 resuming=0 suspended_tail=(nil) options=0x0000a401 used_thr_p_c=0\nexit resume_suspended_connections: daemon=0x56241e9d1830 ret=0\nenter resume_suspended_connections: daemon=0x56241e9d1830 resuming=1 suspended_tail=0x56241e9d1fd0 options=0x0000a401 used_thr_p_c=0\nresuming true: prev=0x56241e9d1fd0 daemon->shutdown=0\niter: pos=0x56241e9d1fd0 prev=(nil) pos->resuming=1 pos->suspended=1 urh=0x56241e9da4a0 cond_not_resuming=0 cond_urh_nonnull=1 cond_urh_not_ready=0\nresuming connection pos=0x56241e9d1fd0: removing from suspended list and clearing suspended flag\nupgrade-resume: inserting pos=0x56241e9d1fd0 into cleanup list urh=0x56241e9da4a0 was_closed=1 clean_ready=1\nfinished iteration for pos=0x56241e9d1fd0: resuming cleared\nexit resume_suspended_connections: daemon=0x56241e9d1830 ret=1\nenter resume_suspended_connections: daemon=0x56241e9d1830 resuming=1 suspended_tail=(nil) options=0x0000a401 used_thr_p_c=0\nresuming true: prev=(nil) daemon->shutdown=1\nexit resume_suspended_connections: daemon=0x56241e9d1830 ret=0\nenter resume_suspended_connections: daemon=0x56241e9d1830 resuming=1 suspended_tail=(nil) options=0x0000a401 used_thr_p_c=0\nresuming true: prev=(nil) daemon->shutdown=1\nexit resume_suspended_connections: daemon=0x56241e9d1830 ret=0\nenter resume_suspended_connections: daemon=0x56241e9da600 resuming=0 suspended_tail=(nil) options=0x0001a601 used_thr_p_c=0\nexit resume_suspended_connections: daemon=0x56241e9da600 ret=0\nenter resume_suspended_connections: daemon=0x56241e9da600 resuming=0 suspended_tail=(nil) options=0x0001a601 used_thr_p_c=0\nexit resume_suspended_connections: daemon=0x56241e9da600 ret=0\nenter resume_suspended_connections: daemon=0x56241e9da600 resuming=0 suspended_tail=(nil) options=0x0001a601 used_thr_p_c=0\nexit resume_suspended_connections: daemon=0x56241e9da600 ret=0\nenter resume_suspended_connections: daemon=0x56241e9da600 resuming=1 suspended_tail=0x56241e9daa80 options=0x0001a601 used_thr_p_c=0\nresuming true: prev=0x56241e9daa80 daemon->shutdown=0\niter: pos=0x56241e9daa80 prev=(nil) pos->resuming=1 pos->suspended=1 urh=0x56241e9da4c0 cond_not_resuming=0 cond_urh_nonnull=1 cond_urh_not_ready=0\nresuming connection pos=0x56241e9daa80: removing from suspended list and clearing suspended flag\nupgrade-resume: inserting pos=0x56241e9daa80 into cleanup list urh=0x56241e9da4c0 was_closed=1 clean_ready=1\nfinished iteration for pos=0x56241e9daa80: resuming cleared\nexit resume_suspended_connections: daemon=0x56241e9da600 ret=1\nenter resume_suspended_connections: daemon=0x56241e9da600 resuming=1 suspended_tail=(nil) options=0x0001a601 used_thr_p_c=0\nresuming true: prev=(nil) daemon->shutdown=1\nexit resume_suspended_connections: daemon=0x56241e9da600 ret=0\nenter resume_suspended_connections: daemon=0x56241e9da600 resuming=1 suspended_tail=(nil) options=0x0001a601 used_thr_p_c=0\nresuming true: prev=(nil) daemon->shutdown=1\nexit resume_suspended_connections: daemon=0x56241e9da600 ret=0\nenter resume_suspended_connections: daemon=0x56241e9dae10 resuming=0 suspended_tail=(nil) options=0x0000a601 used_thr_p_c=0\nexit resume_suspended_connections: daemon=0x56241e9dae10 ret=0\nenter resume_suspended_connections: daemon=0x56241e9dae10 resuming=0 suspended_tail=(nil) options=0x0000a601 used_thr_p_c=0\nexit resume_suspended_connections: daemon=0x56241e9dae10 ret=0\nenter resume_suspended_connections: daemon=0x56241e9dae10 resuming=0 suspended_tail=(nil) options=0x0000a601 used_thr_p_c=0\nexit resume_suspended_connections: daemon=0x56241e9dae10 ret=0\nenter resume_suspended_connections: daemon=0x56241e9dae10 resuming=1 suspended_tail=0x56241e9d2270 options=0x0000a601 used_thr_p_c=0\nresuming true: prev=0x56241e9d2270 daemon->shutdown=0\niter: pos=0x56241e9d2270 prev=(nil) pos->resuming=1 pos->suspended=1 urh=0x56241e9d2220 cond_not_resuming=0 cond_urh_nonnull=1 cond_urh_not_ready=0\nresuming \n</execution_log>\n\n<instruction>\nJudge whether the report is correct or not.\n</instruction>\n",
  "is_report_correct": true,
  "explanation": "The report is correct. In the UPGRADE_SUPPORT branch the local urh is declared as:\n  struct MHD_UpgradeResponseHandle *const urh = pos->urh;\nThe code only reads members (urh->was_closed, urh->clean_ready) and does not use urh to modify the pointed-to object. Per MISRA C 2023 Rule 8.13, the pointed-to type should be const-qualified whenever possible. Declaring urh as\n  const struct MHD_UpgradeResponseHandle *const urh = pos->urh;\nwould satisfy the rule (conversion from T * to const T * is allowed) and is a safe, low-risk change. Therefore the reported violation is valid."
}