{
  "user_message": "An agent A claimed that the following resume_suspended_connections code violates the MISRA C 2023 rule 14.3.\n<misra_rule>\nMISRA C 2023 Rule 14.3 is Controlling expressions shall not be invariant.\nHere are exceptions to this rule:\n1. Invariants that are used to create infinite loops are permitted.\n2. A do-while loop with an essentially Boolean controlling expression that evaluates to false and satisfies the constraints and semantics for an integer constant expression is permitted.\n</misra_rule>\n<target_code>\nHere is the original code of resume_suspended_connections.\n```c\nstatic enum MHD_Result\nresume_suspended_connections (struct MHD_Daemon *daemon)\n{\n  struct MHD_Connection *pos;\n  struct MHD_Connection *prev = NULL;\n  enum MHD_Result ret;\n  const bool used_thr_p_c = (0 != (daemon->options\n                                   & MHD_USE_THREAD_PER_CONNECTION));\n#if defined(MHD_USE_POSIX_THREADS) || defined(MHD_USE_W32_THREADS)\n  mhd_assert (NULL == daemon->worker_pool);\n  mhd_assert ( (! MHD_D_IS_USING_THREADS_ (daemon)) || \\\n               MHD_thread_handle_ID_is_current_thread_ (daemon->tid) );\n#endif\n\n  ret = MHD_NO;\n#if defined(MHD_USE_POSIX_THREADS) || defined(MHD_USE_W32_THREADS)\n  MHD_mutex_lock_chk_ (&daemon->cleanup_connection_mutex);\n#endif\n\n  if (daemon->resuming)\n  {\n    prev = daemon->suspended_connections_tail;\n    /* During shutdown check for resuming is forced. */\n    mhd_assert ((NULL != prev) || (daemon->shutdown) || \\\n                (0 != (daemon->options & MHD_ALLOW_UPGRADE)));\n  }\n\n  daemon->resuming = false;\n\n  while (NULL != (pos = prev))\n  {\n#ifdef UPGRADE_SUPPORT\n    struct MHD_UpgradeResponseHandle *const urh = pos->urh;\n#else  /* ! UPGRADE_SUPPORT */\n    static const void *const urh = NULL;\n#endif /* ! UPGRADE_SUPPORT */\n    prev = pos->prev;\n    if ( (! pos->resuming)\n#ifdef UPGRADE_SUPPORT\n         || ( (NULL != urh) &&\n              ( (! urh->was_closed) ||\n                (! urh->clean_ready) ) )\n#endif /* UPGRADE_SUPPORT */\n         )\n      continue;\n    ret = MHD_YES;\n    mhd_assert (pos->suspended);\n    DLL_remove (daemon->suspended_connections_head,\n                daemon->suspended_connections_tail,\n                pos);\n    pos->suspended = false;\n    if (NULL == urh)\n    {\n      DLL_insert (daemon->connections_head,\n                  daemon->connections_tail,\n                  pos);\n      if (! used_thr_p_c)\n      {\n        /* Reset timeout timer on resume. */\n        if (0 != pos->connection_timeout_ms)\n          pos->last_activity = MHD_monotonic_msec_counter ();\n\n        if (pos->connection_timeout_ms == daemon->connection_timeout_ms)\n          XDLL_insert (daemon->normal_timeout_head,\n                       daemon->normal_timeout_tail,\n                       pos);\n        else\n          XDLL_insert (daemon->manual_timeout_head,\n                       daemon->manual_timeout_tail,\n                       pos);\n      }\n#ifdef EPOLL_SUPPORT\n      if (MHD_D_IS_USING_EPOLL_ (daemon))\n      {\n        if (0 != (pos->epoll_state & MHD_EPOLL_STATE_IN_EREADY_EDLL))\n          MHD_PANIC (\"Resumed connection was already in EREADY set.\\n\");\n        /* we always mark resumed connections as ready, as we\n           might have missed the edge poll event during suspension */\n        EDLL_insert (daemon->eready_head,\n                     daemon->eready_tail,\n                     pos);\n        pos->epoll_state |= MHD_EPOLL_STATE_IN_EREADY_EDLL   \\\n                            | MHD_EPOLL_STATE_READ_READY\n                            | MHD_EPOLL_STATE_WRITE_READY;\n        pos->epoll_state &= ~((enum MHD_EpollState) MHD_EPOLL_STATE_SUSPENDED);\n      }\n#endif\n    }\n#ifdef UPGRADE_SUPPORT\n    else\n    {\n      /* Data forwarding was finished (for TLS connections) AND\n       * application was closed upgraded connection.\n       * Insert connection into cleanup list. */\n\n      if ( (NULL != daemon->notify_completed) &&\n           (! MHD_D_IS_USING_THREAD_PER_CONN_ (daemon)) &&\n           (pos->rq.client_aware) )\n      {\n        daemon->notify_completed (daemon->notify_completed_cls,\n                                  pos,\n                                  &pos->rq.client_context,\n                                  MHD_REQUEST_TERMINATED_COMPLETED_OK);\n        pos->rq.client_aware = false;\n      }\n      DLL_insert (daemon->cleanup_head,\n                  daemon->cleanup_tail,\n                  pos);\n      daemon->data_already_pending = true;\n    }\n#endif /* UPGRADE_SUPPORT */\n    pos->resuming = false;\n  }\n#if defined(MHD_USE_POSIX_THREADS) || defined(MHD_USE_W32_THREADS)\n  MHD_mutex_unlock_chk_ (&daemon->cleanup_connection_mutex);\n#endif\n  if ( (used_thr_p_c) &&\n       (MHD_NO != ret) )\n  {   /* Wake up suspended connections. */\n    if (! MHD_itc_activate_ (daemon->itc,\n                             \"w\"))\n    {\n#ifdef HAVE_MESSAGES\n      MHD_DLOG (daemon,\n                _ (\"Failed to signal resume of connection via \" \\\n                   \"inter-thread communication channel.\\n\"));\n#endif\n    }\n  }\n  return ret;\n}\n```\n</target_code>\n<response format>\nProvide your answer with these fields.\n- explanation: your evaluation of the scenario provided by the agent A.\n- is_report_correct: whether the report is correct or not (true/false). True means there is a violation.\n</response format>\n<scenario>\nThe agent A provided the following violation scenario:\nWhen MHD is built without UPGRADE_SUPPORT the code defines urh as a static const void *const initialized to NULL. Later the code tests if (NULL == urh) which is therefore always true (an invariant controlling expression). This makes that if statement have an invariant controlling expression and thus violates MISRA C 2023 Rule 14.3 (the listed exceptions do not apply).\n</scenario>\n\n<execution_log>\nThe agent A also provided the following output log:\nenter resume_suspended_connections: daemon=0x5570ff11e830 resuming=0 suspended_tail=(nil) shutdown=0 options=0xa401 used_thr_p_c=0\ndaemon->resuming set to false\nexit resume_suspended_connections: daemon=0x5570ff11e830 ret=0\nenter resume_suspended_connections: daemon=0x5570ff11e830 resuming=0 suspended_tail=(nil) shutdown=0 options=0xa401 used_thr_p_c=0\ndaemon->resuming set to false\nexit resume_suspended_connections: daemon=0x5570ff11e830 ret=0\nenter resume_suspended_connections: daemon=0x5570ff11e830 resuming=1 suspended_tail=0x5570ff11efd0 shutdown=0 options=0xa401 used_thr_p_c=0\ndaemon->resuming: found prev=0x5570ff11efd0\ndaemon->resuming set to false\nprocessing pos=0x5570ff11efd0 pos->prev=(nil) pos->resuming=1 pos->suspended=1\nUPGRADE_SUPPORT defined: urh=0x5570ff1274a0\nresuming connection pos=0x5570ff11efd0: will remove from suspended list\nurh non-NULL for pos=0x5570ff11efd0: routing to cleanup path\nfinished processing pos=0x5570ff11efd0; pos->resuming now false\nexit resume_suspended_connections: daemon=0x5570ff11e830 ret=1\nenter resume_suspended_connections: daemon=0x5570ff11e830 resuming=1 suspended_tail=(nil) shutdown=1 options=0xa401 used_thr_p_c=0\ndaemon->resuming: found prev=(nil)\ndaemon->resuming set to false\nexit resume_suspended_connections: daemon=0x5570ff11e830 ret=0\nenter resume_suspended_connections: daemon=0x5570ff11e830 resuming=1 suspended_tail=(nil) shutdown=1 options=0xa401 used_thr_p_c=0\ndaemon->resuming: found prev=(nil)\ndaemon->resuming set to false\nexit resume_suspended_connections: daemon=0x5570ff11e830 ret=0\nenter resume_suspended_connections: daemon=0x5570ff127600 resuming=0 suspended_tail=(nil) shutdown=0 options=0x1a601 used_thr_p_c=0\ndaemon->resuming set to false\nexit resume_suspended_connections: daemon=0x5570ff127600 ret=0\nenter resume_suspended_connections: daemon=0x5570ff127600 resuming=0 suspended_tail=(nil) shutdown=0 options=0x1a601 used_thr_p_c=0\ndaemon->resuming set to false\nexit resume_suspended_connections: daemon=0x5570ff127600 ret=0\nenter resume_suspended_connections: daemon=0x5570ff127600 resuming=0 suspended_tail=(nil) shutdown=0 options=0x1a601 used_thr_p_c=0\ndaemon->resuming set to false\nexit resume_suspended_connections: daemon=0x5570ff127600 ret=0\nenter resume_suspended_connections: daemon=0x5570ff127600 resuming=1 suspended_tail=0x5570ff127a80 shutdown=0 options=0x1a601 used_thr_p_c=0\ndaemon->resuming: found prev=0x5570ff127a80\ndaemon->resuming set to false\nprocessing pos=0x5570ff127a80 pos->prev=(nil) pos->resuming=1 pos->suspended=1\nUPGRADE_SUPPORT defined: urh=0x5570ff11ecb0\nresuming connection pos=0x5570ff127a80: will remove from suspended list\nurh non-NULL for pos=0x5570ff127a80: routing to cleanup path\nfinished processing pos=0x5570ff127a80; pos->resuming now false\nexit resume_suspended_connections: daemon=0x5570ff127600 ret=1\nenter resume_suspended_connections: daemon=0x5570ff127600 resuming=1 suspended_tail=(nil) shutdown=1 options=0x1a601 used_thr_p_c=0\ndaemon->resuming: found prev=(nil)\ndaemon->resuming set to false\nexit resume_suspended_connections: daemon=0x5570ff127600 ret=0\nenter resume_suspended_connections: daemon=0x5570ff127600 resuming=1 suspended_tail=(nil) shutdown=1 options=0x1a601 used_thr_p_c=0\ndaemon->resuming: found prev=(nil)\ndaemon->resuming set to false\nexit resume_suspended_connections: daemon=0x5570ff127600 ret=0\nenter resume_suspended_connections: daemon=0x5570ff127e10 resuming=0 suspended_tail=(nil) shutdown=0 options=0xa601 used_thr_p_c=0\ndaemon->resuming set to false\nexit resume_suspended_connections: daemon=0x5570ff127e10 ret=0\nenter resume_suspended_connections: daemon=0x5570ff127e10 resuming=0 suspended_tail=(nil) shutdown=0 options=0xa601 used_thr_p_c=0\ndaemon->resuming set to false\nexit resume_suspended_connections: daemon=0x5570ff127e10 ret=0\nenter resume_suspended_connections: daemon=0x5570ff127e10 resuming=0 suspended_tail=(nil) shutdown=0 options=0xa601 used_thr_p_c=0\ndaemon->resuming set to false\nexit resume_suspended_connections: daemon=0x5570ff127e10 ret=0\nenter resume_suspended_connections: daemon=0x5570ff127e10 resuming=1\n</execution_log>\n\n<instruction>\nJudge whether the report is correct or not.\n</instruction>\n",
  "is_report_correct": true,
  "explanation": "The report is correct. When UPGRADE_SUPPORT is not defined the code declares\n    static const void *const urh = NULL;\nand later executes\n    if (NULL == urh)\nwhich is a controlling expression that is constant true (invariant) in that build configuration. MISRA C 2023 Rule 14.3 disallows invariant controlling expressions except for the listed exceptions (infinite loops and the special do-while case). This if-statement does not fall under those exceptions, so the code violates Rule 14.3 in the no-UPGRADE_SUPPORT configuration. To fix this, remove the invariant test in that configuration (e.g. wrap the if/else in #ifdef UPGRADE_SUPPORT, avoid defining urh as a compile-time constant, or otherwise restructure the code so the controlling expression is not a constant)."
}