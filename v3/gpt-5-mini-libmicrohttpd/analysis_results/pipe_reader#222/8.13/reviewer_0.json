{
  "user_message": "An agent A claimed that the following pipe_reader code violates the MISRA C 2023 rule 8.13.\n<misra_rule>\nMISRA C 2023 Rule 8.13 is A pointer should point to a const-qualified type whenever possible.\n\n</misra_rule>\n<target_code>\nHere is the original code of pipe_reader.\n```c\nstatic ssize_t\npipe_reader (void *cls,\n             uint64_t pos,\n             char *buf,\n             size_t max)\n{\n  struct MHD_Response *response = cls;\n  ssize_t n;\n\n  (void) pos;\n\n#ifndef _WIN32\n  if (SSIZE_MAX < max)\n    max = SSIZE_MAX;\n  n = read (response->fd,\n            buf,\n            (MHD_SCKT_SEND_SIZE_) max);\n#else  /* _WIN32 */\n  if (UINT_MAX < max)\n    max = INT_MAX;\n  n = read (response->fd,\n            buf,\n            (unsigned int) max);\n#endif /* _WIN32 */\n\n  if (0 == n)\n    return MHD_CONTENT_READER_END_OF_STREAM;\n  if (n < 0)\n    return MHD_CONTENT_READER_END_WITH_ERROR;\n  return n;\n}\n```\n</target_code>\n<response format>\nProvide your answer with these fields.\n- explanation: your evaluation of the scenario provided by the agent A.\n- is_report_correct: whether the report is correct or not (true/false). True means there is a violation.\n</response format>\n<scenario>\nThe agent A provided the following violation scenario:\nThe parameter 'cls' is declared as a non-const void * but is only used for read-only access (it is cast to struct MHD_Response *response and only response->fd is read). Therefore 'cls' could be declared as const void * (or the function could take a const struct MHD_Response *), satisfying MISRA C 2023 Rule 8.13. Note: if this function must match a required external callback prototype that mandates a non-const void *, then the non-const declaration is unavoidable and not a violation; otherwise the current declaration violates the rule.\n</scenario>\n\n<instruction>\nJudge whether the report is correct or not.\n</instruction>\n",
  "is_report_correct": false,
  "explanation": "MISRA C:2023 Rule 8.13 indeed recommends that pointers should be to const-qualified types when possible. In the body of pipe_reader the parameter cls is only read (it is cast to struct MHD_Response * and response->fd is read), so from a purely local-usage perspective cls could be const void * (or the function could take a const struct MHD_Response *), which would satisfy Rule 8.13.\n\nHowever, this rule is applied taking linkage and required interfaces into account. If pipe_reader must match an external callback prototype that specifies a non-const void * parameter (as is common for many C callback APIs), then the non-const parameter is necessary to match that prototype and changing it would break the required signature. In that case there is no MISRA violation. The snippet itself is static, but that does not prove whether the function must match an external API; if it is registered as a callback matching a library typedef requiring non-const void *, then the report is incorrect. If, conversely, the function is purely internal and not constrained by an external prototype, then agent A is correct that the parameter should be const-qualified and the current code violates Rule 8.13.\n\nConclusion: the agent\u2019s observation is conditionally correct \u2014 the code violates Rule 8.13 only if the function signature is not constrained by an external callback prototype. Without evidence that the signature is unconstrained, we cannot assert a definite violation. Given typical usage (callbacks that require void *cls), the safer judgement is that the report as stated is not necessarily correct."
}