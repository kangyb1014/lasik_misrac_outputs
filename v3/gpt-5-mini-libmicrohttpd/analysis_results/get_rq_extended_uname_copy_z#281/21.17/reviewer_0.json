{
  "user_message": "An agent A claimed that the following get_rq_extended_uname_copy_z code violates the MISRA C 2023 rule 21.17.\n<misra_rule>\nMISRA C 2023 Rule 21.17 is Use of the string handling functions from <string.h> shall not result in accesses beyond the bounds of the objects referenced by their pointer parameters.\nThis rule strictly applies to the Standard Library functions in <string.h> such as memcpy, memmove, memset, memcmp, strcpy, strncpy, strcat, strncat, strlen, and strspn.\n</misra_rule>\n<target_code>\nHere is the original code of get_rq_extended_uname_copy_z.\n```c\nstatic ssize_t\nget_rq_extended_uname_copy_z (const char *uname_ext, size_t uname_ext_len,\n                              char *buf, size_t buf_size)\n{\n  size_t r;\n  size_t w;\n  if ((size_t) SSIZE_MAX < uname_ext_len)\n    return -1; /* Too long input string */\n\n  if (MHD_DAUTH_EXT_PARAM_MIN_LEN > uname_ext_len)\n    return -1; /* Required prefix is missing */\n\n  if (! MHD_str_equal_caseless_bin_n_ (uname_ext, MHD_DAUTH_EXT_PARAM_PREFIX,\n                                       MHD_STATICSTR_LEN_ ( \\\n                                         MHD_DAUTH_EXT_PARAM_PREFIX)))\n    return -1; /* Only UTF-8 is supported, as it is implied by RFC 7616 */\n\n  r = MHD_STATICSTR_LEN_ (MHD_DAUTH_EXT_PARAM_PREFIX);\n  /* Skip language tag */\n  while (r < uname_ext_len && '\\'' != uname_ext[r])\n  {\n    const char chr = uname_ext[r];\n    if ((' ' == chr) || ('\\t' == chr) || ('\\\"' == chr) || (',' == chr) ||\n        (';' == chr) )\n      return -1; /* Wrong char in language tag */\n    r++;\n  }\n  if (r >= uname_ext_len)\n    return -1; /* The end of the language tag was not found */\n  r++; /* Advance to the next char */\n\n  w = MHD_str_pct_decode_strict_n_ (uname_ext + r, uname_ext_len - r,\n                                    buf, buf_size);\n  if ((0 == w) && (0 != uname_ext_len - r))\n    return -1; /* Broken percent encoding */\n  buf[w] = 0; /* Zero terminate the result */\n  mhd_assert (SSIZE_MAX > w);\n  return (ssize_t) w;\n}\n```\n</target_code>\n<response format>\nProvide your answer with these fields.\n- explanation: your evaluation of the scenario provided by the agent A.\n- is_report_correct: whether the report is correct or not (true/false). True means there is a violation.\n</response format>\n<scenario>\nThe agent A provided the following violation scenario:\nThe code does not ensure there is room for the terminating NUL. If MHD_str_pct_decode_strict_n_ returns a length equal to buf_size (i.e. the decoder filled the entire buffer), the subsequent write buf[w] = 0 writes to buf[buf_size] which is out-of-bounds. The function only asserts w fits in ssize_t but does not check w < buf_size, so a decoded string of length buf_size will cause an access beyond the bounds of buf.\n</scenario>\n\n<instruction>\nJudge whether the report is correct or not.\n</instruction>\n",
  "is_report_correct": false,
  "explanation": "Agent A correctly identified a real bug risk: if MHD_str_pct_decode_strict_n_ can return w == buf_size then buf[w] = 0 writes one-past-end (out-of-bounds). That is a genuine defect unless the decode function is specified to never return buf_size (i.e. it guarantees room for the terminating NUL and returns at most buf_size-1). However, MISRA C 2023 Rule 21.17, as quoted, specifically concerns the use of the Standard Library string.h functions (memcpy, strcpy, strlen, etc.) and requires that their use not lead to out-of-bounds accesses. The shown snippet does not call any <string.h> library function directly; the overflow risk arises from an unchecked write into buf (or from the contract of the project-specific MHD_str_pct_decode_strict_n_ function). Therefore the claim that this code violates MISRA C 2023 Rule 21.17 is not correct. The code does have a potential buffer-overflow bug (fix by ensuring w < buf_size before writing the terminating NUL, or by documenting/ensuring that the decoder never returns buf_size), but that problem is not an instance of Rule 21.17 unless one of the called helpers internally uses <string.h> functions improperly."
}