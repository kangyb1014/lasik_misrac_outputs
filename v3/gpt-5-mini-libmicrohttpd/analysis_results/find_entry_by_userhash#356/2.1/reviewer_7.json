{
  "user_message": "An agent A claimed that the following find_entry_by_userhash code violates the MISRA C 2023 rule 2.1.\n<misra_rule>\nMISRA C 2023 Rule 2.1 is A project shall not contain unreachable code.\n\n</misra_rule>\n<target_code>\nHere is the original code of find_entry_by_userhash.\n```c\nstatic struct UserEntry *\nfind_entry_by_userhash (enum MHD_DigestAuthAlgo3 algo3,\n                        const void *userhash,\n                        size_t userhash_size)\n{\n  size_t i;\n\n  if (MHD_digest_get_hash_size (algo3) != userhash_size)\n    return NULL; /* Wrong length of the userhash */\n\n  switch (algo3)\n  {\n  case MHD_DIGEST_AUTH_ALGO3_MD5:\n  case MHD_DIGEST_AUTH_ALGO3_MD5_SESSION: /* An extra case not used currently */\n    if (sizeof(user_ids[0].userhash_md5) != userhash_size) /* Extra check. The size was checked before */\n      return NULL;\n    for (i = 0; i < (sizeof(user_ids) / sizeof(user_ids[0])); ++i)\n    {\n      struct UserEntry *entry;\n\n      entry = user_ids + i;\n      if (0 == memcmp (userhash, entry->userhash_md5,\n                       sizeof(entry->userhash_md5)))\n        return entry;\n    }\n    break;\n  case MHD_DIGEST_AUTH_ALGO3_SHA256:\n  case MHD_DIGEST_AUTH_ALGO3_SHA256_SESSION: /* An extra case not used currently */\n    if (sizeof(user_ids[0].userhash_sha256) != userhash_size) /* Extra check. The size was checked before */\n      return NULL;\n    for (i = 0; i < (sizeof(user_ids) / sizeof(user_ids[0])); ++i)\n    {\n      struct UserEntry *entry;\n\n      entry = user_ids + i;\n      if (0 == memcmp (userhash, entry->userhash_sha256,\n                       sizeof(entry->userhash_sha256)))\n        return entry;\n    }\n    break;\n  case MHD_DIGEST_AUTH_ALGO3_SHA512_256:\n  case MHD_DIGEST_AUTH_ALGO3_SHA512_256_SESSION: /* An extra case not used currently */\n    if (sizeof(user_ids[0].userhash_sha512_256) != userhash_size) /* Extra check. The size was checked before */\n      return NULL;\n    for (i = 0; i < (sizeof(user_ids) / sizeof(user_ids[0])); ++i)\n    {\n      struct UserEntry *entry;\n\n      entry = user_ids + i;\n      if (0 == memcmp (userhash, entry->userhash_sha512_256,\n                       sizeof(entry->userhash_sha512_256)))\n        return entry;\n    }\n    break;\n  case MHD_DIGEST_AUTH_ALGO3_INVALID: /* Mute compiler warning. Impossible value in this context. */\n  default:\n    break;\n  }\n  return NULL;\n}\n```\n</target_code>\n<response format>\nProvide your answer with these fields.\n- explanation: your evaluation of the scenario provided by the agent A.\n- is_report_correct: whether the report is correct or not (true/false). True means there is a violation.\n</response format>\n<scenario>\nThe agent A provided the following violation scenario:\nIn find_entry_by_userhash the function first returns NULL if MHD_digest_get_hash_size(algo3) != userhash_size. For the SHA512_256 case, if MHD_digest_get_hash_size(algo3) is defined to be sizeof(user_ids[0].userhash_sha512_256) for that algorithm (as intended), then userhash_size must equal that sizeof value on entry to the case. Therefore the condition if (sizeof(user_ids[0].userhash_sha512_256) != userhash_size) can never be true and the subsequent return NULL is unreachable. (The same reasoning applies to the similar size checks in the other algorithm cases.)\n</scenario>\n\n<instruction>\nJudge whether the report is correct or not.\n</instruction>\n",
  "is_report_correct": true,
  "explanation": "Agent A\u2019s reasoning is sound. The initial guard if (MHD_digest_get_hash_size(algo3) != userhash_size) return NULL; ensures that, for execution to reach any of the switch cases, userhash_size == MHD_digest_get_hash_size(algo3). Inside, each case then tests if (sizeof(user_ids[0].... ) != userhash_size) return NULL; \u2014 so if MHD_digest_get_hash_size(algo3) is implemented to return that same sizeof(...) for the corresponding algorithm (the intended/typical implementation), the inner condition can never be true and the return statement is unreachable. MISRA Rule 2.1 forbids unreachable code in the project, so under that project-wide definition of MHD_digest_get_hash_size the report is correct.\n\nNote: whether the code is actually unreachable depends on the project\u2019s implementation of MHD_digest_get_hash_size. If that function could legitimately return a value different from the sizeof(...) for a given algorithm (e.g. it is external or intentionally differs), the inner checks may be reachable and the report would not apply. Since MISRA 2.1 is a project-level rule, when both the function and this code are under the same project and the mapping is as intended, the agent\u2019s report is correct."
}