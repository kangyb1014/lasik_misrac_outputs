{
  "user_message": "An agent A claimed that the following find_entry_by_userhash code violates the MISRA C 2023 rule 2.1.\n<misra_rule>\nMISRA C 2023 Rule 2.1 is A project shall not contain unreachable code.\n\n</misra_rule>\n<target_code>\nHere is the original code of find_entry_by_userhash.\n```c\nstatic struct UserEntry *\nfind_entry_by_userhash (enum MHD_DigestAuthAlgo3 algo3,\n                        const void *userhash,\n                        size_t userhash_size)\n{\n  size_t i;\n\n  if (MHD_digest_get_hash_size (algo3) != userhash_size)\n    return NULL; /* Wrong length of the userhash */\n\n  switch (algo3)\n  {\n  case MHD_DIGEST_AUTH_ALGO3_MD5:\n  case MHD_DIGEST_AUTH_ALGO3_MD5_SESSION: /* An extra case not used currently */\n    if (sizeof(user_ids[0].userhash_md5) != userhash_size) /* Extra check. The size was checked before */\n      return NULL;\n    for (i = 0; i < (sizeof(user_ids) / sizeof(user_ids[0])); ++i)\n    {\n      struct UserEntry *entry;\n\n      entry = user_ids + i;\n      if (0 == memcmp (userhash, entry->userhash_md5,\n                       sizeof(entry->userhash_md5)))\n        return entry;\n    }\n    break;\n  case MHD_DIGEST_AUTH_ALGO3_SHA256:\n  case MHD_DIGEST_AUTH_ALGO3_SHA256_SESSION: /* An extra case not used currently */\n    if (sizeof(user_ids[0].userhash_sha256) != userhash_size) /* Extra check. The size was checked before */\n      return NULL;\n    for (i = 0; i < (sizeof(user_ids) / sizeof(user_ids[0])); ++i)\n    {\n      struct UserEntry *entry;\n\n      entry = user_ids + i;\n      if (0 == memcmp (userhash, entry->userhash_sha256,\n                       sizeof(entry->userhash_sha256)))\n        return entry;\n    }\n    break;\n  case MHD_DIGEST_AUTH_ALGO3_SHA512_256:\n  case MHD_DIGEST_AUTH_ALGO3_SHA512_256_SESSION: /* An extra case not used currently */\n    if (sizeof(user_ids[0].userhash_sha512_256) != userhash_size) /* Extra check. The size was checked before */\n      return NULL;\n    for (i = 0; i < (sizeof(user_ids) / sizeof(user_ids[0])); ++i)\n    {\n      struct UserEntry *entry;\n\n      entry = user_ids + i;\n      if (0 == memcmp (userhash, entry->userhash_sha512_256,\n                       sizeof(entry->userhash_sha512_256)))\n        return entry;\n    }\n    break;\n  case MHD_DIGEST_AUTH_ALGO3_INVALID: /* Mute compiler warning. Impossible value in this context. */\n  default:\n    break;\n  }\n  return NULL;\n}\n```\n</target_code>\n<response format>\nProvide your answer with these fields.\n- explanation: your evaluation of the scenario provided by the agent A.\n- is_report_correct: whether the report is correct or not (true/false). True means there is a violation.\n</response format>\n<scenario>\nThe agent A provided the following violation scenario:\nWhen algo3 is MHD_DIGEST_AUTH_ALGO3_SHA256 (or SHA256_SESSION), the initial check if (MHD_digest_get_hash_size(algo3) != userhash_size) returns early unless userhash_size equals the hash size for SHA256. Because MHD_digest_get_hash_size(MHD_DIGEST_AUTH_ALGO3_SHA256) is (in correct code) equal to sizeof(user_ids[0].userhash_sha256), the subsequent check if (sizeof(user_ids[0].userhash_sha256) != userhash_size) can never be true \u2014 its return NULL is therefore unreachable. This duplicated defensive check makes the return statement unreachable and thus violates MISRA C 2023 Rule 2.1.\n</scenario>\n\n<instruction>\nJudge whether the report is correct or not.\n</instruction>\n",
  "is_report_correct": true,
  "explanation": "Agent A is correct. The initial guard if (MHD_digest_get_hash_size(algo3) != userhash_size) forces userhash_size to equal the digest size for the given algo3 before the switch is entered. For the SHA256 case (and similarly for the other specific cases) the code assumes MHD_digest_get_hash_size(MHD_DIGEST_AUTH_ALGO3_SHA256) equals sizeof(user_ids[0].userhash_sha256). Under that (correct) mapping the subsequent check if (sizeof(user_ids[0].userhash_sha256) != userhash_size) can never evaluate to true, so its return NULL is provably unreachable. MISRA C 2023 Rule 2.1 disallows unreachable code, so the reported violation is valid. (If the project did not guarantee that MHD_digest_get_hash_size() matches those sizeof() values then the second check might be reachable, but in the intended/correct design it is redundant and unreachable and should be removed or formally justified.)"
}