{
  "user_message": "An agent A claimed that the following calculate_add_nonce code violates the MISRA C 2023 rule 8.13.\n<misra_rule>\nMISRA C 2023 Rule 8.13 is A pointer should point to a const-qualified type whenever possible.\n\n</misra_rule>\n<target_code>\nHere is the original code of calculate_add_nonce.\n```c\nstatic bool\ncalculate_add_nonce (struct MHD_Connection *const connection,\n                     uint64_t timestamp,\n                     const char *realm,\n                     size_t realm_len,\n                     struct DigestAlgorithm *da,\n                     char *nonce)\n{\n  struct MHD_Daemon *const daemon = MHD_get_master (connection->daemon);\n  struct MHD_NonceNc *nn;\n  const size_t nonce_size = NONCE_STD_LEN (digest_get_size (da));\n  bool ret;\n\n  mhd_assert (! da->hashing);\n  mhd_assert (MAX_DIGEST_NONCE_LENGTH >= nonce_size);\n  mhd_assert (0 != nonce_size);\n\n  calculate_nonce (timestamp,\n                   connection->rq.http_mthd,\n                   connection->rq.method,\n                   daemon->digest_auth_random,\n                   daemon->digest_auth_rand_size,\n                   connection->addr,\n                   (size_t) connection->addr_len,\n                   connection->rq.url,\n                   connection->rq.url_len,\n                   connection->rq.headers_received,\n                   realm,\n                   realm_len,\n                   daemon->dauth_bind_type,\n                   da,\n                   nonce);\n\n#ifdef MHD_DIGEST_HAS_EXT_ERROR\n  if (digest_ext_error (da))\n    return false;\n#endif /* MHD_DIGEST_HAS_EXT_ERROR */\n\n  if (0 == daemon->nonce_nc_size)\n    return false;\n\n  /* Sanity check for values */\n  mhd_assert (MAX_DIGEST_NONCE_LENGTH == NONCE_STD_LEN (MAX_DIGEST));\n\n  nn = daemon->nnc + get_nonce_nc_idx (daemon->nonce_nc_size,\n                                       nonce,\n                                       nonce_size);\n\n  MHD_mutex_lock_chk_ (&daemon->nnc_lock);\n  if (is_slot_available (nn, timestamp, nonce, nonce_size))\n  {\n    memcpy (nn->nonce,\n            nonce,\n            nonce_size);\n    nn->nonce[nonce_size] = 0;  /* With terminating zero */\n    nn->nc = 0;\n    nn->nmask = 0;\n    ret = true;\n  }\n  else\n    ret = false;\n  MHD_mutex_unlock_chk_ (&daemon->nnc_lock);\n\n  return ret;\n}\n```\n</target_code>\n<response format>\nProvide your answer with these fields.\n- explanation: your evaluation of the scenario provided by the agent A.\n- is_report_correct: whether the report is correct or not (true/false). True means there is a violation.\n</response format>\n<scenario>\nThe agent A provided the following violation scenario:\nThe parameter 'connection' is declared as 'struct MHD_Connection *const connection' (the pointer is const but the pointed-to object is not). The function only reads from connection fields (no writes), so per MISRA C 2023 Rule 8.13 the pointee should be const-qualified, e.g. 'const struct MHD_Connection *const connection'. Additionally, 'struct DigestAlgorithm *da' appears to be only read here and could be 'const struct DigestAlgorithm *da' unless the called functions modify it.\n</scenario>\n\n<instruction>\nJudge whether the report is correct or not.\n</instruction>\n",
  "is_report_correct": true,
  "explanation": "Rule 8.13 says a pointer parameter should point to a const-qualified type whenever possible. In this function the parameter is declared as\n  struct MHD_Connection *const connection\n(i.e. the pointer is const but the pointed-to object is not). All uses of connection in the body are reads of members (they index fields and pass those fields to other functions) \u2014 the function does not modify the MHD_Connection object \u2014 so the pointee could and should be const-qualified (e.g. const struct MHD_Connection *const connection). That is a violation of Rule 8.13.\n\nThe agent's additional remark about struct DigestAlgorithm *da is speculative: da is only read directly in this function, but it is passed to other functions (calculate_nonce, digest_get_size, digest_ext_error). If those callee signatures accept non-const pointers or actually modify the object, you cannot change da here to const without changing those APIs. Without inspecting those functions' prototypes/behavior we cannot conclude that da must be const. \n\nSo the report is correct with respect to the connection parameter (there is a Rule 8.13 violation). The claim that da should necessarily be made const is not verifiable from the shown code and may be incorrect if callees require a non-const pointer."
}