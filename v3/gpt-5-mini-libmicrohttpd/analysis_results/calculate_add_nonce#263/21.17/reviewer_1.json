{
  "user_message": "An agent A claimed that the following calculate_add_nonce code violates the MISRA C 2023 rule 21.17.\n<misra_rule>\nMISRA C 2023 Rule 21.17 is Use of the string handling functions from <string.h> shall not result in accesses beyond the bounds of the objects referenced by their pointer parameters.\nThis rule strictly applies to the Standard Library functions in <string.h> such as memcpy, memmove, memset, memcmp, strcpy, strncpy, strcat, strncat, strlen, and strspn.\n</misra_rule>\n<target_code>\nHere is the original code of calculate_add_nonce.\n```c\nstatic bool\ncalculate_add_nonce (struct MHD_Connection *const connection,\n                     uint64_t timestamp,\n                     const char *realm,\n                     size_t realm_len,\n                     struct DigestAlgorithm *da,\n                     char *nonce)\n{\n  struct MHD_Daemon *const daemon = MHD_get_master (connection->daemon);\n  struct MHD_NonceNc *nn;\n  const size_t nonce_size = NONCE_STD_LEN (digest_get_size (da));\n  bool ret;\n\n  mhd_assert (! da->hashing);\n  mhd_assert (MAX_DIGEST_NONCE_LENGTH >= nonce_size);\n  mhd_assert (0 != nonce_size);\n\n  calculate_nonce (timestamp,\n                   connection->rq.http_mthd,\n                   connection->rq.method,\n                   daemon->digest_auth_random,\n                   daemon->digest_auth_rand_size,\n                   connection->addr,\n                   (size_t) connection->addr_len,\n                   connection->rq.url,\n                   connection->rq.url_len,\n                   connection->rq.headers_received,\n                   realm,\n                   realm_len,\n                   daemon->dauth_bind_type,\n                   da,\n                   nonce);\n\n#ifdef MHD_DIGEST_HAS_EXT_ERROR\n  if (digest_ext_error (da))\n    return false;\n#endif /* MHD_DIGEST_HAS_EXT_ERROR */\n\n  if (0 == daemon->nonce_nc_size)\n    return false;\n\n  /* Sanity check for values */\n  mhd_assert (MAX_DIGEST_NONCE_LENGTH == NONCE_STD_LEN (MAX_DIGEST));\n\n  nn = daemon->nnc + get_nonce_nc_idx (daemon->nonce_nc_size,\n                                       nonce,\n                                       nonce_size);\n\n  MHD_mutex_lock_chk_ (&daemon->nnc_lock);\n  if (is_slot_available (nn, timestamp, nonce, nonce_size))\n  {\n    memcpy (nn->nonce,\n            nonce,\n            nonce_size);\n    nn->nonce[nonce_size] = 0;  /* With terminating zero */\n    nn->nc = 0;\n    nn->nmask = 0;\n    ret = true;\n  }\n  else\n    ret = false;\n  MHD_mutex_unlock_chk_ (&daemon->nnc_lock);\n\n  return ret;\n}\n```\n</target_code>\n<response format>\nProvide your answer with these fields.\n- explanation: your evaluation of the scenario provided by the agent A.\n- is_report_correct: whether the report is correct or not (true/false). True means there is a violation.\n</response format>\n<scenario>\nThe agent A provided the following violation scenario:\nThe call passes a char *nonce buffer to calculate_nonce without an accompanying size parameter, so calculate_nonce may use string.h functions (memcpy, strcpy, strcat, etc.) to build the nonce and thereby write more bytes than the caller's buffer can hold. For example, if calculate_nonce concatenates daemon->digest_auth_random, parts of connection->rq.url (connection->rq.url_len) and other fields into nonce using memcpy/strcat and those combined lengths exceed the buffer capacity (nonce_size), this will result in out\u2011of\u2011bounds writes. Because the callee is given no explicit buffer length in this call, the use of string functions inside calculate_nonce can violate Rule 21.17.\n</scenario>\n\n<instruction>\nJudge whether the report is correct or not.\n</instruction>\n",
  "is_report_correct": false,
  "explanation": "The claim is speculative and not proven by the code shown. calculate_add_nonce itself does not call any of the <string.h> functions except memcpy, and that memcpy uses nonce_size (which is computed and asserted against MAX_DIGEST_NONCE_LENGTH) so the copy into nn->nonce is bounded by nonce_size and a terminating zero is written at nonce[nonce_size]. The only place where a potential out\u2011of\u2011bounds write could occur is inside calculate_nonce, which is called with a char *nonce but without an explicit length parameter. Whether this is a MISRA 21.17 violation therefore depends entirely on the implementation and contract of calculate_nonce: if calculate_nonce is written to respect the expected nonce buffer length (e.g. it builds at most NONCE_STD_LEN(digest_get_size(da)) bytes and/or the API has a documented precondition that nonce points to a buffer of that required size), there is no violation. If calculate_nonce uses string.h functions in an unbounded way and can write beyond the provided buffer, that function (not calculate_add_nonce) would be the locus of a 21.17 violation. In short: Agent A\u2019s scenario is possible but not demonstrated by the provided code \u2014 the report is not correct as a proven violation of calculate_add_nonce. Recommendation: either ensure calculate_nonce accepts/uses an explicit buffer length or document and enforce the precondition that nonce has the required size so compliance with 21.17 can be verified."
}