{
  "user_message": "An agent A claimed that the following calculate_add_nonce code violates the MISRA C 2023 rule 21.17.\n<misra_rule>\nMISRA C 2023 Rule 21.17 is Use of the string handling functions from <string.h> shall not result in accesses beyond the bounds of the objects referenced by their pointer parameters.\nThis rule strictly applies to the Standard Library functions in <string.h> such as memcpy, memmove, memset, memcmp, strcpy, strncpy, strcat, strncat, strlen, and strspn.\n</misra_rule>\n<target_code>\nHere is the original code of calculate_add_nonce.\n```c\nstatic bool\ncalculate_add_nonce (struct MHD_Connection *const connection,\n                     uint64_t timestamp,\n                     const char *realm,\n                     size_t realm_len,\n                     struct DigestAlgorithm *da,\n                     char *nonce)\n{\n  struct MHD_Daemon *const daemon = MHD_get_master (connection->daemon);\n  struct MHD_NonceNc *nn;\n  const size_t nonce_size = NONCE_STD_LEN (digest_get_size (da));\n  bool ret;\n\n  mhd_assert (! da->hashing);\n  mhd_assert (MAX_DIGEST_NONCE_LENGTH >= nonce_size);\n  mhd_assert (0 != nonce_size);\n\n  calculate_nonce (timestamp,\n                   connection->rq.http_mthd,\n                   connection->rq.method,\n                   daemon->digest_auth_random,\n                   daemon->digest_auth_rand_size,\n                   connection->addr,\n                   (size_t) connection->addr_len,\n                   connection->rq.url,\n                   connection->rq.url_len,\n                   connection->rq.headers_received,\n                   realm,\n                   realm_len,\n                   daemon->dauth_bind_type,\n                   da,\n                   nonce);\n\n#ifdef MHD_DIGEST_HAS_EXT_ERROR\n  if (digest_ext_error (da))\n    return false;\n#endif /* MHD_DIGEST_HAS_EXT_ERROR */\n\n  if (0 == daemon->nonce_nc_size)\n    return false;\n\n  /* Sanity check for values */\n  mhd_assert (MAX_DIGEST_NONCE_LENGTH == NONCE_STD_LEN (MAX_DIGEST));\n\n  nn = daemon->nnc + get_nonce_nc_idx (daemon->nonce_nc_size,\n                                       nonce,\n                                       nonce_size);\n\n  MHD_mutex_lock_chk_ (&daemon->nnc_lock);\n  if (is_slot_available (nn, timestamp, nonce, nonce_size))\n  {\n    memcpy (nn->nonce,\n            nonce,\n            nonce_size);\n    nn->nonce[nonce_size] = 0;  /* With terminating zero */\n    nn->nc = 0;\n    nn->nmask = 0;\n    ret = true;\n  }\n  else\n    ret = false;\n  MHD_mutex_unlock_chk_ (&daemon->nnc_lock);\n\n  return ret;\n}\n```\n</target_code>\n<response format>\nProvide your answer with these fields.\n- explanation: your evaluation of the scenario provided by the agent A.\n- is_report_correct: whether the report is correct or not (true/false). True means there is a violation.\n</response format>\n<scenario>\nThe agent A provided the following violation scenario:\nIf nn->nonce has storage of MAX_DIGEST_NONCE_LENGTH bytes (i.e. no extra byte for a terminating NUL) and nonce_size equals MAX_DIGEST_NONCE_LENGTH, then memcpy(nn->nonce, nonce, nonce_size) fills the buffer and the subsequent write nn->nonce[nonce_size] = 0 writes one byte past the end of the array. Because the code only asserts nonce_size <= MAX_DIGEST_NONCE_LENGTH but does not show that nn->nonce has capacity >= MAX_DIGEST_NONCE_LENGTH+1, this can cause an out\u2011of\u2011bounds write.\n</scenario>\n\n<instruction>\nJudge whether the report is correct or not.\n</instruction>\n",
  "is_report_correct": false,
  "explanation": "Agent A\u2019s scenario correctly identifies a real out\u2011of\u2011bounds risk (the explicit write nn->nonce[nonce_size] = 0 can overflow if nn->nonce has exactly nonce_size bytes and no extra byte for a terminating NUL). However, MISRA C:2023 Rule 21.17 specifically addresses the use of string.h functions (e.g. memcpy) producing accesses beyond the bounds of the objects passed to them. In the scenario given memcpy(nn->nonce, nonce, nonce_size) itself does not write beyond the buffer if the buffer length equals nonce_size; the subsequent single-byte write is performed directly by the code, not by a string.h function. Therefore the claim that this code violates Rule 21.17 is not correct. That said, the code does contain a potential out\u2011of\u2011bounds write (a different rule/recommendation violation) unless it is guaranteed that nn->nonce has capacity >= nonce_size + 1. To fix: ensure nn->nonce is declared with room for the terminator (nonce_size+1), or ensure nonce_size < capacity before writing the terminator, or copy one fewer byte and then set the terminator appropriately."
}