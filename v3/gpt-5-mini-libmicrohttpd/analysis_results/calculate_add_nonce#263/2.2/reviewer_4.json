{
  "user_message": "An agent A claimed that the following calculate_add_nonce code violates the MISRA C 2023 rule 2.2.\n<misra_rule>\nMISRA C 2023 Rule 2.2 is A project shall not contain dead code.\nAny operation that is executed but whose removal would not affect program behaviour constitutes dead code. Notes:\n1. The behaviour of an embedded sytem is often determined not just by the nature of its actions, but also by the time at which they occur.\n2. unreachable code is not dead code, as it cannot be executed.\n3.Initialization is not the same as an assignment operation and is therfore not a candidate for dead code.\n</misra_rule>\n<target_code>\nHere is the original code of calculate_add_nonce.\n```c\nstatic bool\ncalculate_add_nonce (struct MHD_Connection *const connection,\n                     uint64_t timestamp,\n                     const char *realm,\n                     size_t realm_len,\n                     struct DigestAlgorithm *da,\n                     char *nonce)\n{\n  struct MHD_Daemon *const daemon = MHD_get_master (connection->daemon);\n  struct MHD_NonceNc *nn;\n  const size_t nonce_size = NONCE_STD_LEN (digest_get_size (da));\n  bool ret;\n\n  mhd_assert (! da->hashing);\n  mhd_assert (MAX_DIGEST_NONCE_LENGTH >= nonce_size);\n  mhd_assert (0 != nonce_size);\n\n  calculate_nonce (timestamp,\n                   connection->rq.http_mthd,\n                   connection->rq.method,\n                   daemon->digest_auth_random,\n                   daemon->digest_auth_rand_size,\n                   connection->addr,\n                   (size_t) connection->addr_len,\n                   connection->rq.url,\n                   connection->rq.url_len,\n                   connection->rq.headers_received,\n                   realm,\n                   realm_len,\n                   daemon->dauth_bind_type,\n                   da,\n                   nonce);\n\n#ifdef MHD_DIGEST_HAS_EXT_ERROR\n  if (digest_ext_error (da))\n    return false;\n#endif /* MHD_DIGEST_HAS_EXT_ERROR */\n\n  if (0 == daemon->nonce_nc_size)\n    return false;\n\n  /* Sanity check for values */\n  mhd_assert (MAX_DIGEST_NONCE_LENGTH == NONCE_STD_LEN (MAX_DIGEST));\n\n  nn = daemon->nnc + get_nonce_nc_idx (daemon->nonce_nc_size,\n                                       nonce,\n                                       nonce_size);\n\n  MHD_mutex_lock_chk_ (&daemon->nnc_lock);\n  if (is_slot_available (nn, timestamp, nonce, nonce_size))\n  {\n    memcpy (nn->nonce,\n            nonce,\n            nonce_size);\n    nn->nonce[nonce_size] = 0;  /* With terminating zero */\n    nn->nc = 0;\n    nn->nmask = 0;\n    ret = true;\n  }\n  else\n    ret = false;\n  MHD_mutex_unlock_chk_ (&daemon->nnc_lock);\n\n  return ret;\n}\n```\n</target_code>\n<response format>\nProvide your answer with these fields.\n- explanation: your evaluation of the scenario provided by the agent A.\n- is_report_correct: whether the report is correct or not (true/false). True means there is a violation.\n</response format>\n<scenario>\nThe agent A provided the following violation scenario:\nThe assertion tests equality of two compile-time constants (MAX_DIGEST_NONCE_LENGTH and NONCE_STD_LEN(MAX_DIGEST)). If mhd_assert expands to an actual runtime check (i.e. it is active in the build), that check will always succeed and thus is an executed operation whose removal would not affect program behaviour \u2014 this is dead code and violates MISRA C 2023 Rule 2.2. (If mhd_assert is compiled out entirely the statement is not executed, but the important violation scenario is when the assertion is active and redundant.)\n</scenario>\n\n<instruction>\nJudge whether the report is correct or not.\n</instruction>\n",
  "is_report_correct": false,
  "explanation": "The report is not correct. MISRA\u2011C Rule 2.2 forbids dead code defined as an executed operation whose removal would not affect program behaviour. Agent A assumes the mhd_assert expression is a tautology whose removal cannot change behaviour. That assumption is not proven and is generally unsafe under MISRA Rule 2.2 because:\n\n- Note 1 of Rule 2.2: embedded behaviour can depend on timing. Even an assertion that always evaluates true can affect timing (execution time, scheduling, interrupts), so removing it CAN change program behaviour. Thus you cannot conclude it is dead code purely because the test is always true at runtime.\n\n- The expression may not be a compile\u2011time constant across all builds/configurations (NONCE_STD_LEN could be macro/function-like and MAX_DIGEST may vary with configuration), so the check might not be tautological in all configurations.\n\n- mhd_assert might perform actions (logging, instrumentation, memory barriers) when enabled; those side effects mean removal could change observable behaviour.\n\nTo justify a Rule 2.2 violation you would need a demonstrated, build\u2011specific proof that the assertion is executed, has no side effects, does not affect timing, and that removing it cannot change any behaviour. That proof is not provided, so the reported violation is not established."
}