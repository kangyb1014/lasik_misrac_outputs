{
  "user_message": "An agent A claimed that the following test_header code violates the MISRA C 2023 rule 21.17.\n<misra_rule>\nMISRA C 2023 Rule 21.17 is Use of the string handling functions from <string.h> shall not result in accesses beyond the bounds of the objects referenced by their pointer parameters.\nThis rule strictly applies to the Standard Library functions in <string.h> such as memcpy, memmove, memset, memcmp, strcpy, strncpy, strcat, strncat, strlen, and strspn.\n</misra_rule>\n<target_code>\nHere is the original code of test_header.\n```c\nstatic enum MHD_Result\ntest_header (void *cls,\n             const char *key,\n             size_t key_size,\n             const char *value,\n             size_t value_size,\n             enum MHD_ValueKind kind)\n{\n  struct test_header_param *const param = (struct test_header_param *) cls;\n  struct MHD_Connection *connection = param->connection;\n  struct MHD_HTTP_Req_Header *pos;\n  size_t i;\n\n  param->num_headers++;\n  i = 0;\n  for (pos = connection->rq.headers_received; NULL != pos; pos = pos->next)\n  {\n    if (kind != pos->kind)\n      continue;\n    if (++i == param->num_headers)\n    {\n      if (key_size != pos->header_size)\n        return MHD_NO;\n      if (value_size != pos->value_size)\n        return MHD_NO;\n      if (0 != key_size)\n      {\n        mhd_assert (NULL != key);\n        mhd_assert (NULL != pos->header);\n        if (0 != memcmp (key,\n                         pos->header,\n                         key_size))\n          return MHD_NO;\n      }\n      if (0 != value_size)\n      {\n        mhd_assert (NULL != value);\n        mhd_assert (NULL != pos->value);\n        if (0 != memcmp (value,\n                         pos->value,\n                         value_size))\n          return MHD_NO;\n      }\n      return MHD_YES;\n    }\n  }\n  return MHD_NO;\n}\n```\n</target_code>\n<response format>\nProvide your answer with these fields.\n- explanation: your evaluation of the scenario provided by the agent A.\n- is_report_correct: whether the report is correct or not (true/false). True means there is a violation.\n</response format>\n<scenario>\nThe agent A provided the following violation scenario:\nAlthough key_size is compared to pos->header_size and checked non\u2011zero before calling memcmp, the code only uses mhd_assert to check that key and pos->header are non\u2011NULL. If mhd_assert is a no\u2011op (e.g. removed in release builds) or the pointers can be NULL despite the size, memcmp(key, pos->header, key_size) with key_size > 0 may dereference NULL / access beyond the referenced objects. Thus the fragment can violate Rule 21.17 unless there is an external guarantee that the pointers are non\u2011NULL when key_size > 0.\n</scenario>\n\n<instruction>\nJudge whether the report is correct or not.\n</instruction>\n",
  "is_report_correct": true,
  "explanation": "The report is correct. Rule 21.17 requires that calls like memcmp must not access beyond the bounds of the objects referenced by their pointer parameters; in particular if the length argument is > 0 the pointer arguments must be valid non-NULL pointers to objects of at least that size. In the fragment the code only uses mhd_assert to check that key and pos->header (and similarly value/pos->value) are non-NULL before calling memcmp, and mhd_assert can be a no-op in production builds. There is no runtime check that the pointers are non-NULL (only an assert) and no local evidence that the pointers point to buffers of at least key_size/value_size bytes. Therefore, unless there is an external/invariant guarantee (not shown) that these pointers are non-NULL and of sufficient size when the sizes are non-zero, the memcmp calls can dereference NULL or otherwise access out of bounds and so violate MISRA C 2023 Rule 21.17. Recommended fix: replace the assertions with explicit runtime checks (e.g. return an error if pointer == NULL when size > 0) or otherwise ensure the contract that pointers are valid when size > 0 is enforced and provable."
}