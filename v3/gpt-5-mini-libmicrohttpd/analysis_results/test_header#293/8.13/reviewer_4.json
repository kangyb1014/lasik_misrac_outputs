{
  "user_message": "An agent A claimed that the following test_header code violates the MISRA C 2023 rule 8.13.\n<misra_rule>\nMISRA C 2023 Rule 8.13 is A pointer should point to a const-qualified type whenever possible.\n\n</misra_rule>\n<target_code>\nHere is the original code of test_header.\n```c\nstatic enum MHD_Result\ntest_header (void *cls,\n             const char *key,\n             size_t key_size,\n             const char *value,\n             size_t value_size,\n             enum MHD_ValueKind kind)\n{\n  struct test_header_param *const param = (struct test_header_param *) cls;\n  struct MHD_Connection *connection = param->connection;\n  struct MHD_HTTP_Req_Header *pos;\n  size_t i;\n\n  param->num_headers++;\n  i = 0;\n  for (pos = connection->rq.headers_received; NULL != pos; pos = pos->next)\n  {\n    if (kind != pos->kind)\n      continue;\n    if (++i == param->num_headers)\n    {\n      if (key_size != pos->header_size)\n        return MHD_NO;\n      if (value_size != pos->value_size)\n        return MHD_NO;\n      if (0 != key_size)\n      {\n        mhd_assert (NULL != key);\n        mhd_assert (NULL != pos->header);\n        if (0 != memcmp (key,\n                         pos->header,\n                         key_size))\n          return MHD_NO;\n      }\n      if (0 != value_size)\n      {\n        mhd_assert (NULL != value);\n        mhd_assert (NULL != pos->value);\n        if (0 != memcmp (value,\n                         pos->value,\n                         value_size))\n          return MHD_NO;\n      }\n      return MHD_YES;\n    }\n  }\n  return MHD_NO;\n}\n```\n</target_code>\n<response format>\nProvide your answer with these fields.\n- explanation: your evaluation of the scenario provided by the agent A.\n- is_report_correct: whether the report is correct or not (true/false). True means there is a violation.\n</response format>\n<scenario>\nThe agent A provided the following violation scenario:\nThe local pointer 'connection' is declared as 'struct MHD_Connection *connection' but is only used for read-only access (e.g. accessing connection->rq.headers_received). According to MISRA C 2023 Rule 8.13 the pointer should point to a const-qualified type whenever possible. Declare it as 'const struct MHD_Connection *connection = param->connection;' (unless the code later modifies the pointee, in which case const would not be possible).\n</scenario>\n\n<execution_log>\nThe agent A also provided the following output log:\ntest_header: enter cls=0x7f4b72442df8 param=0x7f4b72442df8 connection=0x7f4b6c000b70 key=0x7f4b72442f7b key_size=3 value=0x7f4b72442f7f value_size=5 kind=8\ntest_header: iter pos=0x7f4b6c008db0 next=0x7f4b6c008d70 pos->kind=8 pos->header_size=3 pos->value_size=5 i=0\ntest_header: candidate header index=1 (param->num_headers=1)\ntest_header: header memcmp match\ntest_header: value memcmp match\ntest_header: all checks passed - returning MHD_YES\ntest_header: enter cls=0x7f4b72442df8 param=0x7f4b72442df8 connection=0x7f4b6c000b70 key=0x7f4b72442f85 key_size=4 value=0x7f4b72442f8a value_size=9 kind=8\ntest_header: iter pos=0x7f4b6c008db0 next=0x7f4b6c008d70 pos->kind=8 pos->header_size=3 pos->value_size=5 i=0\ntest_header: iter pos=0x7f4b6c008d70 next=0x7f4b6c008d30 pos->kind=8 pos->header_size=4 pos->value_size=9 i=1\ntest_header: candidate header index=2 (param->num_headers=2)\ntest_header: header memcmp match\ntest_header: value memcmp match\ntest_header: all checks passed - returning MHD_YES\ntest_header: enter cls=0x7f4b72442df8 param=0x7f4b72442df8 connection=0x7f4b6c000b70 key=0x7f4b72442f96 key_size=5 value=(nil) value_size=0 kind=8\ntest_header: iter pos=0x7f4b6c008db0 next=0x7f4b6c008d70 pos->kind=8 pos->header_size=3 pos->value_size=5 i=0\ntest_header: iter pos=0x7f4b6c008d70 next=0x7f4b6c008d30 pos->kind=8 pos->header_size=4 pos->value_size=9 i=1\ntest_header: iter pos=0x7f4b6c008d30 next=0x7f4b6c008cf0 pos->kind=8 pos->header_size=5 pos->value_size=0 i=2\ntest_header: candidate header index=3 (param->num_headers=3)\ntest_header: header memcmp match\ntest_header: all checks passed - returning MHD_YES\ntest_header: enter cls=0x7f4b72442df8 param=0x7f4b72442df8 connection=0x7f4b6c000b70 key=0x7f4b72442f9c key_size=0 value=0x7f4b72442f9d value_size=6 kind=8\ntest_header: iter pos=0x7f4b6c008db0 next=0x7f4b6c008d70 pos->kind=8 pos->header_size=3 pos->value_size=5 i=0\ntest_header: iter pos=0x7f4b6c008d70 next=0x7f4b6c008d30 pos->kind=8 pos->header_size=4 pos->value_size=9 i=1\ntest_header: iter pos=0x7f4b6c008d30 next=0x7f4b6c008cf0 pos->kind=8 pos->header_size=5 pos->value_size=0 i=2\ntest_header: iter pos=0x7f4b6c008cf0 next=0x7f4b6c008cb0 pos->kind=8 pos->header_size=0 pos->value_size=6 i=3\ntest_header: candidate header index=4 (param->num_headers=4)\ntest_header: value memcmp match\ntest_header: all checks passed - returning MHD_YES\ntest_header: enter cls=0x7f4b72442df8 param=0x7f4b72442df8 connection=0x7f4b6c000b70 key=0x7f4b72442fa4 key_size=0 value=(nil) value_size=0 kind=8\ntest_header: iter pos=0x7f4b6c008db0 next=0x7f4b6c008d70 pos->kind=8 pos->header_size=3 pos->value_size=5 i=0\ntest_header: iter pos=0x7f4b6c008d70 next=0x7f4b6c008d30 pos->kind=8 pos->header_size=4 pos->value_size=9 i=1\ntest_header: iter pos=0x7f4b6c008d30 next=0x7f4b6c008cf0 pos->kind=8 pos->header_size=5 pos->value_size=0 i=2\ntest_header: iter pos=0x7f4b6c008cf0 next=0x7f4b6c008cb0 pos->kind=8 pos->header_size=0 pos->value_size=6 i=3\ntest_header: iter pos=0x7f4b6c008cb0 next=0x7f4b6c008c70 pos->kind=8 pos->header_size=0 pos->value_size=0 i=4\ntest_header: candidate header index=5 (param->num_headers=5)\ntest_header: all checks passed - returning MHD_YES\ntest_header: enter cls=0x7f4b72442df8 param=0x7f4b72442df8 connection=0x7f4b6c000b70 key=0x7f4b72442fa5 key_size=4 value=0x7f4b72442faa value_size=3 kind=8\ntest_header: iter pos=0x7f4b6c008db0 next=0x7f4b6c008d70 pos->kind=8 pos->header_size=3 pos->value_size=5 i=0\ntest_header: iter pos=0x7f4b6c008d70 next=0x7f4b6c008d30 pos->kind=8 pos->header_size=4 pos->value_size=9 i=1\ntest_header: iter pos=0x7f4b6c008d30 next=0x7f4b6c008cf0 pos->kind=8 pos->header_size=5 pos->value_size=0 i=2\ntest_header: iter pos=0x7f4b6c008cf0 next=0x7f4b6c008cb0 pos->kind=8 pos->header_size=0 pos->value_size=6 i=3\ntest_header: iter pos=0x7f4b6c008cb0 next=0x7f4b6c008c70 pos->kind=8 pos->header_size=0 pos->value_size=0 i=4\ntest_header: iter pos=0x7f4b6c008c70 next=0x7f4b6c008c30 pos->kind=8 pos->header_size=4 pos->value_size=3 i=5\ntest_header: candidate header index=6 (param->num_headers=6)\ntest_header: header memcmp match\ntest_header: value \n</execution_log>\n\n<instruction>\nJudge whether the report is correct or not.\n</instruction>\n",
  "is_report_correct": true,
  "explanation": "The report is correct. Rule 8.13 advises that a pointer should point to a const-qualified type whenever possible. In this function the local variable connection is only used for read-only access (accessing connection->rq.headers_received and then reading fields from the list). There is no modification of the pointee through connection, so it can and should be declared as a pointer-to-const. Declaring connection as\n  const struct MHD_Connection *connection = param->connection;\nwould be valid (no cast required) and would better satisfy the rule. Note also that to avoid qualifier-mismatch you should likewise declare the iterator as a pointer-to-const, e.g.\n  const struct MHD_HTTP_Req_Header *pos;\nbecause assigning connection->rq.headers_received (a non-const pointer) to a pointer-to-const is permitted. Therefore A\u2019s finding is correct."
}