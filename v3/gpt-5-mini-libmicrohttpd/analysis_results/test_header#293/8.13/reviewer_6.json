{
  "user_message": "An agent A claimed that the following test_header code violates the MISRA C 2023 rule 8.13.\n<misra_rule>\nMISRA C 2023 Rule 8.13 is A pointer should point to a const-qualified type whenever possible.\n\n</misra_rule>\n<target_code>\nHere is the original code of test_header.\n```c\nstatic enum MHD_Result\ntest_header (void *cls,\n             const char *key,\n             size_t key_size,\n             const char *value,\n             size_t value_size,\n             enum MHD_ValueKind kind)\n{\n  struct test_header_param *const param = (struct test_header_param *) cls;\n  struct MHD_Connection *connection = param->connection;\n  struct MHD_HTTP_Req_Header *pos;\n  size_t i;\n\n  param->num_headers++;\n  i = 0;\n  for (pos = connection->rq.headers_received; NULL != pos; pos = pos->next)\n  {\n    if (kind != pos->kind)\n      continue;\n    if (++i == param->num_headers)\n    {\n      if (key_size != pos->header_size)\n        return MHD_NO;\n      if (value_size != pos->value_size)\n        return MHD_NO;\n      if (0 != key_size)\n      {\n        mhd_assert (NULL != key);\n        mhd_assert (NULL != pos->header);\n        if (0 != memcmp (key,\n                         pos->header,\n                         key_size))\n          return MHD_NO;\n      }\n      if (0 != value_size)\n      {\n        mhd_assert (NULL != value);\n        mhd_assert (NULL != pos->value);\n        if (0 != memcmp (value,\n                         pos->value,\n                         value_size))\n          return MHD_NO;\n      }\n      return MHD_YES;\n    }\n  }\n  return MHD_NO;\n}\n```\n</target_code>\n<response format>\nProvide your answer with these fields.\n- explanation: your evaluation of the scenario provided by the agent A.\n- is_report_correct: whether the report is correct or not (true/false). True means there is a violation.\n</response format>\n<scenario>\nThe agent A provided the following violation scenario:\nIf the struct field pos->value is declared as a non-const pointer (e.g. char *value) but is only ever read (used in memcmp and checked for NULL), then Rule 8.13 is violated \u2014 the pointer should be declared as pointing to a const-qualified type (const char *value). The same applies to pos->header. If, however, pos->value is already declared const char *, there is no violation.\n</scenario>\n\n<execution_log>\nThe agent A also provided the following output log:\nstage=enter cls=0x7fe6e601bdf8 num_headers=0 i=0 kind=8 key=0x7fe6e601bf7b key_size=3 value=0x7fe6e601bf7f value_size=5 pos=(nil) pos=NULL\nstage=loop_iter cls=0x7fe6e601bdf8 num_headers=1 i=0 kind=8 key=0x7fe6e601bf7b key_size=3 value=0x7fe6e601bf7f value_size=5 pos=0x7fe6e0008db0 pos->header=0x7fe6e0000dff pos->header_size=3 pos->value=0x7fe6e0000e03 pos->value_size=5 pos->kind=8\nstage=matched_index cls=0x7fe6e601bdf8 num_headers=1 i=1 kind=8 key=0x7fe6e601bf7b key_size=3 value=0x7fe6e601bf7f value_size=5 pos=0x7fe6e0008db0 pos->header=0x7fe6e0000dff pos->header_size=3 pos->value=0x7fe6e0000e03 pos->value_size=5 pos->kind=8\nstage=before_key_memcmp cls=0x7fe6e601bdf8 num_headers=1 i=1 kind=8 key=0x7fe6e601bf7b key_size=3 value=0x7fe6e601bf7f value_size=5 pos=0x7fe6e0008db0 pos->header=0x7fe6e0000dff pos->header_size=3 pos->value=0x7fe6e0000e03 pos->value_size=5 pos->kind=8\nstage=key_memcmp_ok cls=0x7fe6e601bdf8 num_headers=1 i=1 kind=8 key=0x7fe6e601bf7b key_size=3 value=0x7fe6e601bf7f value_size=5 pos=0x7fe6e0008db0 pos->header=0x7fe6e0000dff pos->header_size=3 pos->value=0x7fe6e0000e03 pos->value_size=5 pos->kind=8\nstage=before_value_memcmp cls=0x7fe6e601bdf8 num_headers=1 i=1 kind=8 key=0x7fe6e601bf7b key_size=3 value=0x7fe6e601bf7f value_size=5 pos=0x7fe6e0008db0 pos->header=0x7fe6e0000dff pos->header_size=3 pos->value=0x7fe6e0000e03 pos->value_size=5 pos->kind=8\nstage=value_memcmp_ok cls=0x7fe6e601bdf8 num_headers=1 i=1 kind=8 key=0x7fe6e601bf7b key_size=3 value=0x7fe6e601bf7f value_size=5 pos=0x7fe6e0008db0 pos->header=0x7fe6e0000dff pos->header_size=3 pos->value=0x7fe6e0000e03 pos->value_size=5 pos->kind=8\nstage=return_yes cls=0x7fe6e601bdf8 num_headers=1 i=1 kind=8 key=0x7fe6e601bf7b key_size=3 value=0x7fe6e601bf7f value_size=5 pos=0x7fe6e0008db0 pos->header=0x7fe6e0000dff pos->header_size=3 pos->value=0x7fe6e0000e03 pos->value_size=5 pos->kind=8\nstage=enter cls=0x7fe6e601bdf8 num_headers=1 i=0 kind=8 key=0x7fe6e601bf85 key_size=4 value=0x7fe6e601bf8a value_size=9 pos=(nil) pos=NULL\nstage=loop_iter cls=0x7fe6e601bdf8 num_headers=2 i=0 kind=8 key=0x7fe6e601bf85 key_size=4 value=0x7fe6e601bf8a value_size=9 pos=0x7fe6e0008db0 pos->header=0x7fe6e0000dff pos->header_size=3 pos->value=0x7fe6e0000e03 pos->value_size=5 pos->kind=8\nstage=loop_iter cls=0x7fe6e601bdf8 num_headers=2 i=1 kind=8 key=0x7fe6e601bf85 key_size=4 value=0x7fe6e601bf8a value_size=9 pos=0x7fe6e0008d70 pos->header=0x7fe6e0000e09 pos->header_size=4 pos->value=0x7fe6e0000e0e pos->value_size=9 pos->kind=8\nstage=matched_index cls=0x7fe6e601bdf8 num_headers=2 i=2 kind=8 key=0x7fe6e601bf85 key_size=4 value=0x7fe6e601bf8a value_size=9 pos=0x7fe6e0008d70 pos->header=0x7fe6e0000e09 pos->header_size=4 pos->value=0x7fe6e0000e0e pos->value_size=9 pos->kind=8\nstage=before_key_memcmp cls=0x7fe6e601bdf8 num_headers=2 i=2 kind=8 key=0x7fe6e601bf85 key_size=4 value=0x7fe6e601bf8a value_size=9 pos=0x7fe6e0008d70 pos->header=0x7fe6e0000e09 pos->header_size=4 pos->value=0x7fe6e0000e0e pos->value_size=9 pos->kind=8\nstage=key_memcmp_ok cls=0x7fe6e601bdf8 num_headers=2 i=2 kind=8 key=0x7fe6e601bf85 key_size=4 value=0x7fe6e601bf8a value_size=9 pos=0x7fe6e0008d70 pos->header=0x7fe6e0000e09 pos->header_size=4 pos->value=0x7fe6e0000e0e pos->value_size=9 pos->kind=8\nstage=before_value_memcmp cls=0x7fe6e601bdf8 num_headers=2 i=2 kind=8 key=0x7fe6e601bf85 key_size=4 value=0x7fe6e601bf8a value_size=9 pos=0x7fe6e0008d70 pos->header=0x7fe6e0000e09 pos->header_size=4 pos->value=0x7fe6e0000e0e pos->value_size=9 pos->kind=8\nstage=value_memcmp_ok cls=0x7fe6e601bdf8 num_headers=2 i=2 kind=8 key=0x7fe6e601bf85 key_size=4 value=0x7fe6e601bf8a value_size=9 pos=0x7fe6e0008d70 pos->header=0x7fe6e0000e09 pos->header_size=4 pos->value=0x7fe6e0000e0e pos->value_size=9 pos->kind=8\nstage=return_yes cls=0x7fe6e601bdf8 num_headers=2 i=2 kind=8 key=0x7fe6e601bf85 key_size=4 value=0x7fe6e601bf8a value_size=9 pos=0x7fe6e0008d70 pos->header=0x7fe6e0000e09 pos->header_size=4 pos->value=0x7fe6e0000e0e pos->value_size=9 pos->kind=8\nstage=enter cls=0x7fe6e601bdf8 num_headers=2 i=0 kind=8 key=0x7fe6e601bf96 ke\n</execution_log>\n\n<instruction>\nJudge whether the report is correct or not.\n</instruction>\n",
  "is_report_correct": false,
  "explanation": "The asserted violation depends on how the fields of struct MHD_HTTP_Req_Header are declared. MISRA C:2023 Rule 8.13 concerns pointer declarations (a pointer should point to a const-qualified type whenever possible), not the mere uses of a pointer. In the provided function pos->header and pos->value are only read (memcmp and NULL checks), so if those fields are declared as non-const (e.g. char *header; char *value;) then that declaration would violate Rule 8.13 and Agent A\u2019s reasoning would be correct. However the snippet does not include the definition of struct MHD_HTTP_Req_Header, so you cannot determine a violation from this function alone. Therefore Agent A\u2019s report is not proven by the code shown \u2014 it is only correct if the struct fields are indeed non-const. To resolve: inspect/modify the declaration of MHD_HTTP_Req_Header; if header and value are read-only they should be declared const char * to conform to Rule 8.13."
}