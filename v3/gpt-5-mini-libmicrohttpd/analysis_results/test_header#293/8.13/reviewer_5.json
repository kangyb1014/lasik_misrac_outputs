{
  "user_message": "An agent A claimed that the following test_header code violates the MISRA C 2023 rule 8.13.\n<misra_rule>\nMISRA C 2023 Rule 8.13 is A pointer should point to a const-qualified type whenever possible.\n\n</misra_rule>\n<target_code>\nHere is the original code of test_header.\n```c\nstatic enum MHD_Result\ntest_header (void *cls,\n             const char *key,\n             size_t key_size,\n             const char *value,\n             size_t value_size,\n             enum MHD_ValueKind kind)\n{\n  struct test_header_param *const param = (struct test_header_param *) cls;\n  struct MHD_Connection *connection = param->connection;\n  struct MHD_HTTP_Req_Header *pos;\n  size_t i;\n\n  param->num_headers++;\n  i = 0;\n  for (pos = connection->rq.headers_received; NULL != pos; pos = pos->next)\n  {\n    if (kind != pos->kind)\n      continue;\n    if (++i == param->num_headers)\n    {\n      if (key_size != pos->header_size)\n        return MHD_NO;\n      if (value_size != pos->value_size)\n        return MHD_NO;\n      if (0 != key_size)\n      {\n        mhd_assert (NULL != key);\n        mhd_assert (NULL != pos->header);\n        if (0 != memcmp (key,\n                         pos->header,\n                         key_size))\n          return MHD_NO;\n      }\n      if (0 != value_size)\n      {\n        mhd_assert (NULL != value);\n        mhd_assert (NULL != pos->value);\n        if (0 != memcmp (value,\n                         pos->value,\n                         value_size))\n          return MHD_NO;\n      }\n      return MHD_YES;\n    }\n  }\n  return MHD_NO;\n}\n```\n</target_code>\n<response format>\nProvide your answer with these fields.\n- explanation: your evaluation of the scenario provided by the agent A.\n- is_report_correct: whether the report is correct or not (true/false). True means there is a violation.\n</response format>\n<scenario>\nThe agent A provided the following violation scenario:\nThe code passes pos->value to memcmp as read-only data. If the struct member pos->value is declared as 'char *' (non-const) rather than 'const char *', that is a violation of MISRA C 2023 Rule 8.13 because the pointer should point to a const-qualified type when it is only used for read access.\n</scenario>\n\n<execution_log>\nThe agent A also provided the following output log:\nEVENT: entry\n  param=0x7fba0f73cdf8, connection=0x7fba08000b70, kind=8, idx=0\n  key=0x7fba0f73cf7b, key_size=3, value=0x7fba0f73cf7f, value_size=5\n----\nEVENT: iter-start\n  param=0x7fba0f73cdf8, connection=0x7fba08000b70, kind=8, idx=0\n  key=0x7fba0f73cf7b, key_size=3, value=0x7fba0f73cf7f, value_size=5\n  pos=0x7fba08008db0, pos->header=0x7fba08000dff, pos->header_size=3, pos->value=0x7fba08000e03, pos->value_size=5, pos->kind=8\n    header bytes (up to 16): 6B 65 79\n    value bytes (up to 16): 76 61 6C 75 65\n----\nEVENT: key_memcmp_match\n  param=0x7fba0f73cdf8, connection=0x7fba08000b70, kind=8, idx=1\n  key=0x7fba0f73cf7b, key_size=3, value=0x7fba0f73cf7f, value_size=5\n  pos=0x7fba08008db0, pos->header=0x7fba08000dff, pos->header_size=3, pos->value=0x7fba08000e03, pos->value_size=5, pos->kind=8\n    header bytes (up to 16): 6B 65 79\n    value bytes (up to 16): 76 61 6C 75 65\n----\nEVENT: value_memcmp_match\n  param=0x7fba0f73cdf8, connection=0x7fba08000b70, kind=8, idx=1\n  key=0x7fba0f73cf7b, key_size=3, value=0x7fba0f73cf7f, value_size=5\n  pos=0x7fba08008db0, pos->header=0x7fba08000dff, pos->header_size=3, pos->value=0x7fba08000e03, pos->value_size=5, pos->kind=8\n    header bytes (up to 16): 6B 65 79\n    value bytes (up to 16): 76 61 6C 75 65\n----\nEVENT: return_yes\n  param=0x7fba0f73cdf8, connection=0x7fba08000b70, kind=8, idx=1\n  key=0x7fba0f73cf7b, key_size=3, value=0x7fba0f73cf7f, value_size=5\n  pos=0x7fba08008db0, pos->header=0x7fba08000dff, pos->header_size=3, pos->value=0x7fba08000e03, pos->value_size=5, pos->kind=8\n    header bytes (up to 16): 6B 65 79\n    value bytes (up to 16): 76 61 6C 75 65\n----\nEVENT: entry\n  param=0x7fba0f73cdf8, connection=0x7fba08000b70, kind=8, idx=0\n  key=0x7fba0f73cf85, key_size=4, value=0x7fba0f73cf8a, value_size=9\n----\nEVENT: iter-start\n  param=0x7fba0f73cdf8, connection=0x7fba08000b70, kind=8, idx=0\n  key=0x7fba0f73cf85, key_size=4, value=0x7fba0f73cf8a, value_size=9\n  pos=0x7fba08008db0, pos->header=0x7fba08000dff, pos->header_size=3, pos->value=0x7fba08000e03, pos->value_size=5, pos->kind=8\n    header bytes (up to 16): 6B 65 79\n    value bytes (up to 16): 76 61 6C 75 65\n----\nEVENT: iter-start\n  param=0x7fba0f73cdf8, connection=0x7fba08000b70, kind=8, idx=1\n  key=0x7fba0f73cf85, key_size=4, value=0x7fba0f73cf8a, value_size=9\n  pos=0x7fba08008d70, pos->header=0x7fba08000e09, pos->header_size=4, pos->value=0x7fba08000e0e, pos->value_size=9, pos->kind=8\n    header bytes (up to 16): 6D 6F 72 65\n    value bytes (up to 16): 65 76 65 6E 20 6D 6F 72 65\n----\nEVENT: key_memcmp_match\n  param=0x7fba0f73cdf8, connection=0x7fba08000b70, kind=8, idx=2\n  key=0x7fba0f73cf85, key_size=4, value=0x7fba0f73cf8a, value_size=9\n  pos=0x7fba08008d70, pos->header=0x7fba08000e09, pos->header_size=4, pos->value=0x7fba08000e0e, pos->value_size=9, pos->kind=8\n    header bytes (up to 16): 6D 6F 72 65\n    value bytes (up to 16): 65 76 65 6E 20 6D 6F 72 65\n----\nEVENT: value_memcmp_match\n  param=0x7fba0f73cdf8, connection=0x7fba08000b70, kind=8, idx=2\n  key=0x7fba0f73cf85, key_size=4, value=0x7fba0f73cf8a, value_size=9\n  pos=0x7fba08008d70, pos->header=0x7fba08000e09, pos->header_size=4, pos->value=0x7fba08000e0e, pos->value_size=9, pos->kind=8\n    header bytes (up to 16): 6D 6F 72 65\n    value bytes (up to 16): 65 76 65 6E 20 6D 6F 72 65\n----\nEVENT: return_yes\n  param=0x7fba0f73cdf8, connection=0x7fba08000b70, kind=8, idx=2\n  key=0x7fba0f73cf85, key_size=4, value=0x7fba0f73cf8a, value_size=9\n  pos=0x7fba08008d70, pos->header=0x7fba08000e09, pos->header_size=4, pos->value=0x7fba08000e0e, pos->value_size=9, pos->kind=8\n    header bytes (up to 16): 6D 6F 72 65\n    value bytes (up to 16): 65 76 65 6E 20 6D 6F 72 65\n----\nEVENT: entry\n  param=0x7fba0f73cdf8, connection=0x7fba08000b70, kind=8, idx=0\n  key=0x7fba0f73cf96, key_size=5, value=(nil), value_size=0\n----\nEVENT: iter-start\n  param=0x7fba0f73cdf8, connection=0x7fba08000b70, kind=8, idx=0\n  key=0x7fba0f73cf96, key_size=5, value=(nil), value_size=0\n  pos=0x7fba08008db0, pos->header=0x7fba08000dff, pos->header_size=3, pos->value=0x7fba08000e03, pos->value_size=5, pos->kin\n</execution_log>\n\n<instruction>\nJudge whether the report is correct or not.\n</instruction>\n",
  "is_report_correct": false,
  "explanation": "MISRA C:2023 Rule 8.13 concerns declarations: a pointer type should be const-qualified when the pointed-to object is only accessed for read. The snippet shown only shows uses of pos->header and pos->value (passed to memcmp and asserted non-NULL). Passing a char * to memcmp is perfectly legal because memcmp takes const void * \u2014 that implicit qualification conversion does not itself violate the rule. Whether there is an actual Rule 8.13 violation depends on the declaration and other uses of struct MHD_HTTP_Req_Header (i.e. whether pos->header/pos->value are declared as char * and whether those members are ever modified elsewhere). Since the struct definition and other uses are not provided, the report is not proven by the evidence given. To confirm the report, inspect the declaration of MHD_HTTP_Req_Header: if header/value are declared as non-const pointers and are never modified, then they should be declared const and the report would be correct; if they are modified elsewhere, the non-const declaration is justified and there is no violation."
}