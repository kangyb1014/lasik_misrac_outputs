{
  "user_message": "An agent A claimed that the following MHD_get_rq_bauth_params_ code violates the MISRA C 2023 rule 8.13.\n<misra_rule>\nMISRA C 2023 Rule 8.13 is A pointer should point to a const-qualified type whenever possible.\n\n</misra_rule>\n<target_code>\nHere is the original code of MHD_get_rq_bauth_params_.\n```c\nconst struct MHD_RqBAuth *\nMHD_get_rq_bauth_params_ (struct MHD_Connection *connection)\n{\n  struct _MHD_str_w_len h_auth_value;\n  struct MHD_RqBAuth *bauth;\n\n  mhd_assert (MHD_CONNECTION_HEADERS_PROCESSED <= connection->state);\n\n  if (connection->rq.bauth_tried)\n    return connection->rq.bauth;\n\n  if (MHD_CONNECTION_HEADERS_PROCESSED > connection->state)\n    return NULL;\n\n  if (! find_auth_rq_header_ (connection, MHD_AUTHTYPE_BASIC, &h_auth_value))\n  {\n    connection->rq.bauth_tried = true;\n    connection->rq.bauth = NULL;\n    return NULL;\n  }\n\n  bauth =\n    (struct MHD_RqBAuth *)\n    MHD_connection_alloc_memory_ (connection, sizeof (struct MHD_RqBAuth));\n\n  if (NULL == bauth)\n  {\n#ifdef HAVE_MESSAGES\n    MHD_DLOG (connection->daemon,\n              _ (\"Not enough memory in the connection's pool to allocate \" \\\n                 \"for Basic Authorization header parsing.\\n\"));\n#endif /* HAVE_MESSAGES */\n    return NULL;\n  }\n\n  memset (bauth, 0, sizeof(struct MHD_RqBAuth));\n  if (parse_bauth_params (h_auth_value.str, h_auth_value.len, bauth))\n    connection->rq.bauth = bauth;\n  else\n  {\n#ifdef HAVE_MESSAGES\n    MHD_DLOG (connection->daemon,\n              _ (\"The Basic Authorization client's header has \"\n                 \"incorrect format.\\n\"));\n#endif /* HAVE_MESSAGES */\n    connection->rq.bauth = NULL;\n    /* Memory in the pool remains allocated until next request */\n  }\n  connection->rq.bauth_tried = true;\n  return connection->rq.bauth;\n}\n```\n</target_code>\n<response format>\nProvide your answer with these fields.\n- explanation: your evaluation of the scenario provided by the agent A.\n- is_report_correct: whether the report is correct or not (true/false). True means there is a violation.\n</response format>\n<scenario>\nThe agent A provided the following violation scenario:\nIf the member connection->rq.bauth is declared as a non-const pointer (struct MHD_RqBAuth *), then the assignment connection->rq.bauth = bauth; violates MISRA C 2023 Rule 8.13. The rule requires pointers to point to const-qualified types whenever possible. In this code the allocated object is only modified locally (via the non-const local pointer bauth) and then published for read-only use; therefore connection->rq.bauth should be declared as const struct MHD_RqBAuth * so callers cannot modify the object. Recommended fix: change the member to const struct MHD_RqBAuth *; assigning the non-const bauth to it is allowed (struct MHD_RqBAuth * -> const struct MHD_RqBAuth *).\n</scenario>\n\n<instruction>\nJudge whether the report is correct or not.\n</instruction>\n",
  "is_report_correct": false,
  "explanation": "Not correct. MISRA C 2023 Rule 8.13 advises that pointers should point to const-qualified types where possible, but the snippet alone does not demonstrate a definite violation. The rule concerns the declarations (i.e. whether connection->rq.bauth could be declared as const struct MHD_RqBAuth *). From this single function you cannot determine whether connection->rq.bauth is later used to modify the pointee elsewhere in the program; if it is modified elsewhere, it must remain non-const. If it is never used to modify the object, then making the member a pointer-to-const would be preferable, but that requires whole-program (or at least whole-module) analysis. The assignment connection->rq.bauth = bauth itself is not a breach of the rule: the rule targets the appropriateness of the pointer's declared type, not the act of assigning a non-const pointer value. Also note that returning connection->rq.bauth from this function as a const-qualified return type is an implicit conversion (struct MHD_RqBAuth * \u2192 const struct MHD_RqBAuth *) and is allowed. In short, the report overreaches \u2014 you cannot claim a definite MISRA 8.13 violation without verifying that the member could safely be const-qualified across its uses."
}