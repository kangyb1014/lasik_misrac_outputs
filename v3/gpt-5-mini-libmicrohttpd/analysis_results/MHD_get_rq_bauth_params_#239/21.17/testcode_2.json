{
  "user_message": "<misra_rule>\nMISRA C 2023 Rule 21.17 is: Use of the string handling functions from <string.h> shall not result in accesses beyond the bounds of the objects referenced by their pointer parameters.\nThis rule strictly applies to the Standard Library functions in <string.h> such as memcpy, memmove, memset, memcmp, strcpy, strncpy, strcat, strncat, strlen, and strspn.\n</misra_rule>\n\nAnother agent reported that the target code violated the Rule 21.17.\nHere is the comment from the agent.\n<violation scenario>\nPotential out-of-bounds access if parse_bauth_params uses unbounded string.h functions on h_auth_value.str. For example, if parse_bauth_params calls strlen(h_auth_value.str) or strcpy/strcat/strcpy-like functions that expect a NUL-terminated C string but h_auth_value.str is a non\u2011terminated buffer of length h_auth_value.len, those functions will read past the h_auth_value.len bytes and access memory beyond the object. Similarly, if parse_bauth_params calls memcpy/memmove with a length greater than the actual buffer available, an out\u2011of\u2011bounds read/write can occur. Because the implementation of parse_bauth_params is not shown and only a pointer+length are passed, this call can violate Rule 21.17 unless parse_bauth_params is explicitly written to use the provided length and bounded string routines (e.g., strnlen, memchr or length-limited copying).\n</violation scenario>\n\nYour job is to insert logging code to capture the control flow and state information of the program.\nInsert logging code so that other agents can reproduce and get evidence for the violation scenario.\n<response format>\n- test_code: a modified MHD_get_rq_bauth_params_ code that contains useful probe functions that print useful logs to a file \"/tmp/logs/2399.txt\". The logs should contain the control path and state information of the violation scenario. If test code is not required to validate the scenario, you can leave this blank.\nHere are the constraints for the test code:\n- The test code MUST preserve the original logic of MHD_get_rq_bauth_params_ as much as possible.\nYou CAN just insert probe functions to the original code.\n- DO NOT introduce new violations to demonstrate your scenario.\n- The test code MUST be compilable and executable.\n- The test code MUST include line breaks.\n- You MUST NOT define the main function.\n- You MUST NOT define macros.\n</response format>\n<target_code>\nHere is the code of MHD_get_rq_bauth_params_:\n```c\nconst struct MHD_RqBAuth *\nMHD_get_rq_bauth_params_ (struct MHD_Connection *connection)\n{\n  struct _MHD_str_w_len h_auth_value;\n  struct MHD_RqBAuth *bauth;\n\n  mhd_assert (MHD_CONNECTION_HEADERS_PROCESSED <= connection->state);\n\n  if (connection->rq.bauth_tried)\n    return connection->rq.bauth;\n\n  if (MHD_CONNECTION_HEADERS_PROCESSED > connection->state)\n    return NULL;\n\n  if (! find_auth_rq_header_ (connection, MHD_AUTHTYPE_BASIC, &h_auth_value))\n  {\n    connection->rq.bauth_tried = true;\n    connection->rq.bauth = NULL;\n    return NULL;\n  }\n\n  bauth =\n    (struct MHD_RqBAuth *)\n    MHD_connection_alloc_memory_ (connection, sizeof (struct MHD_RqBAuth));\n\n  if (NULL == bauth)\n  {\n#ifdef HAVE_MESSAGES\n    MHD_DLOG (connection->daemon,\n              _ (\"Not enough memory in the connection's pool to allocate \" \\\n                 \"for Basic Authorization header parsing.\\n\"));\n#endif /* HAVE_MESSAGES */\n    return NULL;\n  }\n\n  memset (bauth, 0, sizeof(struct MHD_RqBAuth));\n  if (parse_bauth_params (h_auth_value.str, h_auth_value.len, bauth))\n    connection->rq.bauth = bauth;\n  else\n  {\n#ifdef HAVE_MESSAGES\n    MHD_DLOG (connection->daemon,\n              _ (\"The Basic Authorization client's header has \"\n                 \"incorrect format.\\n\"));\n#endif /* HAVE_MESSAGES */\n    connection->rq.bauth = NULL;\n    /* Memory in the pool remains allocated until next request */\n  }\n  connection->rq.bauth_tried = true;\n  return connection->rq.bauth;\n}\n```\n</target_code>\nPlease provide the modified MHD_get_rq_bauth_params_ code.\n",
  "test_code": "const struct MHD_RqBAuth *\nMHD_get_rq_bauth_params_ (struct MHD_Connection *connection)\n{\n  struct _MHD_str_w_len h_auth_value;\n  struct MHD_RqBAuth *bauth;\n  FILE *log = NULL;\n  size_t i, dump_len;\n  int parsed = 0;\n\n  /* Try to open append-only log for diagnostics. Failure to open the log\n     must not change behavior of the function. */\n  log = fopen(\"/tmp/logs/2399.txt\", \"a\");\n  if (log)\n  {\n    fprintf(log, \"ENTER: MHD_get_rq_bauth_params_ - connection=%p\\n\", (void *)connection);\n    fflush(log);\n  }\n\n  mhd_assert (MHD_CONNECTION_HEADERS_PROCESSED <= connection->state);\n\n  if (connection->rq.bauth_tried)\n  {\n    if (log)\n    {\n      fprintf(log, \"EARLY RETURN: bauth_tried==true, returning existing bauth=%p\\n\",\n              (void *)connection->rq.bauth);\n      fclose(log);\n    }\n    return connection->rq.bauth;\n  }\n\n  if (MHD_CONNECTION_HEADERS_PROCESSED > connection->state)\n  {\n    if (log)\n    {\n      fprintf(log, \"EARLY RETURN: headers not processed (state=%d)\\n\", connection->state);\n      fclose(log);\n    }\n    return NULL;\n  }\n\n  if (! find_auth_rq_header_ (connection, MHD_AUTHTYPE_BASIC, &h_auth_value))\n  {\n    if (log)\n    {\n      fprintf(log, \"AUTH HEADER NOT FOUND: connection=%p\\n\", (void *)connection);\n      fclose(log);\n    }\n    connection->rq.bauth_tried = true;\n    connection->rq.bauth = NULL;\n    return NULL;\n  }\n\n  if (log)\n  {\n    fprintf(log, \"AUTH HEADER FOUND: h_auth_value.str=%p h_auth_value.len=%zu\\n\",\n            (void *)h_auth_value.str, h_auth_value.len);\n    /* Dump up to 256 bytes of the provided buffer in hex and printable form.\n       We limit the dump size to avoid excessively large logs. This reads only\n       up to h_auth_value.len bytes and does not assume NUL termination. */\n    dump_len = (h_auth_value.len > 256) ? 256 : h_auth_value.len;\n    fprintf(log, \"AUTH VALUE DUMP (first %zu bytes):\", dump_len);\n    for (i = 0; i < dump_len; ++i)\n      fprintf(log, \" %02x\", (unsigned char)h_auth_value.str[i]);\n    fprintf(log, \"\\nAUTH VALUE ASCII (non-printable as '.'):\");\n    for (i = 0; i < dump_len; ++i)\n    {\n      unsigned char c = (unsigned char)h_auth_value.str[i];\n      if (c >= 32 && c < 127)\n        fprintf(log, \"%c\", c);\n      else\n        fprintf(log, \".\");\n    }\n    fprintf(log, \"\\n\");\n    fflush(log);\n  }\n\n  bauth =\n    (struct MHD_RqBAuth *)\n    MHD_connection_alloc_memory_ (connection, sizeof (struct MHD_RqBAuth));\n\n  if (NULL == bauth)\n  {\n#ifdef HAVE_MESSAGES\n    MHD_DLOG (connection->daemon,\n              _ (\"Not enough memory in the connection's pool to allocate \" \\\n                 \"for Basic Authorization header parsing.\\n\"));\n#endif /* HAVE_MESSAGES */\n    if (log)\n    {\n      fprintf(log, \"MEMORY ALLOCATION FAILED for bauth (size=%zu)\\n\", sizeof(struct MHD_RqBAuth));\n      fclose(log);\n    }\n    return NULL;\n  }\n\n  memset (bauth, 0, sizeof(struct MHD_RqBAuth));\n\n  if (log)\n  {\n    fprintf(log, \"Calling parse_bauth_params with str=%p len=%zu bauth=%p\\n\",\n            (void *)h_auth_value.str, h_auth_value.len, (void *)bauth);\n    fflush(log);\n  }\n\n  /* Call the parser. If parse_bauth_params internally uses unbounded\n     string.h functions on the non-NUL-terminated buffer h_auth_value.str,\n     that could cause an out-of-bounds read; the log above captures the\n     pointer and the provided length to help reproduce that scenario. */\n  parsed = parse_bauth_params (h_auth_value.str, h_auth_value.len, bauth);\n\n  if (log)\n  {\n    fprintf(log, \"parse_bauth_params returned %d\\n\", parsed);\n    if (parsed)\n      fprintf(log, \"Parser succeeded; storing bauth=%p\\n\", (void *)bauth);\n    else\n      fprintf(log, \"Parser failed; bauth will be set to NULL\\n\");\n    fflush(log);\n  }\n\n  if (parsed)\n    connection->rq.bauth = bauth;\n  else\n  {\n#ifdef HAVE_MESSAGES\n    MHD_DLOG (connection->daemon,\n              _ (\"The Basic Authorization client's header has \"\n                 \"incorrect format.\\n\"));\n#endif /* HAVE_MESSAGES */\n    connection->rq.bauth = NULL;\n    /* Memory in the pool remains allocated until next request */\n  }\n  connection->rq.bauth_tried = true;\n\n  if (log)\n  {\n    fprintf(log, \"EXIT: returning connection->rq.bauth=%p bauth_tried=%d\\n\",\n            (void *)connection->rq.bauth, connection->rq.bauth_tried);\n    fclose(log);\n  }\n\n  return connection->rq.bauth;\n}\n"
}