{
  "user_message": "<misra_rule>\nMISRA C 2023 Rule 2.2 is: A project shall not contain dead code.\nAny operation that is executed but whose removal would not affect program behaviour constitutes dead code. Notes:\n1. The behaviour of an embedded sytem is often determined not just by the nature of its actions, but also by the time at which they occur.\n2. unreachable code is not dead code, as it cannot be executed.\n3.Initialization is not the same as an assignment operation and is therfore not a candidate for dead code.\n</misra_rule>\n<response format>\nProvide your answer with these fields.\n- is_rule_violated: whether the rule is violated or not (true/false),\n- scenario: a specific violation scenario.\n</response format>\n<target_code>\nHere is the code of close_connection:\n```c\nstatic void\nclose_connection (struct MHD_Connection *pos)\n{\n  struct MHD_Daemon *daemon = pos->daemon;\n\n#ifdef MHD_USE_THREADS\n  mhd_assert ( (! MHD_D_IS_USING_THREADS_ (daemon)) || \\\n               MHD_thread_handle_ID_is_current_thread_ (daemon->tid) );\n  mhd_assert (NULL == daemon->worker_pool);\n#endif /* MHD_USE_THREADS */\n\n  if (MHD_D_IS_USING_THREAD_PER_CONN_ (daemon))\n  {\n    MHD_connection_mark_closed_ (pos);\n    return;   /* must let thread to do the rest */\n  }\n  MHD_connection_close_ (pos,\n                         MHD_REQUEST_TERMINATED_DAEMON_SHUTDOWN);\n#if defined(MHD_USE_POSIX_THREADS) || defined(MHD_USE_W32_THREADS)\n  MHD_mutex_lock_chk_ (&daemon->cleanup_connection_mutex);\n#endif\n  mhd_assert (! pos->suspended);\n  mhd_assert (! pos->resuming);\n  if (pos->connection_timeout_ms == daemon->connection_timeout_ms)\n    XDLL_remove (daemon->normal_timeout_head,\n                 daemon->normal_timeout_tail,\n                 pos);\n  else\n    XDLL_remove (daemon->manual_timeout_head,\n                 daemon->manual_timeout_tail,\n                 pos);\n  DLL_remove (daemon->connections_head,\n              daemon->connections_tail,\n              pos);\n  DLL_insert (daemon->cleanup_head,\n              daemon->cleanup_tail,\n              pos);\n  daemon->data_already_pending = true;\n#if defined(MHD_USE_POSIX_THREADS) || defined(MHD_USE_W32_THREADS)\n  MHD_mutex_unlock_chk_ (&daemon->cleanup_connection_mutex);\n#endif\n}\n```\n</target_code>\n<target_code>\nHere is the code fragment that you need to analyze:\n```c\n#ifdef MHD_USE_THREADS\n  mhd_assert ( (! MHD_D_IS_USING_THREADS_ (daemon)) || \\\n               MHD_thread_handle_ID_is_current_thread_ (daemon->tid) );\n  mhd_assert (NULL == daemon->worker_pool);\n#endif /* MHD_USE_THREADS */\n```\nFocus on the above code fragment and judge whether it violates the rule 2.2 or not.\n</target_code>\n",
  "is_rule_violated": false,
  "scenario": "Not violated in typical builds: these are assertion checks whose removal can change observable behaviour (they may abort/log on failure) or are entirely compiled out (so not executed). Therefore, as written they are not inherently dead code. Specific violation scenario: if mhd_assert is implemented so that the calls (and their operand evaluations) are executed at runtime but have no effect (for example mhd_assert expands to '(void)(expr);' or a no-op while still evaluating expr), and the predicates MHD_D_IS_USING_THREADS_ and MHD_thread_handle_ID_is_current_thread_ have no side-effects, then those evaluated assertions would be executed yet removable without changing program behaviour \u2014 i.e. dead code (Rule 2.2 violated)."
}