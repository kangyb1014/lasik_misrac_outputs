{
  "user_message": "<misra_rule>\nMISRA C 2023 Rule 2.2 is: A project shall not contain dead code.\nAny operation that is executed but whose removal would not affect program behaviour constitutes dead code. Notes:\n1. The behaviour of an embedded sytem is often determined not just by the nature of its actions, but also by the time at which they occur.\n2. unreachable code is not dead code, as it cannot be executed.\n3.Initialization is not the same as an assignment operation and is therfore not a candidate for dead code.\n</misra_rule>\n\nAnother agent reported that the target code violated the Rule 2.2.\nHere is the comment from the agent.\n<violation scenario>\nThe mhd_assert(buf_size >= buf_used) call is a diagnostic assertion that performs no program-state modification (no side effects). As written it only checks a condition and, in common configurations, is implemented as a no-op in production builds (or, even when active, its normal execution does not alter program behaviour). Thus the operation is executed but its removal would not affect program behaviour, which meets the definition of dead code in MISRA C 2023 Rule 2.2. A concrete scenario: with the typical mhd_assert macro that expands to nothing when diagnostics are disabled, the assertion is present in the source but has no effect at runtime \u2014 removing it changes nothing. To comply, replace the assertion with a proper runtime check and error handling (or otherwise ensure the statement has required functional effect).\n</violation scenario>\n\nYour job is to insert logging code to capture the control flow and state information of the program.\nInsert logging code so that other agents can reproduce and get evidence for the violation scenario.\n<response format>\n- test_code: a modified get_rq_uname code that contains useful probe functions that print useful logs to a file \"/tmp/logs/2842.txt\". The logs should contain the control path and state information of the violation scenario. If test code is not required to validate the scenario, you can leave this blank.\nHere are the constraints for the test code:\n- The test code MUST preserve the original logic of get_rq_uname as much as possible.\nYou CAN just insert probe functions to the original code.\n- DO NOT introduce new violations to demonstrate your scenario.\n- The test code MUST be compilable and executable.\n- The test code MUST include line breaks.\n- You MUST NOT define the main function.\n- You MUST NOT define macros.\n</response format>\n<target_code>\nHere is the code of get_rq_uname:\n```c\nstatic size_t\nget_rq_uname (const struct MHD_RqDAuth *params,\n              enum MHD_DigestAuthUsernameType uname_type,\n              struct MHD_DigestAuthUsernameInfo *uname_info,\n              uint8_t *buf,\n              size_t buf_size)\n{\n  size_t buf_used;\n\n  buf_used = 0;\n  mhd_assert (get_rq_uname_type (params) == uname_type);\n  mhd_assert (MHD_DIGEST_AUTH_UNAME_TYPE_INVALID != uname_type);\n  mhd_assert (MHD_DIGEST_AUTH_UNAME_TYPE_MISSING != uname_type);\n\n  uname_info->username = NULL;\n  uname_info->username_len = 0;\n  uname_info->userhash_hex = NULL;\n  uname_info->userhash_hex_len = 0;\n  uname_info->userhash_bin = NULL;\n\n  if (MHD_DIGEST_AUTH_UNAME_TYPE_STANDARD == uname_type)\n  {\n    uname_info->username = (char *) (buf + buf_used);\n    uname_info->username_len =\n      get_rq_param_unquoted_copy_z (&params->username,\n                                    uname_info->username);\n    buf_used += uname_info->username_len + 1;\n    uname_info->uname_type = MHD_DIGEST_AUTH_UNAME_TYPE_STANDARD;\n  }\n  else if (MHD_DIGEST_AUTH_UNAME_TYPE_USERHASH == uname_type)\n  {\n    size_t res;\n\n    uname_info->userhash_hex = (char *) (buf + buf_used);\n    uname_info->userhash_hex_len =\n      get_rq_param_unquoted_copy_z (&params->username,\n                                    uname_info->userhash_hex);\n    buf_used += uname_info->userhash_hex_len + 1;\n    uname_info->userhash_bin = (uint8_t *) (buf + buf_used);\n    res = MHD_hex_to_bin (uname_info->userhash_hex,\n                          uname_info->userhash_hex_len,\n                          uname_info->userhash_bin);\n    if (res != uname_info->userhash_hex_len / 2)\n    {\n      uname_info->userhash_bin = NULL;\n      uname_info->uname_type = MHD_DIGEST_AUTH_UNAME_TYPE_INVALID;\n    }\n    else\n    {\n      /* Avoid pointers outside allocated region when the size is zero */\n      if (0 == res)\n        uname_info->userhash_bin = (uint8_t *) uname_info->username;\n      uname_info->uname_type = MHD_DIGEST_AUTH_UNAME_TYPE_USERHASH;\n      buf_used += res;\n    }\n  }\n  else if (MHD_DIGEST_AUTH_UNAME_TYPE_EXTENDED == uname_type)\n  {\n    ssize_t res;\n    res = get_rq_extended_uname_copy_z (params->username_ext.value.str,\n                                        params->username_ext.value.len,\n                                        (char *) (buf + buf_used),\n                                        buf_size - buf_used);\n    if (0 > res)\n      uname_info->uname_type = MHD_DIGEST_AUTH_UNAME_TYPE_INVALID;\n    else\n    {\n      uname_info->username = (char *) (buf + buf_used);\n      uname_info->username_len = (size_t) res;\n      uname_info->uname_type = MHD_DIGEST_AUTH_UNAME_TYPE_EXTENDED;\n      buf_used += uname_info->username_len + 1;\n    }\n  }\n  else\n  {\n    mhd_assert (0);\n    uname_info->uname_type = MHD_DIGEST_AUTH_UNAME_TYPE_INVALID;\n  }\n  mhd_assert (buf_size >= buf_used);\n  return buf_used;\n}\n```\n</target_code>\nPlease provide the modified get_rq_uname code.\n",
  "test_code": "#include <stdio.h>\n#include <stdint.h>\n#include <stddef.h>\n#include <stdarg.h>\n#include <sys/types.h>\n\n/* Minimal required types and prototypes to make this test snippet compilable.\n   In the actual project these are provided elsewhere. */\n\nenum MHD_DigestAuthUsernameType\n{\n  MHD_DIGEST_AUTH_UNAME_TYPE_INVALID = 0,\n  MHD_DIGEST_AUTH_UNAME_TYPE_MISSING,\n  MHD_DIGEST_AUTH_UNAME_TYPE_STANDARD,\n  MHD_DIGEST_AUTH_UNAME_TYPE_USERHASH,\n  MHD_DIGEST_AUTH_UNAME_TYPE_EXTENDED\n};\n\nstruct MHD_Param_String\n{\n  char *str;\n  size_t len;\n};\n\nstruct MHD_RqDAuth\n{\n  /* username is a parameter object in real code; keep minimal shape */\n  struct MHD_Param_String username;\n  struct { struct MHD_Param_String value; } username_ext;\n};\n\nstruct MHD_DigestAuthUsernameInfo\n{\n  char *username;\n  size_t username_len;\n  char *userhash_hex;\n  size_t userhash_hex_len;\n  uint8_t *userhash_bin;\n  enum MHD_DigestAuthUsernameType uname_type;\n};\n\n/* External functions used by get_rq_uname. Real implementations are in the\n   project; here we only provide prototypes so this file compiles. */\nextern enum MHD_DigestAuthUsernameType\nget_rq_uname_type (const struct MHD_RqDAuth *params);\n\nextern size_t\nget_rq_param_unquoted_copy_z (const void *param, char *dest);\n\nextern size_t\nMHD_hex_to_bin (const char *hex, size_t hex_len, uint8_t *out);\n\nextern ssize_t\nget_rq_extended_uname_copy_z (const char *str, size_t len, char *dest, size_t avail);\n\n/* mhd_assert may be a no-op in production builds. Keep it as a function\n   so that calls remain present in this test snippet. */\nstatic void mhd_assert (int cond)\n{\n  /* Intentionally do nothing (simulate typical production no-op assert).\n     We keep the call so that logging can demonstrate it has no side-effects. */\n  (void) cond;\n}\n\n/* Simple logging probe that appends human-readable traces to\n   /tmp/logs/2842.txt. The logs capture control-flow choices and key state\n   (buf_size, buf_used, uname_type and other intermediate results). */\nstatic void\nlog_probe (const char *fmt, ...)\n{\n  FILE *f = fopen(\"/tmp/logs/2842.txt\", \"a\");\n  if (f == NULL)\n    return; /* Best-effort logging; do not change control flow if logging fails */\n\n  va_list ap;\n  va_start (ap, fmt);\n  vfprintf (f, fmt, ap);\n  fprintf (f, \"\\n\");\n  va_end (ap);\n  fclose (f);\n}\n\nstatic size_t\nget_rq_uname (const struct MHD_RqDAuth *params,\n              enum MHD_DigestAuthUsernameType uname_type,\n              struct MHD_DigestAuthUsernameInfo *uname_info,\n              uint8_t *buf,\n              size_t buf_size)\n{\n  size_t buf_used;\n\n  buf_used = 0;\n  /* Log entry state */\n  log_probe (\"ENTER get_rq_uname: params=%p uname_type=%d buf_size=%zu\", (void *) params, (int) uname_type, buf_size);\n\n  mhd_assert (get_rq_uname_type (params) == uname_type);\n  /* Log that the assertion call was executed; since mhd_assert is a no-op\n     this documents that no state change occurred here. */\n  log_probe (\"ASSERT 1 executed: get_rq_uname_type(params)==%d\", (int) uname_type);\n\n  mhd_assert (MHD_DIGEST_AUTH_UNAME_TYPE_INVALID != uname_type);\n  log_probe (\"ASSERT 2 executed: uname_type != INVALID (value %d)\", (int) uname_type);\n\n  mhd_assert (MHD_DIGEST_AUTH_UNAME_TYPE_MISSING != uname_type);\n  log_probe (\"ASSERT 3 executed: uname_type != MISSING (value %d)\", (int) uname_type);\n\n  uname_info->username = NULL;\n  uname_info->username_len = 0;\n  uname_info->userhash_hex = NULL;\n  uname_info->userhash_hex_len = 0;\n  uname_info->userhash_bin = NULL;\n\n  if (MHD_DIGEST_AUTH_UNAME_TYPE_STANDARD == uname_type)\n  {\n    log_probe (\"BRANCH: STANDARD (buf_used=%zu)\", buf_used);\n    uname_info->username = (char *) (buf + buf_used);\n    uname_info->username_len =\n      get_rq_param_unquoted_copy_z (&params->username,\n                                    uname_info->username);\n    log_probe (\"STANDARD: copied username len=%zu\", uname_info->username_len);\n    buf_used += uname_info->username_len + 1;\n    uname_info->uname_type = MHD_DIGEST_AUTH_UNAME_TYPE_STANDARD;\n    log_probe (\"STANDARD: updated buf_used=%zu\", buf_used);\n  }\n  else if (MHD_DIGEST_AUTH_UNAME_TYPE_USERHASH == uname_type)\n  {\n    size_t res;\n\n    log_probe (\"BRANCH: USERHASH (buf_used=%zu)\", buf_used);\n    uname_info->userhash_hex = (char *) (buf + buf_used);\n    uname_info->userhash_hex_len =\n      get_rq_param_unquoted_copy_z (&params->username,\n                                    uname_info->userhash_hex);\n    log_probe (\"USERHASH: copied userhash_hex_len=%zu\", uname_info->userhash_hex_len);\n    buf_used += uname_info->userhash_hex_len + 1;\n    uname_info->userhash_bin = (uint8_t *) (buf + buf_used);\n    res = MHD_hex_to_bin (uname_info->userhash_hex,\n                          uname_info->userhash_hex_len,\n                          uname_info->userhash_bin);\n    log_probe (\"USERHASH: MHD_hex_to_bin returned res=%zu\", res);\n    if (res != uname_info->userhash_hex_len / 2)\n    {\n      uname_info->userhash_bin = NULL;\n      uname_info->uname_type = MHD_DIGEST_AUTH_UNAME_TYPE_INVALID;\n      log_probe (\"USERHASH: invalid hex length -> set uname_type=INVALID\");\n    }\n    else\n    {\n      /* Avoid pointers outside allocated region when the size is zero */\n      if (0 == res)\n        uname_info->userhash_bin = (uint8_t *) uname_info->username;\n      uname_info->uname_type = MHD_DIGEST_AUTH_UNAME_TYPE_USERHASH;\n      buf_used += res;\n      log_probe (\"USERHASH: success -> uname_type=USERHASH buf_used=%zu\", buf_used);\n    }\n  }\n  else if (MHD_DIGEST_AUTH_UNAME_TYPE_EXTENDED == uname_type)\n  {\n    ssize_t res;\n    log_probe (\"BRANCH: EXTENDED (buf_used=%zu buf_size=%zu)\", buf_used, buf_size);\n    res = get_rq_extended_uname_copy_z (params->username_ext.value.str,\n                                        params->username_ext.value.len,\n                                        (char *) (buf + buf_used),\n                                        buf_size - buf_used);\n    log_probe (\"EXTENDED: get_rq_extended_uname_copy_z returned res=%zd\", res);\n    if (0 > res)\n      uname_info->uname_type = MHD_DIGEST_AUTH_UNAME_TYPE_INVALID;\n    else\n    {\n      uname_info->username = (char *) (buf + buf_used);\n      uname_info->username_len = (size_t) res;\n      uname_info->uname_type = MHD_DIGEST_AUTH_UNAME_TYPE_EXTENDED;\n      buf_used += uname_info->username_len + 1;\n      log_probe (\"EXTENDED: success username_len=%zu buf_used=%zu\", uname_info->username_len, buf_used);\n    }\n  }\n  else\n  {\n    log_probe (\"BRANCH: DEFAULT/UNKNOWN uname_type=%d\", (int) uname_type);\n    mhd_assert (0);\n    uname_info->uname_type = MHD_DIGEST_AUTH_UNAME_TYPE_INVALID;\n  }\n\n  /* Log state just before the final buffer-size assertion */\n  log_probe (\"BEFORE FINAL ASSERT: buf_size=%zu buf_used=%zu uname_type=%d\",\n             buf_size, buf_used, (int) uname_info->uname_type);\n\n  mhd_assert (buf_size >= buf_used);\n  /* Document that final assertion was executed but did not change state */\n  log_probe (\"ASSERT final executed (buf_size >= buf_used) ; post-check buf_used=%zu\", buf_used);\n\n  log_probe (\"EXIT get_rq_uname: returning buf_used=%zu\", buf_used);\n  return buf_used;\n}\n"
}