{
  "user_message": "<target code>Here is the code that failed to compile:\n```c\nstruct MHD_Param_String\n{\n  char *str;\n  size_t len;\n};\nstatic void mhd_assert (int cond)\n{\n  /* Intentionally do nothing (simulate typical production no-op assert).\n     We keep the call so that logging can demonstrate it has no side-effects. */\n  (void) cond;\n}\nstatic void\nlog_probe (const char *fmt, ...)\n{\n  FILE *f = fopen(\"/tmp/logs/2842.txt\", \"a\");\n  if (f == NULL)\n    return; /* Best-effort logging; do not change control flow if logging fails */\n\n  va_list ap;\n  va_start (ap, fmt);\n  vfprintf (f, fmt, ap);\n  fprintf (f, \"\\n\");\n  va_end (ap);\n  fclose (f);\n}\n\nstatic size_t\nget_rq_uname (const struct MHD_RqDAuth *params,\n              enum MHD_DigestAuthUsernameType uname_type,\n              struct MHD_DigestAuthUsernameInfo *uname_info,\n              uint8_t *buf,\n              size_t buf_size)\n{\n  size_t buf_used;\n\n  buf_used = 0;\n  /* Log entry state */\n  log_probe (\"ENTER get_rq_uname: params=%p uname_type=%d buf_size=%zu\", (void *) params, (int) uname_type, buf_size);\n\n  mhd_assert (get_rq_uname_type (params) == uname_type);\n  /* Log that the assertion call was executed; since mhd_assert is a no-op\n     this documents that no state change occurred here. */\n  log_probe (\"ASSERT 1 executed: get_rq_uname_type(params)==%d\", (int) uname_type);\n\n  mhd_assert (MHD_DIGEST_AUTH_UNAME_TYPE_INVALID != uname_type);\n  log_probe (\"ASSERT 2 executed: uname_type != INVALID (value %d)\", (int) uname_type);\n\n  mhd_assert (MHD_DIGEST_AUTH_UNAME_TYPE_MISSING != uname_type);\n  log_probe (\"ASSERT 3 executed: uname_type != MISSING (value %d)\", (int) uname_type);\n\n  uname_info->username = NULL;\n  uname_info->username_len = 0;\n  uname_info->userhash_hex = NULL;\n  uname_info->userhash_hex_len = 0;\n  uname_info->userhash_bin = NULL;\n\n  if (MHD_DIGEST_AUTH_UNAME_TYPE_STANDARD == uname_type)\n  {\n    log_probe (\"BRANCH: STANDARD (buf_used=%zu)\", buf_used);\n    uname_info->username = (char *) (buf + buf_used);\n    uname_info->username_len =\n      get_rq_param_unquoted_copy_z (&params->username,\n                                    uname_info->username);\n    log_probe (\"STANDARD: copied username len=%zu\", uname_info->username_len);\n    buf_used += uname_info->username_len + 1;\n    uname_info->uname_type = MHD_DIGEST_AUTH_UNAME_TYPE_STANDARD;\n    log_probe (\"STANDARD: updated buf_used=%zu\", buf_used);\n  }\n  else if (MHD_DIGEST_AUTH_UNAME_TYPE_USERHASH == uname_type)\n  {\n    size_t res;\n\n    log_probe (\"BRANCH: USERHASH (buf_used=%zu)\", buf_used);\n    uname_info->userhash_hex = (char *) (buf + buf_used);\n    uname_info->userhash_hex_len =\n      get_rq_param_unquoted_copy_z (&params->username,\n                                    uname_info->userhash_hex);\n    log_probe (\"USERHASH: copied userhash_hex_len=%zu\", uname_info->userhash_hex_len);\n    buf_used += uname_info->userhash_hex_len + 1;\n    uname_info->userhash_bin = (uint8_t *) (buf + buf_used);\n    res = MHD_hex_to_bin (uname_info->userhash_hex,\n                          uname_info->userhash_hex_len,\n                          uname_info->userhash_bin);\n    log_probe (\"USERHASH: MHD_hex_to_bin returned res=%zu\", res);\n    if (res != uname_info->userhash_hex_len / 2)\n    {\n      uname_info->userhash_bin = NULL;\n      uname_info->uname_type = MHD_DIGEST_AUTH_UNAME_TYPE_INVALID;\n      log_probe (\"USERHASH: invalid hex length -> set uname_type=INVALID\");\n    }\n    else\n    {\n      /* Avoid pointers outside allocated region when the size is zero */\n      if (0 == res)\n        uname_info->userhash_bin = (uint8_t *) uname_info->username;\n      uname_info->uname_type = MHD_DIGEST_AUTH_UNAME_TYPE_USERHASH;\n      buf_used += res;\n      log_probe (\"USERHASH: success -> uname_type=USERHASH buf_used=%zu\", buf_used);\n    }\n  }\n  else if (MHD_DIGEST_AUTH_UNAME_TYPE_EXTENDED == uname_type)\n  {\n    ssize_t res;\n    log_probe (\"BRANCH: EXTENDED (buf_used=%zu buf_size=%zu)\", buf_used, buf_size);\n    res = get_rq_extended_uname_copy_z (params->username_ext.value.str,\n                                        params->username_ext.value.len,\n                                        (char *) (buf + buf_used),\n                                        buf_size - buf_used);\n    log_probe (\"EXTENDED: get_rq_extended_uname_copy_z returned res=%zd\", res);\n    if (0 > res)\n      uname_info->uname_type = MHD_DIGEST_AUTH_UNAME_TYPE_INVALID;\n    else\n    {\n      uname_info->username = (char *) (buf + buf_used);\n      uname_info->username_len = (size_t) res;\n      uname_info->uname_type = MHD_DIGEST_AUTH_UNAME_TYPE_EXTENDED;\n      buf_used += uname_info->username_len + 1;\n      log_probe (\"EXTENDED: success username_len=%zu buf_used=%zu\", uname_info->username_len, buf_used);\n    }\n  }\n  else\n  {\n    log_probe (\"BRANCH: DEFAULT/UNKNOWN uname_type=%d\", (int) uname_type);\n    mhd_assert (0);\n    uname_info->uname_type = MHD_DIGEST_AUTH_UNAME_TYPE_INVALID;\n  }\n\n  /* Log state just before the final buffer-size assertion */\n  log_probe (\"BEFORE FINAL ASSERT: buf_size=%zu buf_used=%zu uname_type=%d\",\n             buf_size, buf_used, (int) uname_info->uname_type);\n\n  mhd_assert (buf_size >= buf_used);\n  /* Document that final assertion was executed but did not change state */\n  log_probe (\"ASSERT final executed (buf_size >= buf_used) ; post-check buf_used=%zu\", buf_used);\n\n  log_probe (\"EXIT get_rq_uname: returning buf_used=%zu\", buf_used);\n  return buf_used;\n}\n\n```\n</target code>\n<build error>\nThe build failed with the following error:\n```\ndigestauth.c:1116:13: error: expected identifier or '('\n 1116 | static void mhd_assert (int cond)\n      |             ^\n./mhd_assert.h:45:32: note: expanded from macro 'mhd_assert'\n   45 | #  define mhd_assert(ignore) ((void) 0)\n      |                                ^\ndigestauth.c:1116:13: error: expected ')'\n./mhd_assert.h:45:32: note: expanded from macro 'mhd_assert'\n   45 | #  define mhd_assert(ignore) ((void) 0)\n      |                                ^\ndigestauth.c:1116:13: note: to match this '('\n./mhd_assert.h:45:31: note: expanded from macro 'mhd_assert'\n   45 | #  define mhd_assert(ignore) ((void) 0)\n      |                               ^\ndigestauth.c:1116:13: error: expected ')'\n 1116 | static void mhd_assert (int cond)\n      |             ^\n./mhd_assert.h:45:38: note: expanded from macro 'mhd_assert'\n   45 | #  define mhd_assert(ignore) ((void) 0)\n      |                                      ^\ndigestauth.c:1116:13: note: to match this '('\n./mhd_assert.h:45:30: note: expanded from macro 'mhd_assert'\n   45 | #  define mhd_assert(ignore) ((void) 0)\n      |                              ^\n3 errors generated.\nmake[3]: *** [Makefile:2224: libmicrohttpd_la-digestauth.lo] Error 1\nmake[2]: *** [Makefile:449: all-recursive] Error 1\nmake[1]: *** [Makefile:788: all-recursive] Error 1\nmake: *** [Makefile:693: all] Error 2\n```\n</build error>\n<response format>\nProvide your answer with these answers.\n- fixed_test_code: the fixed test code that compiles successfully.\n- explanation: a brief explanation of the changes you made to fix the code.\nHere are the constraints for the test code:\n- The test code MUST be compilable and executable.\n- The test code MUST include line breaks.\n- The test code MUST preserve the original logic of get_rq_uname as much as possible.\n- You MUST not define the main function.\n- You MUST not define macros.\n- The test code MUST not contain any mock functions.\n</response format>\n<instruction>\nPlease fix the code so that it compiles successfully.\n</instruction>\n",
  "fixed_test_code": "/* Fixed digestauth.c fragment to avoid conflict with an existing mhd_assert macro.\n   This file provides necessary type declarations so it compiles as a translation unit.\n   It does not define any mock functions or a main(). */\n\n#include <stdio.h>\n#include <stdarg.h>\n#include <stddef.h>\n#include <stdint.h>\n#include <sys/types.h>\n\n/* Minimal type and constant declarations referenced by get_rq_uname.\n   These are forward/compatible declarations to allow compilation of this\n   translation unit. They preserve the original logic of get_rq_uname. */\n\nstruct MHD_Param_String\n{\n  char *str;\n  size_t len;\n};\n\nenum MHD_DigestAuthUsernameType\n{\n  MHD_DIGEST_AUTH_UNAME_TYPE_INVALID = 0,\n  MHD_DIGEST_AUTH_UNAME_TYPE_MISSING,\n  MHD_DIGEST_AUTH_UNAME_TYPE_STANDARD,\n  MHD_DIGEST_AUTH_UNAME_TYPE_USERHASH,\n  MHD_DIGEST_AUTH_UNAME_TYPE_EXTENDED\n};\n\nstruct MHD_RqDAuth\n{\n  struct MHD_Param_String username;\n  struct { struct MHD_Param_String value; } username_ext;\n};\n\nstruct MHD_DigestAuthUsernameInfo\n{\n  char *username;\n  size_t username_len;\n  char *userhash_hex;\n  size_t userhash_hex_len;\n  uint8_t *userhash_bin;\n  enum MHD_DigestAuthUsernameType uname_type;\n};\n\n/* Prototypes for external functions used by get_rq_uname. These are\n   declarations only (no mock implementations), so the file remains\n   compileable in isolation. */\nextern enum MHD_DigestAuthUsernameType get_rq_uname_type(const struct MHD_RqDAuth *params);\nextern size_t get_rq_param_unquoted_copy_z(const struct MHD_Param_String *param, char *out);\nextern size_t MHD_hex_to_bin(const char *hex, size_t hex_len, uint8_t *out);\nextern ssize_t get_rq_extended_uname_copy_z(const char *str, size_t len, char *out, size_t out_size);\n\n/* The original code defined a static function named mhd_assert, but in some\n   build configurations mhd_assert is a macro (from an included header), which\n   causes a preprocessor/name collision. To avoid that, rename the local\n   no-op assert function to mhd_assert_noop and call it in place of mhd_assert.\n   This preserves the original semantics (no-op in production) while avoiding\n   macro conflicts. */\nstatic void mhd_assert_noop (int cond)\n{\n  /* Intentionally do nothing (simulate typical production no-op assert).\n     We keep the call so that logging can demonstrate it has no side-effects. */\n  (void) cond;\n}\n\nstatic void\nlog_probe (const char *fmt, ...)\n{\n  FILE *f = fopen(\"/tmp/logs/2842.txt\", \"a\");\n  if (f == NULL)\n    return; /* Best-effort logging; do not change control flow if logging fails */\n\n  va_list ap;\n  va_start (ap, fmt);\n  vfprintf (f, fmt, ap);\n  fprintf (f, \"\\n\");\n  va_end (ap);\n  fclose (f);\n}\n\nstatic size_t\nget_rq_uname (const struct MHD_RqDAuth *params,\n              enum MHD_DigestAuthUsernameType uname_type,\n              struct MHD_DigestAuthUsernameInfo *uname_info,\n              uint8_t *buf,\n              size_t buf_size)\n{\n  size_t buf_used;\n\n  buf_used = 0;\n  /* Log entry state */\n  log_probe (\"ENTER get_rq_uname: params=%p uname_type=%d buf_size=%zu\", (void *) params, (int) uname_type, buf_size);\n\n  mhd_assert_noop (get_rq_uname_type (params) == uname_type);\n  /* Log that the assertion call was executed; since mhd_assert is a no-op\n     this documents that no state change occurred here. */\n  log_probe (\"ASSERT 1 executed: get_rq_uname_type(params)==%d\", (int) uname_type);\n\n  mhd_assert_noop (MHD_DIGEST_AUTH_UNAME_TYPE_INVALID != uname_type);\n  log_probe (\"ASSERT 2 executed: uname_type != INVALID (value %d)\", (int) uname_type);\n\n  mhd_assert_noop (MHD_DIGEST_AUTH_UNAME_TYPE_MISSING != uname_type);\n  log_probe (\"ASSERT 3 executed: uname_type != MISSING (value %d)\", (int) uname_type);\n\n  uname_info->username = NULL;\n  uname_info->username_len = 0;\n  uname_info->userhash_hex = NULL;\n  uname_info->userhash_hex_len = 0;\n  uname_info->userhash_bin = NULL;\n\n  if (MHD_DIGEST_AUTH_UNAME_TYPE_STANDARD == uname_type)\n  {\n    log_probe (\"BRANCH: STANDARD (buf_used=%zu)\", buf_used);\n    uname_info->username = (char *) (buf + buf_used);\n    uname_info->username_len =\n      get_rq_param_unquoted_copy_z (&params->username,\n                                    uname_info->username);\n    log_probe (\"STANDARD: copied username len=%zu\", uname_info->username_len);\n    buf_used += uname_info->username_len + 1;\n    uname_info->uname_type = MHD_DIGEST_AUTH_UNAME_TYPE_STANDARD;\n    log_probe (\"STANDARD: updated buf_used=%zu\", buf_used);\n  }\n  else if (MHD_DIGEST_AUTH_UNAME_TYPE_USERHASH == uname_type)\n  {\n    size_t res;\n\n    log_probe (\"BRANCH: USERHASH (buf_used=%zu)\", buf_used);\n    uname_info->userhash_hex = (char *) (buf + buf_used);\n    uname_info->userhash_hex_len =\n      get_rq_param_unquoted_copy_z (&params->username,\n                                    uname_info->userhash_hex);\n    log_probe (\"USERHASH: copied userhash_hex_len=%zu\", uname_info->userhash_hex_len);\n    buf_used += uname_info->userhash_hex_len + 1;\n    uname_info->userhash_bin = (uint8_t *) (buf + buf_used);\n    res = MHD_hex_to_bin (uname_info->userhash_hex,\n                          uname_info->userhash_hex_len,\n                          uname_info->userhash_bin);\n    log_probe (\"USERHASH: MHD_hex_to_bin returned res=%zu\", res);\n    if (res != uname_info->userhash_hex_len / 2)\n    {\n      uname_info->userhash_bin = NULL;\n      uname_info->uname_type = MHD_DIGEST_AUTH_UNAME_TYPE_INVALID;\n      log_probe (\"USERHASH: invalid hex length -> set uname_type=INVALID\");\n    }\n    else\n    {\n      /* Avoid pointers outside allocated region when the size is zero */\n      if (0 == res)\n        uname_info->userhash_bin = (uint8_t *) uname_info->username;\n      uname_info->uname_type = MHD_DIGEST_AUTH_UNAME_TYPE_USERHASH;\n      buf_used += res;\n      log_probe (\"USERHASH: success -> uname_type=USERHASH buf_used=%zu\", buf_used);\n    }\n  }\n  else if (MHD_DIGEST_AUTH_UNAME_TYPE_EXTENDED == uname_type)\n  {\n    ssize_t res;\n    log_probe (\"BRANCH: EXTENDED (buf_used=%zu buf_size=%zu)\", buf_used, buf_size);\n    res = get_rq_extended_uname_copy_z (params->username_ext.value.str,\n                                        params->username_ext.value.len,\n                                        (char *) (buf + buf_used),\n                                        buf_size - buf_used);\n    log_probe (\"EXTENDED: get_rq_extended_uname_copy_z returned res=%zd\", res);\n    if (0 > res)\n      uname_info->uname_type = MHD_DIGEST_AUTH_UNAME_TYPE_INVALID;\n    else\n    {\n      uname_info->username = (char *) (buf + buf_used);\n      uname_info->username_len = (size_t) res;\n      uname_info->uname_type = MHD_DIGEST_AUTH_UNAME_TYPE_EXTENDED;\n      buf_used += uname_info->username_len + 1;\n      log_probe (\"EXTENDED: success username_len=%zu buf_used=%zu\", uname_info->username_len, buf_used);\n    }\n  }\n  else\n  {\n    log_probe (\"BRANCH: DEFAULT/UNKNOWN uname_type=%d\", (int) uname_type);\n    mhd_assert_noop (0);\n    uname_info->uname_type = MHD_DIGEST_AUTH_UNAME_TYPE_INVALID;\n  }\n\n  /* Log state just before the final buffer-size assertion */\n  log_probe (\"BEFORE FINAL ASSERT: buf_size=%zu buf_used=%zu uname_type=%d\",\n             buf_size, buf_used, (int) uname_info->uname_type);\n\n  mhd_assert_noop (buf_size >= buf_used);\n  /* Document that final assertion was executed but did not change state */\n  log_probe (\"ASSERT final executed (buf_size >= buf_used) ; post-check buf_used=%zu\", buf_used);\n\n  log_probe (\"EXIT get_rq_uname: returning buf_used=%zu\", buf_used);\n  return buf_used;\n}\n",
  "explanation": "The compilation error was caused by a name collision between a locally defined function named mhd_assert and a macro mhd_assert coming from an included header. I renamed the local no-op assert function to mhd_assert_noop and replaced all mhd_assert calls with mhd_assert_noop to avoid macro expansion issues. I also added minimal forward declarations for the types, enum constants, and external function prototypes referenced by get_rq_uname so the file compiles as a standalone translation unit. No macros were defined, no mock functions were implemented, and the original logic of get_rq_uname was preserved."
}