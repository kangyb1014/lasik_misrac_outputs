{
  "user_message": "An agent A claimed that the following MHD_DLOG code violates the MISRA C 2023 rule 8.13.\n<misra_rule>\nMISRA C 2023 Rule 8.13 is A pointer should point to a const-qualified type whenever possible.\n\n</misra_rule>\n<target_code>\nHere is the original code of MHD_DLOG.\n```c\nvoid\nMHD_DLOG (const struct MHD_Daemon *daemon,\n          const char *format,\n          ...)\n{\n  va_list va;\n\n  if (0 == (daemon->options & MHD_USE_ERROR_LOG))\n    return;\n  va_start (va, format);\n  daemon->custom_error_log (daemon->custom_error_log_cls,\n                            format,\n                            va);\n  va_end (va);\n}\n```\n</target_code>\n<response format>\nProvide your answer with these fields.\n- explanation: your evaluation of the scenario provided by the agent A.\n- is_report_correct: whether the report is correct or not (true/false). True means there is a violation.\n</response format>\n<scenario>\nThe agent A provided the following violation scenario:\nThe daemon object is passed as const, but the member custom_error_log_cls is (presumably) declared as a pointer to a non-const type (e.g. void *custom_error_log_cls). Accessing daemon->custom_error_log_cls therefore yields a pointer that is top-level const (void * const) but which points to a non-const type. Rule 8.13 requires pointers to point to const-qualified types when possible, so the member should be declared as const void *custom_error_log_cls (and the callback should accept a const void *), or the API adjusted otherwise.\n</scenario>\n\n<execution_log>\nThe agent A also provided the following output log:\nMHD_DLOG probe: phase=entry\n  daemon=0x55db795f58d0\n  format_ptr=0x7f1b4cdd1714\n  format_text=\"Connection was closed by remote side with incomplete request.\n\"\n  options=0x00080001\n  MHD_USE_ERROR_LOG bit set=1\n  custom_error_log_is_non_null=1\n  custom_error_log_cls_ptr=0x7f1b4cd596a0\n  callback_invoked=0\n---\nMHD_DLOG probe: phase=before_callback\n  daemon=0x55db795f58d0\n  format_ptr=0x7f1b4cdd1714\n  format_text=\"Connection was closed by remote side with incomplete request.\n\"\n  options=0x00080001\n  MHD_USE_ERROR_LOG bit set=1\n  custom_error_log_is_non_null=1\n  custom_error_log_cls_ptr=0x7f1b4cd596a0\n  callback_invoked=0\n---\nMHD_DLOG probe: phase=after_callback\n  daemon=0x55db795f58d0\n  format_ptr=0x7f1b4cdd1714\n  format_text=\"Connection was closed by remote side with incomplete request.\n\"\n  options=0x00080001\n  MHD_USE_ERROR_LOG bit set=1\n  custom_error_log_is_non_null=1\n  custom_error_log_cls_ptr=0x7f1b4cd596a0\n  callback_invoked=1\n---\nMHD_DLOG probe: phase=entry\n  daemon=0x55db795f58d0\n  format_ptr=0x7f1b4cdd1714\n  format_text=\"Connection was closed by remote side with incomplete request.\n\"\n  options=0x00080001\n  MHD_USE_ERROR_LOG bit set=1\n  custom_error_log_is_non_null=1\n  custom_error_log_cls_ptr=0x7f1b4cd596a0\n  callback_invoked=0\n---\nMHD_DLOG probe: phase=before_callback\n  daemon=0x55db795f58d0\n  format_ptr=0x7f1b4cdd1714\n  format_text=\"Connection was closed by remote side with incomplete request.\n\"\n  options=0x00080001\n  MHD_USE_ERROR_LOG bit set=1\n  custom_error_log_is_non_null=1\n  custom_error_log_cls_ptr=0x7f1b4cd596a0\n  callback_invoked=0\n---\nMHD_DLOG probe: phase=after_callback\n  daemon=0x55db795f58d0\n  format_ptr=0x7f1b4cdd1714\n  format_text=\"Connection was closed by remote side with incomplete request.\n\"\n  options=0x00080001\n  MHD_USE_ERROR_LOG bit set=1\n  custom_error_log_is_non_null=1\n  custom_error_log_cls_ptr=0x7f1b4cd596a0\n  callback_invoked=1\n---\nMHD_DLOG probe: phase=entry\n  daemon=0x55db795f58d0\n  format_ptr=0x7f1b4cdd1714\n  format_text=\"Connection was closed by remote side with incomplete request.\n\"\n  options=0x00080001\n  MHD_USE_ERROR_LOG bit set=1\n  custom_error_log_is_non_null=1\n  custom_error_log_cls_ptr=0x7f1b4cd596a0\n  callback_invoked=0\n---\nMHD_DLOG probe: phase=before_callback\n  daemon=0x55db795f58d0\n  format_ptr=0x7f1b4cdd1714\n  format_text=\"Connection was closed by remote side with incomplete request.\n\"\n  options=0x00080001\n  MHD_USE_ERROR_LOG bit set=1\n  custom_error_log_is_non_null=1\n  custom_error_log_cls_ptr=0x7f1b4cd596a0\n  callback_invoked=0\n---\nMHD_DLOG probe: phase=after_callback\n  daemon=0x55db795f58d0\n  format_ptr=0x7f1b4cdd1714\n  format_text=\"Connection was closed by remote side with incomplete request.\n\"\n  options=0x00080001\n  MHD_USE_ERROR_LOG bit set=1\n  custom_error_log_is_non_null=1\n  custom_error_log_cls_ptr=0x7f1b4cd596a0\n  callback_invoked=1\n---\nMHD_DLOG probe: phase=entry\n  daemon=0x55db795f58d0\n  format_ptr=0x7f1b4cdd1714\n  format_text=\"Connection was closed by remote side with incomplete request.\n\"\n  options=0x00080001\n  MHD_USE_ERROR_LOG bit set=1\n  custom_error_log_is_non_null=1\n  custom_error_log_cls_ptr=0x7f1b4cd596a0\n  callback_invoked=0\n---\nMHD_DLOG probe: phase=before_callback\n  daemon=0x55db795f58d0\n  format_ptr=0x7f1b4cdd1714\n  format_text=\"Connection was closed by remote side with incomplete request.\n\"\n  options=0x00080001\n  MHD_USE_ERROR_LOG bit set=1\n  custom_error_log_is_non_null=1\n  custom_error_log_cls_ptr=0x7f1b4cd596a0\n  callback_invoked=0\n---\nMHD_DLOG probe: phase=after_callback\n  daemon=0x55db795f58d0\n  format_ptr=0x7f1b4cdd1714\n  format_text=\"Connection was closed by remote side with incomplete request.\n\"\n  options=0x00080001\n  MHD_USE_ERROR_LOG bit set=1\n  custom_error_log_is_non_null=1\n  custom_error_log_cls_ptr=0x7f1b4cd596a0\n  callback_invoked=1\n---\nMHD_DLOG probe: phase=entry\n  daemon=0x55db795f58d0\n  format_ptr=0x7f1b4cdd1714\n  format_text=\"Connection was closed by remote side with incomplete request.\n\"\n  options=0x00080001\n  MHD_USE_ERROR_LOG bit set=1\n  custom_error_log_is_non_null=1\n  custom_error_log_cls_ptr=0x7f1b4cd596a0\n  callback_invo\n</execution_log>\n\n<instruction>\nJudge whether the report is correct or not.\n</instruction>\n",
  "is_report_correct": false,
  "explanation": "Agent A's report is not justified on the information given. MISRA C 2023 Rule 8.13 is a guidance about declaring pointer types so that the pointed-to type is const whenever possible (i.e. prefer void const * over void * if the object pointed to must not be modified). The claim hinges on the declaration of the struct member and the callback prototype (which are not shown). A few points:\n\n- The expression daemon->custom_error_log_cls, when daemon has type const struct MHD_Daemon *, has type \"void * const\" if the member is declared as \"void *custom_error_log_cls\". That is a top-level const on the pointer object, not a const qualification of the pointee. Rule 8.13 concerns low-level const (the pointed-to type), not whether the pointer object itself is top-level const via access through a const-qualified aggregate.\n\n- Whether the member should be declared \"const void *custom_error_log_cls\" (and the callback accept a const void *) depends on whether the callback is allowed/expected to modify the pointed-to object. If the context object is intended to be mutable by the callback, then declaring it as const would be incorrect. Without the struct and callback declarations (and the intended semantics), you cannot conclude a violation.\n\n- The code as shown does not itself perform any modification of the pointed-to object; it merely passes the member to a callback. That usage alone is insufficient to declare a Rule 8.13 violation. The rule would be violated only if the member is declared to point to a non-const type even though it could be declared to point to a const-qualified type (i.e. the API/implementation guarantees the pointee will never be modified). That determination needs the API definition/intent.\n\nTherefore the agent's claim is a possible improvement suggestion (making the context pointer point to a const-qualified type if it is never modified), but it is not provably a MISRA 8.13 violation from the code shown."
}