{
  "user_message": "An agent A claimed that the following internal_get_fdset2 code violates the MISRA C 2023 rule 14.3.\n<misra_rule>\nMISRA C 2023 Rule 14.3 is Controlling expressions shall not be invariant.\nHere are exceptions to this rule:\n1. Invariants that are used to create infinite loops are permitted.\n2. A do-while loop with an essentially Boolean controlling expression that evaluates to false and satisfies the constraints and semantics for an integer constant expression is permitted.\n</misra_rule>\n<target_code>\nHere is the original code of internal_get_fdset2.\n```c\nstatic enum MHD_Result\ninternal_get_fdset2 (struct MHD_Daemon *daemon,\n                     fd_set *read_fd_set,\n                     fd_set *write_fd_set,\n                     fd_set *except_fd_set,\n                     MHD_socket *max_fd,\n                     int fd_setsize)\n{\n  struct MHD_Connection *pos;\n  struct MHD_Connection *posn;\n  enum MHD_Result result = MHD_YES;\n  MHD_socket ls;\n  bool itc_added;\n\n#ifndef HAS_FD_SETSIZE_OVERRIDABLE\n  (void) fd_setsize;  /* Mute compiler warning */\n  fd_setsize = (int) FD_SETSIZE; /* Help compiler to optimise */\n#endif /* ! HAS_FD_SETSIZE_OVERRIDABLE */\n\n  if (daemon->shutdown)\n    return MHD_YES;\n\n  /* The order of FDs added is important for W32 sockets as W32 fd_set has\n     limits for number of added FDs instead of the limit for the higher\n     FD value. */\n\n  /* Add ITC FD first. The daemon must be able to respond on application\n     commands issued in other threads. */\n  itc_added = false;\n  if (MHD_ITC_IS_VALID_ (daemon->itc))\n  {\n    itc_added = MHD_add_to_fd_set_ (MHD_itc_r_fd_ (daemon->itc),\n                                    read_fd_set,\n                                    max_fd,\n                                    fd_setsize);\n    if (! itc_added)\n      result = MHD_NO;\n  }\n\n  ls = daemon->was_quiesced ? MHD_INVALID_SOCKET : daemon->listen_fd;\n  if (! itc_added &&\n      (MHD_INVALID_SOCKET != ls))\n  {\n    /* Add listen FD if ITC was not added. Listen FD could be used to signal\n       the daemon shutdown. */\n    if (MHD_add_to_fd_set_ (ls,\n                            read_fd_set,\n                            max_fd,\n                            fd_setsize))\n      ls = MHD_INVALID_SOCKET;   /* Already added */\n    else\n      result = MHD_NO;\n  }\n\n  /* Add all sockets to 'except_fd_set' as well to watch for\n   * out-of-band data. However, ignore errors if INFO_READ\n   * or INFO_WRITE sockets will not fit 'except_fd_set'. */\n  /* Start from oldest connections. Make sense for W32 FDSETs. */\n  for (pos = daemon->connections_tail; NULL != pos; pos = posn)\n  {\n    posn = pos->prev;\n\n    switch (pos->event_loop_info)\n    {\n    case MHD_EVENT_LOOP_INFO_READ:\n    case MHD_EVENT_LOOP_INFO_PROCESS_READ:\n      if (! MHD_add_to_fd_set_ (pos->socket_fd,\n                                read_fd_set,\n                                max_fd,\n                                fd_setsize))\n        result = MHD_NO;\n#ifdef MHD_POSIX_SOCKETS\n      if (NULL != except_fd_set)\n        (void) MHD_add_to_fd_set_ (pos->socket_fd,\n                                   except_fd_set,\n                                   max_fd,\n                                   fd_setsize);\n#endif /* MHD_POSIX_SOCKETS */\n      break;\n    case MHD_EVENT_LOOP_INFO_WRITE:\n      if (! MHD_add_to_fd_set_ (pos->socket_fd,\n                                write_fd_set,\n                                max_fd,\n                                fd_setsize))\n        result = MHD_NO;\n#ifdef MHD_POSIX_SOCKETS\n      if (NULL != except_fd_set)\n        (void) MHD_add_to_fd_set_ (pos->socket_fd,\n                                   except_fd_set,\n                                   max_fd,\n                                   fd_setsize);\n#endif /* MHD_POSIX_SOCKETS */\n      break;\n    case MHD_EVENT_LOOP_INFO_PROCESS:\n      if ( (NULL == except_fd_set) ||\n           ! MHD_add_to_fd_set_ (pos->socket_fd,\n                                 except_fd_set,\n                                 max_fd,\n                                 fd_setsize))\n        result = MHD_NO;\n      break;\n    case MHD_EVENT_LOOP_INFO_CLEANUP:\n      /* this should never happen */\n      break;\n    }\n  }\n#ifdef MHD_WINSOCK_SOCKETS\n  /* W32 use limited array for fd_set so add INFO_READ/INFO_WRITE sockets\n   * only after INFO_BLOCK sockets to ensure that INFO_BLOCK sockets will\n   * not be pushed out. */\n  if (NULL != except_fd_set)\n  {\n    for (pos = daemon->connections_tail; NULL != pos; pos = posn)\n    {\n      posn = pos->prev;\n      MHD_add_to_fd_set_ (pos->socket_fd,\n                          except_fd_set,\n                          max_fd,\n                          fd_setsize);\n    }\n  }\n#endif /* MHD_WINSOCK_SOCKETS */\n#if defined(HTTPS_SUPPORT) && defined(UPGRADE_SUPPORT)\n  if (1)\n  {\n    struct MHD_UpgradeResponseHandle *urh;\n\n    for (urh = daemon->urh_tail; NULL != urh; urh = urh->prev)\n    {\n      if (MHD_NO ==\n          urh_to_fdset (urh,\n                        read_fd_set,\n                        write_fd_set,\n                        except_fd_set,\n                        max_fd,\n                        fd_setsize))\n        result = MHD_NO;\n    }\n  }\n#endif\n\n  if (MHD_INVALID_SOCKET != ls)\n  {\n    /* The listen socket is present and hasn't been added */\n    if ((daemon->connections < daemon->connection_limit) &&\n        ! daemon->at_limit)\n    {\n      if (! MHD_add_to_fd_set_ (ls,\n                                read_fd_set,\n                                max_fd,\n                                fd_setsize))\n        result = MHD_NO;\n    }\n  }\n\n#if _MHD_DEBUG_CONNECT\n#ifdef HAVE_MESSAGES\n  if (NULL != max_fd)\n    MHD_DLOG (daemon,\n              _ (\"Maximum socket in select set: %d\\n\"),\n              *max_fd);\n#endif\n#endif /* HTTPS_SUPPORT && UPGRADE_SUPPORT */\n  return result;\n}\n```\n</target_code>\n<response format>\nProvide your answer with these fields.\n- explanation: your evaluation of the scenario provided by the agent A.\n- is_report_correct: whether the report is correct or not (true/false). True means there is a violation.\n</response format>\n<scenario>\nThe agent A provided the following violation scenario:\nThe controlling expression of the 'if' statement is the constant literal 1 (if (1)) which is invariant and always true. This is not an infinite-loop use nor the permitted do-while constant-false exception, so it violates MISRA C 2023 Rule 14.3.\n</scenario>\n\n<execution_log>\nThe agent A also provided the following output log:\ninternal_get_fdset2: entry daemon=0x55a0cd608de0 fd_setsize=1024\ninternal_get_fdset2: was_quiesced=0 original_listen_fd=3 resolved_ls=3\ninternal_get_fdset2: listen fd 3 already added, marking ls=MHD_INVALID_SOCKET\ninternal_get_fdset2: exit result=1 max_fd=0x7ffd8ca9dd6c\ninternal_get_fdset2: entry daemon=0x55a0cd608de0 fd_setsize=1024\ninternal_get_fdset2: was_quiesced=0 original_listen_fd=3 resolved_ls=3\ninternal_get_fdset2: listen fd 3 already added, marking ls=MHD_INVALID_SOCKET\ninternal_get_fdset2: exit result=1 max_fd=0x7ffd8ca9db44\ninternal_get_fdset2: entry daemon=0x55a0cd608de0 fd_setsize=1024\ninternal_get_fdset2: was_quiesced=0 original_listen_fd=3 resolved_ls=3\ninternal_get_fdset2: listen fd 3 already added, marking ls=MHD_INVALID_SOCKET\ninternal_get_fdset2: exit result=1 max_fd=0x7ffd8ca9dd6c\ninternal_get_fdset2: entry daemon=0x55a0cd608de0 fd_setsize=1024\ninternal_get_fdset2: was_quiesced=0 original_listen_fd=3 resolved_ls=3\ninternal_get_fdset2: listen fd 3 already added, marking ls=MHD_INVALID_SOCKET\ninternal_get_fdset2: exit result=1 max_fd=0x7ffd8ca9db44\ninternal_get_fdset2: entry daemon=0x55a0cd608de0 fd_setsize=1024\ninternal_get_fdset2: was_quiesced=0 original_listen_fd=3 resolved_ls=3\ninternal_get_fdset2: listen fd 3 already added, marking ls=MHD_INVALID_SOCKET\ninternal_get_fdset2: exit result=1 max_fd=0x7ffd8ca9dd6c\ninternal_get_fdset2: entry daemon=0x55a0cd608de0 fd_setsize=1024\ninternal_get_fdset2: was_quiesced=0 original_listen_fd=3 resolved_ls=3\ninternal_get_fdset2: listen fd 3 already added, marking ls=MHD_INVALID_SOCKET\ninternal_get_fdset2: exit result=1 max_fd=0x7ffd8ca9db44\ninternal_get_fdset2: entry daemon=0x55a0cd608de0 fd_setsize=1024\ninternal_get_fdset2: was_quiesced=0 original_listen_fd=3 resolved_ls=3\ninternal_get_fdset2: listen fd 3 already added, marking ls=MHD_INVALID_SOCKET\ninternal_get_fdset2: exit result=1 max_fd=0x7ffd8ca9dd6c\ninternal_get_fdset2: entry daemon=0x55a0cd608de0 fd_setsize=1024\ninternal_get_fdset2: was_quiesced=0 original_listen_fd=3 resolved_ls=3\ninternal_get_fdset2: listen fd 3 already added, marking ls=MHD_INVALID_SOCKET\ninternal_get_fdset2: exit result=1 max_fd=0x7ffd8ca9db44\ninternal_get_fdset2: entry daemon=0x55a0cd608de0 fd_setsize=1024\ninternal_get_fdset2: was_quiesced=0 original_listen_fd=3 resolved_ls=3\ninternal_get_fdset2: listen fd 3 already added, marking ls=MHD_INVALID_SOCKET\ninternal_get_fdset2: exit result=1 max_fd=0x7ffd8ca9dd6c\ninternal_get_fdset2: entry daemon=0x55a0cd608de0 fd_setsize=1024\ninternal_get_fdset2: was_quiesced=0 original_listen_fd=3 resolved_ls=3\ninternal_get_fdset2: listen fd 3 already added, marking ls=MHD_INVALID_SOCKET\ninternal_get_fdset2: exit result=1 max_fd=0x7ffd8ca9db44\ninternal_get_fdset2: entry daemon=0x55a0cd608de0 fd_setsize=1024\ninternal_get_fdset2: was_quiesced=0 original_listen_fd=3 resolved_ls=3\ninternal_get_fdset2: listen fd 3 already added, marking ls=MHD_INVALID_SOCKET\ninternal_get_fdset2: exit result=1 max_fd=0x7ffd8ca9dd6c\ninternal_get_fdset2: entry daemon=0x55a0cd608de0 fd_setsize=1024\ninternal_get_fdset2: was_quiesced=0 original_listen_fd=3 resolved_ls=3\ninternal_get_fdset2: listen fd 3 already added, marking ls=MHD_INVALID_SOCKET\ninternal_get_fdset2: exit result=1 max_fd=0x7ffd8ca9db44\ninternal_get_fdset2: entry daemon=0x55a0cd608de0 fd_setsize=1024\ninternal_get_fdset2: was_quiesced=0 original_listen_fd=3 resolved_ls=3\ninternal_get_fdset2: listen fd 3 already added, marking ls=MHD_INVALID_SOCKET\ninternal_get_fdset2: exit result=1 max_fd=0x7ffd8ca9dd6c\ninternal_get_fdset2: entry daemon=0x55a0cd608de0 fd_setsize=1024\ninternal_get_fdset2: was_quiesced=0 original_listen_fd=3 resolved_ls=3\ninternal_get_fdset2: listen fd 3 already added, marking ls=MHD_INVALID_SOCKET\ninternal_get_fdset2: exit result=1 max_fd=0x7ffd8ca9db44\ninternal_get_fdset2: entry daemon=0x55a0cd608de0 fd_setsize=1024\ninternal_get_fdset2: was_quiesced=0 original_listen_fd=3 resolved_ls=3\ninternal_get_fdset2: listen fd 3 already added, marking ls=MHD_INVALID_SOCKET\ninternal_get_fdset2: exit result=1 max_fd=0x7ffd8ca9dd6c\ninternal_get_fdset2: entry daem\n</execution_log>\n\n<instruction>\nJudge whether the report is correct or not.\n</instruction>\n",
  "is_report_correct": true,
  "explanation": "Agent A is correct. The code contains an if (1) block (inside the #if defined(HTTPS_SUPPORT) && defined(UPGRADE_SUPPORT) section). The controlling expression is the literal constant 1, which is invariant and always true. This is not an infinite-loop usage nor the permitted do-while constant-false case, so it violates MISRA C 2023 Rule 14.3. A simple fix is to remove the if (1) and use a plain block ( { ... } ) or just the for-loop (declaring urh in an enclosing block) so the code does not use an invariant controlling expression."
}