{
  "user_message": "An agent A claimed that the following MHD_basic_auth_get_username_password3 code violates the MISRA C 2023 rule 21.17.\n<misra_rule>\nMISRA C 2023 Rule 21.17 is Use of the string handling functions from <string.h> shall not result in accesses beyond the bounds of the objects referenced by their pointer parameters.\nThis rule strictly applies to the Standard Library functions in <string.h> such as memcpy, memmove, memset, memcmp, strcpy, strncpy, strcat, strncat, strlen, and strspn.\n</misra_rule>\n<target_code>\nHere is the original code of MHD_basic_auth_get_username_password3.\n```c\n_MHD_EXTERN struct MHD_BasicAuthInfo *\nMHD_basic_auth_get_username_password3 (struct MHD_Connection *connection)\n{\n  const struct MHD_RqBAuth *params;\n  size_t decoded_max_len;\n  struct MHD_BasicAuthInfo *ret;\n\n  params = MHD_get_rq_bauth_params_ (connection);\n\n  if (NULL == params)\n    return NULL;\n\n  if ((NULL == params->token68.str) || (0 == params->token68.len))\n    return NULL;\n\n  decoded_max_len = MHD_base64_max_dec_size_ (params->token68.len);\n  ret = (struct MHD_BasicAuthInfo *) malloc (sizeof(struct MHD_BasicAuthInfo)\n                                             + decoded_max_len + 1);\n  if (NULL != ret)\n  {\n    size_t decoded_len;\n    char *decoded;\n\n    decoded = (char *) (ret + 1);\n    decoded_len = MHD_base64_to_bin_n (params->token68.str, params->token68.len,\n                                       decoded, decoded_max_len);\n    mhd_assert (decoded_max_len >= decoded_len);\n    if (0 != decoded_len)\n    {\n      size_t username_len;\n      char *colon;\n\n      colon = memchr (decoded, ':', decoded_len);\n      if (NULL != colon)\n      {\n        size_t password_pos;\n        size_t password_len;\n\n        username_len = (size_t) (colon - decoded);\n        password_pos = username_len + 1;\n        password_len = decoded_len - password_pos;\n        ret->password = decoded + password_pos;\n        ret->password[password_len] = 0;  /* Zero-terminate the string */\n        ret->password_len = password_len;\n      }\n      else\n      {\n        username_len = decoded_len;\n        ret->password = NULL;\n        ret->password_len = 0;\n      }\n      ret->username = decoded;\n      ret->username[username_len] = 0;  /* Zero-terminate the string */\n      ret->username_len = username_len;\n\n      return ret; /* Success exit point */\n    }\n#ifdef HAVE_MESSAGES\n    else\n      MHD_DLOG (connection->daemon,\n                _ (\"Error decoding Basic Authorization authentication.\\n\"));\n#endif /* HAVE_MESSAGES */\n\n    free (ret);\n  }\n#ifdef HAVE_MESSAGES\n  else\n  {\n    MHD_DLOG (connection->daemon,\n              _ (\"Failed to allocate memory to process \" \\\n                 \"Basic Authorization authentication.\\n\"));\n  }\n#endif /* HAVE_MESSAGES */\n\n  return NULL; /* Failure exit point */\n}\n```\n</target_code>\n<response format>\nProvide your answer with these fields.\n- explanation: your evaluation of the scenario provided by the agent A.\n- is_report_correct: whether the report is correct or not (true/false). True means there is a violation.\n</response format>\n<scenario>\nThe agent A provided the following violation scenario:\nThe assertion mhd_assert(decoded_max_len >= decoded_len) is the only explicit check that decoded_len does not exceed the allocated buffer size. If mhd_assert is implemented as a macro that compiles out (or otherwise does nothing) in production, and if MHD_base64_to_bin_n were to return a decoded_len > decoded_max_len (e.g. due to a bug or unexpected input), subsequent calls that use decoded_len with string.h functions (memchr(decoded, ':', decoded_len)) or the subsequent zero-terminations (ret->username[username_len] = 0 / ret->password[password_len] = 0) could access beyond the bounds of the allocated object. In that scenario the use of the string handling function memchr (and the later writes treating decoded as a string) would violate MISRA C 2023 Rule 21.17.\n</scenario>\n\n<instruction>\nJudge whether the report is correct or not.\n</instruction>\n",
  "is_report_correct": true,
  "explanation": "Agent A is correct. The call to memchr(decoded, ':', decoded_len) (memchr is a <string.h> function) and the subsequent writes that treat decoded as a NUL-terminated string rely on the implicit guarantee that decoded_len does not exceed the buffer that was allocated (decoded_max_len, with one extra byte reserved for a terminator). The only check in the function is mhd_assert(decoded_max_len >= decoded_len). If mhd_assert is a build-time/no-op macro in production (or otherwise not a guaranteed runtime check), there is no remaining runtime guarantee that MHD_base64_to_bin_n returned decoded_len <= decoded_max_len. If decoded_len > decoded_max_len, memchr may read beyond the allocated object and the zero-termination writes may write beyond it \u2014 precisely the kind of out-of-bounds access Rule 21.17 forbids. To comply, the code must perform an explicit runtime check (e.g. if (decoded_len <= decoded_max_len) ...) rather than relying solely on an assert or on assumptions about the decoder."
}