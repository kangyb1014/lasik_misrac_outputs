{
  "user_message": "<misra_rule>\nMISRA C 2023 Rule 2.2 is: A project shall not contain dead code.\nAny operation that is executed but whose removal would not affect program behaviour constitutes dead code. Notes:\n1. The behaviour of an embedded sytem is often determined not just by the nature of its actions, but also by the time at which they occur.\n2. unreachable code is not dead code, as it cannot be executed.\n3.Initialization is not the same as an assignment operation and is therfore not a candidate for dead code.\n</misra_rule>\n\nAnother agent reported that the target code violated the Rule 2.2.\nHere is the comment from the agent.\n<violation scenario>\nIf mhd_assert is a typical assert macro that is compiled out in production (for example mhd_assert(x) expands to ((void)0) when assertions are disabled / NDEBUG is defined), the statement mhd_assert(0); has no effect in that build and its removal would not change program behaviour. In that configuration the statement is redundant (dead) and thus violates MISRA C 2023 Rule 2.2. If, instead, mhd_assert is always active and causes termination/logging on failure, the statement is not dead (no violation).\n</violation scenario>\n\nYour job is to insert logging code to capture the control flow and state information of the program.\nInsert logging code so that other agents can reproduce and get evidence for the violation scenario.\n<response format>\n- test_code: a modified digest_update code that contains useful probe functions that print useful logs to a file \"/tmp/logs/2762.txt\". The logs should contain the control path and state information of the violation scenario. If test code is not required to validate the scenario, you can leave this blank.\nHere are the constraints for the test code:\n- The test code MUST preserve the original logic of digest_update as much as possible.\nYou CAN just insert probe functions to the original code.\n- DO NOT introduce new violations to demonstrate your scenario.\n- The test code MUST be compilable and executable.\n- The test code MUST include line breaks.\n- You MUST NOT define the main function.\n- You MUST NOT define macros.\n</response format>\n<target_code>\nHere is the code of digest_update:\n```c\n_MHD_static_inline void\ndigest_update (struct DigestAlgorithm *da,\n               const void *data,\n               size_t length)\n{\n  mhd_assert (! da->uninitialised);\n  mhd_assert (da->algo_selected);\n  mhd_assert (da->ready_for_hashing);\n#ifdef MHD_MD5_SUPPORT\n  if (MHD_DIGEST_BASE_ALGO_MD5 == da->algo)\n    MHD_MD5_update (&da->ctx.md5_ctx, (const uint8_t *) data, length);\n  else\n#endif /* MHD_MD5_SUPPORT */\n#ifdef MHD_SHA256_SUPPORT\n  if (MHD_DIGEST_BASE_ALGO_SHA256 == da->algo)\n    MHD_SHA256_update (&da->ctx.sha256_ctx, (const uint8_t *) data, length);\n  else\n#endif /* MHD_SHA256_SUPPORT */\n#ifdef MHD_SHA512_256_SUPPORT\n  if (MHD_DIGEST_BASE_ALGO_SHA512_256 == da->algo)\n    MHD_SHA512_256_update (&da->ctx.sha512_256_ctx,\n                           (const uint8_t *) data, length);\n  else\n#endif /* MHD_SHA512_256_SUPPORT */\n  mhd_assert (0);   /* May not happen */\n#ifdef _DEBUG\n  da->hashing = true;\n#endif\n}\n```\n</target_code>\nPlease provide the modified digest_update code.\n",
  "test_code": "#include <stdio.h>\n#include <stdarg.h>\n#include <time.h>\n#include <stdint.h>\n#include <stddef.h>\n#include <stdbool.h>\n\n/* Probe logging helpers: write human-readable traces to /tmp/logs/2762.txt */\nstatic void probe_log(const char *fmt, ...)\n{\n    FILE *f = fopen(\"/tmp/logs/2762.txt\", \"a\");\n    if (f == NULL)\n    {\n        /* If we cannot open the file, silently ignore to avoid changing program flow. */\n        return;\n    }\n\n    time_t t = time(NULL);\n    if (t != (time_t)-1)\n    {\n        struct tm *lt = localtime(&t);\n        if (lt != NULL)\n        {\n            fprintf(f, \"%04d-%02d-%02d %02d:%02d:%02d \",\n                    lt->tm_year + 1900, lt->tm_mon + 1, lt->tm_mday,\n                    lt->tm_hour, lt->tm_min, lt->tm_sec);\n        }\n        else\n        {\n            fprintf(f, \"%ld \", (long)t);\n        }\n    }\n\n    va_list ap;\n    va_start(ap, fmt);\n    vfprintf(f, fmt, ap);\n    va_end(ap);\n    fprintf(f, \"\\n\");\n    fclose(f);\n}\n\n_MHD_static_inline void\ndigest_update (struct DigestAlgorithm *da,\n               const void *data,\n               size_t length)\n{\n  /* Log entry and key state so that whether assertions are active can be observed. */\n  probe_log(\"digest_update entry: da=%p algo=%d length=%zu uninitialised=%d algo_selected=%d ready_for_hashing=%d\",\n            (void *)da,\n            (int)da->algo,\n            length,\n            (int)da->uninitialised,\n            (int)da->algo_selected,\n            (int)da->ready_for_hashing);\n\n  mhd_assert (! da->uninitialised);\n  mhd_assert (da->algo_selected);\n  mhd_assert (da->ready_for_hashing);\n#ifdef MHD_MD5_SUPPORT\n  if (MHD_DIGEST_BASE_ALGO_MD5 == da->algo) {\n    probe_log(\"digest_update: selected MD5 path: da=%p length=%zu\", (void *)da, length);\n    MHD_MD5_update (&da->ctx.md5_ctx, (const uint8_t *) data, length);\n  }\n  else\n#endif /* MHD_MD5_SUPPORT */\n#ifdef MHD_SHA256_SUPPORT\n  if (MHD_DIGEST_BASE_ALGO_SHA256 == da->algo) {\n    probe_log(\"digest_update: selected SHA256 path: da=%p length=%zu\", (void *)da, length);\n    MHD_SHA256_update (&da->ctx.sha256_ctx, (const uint8_t *) data, length);\n  }\n  else\n#endif /* MHD_SHA256_SUPPORT */\n#ifdef MHD_SHA512_256_SUPPORT\n  if (MHD_DIGEST_BASE_ALGO_SHA512_256 == da->algo) {\n    probe_log(\"digest_update: selected SHA512_256 path: da=%p length=%zu\", (void *)da, length);\n    MHD_SHA512_256_update (&da->ctx.sha512_256_ctx,\n                           (const uint8_t *) data, length);\n  }\n  else\n#endif /* MHD_SHA512_256_SUPPORT */\n  {\n    /* This branch indicates an unexpected algorithm value.\n       Log before and after the assert so that we can detect whether\n       mhd_assert(0) was a no-op (compiled out) or caused termination. */\n    probe_log(\"digest_update: unexpected algorithm value: da=%p algo=%d -- about to call mhd_assert(0)\",\n              (void *)da, (int)da->algo);\n    mhd_assert (0);   /* May not happen */\n    /* If execution reaches here, mhd_assert(0) did not terminate the program\n       (likely compiled out). Log that fact so other agents can reproduce the scenario. */\n    probe_log(\"digest_update: execution continued after mhd_assert(0) (assert may be compiled out): da=%p algo=%d\",\n              (void *)da, (int)da->algo);\n  }\n\n#ifdef _DEBUG\n  da->hashing = true;\n#endif\n\n  probe_log(\"digest_update exit: da=%p hashing=%d\", (void *)da,\n            (int)(\n#ifdef _DEBUG\n            da->hashing\n#else\n            0\n#endif\n            ));\n}\n"
}