{
  "user_message": "An agent A claimed that the following process_value code violates the MISRA C 2023 rule 17.8.\n<misra_rule>\nMISRA C 2023 Rule 17.8 is A function parameter should not be modified.\nNote that the object referred to by a pointer parameter may be modified, but the pointer itself shall not be modified.\n</misra_rule>\n<target_code>\nHere is the original code of process_value.\n```c\nstatic void\nprocess_value (struct MHD_PostProcessor *pp,\n               const char *value_start,\n               const char *value_end,\n               const char *last_escape)\n{\n  char xbuf[XBUF_SIZE + 1];\n  size_t xoff;\n\n  mhd_assert (pp->xbuf_pos < sizeof (xbuf));\n  /* 'value_start' and 'value_end' must be either both non-NULL or both NULL */\n  mhd_assert ( (NULL == value_start) || (NULL != value_end) );\n  mhd_assert ( (NULL != value_start) || (NULL == value_end) );\n  mhd_assert ( (NULL == last_escape) || (NULL != value_start) );\n  /* move remaining input from previous round into processing buffer */\n  if (0 != pp->xbuf_pos)\n    memcpy (xbuf,\n            pp->xbuf,\n            pp->xbuf_pos);\n  xoff = pp->xbuf_pos;\n  pp->xbuf_pos = 0;\n  if ( (NULL != last_escape) &&\n       (((size_t) (value_end - last_escape)) < sizeof (pp->xbuf)) )\n  {\n    mhd_assert (value_end >= last_escape);\n    pp->xbuf_pos = (size_t) (value_end - last_escape);\n    memcpy (pp->xbuf,\n            last_escape,\n            (size_t) (value_end - last_escape));\n    value_end = last_escape;\n  }\n  while ( (value_start != value_end) ||\n          (pp->must_ikvi) ||\n          (xoff > 0) )\n  {\n    size_t delta = (size_t) (value_end - value_start);\n    bool cut = false;\n    size_t clen = 0;\n\n    mhd_assert (value_end >= value_start);\n\n    if (delta > XBUF_SIZE - xoff)\n      delta = XBUF_SIZE - xoff;\n    /* move (additional) input into processing buffer */\n    if (0 != delta)\n    {\n      memcpy (&xbuf[xoff],\n              value_start,\n              delta);\n      xoff += delta;\n      value_start += delta;\n    }\n    /* find if escape sequence is at the end of the processing buffer;\n       if so, exclude those from processing (reduce delta to point at\n       end of processed region) */\n    if ( (xoff > 0) &&\n         ('%' == xbuf[xoff - 1]) )\n    {\n      cut = (xoff != XBUF_SIZE);\n      xoff--;\n      if (cut)\n      {\n        /* move escape sequence into buffer for next function invocation */\n        pp->xbuf[0] = '%';\n        pp->xbuf_pos = 1;\n      }\n      else\n      {\n        /* just skip escape sequence for next loop iteration */\n        delta = xoff;\n        clen = 1;\n      }\n    }\n    else if ( (xoff > 1) &&\n              ('%' == xbuf[xoff - 2]) )\n    {\n      cut = (xoff != XBUF_SIZE);\n      xoff -= 2;\n      if (cut)\n      {\n        /* move escape sequence into buffer for next function invocation */\n        memcpy (pp->xbuf,\n                &xbuf[xoff],\n                2);\n        pp->xbuf_pos = 2;\n      }\n      else\n      {\n        /* just skip escape sequence for next loop iteration */\n        delta = xoff;\n        clen = 2;\n      }\n    }\n    mhd_assert (xoff < sizeof (xbuf));\n    /* unescape */\n    xbuf[xoff] = '\\0';        /* 0-terminate in preparation */\n    if (0 != xoff)\n    {\n      MHD_unescape_plus (xbuf);\n      xoff = MHD_http_unescape (xbuf);\n    }\n    /* finally: call application! */\n    if (pp->must_ikvi || (0 != xoff) )\n    {\n      pp->must_ikvi = false;\n      if (MHD_NO == pp->ikvi (pp->cls,\n                              MHD_POSTDATA_KIND,\n                              (const char *) &pp[1],      /* key */\n                              NULL,\n                              NULL,\n                              NULL,\n                              xbuf,\n                              pp->value_offset,\n                              xoff))\n      {\n        pp->state = PP_Error;\n        return;\n      }\n    }\n    pp->value_offset += xoff;\n    if (cut)\n      break;\n    if (0 != clen)\n    {\n      xbuf[delta] = '%';        /* undo 0-termination */\n      memmove (xbuf,\n               &xbuf[delta],\n               clen);\n    }\n    xoff = clen;\n  }\n}\n```\n</target_code>\n<response format>\nProvide your answer with these fields.\n- explanation: your evaluation of the scenario provided by the agent A.\n- is_report_correct: whether the report is correct or not (true/false). True means there is a violation.\n</response format>\n<scenario>\nThe agent A provided the following violation scenario:\nThe assignment 'value_end = last_escape;' in the shown fragment modifies the pointer parameter 'value_end'. MISRA C 2023 Rule 17.8 prohibits modifying function parameter pointers themselves (the object they point to may be changed, but not the pointer). Thus this line violates Rule 17.8. (As a note, elsewhere in the function 'value_start += delta;' also modifies a pointer parameter and would likewise violate the rule.)\n</scenario>\n\n<execution_log>\nThe agent A also provided the following output log:\nprocess_value ENTER: pp=0x556741f233e0, value_start=0x55671ee9d02b, value_end=0x55671ee9d02f, last_escape=(nil), pp->xbuf_pos=0, pp->value_offset=0\nLoop iter=1 start: value_start=0x55671ee9d02b, value_end=0x55671ee9d02f, delta=4, xoff=0, must_ikvi=1\nAbout to memcpy 4 bytes from value_start=0x55671ee9d02b to &xbuf[0]; xoff=0\nBefore advancing value_start: value_start=0x55671ee9d02b, delta=4\nAfter advancing value_start: value_start=0x55671ee9d02f, value_end=0x55671ee9d02f, delta=4, xoff=4\nLoop iter=1 end: value_start=0x55671ee9d02f, value_end=0x55671ee9d02f, xoff=0, pp->value_offset=4\nprocess_value EXIT: pp=0x556741f233e0, final value_start=0x55671ee9d02f, value_end=0x55671ee9d02f, last_escape=(nil), pp->xbuf_pos=0, pp->value_offset=4\nprocess_value ENTER: pp=0x556741f233e0, value_start=0x55671ee9d036, value_end=0x55671ee9d03a, last_escape=(nil), pp->xbuf_pos=0, pp->value_offset=0\nLoop iter=2 start: value_start=0x55671ee9d036, value_end=0x55671ee9d03a, delta=4, xoff=0, must_ikvi=1\nAbout to memcpy 4 bytes from value_start=0x55671ee9d036 to &xbuf[0]; xoff=0\nBefore advancing value_start: value_start=0x55671ee9d036, delta=4\nAfter advancing value_start: value_start=0x55671ee9d03a, value_end=0x55671ee9d03a, delta=4, xoff=4\nLoop iter=2 end: value_start=0x55671ee9d03a, value_end=0x55671ee9d03a, xoff=0, pp->value_offset=4\nprocess_value EXIT: pp=0x556741f233e0, final value_start=0x55671ee9d03a, value_end=0x55671ee9d03a, last_escape=(nil), pp->xbuf_pos=0, pp->value_offset=4\nprocess_value ENTER: pp=0x556741f233e0, value_start=0x55671ee9d040, value_end=0x55671ee9d040, last_escape=(nil), pp->xbuf_pos=0, pp->value_offset=0\nLoop iter=3 start: value_start=0x55671ee9d040, value_end=0x55671ee9d040, delta=0, xoff=0, must_ikvi=1\nLoop iter=3 end: value_start=0x55671ee9d040, value_end=0x55671ee9d040, xoff=0, pp->value_offset=0\nprocess_value EXIT: pp=0x556741f233e0, final value_start=0x55671ee9d040, value_end=0x55671ee9d040, last_escape=(nil), pp->xbuf_pos=0, pp->value_offset=0\nprocess_value ENTER: pp=0x556741f233e0, value_start=0x55671eea509c, value_end=0x55671eea509c, last_escape=(nil), pp->xbuf_pos=0, pp->value_offset=0\nLoop iter=4 start: value_start=0x55671eea509c, value_end=0x55671eea509c, delta=0, xoff=0, must_ikvi=1\nLoop iter=4 end: value_start=0x55671eea509c, value_end=0x55671eea509c, xoff=0, pp->value_offset=0\nprocess_value EXIT: pp=0x556741f233e0, final value_start=0x55671eea509c, value_end=0x55671eea509c, last_escape=(nil), pp->xbuf_pos=0, pp->value_offset=0\nprocess_value ENTER: pp=0x556741f233e0, value_start=0x55671ee9d04c, value_end=0x55671ee9d052, last_escape=0x55671ee9d050, pp->xbuf_pos=0, pp->value_offset=0\nLoop iter=5 start: value_start=0x55671ee9d04c, value_end=0x55671ee9d052, delta=6, xoff=0, must_ikvi=1\nAbout to memcpy 6 bytes from value_start=0x55671ee9d04c to &xbuf[0]; xoff=0\nBefore advancing value_start: value_start=0x55671ee9d04c, delta=6\nAfter advancing value_start: value_start=0x55671ee9d052, value_end=0x55671ee9d052, delta=6, xoff=6\nEscaped-penultimate: cut=1, xoff=4, clen=0, pp->xbuf_pos=2\nBreaking loop due to cut=true at iter=5, pp->value_offset=4\nprocess_value EXIT: pp=0x556741f233e0, final value_start=0x55671ee9d052, value_end=0x55671ee9d052, last_escape=0x55671ee9d050, pp->xbuf_pos=2, pp->value_offset=4\nprocess_value ENTER: pp=0x556741f233e0, value_start=0x55671ee9d053, value_end=0x55671ee9d059, last_escape=(nil), pp->xbuf_pos=2, pp->value_offset=4\nLoop iter=6 start: value_start=0x55671ee9d053, value_end=0x55671ee9d059, delta=6, xoff=2, must_ikvi=0\nAbout to memcpy 6 bytes from value_start=0x55671ee9d053 to &xbuf[2]; xoff=2\nBefore advancing value_start: value_start=0x55671ee9d053, delta=6\nAfter advancing value_start: value_start=0x55671ee9d059, value_end=0x55671ee9d059, delta=6, xoff=8\nLoop iter=6 end: value_start=0x55671ee9d059, value_end=0x55671ee9d059, xoff=0, pp->value_offset=10\nprocess_value EXIT: pp=0x556741f233e0, final value_start=0x55671ee9d059, value_end=0x55671ee9d059, last_escape=(nil), pp->xbuf_pos=0, pp->value_offset=10\nprocess_value ENTER: pp=0x556741f233e0, value_start=0x55671ee9d05c, value_end=0x55671\n</execution_log>\n\n<instruction>\nJudge whether the report is correct or not.\n</instruction>\n",
  "is_report_correct": true,
  "explanation": "Agent A is correct. MISRA C 2023 Rule 17.8 states that a function parameter shall not be modified; while the object referred to by a pointer parameter may be modified, the pointer itself shall not be changed. In the shown function the pointer parameters are reassigned/advanced: value_end is assigned in \"value_end = last_escape;\" and value_start is advanced with \"value_start += delta;\" (and generally value_start/value_end are used as loop-modified cursors). These statements modify the pointer parameters themselves and therefore violate Rule 17.8. To comply, the code should copy these pointer parameters into local non-parameter variables and modify those instead."
}