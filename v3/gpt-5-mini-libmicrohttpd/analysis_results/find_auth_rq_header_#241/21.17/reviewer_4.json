{
  "user_message": "An agent A claimed that the following find_auth_rq_header_ code violates the MISRA C 2023 rule 21.17.\n<misra_rule>\nMISRA C 2023 Rule 21.17 is Use of the string handling functions from <string.h> shall not result in accesses beyond the bounds of the objects referenced by their pointer parameters.\nThis rule strictly applies to the Standard Library functions in <string.h> such as memcpy, memmove, memset, memcmp, strcpy, strncpy, strcat, strncat, strlen, and strspn.\n</misra_rule>\n<target_code>\nHere is the original code of find_auth_rq_header_.\n```c\nstatic bool\nfind_auth_rq_header_ (const struct MHD_Connection *c, enum MHD_AuthType type,\n                      struct _MHD_str_w_len *auth_value)\n{\n  const struct MHD_HTTP_Req_Header *h;\n  const char *token;\n  size_t token_len;\n\n  mhd_assert (MHD_CONNECTION_HEADERS_PROCESSED <= c->state);\n  if (MHD_CONNECTION_HEADERS_PROCESSED > c->state)\n    return false;\n\n#ifdef DAUTH_SUPPORT\n  if (MHD_AUTHTYPE_DIGEST == type)\n  {\n    token = _MHD_AUTH_DIGEST_BASE;\n    token_len = MHD_STATICSTR_LEN_ (_MHD_AUTH_DIGEST_BASE);\n  }\n  else /* combined with the next line */\n#endif /* DAUTH_SUPPORT */\n#ifdef BAUTH_SUPPORT\n  if (MHD_AUTHTYPE_BASIC == type)\n  {\n    token = _MHD_AUTH_BASIC_BASE;\n    token_len = MHD_STATICSTR_LEN_ (_MHD_AUTH_BASIC_BASE);\n  }\n  else /* combined with the next line */\n#endif /* BAUTH_SUPPORT */\n  {\n    mhd_assert (0);\n    return false;\n  }\n\n  for (h = c->rq.headers_received; NULL != h; h = h->next)\n  {\n    if (MHD_HEADER_KIND != h->kind)\n      continue;\n    if (MHD_STATICSTR_LEN_ (MHD_HTTP_HEADER_AUTHORIZATION) != h->header_size)\n      continue;\n    if (token_len > h->value_size)\n      continue;\n    if (! MHD_str_equal_caseless_bin_n_ (MHD_HTTP_HEADER_AUTHORIZATION,\n                                         h->header,\n                                         MHD_STATICSTR_LEN_ ( \\\n                                           MHD_HTTP_HEADER_AUTHORIZATION)))\n      continue;\n    if (! MHD_str_equal_caseless_bin_n_ (h->value, token, token_len))\n      continue;\n    /* Match only if token string is full header value or token is\n     * followed by space or tab\n     * Note: RFC 9110 (and RFC 7234) allows only space character, but\n     * tab is supported here as well for additional flexibility and uniformity\n     * as tabs are supported as separators between parameters.\n     */\n    if ((token_len == h->value_size) ||\n        (' ' == h->value[token_len]) || ('\\t'  == h->value[token_len]))\n    {\n      if (token_len != h->value_size)\n      { /* Skip whitespace */\n        auth_value->str = h->value + token_len + 1;\n        auth_value->len = h->value_size - (token_len + 1);\n      }\n      else\n      { /* No whitespace to skip */\n        auth_value->str = h->value + token_len;\n        auth_value->len = h->value_size - token_len;\n      }\n      return true; /* Found a match */\n    }\n  }\n  return false; /* No matching header has been found */\n}\n```\n</target_code>\n<response format>\nProvide your answer with these fields.\n- explanation: your evaluation of the scenario provided by the agent A.\n- is_report_correct: whether the report is correct or not (true/false). True means there is a violation.\n</response format>\n<scenario>\nThe agent A provided the following violation scenario:\nIf token_len == h->value_size - 1 and the character at h->value[token_len] is a space or tab, the code sets auth_value->str = h->value + token_len + 1 which equals h->value + h->value_size (a pointer one past the end) and auth_value->len = 0. If that pointer is later passed to a <string.h> function that reads the string data (for example strlen(auth_value->str), strcpy, strcat, or any function that expects a NUL-terminated buffer or a non\u2011zero length), the function will attempt to access memory past the end of h->value, causing an out\u2011of\u2011bounds access and violating MISRA C 2023 Rule 21.17. Note: the code\u2019s immediate indexing of h->value[token_len] is safe because an earlier check and short\u2011circuit evaluation guarantee token_len < h->value_size when that access occurs, but the produced one\u2011past\u2011end pointer + zero length can lead to a later string.h call reading out of bounds.\n</scenario>\n\n<instruction>\nJudge whether the report is correct or not.\n</instruction>\n",
  "is_report_correct": false,
  "explanation": "The report is not correct. The code in find_auth_rq_header_ does not itself call any <string.h> functions and therefore cannot by itself violate MISRA C:2023 Rule 21.17 (which constrains uses of the string.h functions so they do not access out\u2011of\u2011bounds memory). The scenario described (auth_value->str = h->value + h->value_size and auth_value->len = 0) is possible when the token is the last character before the end and a single space/tab follows; forming a pointer one past the end of an object is defined by the C language as allowed so long as it is not dereferenced. The code also already ensures the character access h->value[token_len] is safe: the conditional uses (token_len == h->value_size) || (' ' == h->value[token_len]) || ... and the left\u2011to\u2011right short\u2011circuiting of || guarantees the indexing only occurs when token_len < h->value_size. A real Rule 21.17 violation would occur only if a <string.h> function (e.g. strlen, strcpy, etc.) were later called with auth_value->str such that the function attempted to read through that one\u2011past\u2011end pointer. That would be a misuse at the call site, not a direct violation by this function. If you want to avoid even the potential for misuses by callers, change the API/contract (e.g. set auth_value->str to NULL or to a pointer to a small static empty string when len==0, or ensure all callers always use the provided length and never call string.h functions on the returned pointer)."
}