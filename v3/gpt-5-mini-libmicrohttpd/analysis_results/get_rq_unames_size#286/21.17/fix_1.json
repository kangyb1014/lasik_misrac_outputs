{
  "user_message": "<target code>Here is the code that failed to compile:\n```c\n_MHD_static_inline size_t\nget_rq_unames_size (const struct MHD_RqDAuth *params,\n                    enum MHD_DigestAuthUsernameType uname_type)\n{\n  size_t s;\n\n  /* Helper probe: append a one-line log to /tmp/logs/2869.txt. Keep it small and safe. */\n  /* Note: this helper intentionally avoids changing computation semantics; it only observes values. */\n  {\n    FILE *f = fopen(\"/tmp/logs/2869.txt\", \"a\");\n    if (f)\n      {\n        fprintf(f, \"ENTRY: get_rq_unames_size called: uname_type=%d, get_rq_uname_type=%d, username.len=%zu, username_ext.len=%zu, MHD_DAUTH_EXT_PARAM_MIN_LEN=%zu\\n\",\n                (int) uname_type,\n                (int) get_rq_uname_type (params),\n                params->username.value.len,\n                params->username_ext.value.len,\n                (size_t) MHD_DAUTH_EXT_PARAM_MIN_LEN);\n        fclose(f);\n      }\n  }\n\n  mhd_assert (get_rq_uname_type (params) == uname_type);\n  s = 0;\n  if ((MHD_DIGEST_AUTH_UNAME_TYPE_STANDARD == uname_type) ||\n      (MHD_DIGEST_AUTH_UNAME_TYPE_USERHASH == uname_type) )\n  {\n    s += params->username.value.len + 1; /* Add one byte for zero-termination */\n    {\n      FILE *f = fopen(\"/tmp/logs/2869.txt\", \"a\");\n      if (f)\n        {\n          fprintf(f, \"BRANCH: standard/userhash selected: uname_type=%d, username.len=%zu, added=%zu, s_now=%zu\\n\",\n                  (int) uname_type,\n                  params->username.value.len,\n                  (size_t) (params->username.value.len + 1),\n                  s);\n          fclose(f);\n        }\n    }\n    if (MHD_DIGEST_AUTH_UNAME_TYPE_USERHASH == uname_type)\n      {\n        s += (params->username.value.len + 1) / 2;\n        {\n          FILE *f = fopen(\"/tmp/logs/2869.txt\", \"a\");\n          if (f)\n            {\n              fprintf(f, \"SUBBRANCH: userhash extra added=%zu, s_now=%zu\\n\",\n                      (size_t) ((params->username.value.len + 1) / 2),\n                      s);\n              fclose(f);\n            }\n        }\n      }\n  }\n  else if (MHD_DIGEST_AUTH_UNAME_TYPE_EXTENDED == uname_type)\n    {\n      /* Log values before subtraction to capture potential underflow scenario. */\n      size_t len_ext = params->username_ext.value.len;\n      size_t min_len = (size_t) MHD_DAUTH_EXT_PARAM_MIN_LEN;\n\n      {\n        FILE *f = fopen(\"/tmp/logs/2869.txt\", \"a\");\n        if (f)\n          {\n            fprintf(f, \"BRANCH: extended selected: username_ext.len=%zu, MHD_DAUTH_EXT_PARAM_MIN_LEN=%zu\\n\",\n                    len_ext, min_len);\n            /* Detect and log if an underflow will occur (len_ext < min_len). This does not change behavior. */\n            if (len_ext < min_len)\n              fprintf(f, \"ALERT: potential underflow: username_ext.len (%zu) < MHD_DAUTH_EXT_PARAM_MIN_LEN (%zu)\\n\",\n                      len_ext, min_len);\n            fclose(f);\n          }\n      }\n\n      /* Preserve original arithmetic exactly as in the target code. */\n      s += params->username_ext.value.len\n           - MHD_DAUTH_EXT_PARAM_MIN_LEN + 1; /* Add one byte for zero-termination */\n\n      /* Log the result of the computation (this will show the wrapped value if underflow occurred). */\n      {\n        FILE *f = fopen(\"/tmp/logs/2869.txt\", \"a\");\n        if (f)\n          {\n            fprintf(f, \"AFTER: extended computation: computed_add=%zu, s_now=%zu\\n\",\n                    (size_t) (params->username_ext.value.len - MHD_DAUTH_EXT_PARAM_MIN_LEN + 1),\n                    s);\n            fclose(f);\n          }\n      }\n    }\n\n  /* Final value log */\n  {\n    FILE *f = fopen(\"/tmp/logs/2869.txt\", \"a\");\n    if (f)\n      {\n        fprintf(f, \"EXIT: get_rq_unames_size returning s=%zu\\n\", s);\n        fclose(f);\n      }\n  }\n\n  return s;\n}\n\n```\n</target code>\n<build error>\nThe build failed with the following error:\n```\nFailed to parse the test code.\n```\n</build error>\n<response format>\nProvide your answer with these answers.\n- fixed_test_code: the fixed test code that compiles successfully.\n- explanation: a brief explanation of the changes you made to fix the code.\nHere are the constraints for the test code:\n- The test code MUST be compilable and executable.\n- The test code MUST include line breaks.\n- The test code MUST preserve the original logic of get_rq_unames_size as much as possible.\n- You MUST not define the main function.\n- You MUST not define macros.\n- The test code MUST not contain any mock functions.\n</response format>\n<instruction>\nPlease fix the code so that it compiles successfully.\n</instruction>\n",
  "fixed_test_code": "#include <stdio.h>\n#include <stddef.h>\n\n/* Minimal supporting types and constants so this translation unit compiles. */\n\nenum MHD_DigestAuthUsernameType {\n  MHD_DIGEST_AUTH_UNAME_TYPE_STANDARD = 0,\n  MHD_DIGEST_AUTH_UNAME_TYPE_USERHASH = 1,\n  MHD_DIGEST_AUTH_UNAME_TYPE_EXTENDED = 2\n};\n\nstatic const size_t MHD_DAUTH_EXT_PARAM_MIN_LEN = 2; /* keep a small example value */\n\nstruct MHD_Buf { size_t len; };\nstruct MHD_Field { struct MHD_Buf value; };\n\nstruct MHD_RqDAuth\n{\n  struct MHD_Field username;\n  struct MHD_Field username_ext;\n  enum MHD_DigestAuthUsernameType uname_type;\n};\n\n/* Helper functions used by get_rq_unames_size */\nstatic inline enum MHD_DigestAuthUsernameType\nget_rq_uname_type (const struct MHD_RqDAuth *params)\n{\n  return params->uname_type;\n}\n\nstatic inline void\nmhd_assert (int cond)\n{\n  /* In the original code this is an assert; preserve behavior by discarding in release.\n     Keep it present so calling code remains unchanged. */\n  (void) cond;\n}\n\nstatic inline size_t\nget_rq_unames_size (const struct MHD_RqDAuth *params,\n                    enum MHD_DigestAuthUsernameType uname_type)\n{\n  size_t s;\n\n  /* Helper probe: append a one-line log to /tmp/logs/2869.txt. Keep it small and safe. */\n  /* Note: this helper intentionally avoids changing computation semantics; it only observes values. */\n  {\n    FILE *f = fopen(\"/tmp/logs/2869.txt\", \"a\");\n    if (f)\n      {\n        fprintf(f, \"ENTRY: get_rq_unames_size called: uname_type=%d, get_rq_uname_type=%d, username.len=%zu, username_ext.len=%zu, MHD_DAUTH_EXT_PARAM_MIN_LEN=%zu\\n\",\n                (int) uname_type,\n                (int) get_rq_uname_type (params),\n                params->username.value.len,\n                params->username_ext.value.len,\n                (size_t) MHD_DAUTH_EXT_PARAM_MIN_LEN);\n        fclose(f);\n      }\n  }\n\n  mhd_assert (get_rq_uname_type (params) == uname_type);\n  s = 0;\n  if ((MHD_DIGEST_AUTH_UNAME_TYPE_STANDARD == uname_type) ||\n      (MHD_DIGEST_AUTH_UNAME_TYPE_USERHASH == uname_type) )\n  {\n    s += params->username.value.len + 1; /* Add one byte for zero-termination */\n    {\n      FILE *f = fopen(\"/tmp/logs/2869.txt\", \"a\");\n      if (f)\n        {\n          fprintf(f, \"BRANCH: standard/userhash selected: uname_type=%d, username.len=%zu, added=%zu, s_now=%zu\\n\",\n                  (int) uname_type,\n                  params->username.value.len,\n                  (size_t) (params->username.value.len + 1),\n                  s);\n          fclose(f);\n        }\n    }\n    if (MHD_DIGEST_AUTH_UNAME_TYPE_USERHASH == uname_type)\n      {\n        s += (params->username.value.len + 1) / 2;\n        {\n          FILE *f = fopen(\"/tmp/logs/2869.txt\", \"a\");\n          if (f)\n            {\n              fprintf(f, \"SUBBRANCH: userhash extra added=%zu, s_now=%zu\\n\",\n                      (size_t) ((params->username.value.len + 1) / 2),\n                      s);\n              fclose(f);\n            }\n        }\n      }\n  }\n  else if (MHD_DIGEST_AUTH_UNAME_TYPE_EXTENDED == uname_type)\n    {\n      /* Log values before subtraction to capture potential underflow scenario. */\n      size_t len_ext = params->username_ext.value.len;\n      size_t min_len = (size_t) MHD_DAUTH_EXT_PARAM_MIN_LEN;\n\n      {\n        FILE *f = fopen(\"/tmp/logs/2869.txt\", \"a\");\n        if (f)\n          {\n            fprintf(f, \"BRANCH: extended selected: username_ext.len=%zu, MHD_DAUTH_EXT_PARAM_MIN_LEN=%zu\\n\",\n                    len_ext, min_len);\n            /* Detect and log if an underflow will occur (len_ext < min_len). This does not change behavior. */\n            if (len_ext < min_len)\n              fprintf(f, \"ALERT: potential underflow: username_ext.len (%zu) < MHD_DAUTH_EXT_PARAM_MIN_LEN (%zu)\\n\",\n                      len_ext, min_len);\n            fclose(f);\n          }\n      }\n\n      /* Preserve original arithmetic exactly as in the target code. */\n      s += params->username_ext.value.len\n           - MHD_DAUTH_EXT_PARAM_MIN_LEN + 1; /* Add one byte for zero-termination */\n\n      /* Log the result of the computation (this will show the wrapped value if underflow occurred). */\n      {\n        FILE *f = fopen(\"/tmp/logs/2869.txt\", \"a\");\n        if (f)\n          {\n            fprintf(f, \"AFTER: extended computation: computed_add=%zu, s_now=%zu\\n\",\n                    (size_t) (params->username_ext.value.len - MHD_DAUTH_EXT_PARAM_MIN_LEN + 1),\n                    s);\n            fclose(f);\n          }\n      }\n    }\n\n  /* Final value log */\n  {\n    FILE *f = fopen(\"/tmp/logs/2869.txt\", \"a\");\n    if (f)\n      {\n        fprintf(f, \"EXIT: get_rq_unames_size returning s=%zu\\n\", s);\n        fclose(f);\n      }\n  }\n\n  return s;\n}\n",
  "explanation": "Fixes made to allow compilation:\n- Replaced the unknown identifier _MHD_static_inline with standard C \"static inline\" for the function definition.\n- Added necessary includes (<stdio.h>, <stddef.h>).\n- Provided minimal definitions for the used enum, constants, and struct layout (MHD_DigestAuthUsernameType, MHD_DAUTH_EXT_PARAM_MIN_LEN, MHD_RqDAuth and nested fields) so the function can be compiled in isolation while preserving original field accesses.\n- Implemented small inline helper functions get_rq_uname_type and mhd_assert to match the original uses; these are simple and preserve the original logic of get_rq_unames_size.\n\nNo macros were introduced and the core logic and logging of get_rq_unames_size were preserved as closely as possible."
}