{
  "user_message": "An agent A claimed that the following get_rq_unames_size code violates the MISRA C 2023 rule 21.17.\n<misra_rule>\nMISRA C 2023 Rule 21.17 is Use of the string handling functions from <string.h> shall not result in accesses beyond the bounds of the objects referenced by their pointer parameters.\nThis rule strictly applies to the Standard Library functions in <string.h> such as memcpy, memmove, memset, memcmp, strcpy, strncpy, strcat, strncat, strlen, and strspn.\n</misra_rule>\n<target_code>\nHere is the original code of get_rq_unames_size.\n```c\n_MHD_static_inline size_t\nget_rq_unames_size (const struct MHD_RqDAuth *params,\n                    enum MHD_DigestAuthUsernameType uname_type)\n{\n  size_t s;\n\n  mhd_assert (get_rq_uname_type (params) == uname_type);\n  s = 0;\n  if ((MHD_DIGEST_AUTH_UNAME_TYPE_STANDARD == uname_type) ||\n      (MHD_DIGEST_AUTH_UNAME_TYPE_USERHASH == uname_type) )\n  {\n    s += params->username.value.len + 1; /* Add one byte for zero-termination */\n    if (MHD_DIGEST_AUTH_UNAME_TYPE_USERHASH == uname_type)\n      s += (params->username.value.len + 1) / 2;\n  }\n  else if (MHD_DIGEST_AUTH_UNAME_TYPE_EXTENDED == uname_type)\n    s += params->username_ext.value.len\n         - MHD_DAUTH_EXT_PARAM_MIN_LEN + 1; /* Add one byte for zero-termination */\n  return s;\n}\n```\n</target_code>\n<response format>\nProvide your answer with these fields.\n- explanation: your evaluation of the scenario provided by the agent A.\n- is_report_correct: whether the report is correct or not (true/false). True means there is a violation.\n</response format>\n<scenario>\nThe agent A provided the following violation scenario:\nYes. If params->username_ext.value.len is less than MHD_DAUTH_EXT_PARAM_MIN_LEN the subtraction performs unsigned wrap-around (size_t underflow) producing a very large s. If that s is later used as a length/count for a string.h function (e.g. memcpy, strlen, strncpy, strcpy, strcat, etc.) or for an allocation, the subsequent string handling will access beyond the bounds of the referenced objects. Example: value.len = 5, MHD_DAUTH_EXT_PARAM_MIN_LEN = 8 -> computed s = (size_t)5 - 8 + 1 => wrap to a large value, and passing that to memcpy/strncpy would violate Rule 21.17.\n</scenario>\n\n<instruction>\nJudge whether the report is correct or not.\n</instruction>\n",
  "is_report_correct": false,
  "explanation": "The report is not correct as a direct violation of MISRA C 2023 Rule 21.17. Rule 21.17 concerns uses of the string.h functions that can cause out\u2011of\u2011bounds accesses. The function shown (get_rq_unames_size) does not call any string.h routines itself \u2014 it only computes a size value. Therefore this function by itself does not violate 21.17. That said, the agent A\u2019s scenario identifies a real defect: the expression params->username_ext.value.len - MHD_DAUTH_EXT_PARAM_MIN_LEN can underflow (size_t wraparound) if the length is smaller than the minimum, producing a very large s. If that computed s is later passed unchecked as a length/count to a string.h function or to an allocation, that later use could indeed produce an out\u2011of\u2011bounds access and thus violate Rule 21.17. In short: the claim that get_rq_unames_size itself violates 21.17 is incorrect, but the function contains an unsigned underflow risk that must be fixed to prevent subsequent 21.17 violations."
}