{
  "user_message": "<misra_rule>\nMISRA C 2023 Rule 21.17 is: Use of the string handling functions from <string.h> shall not result in accesses beyond the bounds of the objects referenced by their pointer parameters.\nThis rule strictly applies to the Standard Library functions in <string.h> such as memcpy, memmove, memset, memcmp, strcpy, strncpy, strcat, strncat, strlen, and strspn.\n</misra_rule>\n\nAnother agent reported that the target code violated the Rule 21.17.\nHere is the comment from the agent.\n<violation scenario>\nYes. If params->username_ext.value.len is less than MHD_DAUTH_EXT_PARAM_MIN_LEN the subtraction performs unsigned wrap-around (size_t underflow) producing a very large s. If that s is later used as a length/count for a string.h function (e.g. memcpy, strlen, strncpy, strcpy, strcat, etc.) or for an allocation, the subsequent string handling will access beyond the bounds of the referenced objects. Example: value.len = 5, MHD_DAUTH_EXT_PARAM_MIN_LEN = 8 -> computed s = (size_t)5 - 8 + 1 => wrap to a large value, and passing that to memcpy/strncpy would violate Rule 21.17.\n</violation scenario>\n\nYour job is to insert logging code to capture the control flow and state information of the program.\nInsert logging code so that other agents can reproduce and get evidence for the violation scenario.\n<response format>\n- test_code: a modified get_rq_unames_size code that contains useful probe functions that print useful logs to a file \"/tmp/logs/2869.txt\". The logs should contain the control path and state information of the violation scenario. If test code is not required to validate the scenario, you can leave this blank.\nHere are the constraints for the test code:\n- The test code MUST preserve the original logic of get_rq_unames_size as much as possible.\nYou CAN just insert probe functions to the original code.\n- DO NOT introduce new violations to demonstrate your scenario.\n- The test code MUST be compilable and executable.\n- The test code MUST include line breaks.\n- You MUST NOT define the main function.\n- You MUST NOT define macros.\n</response format>\n<target_code>\nHere is the code of get_rq_unames_size:\n```c\n_MHD_static_inline size_t\nget_rq_unames_size (const struct MHD_RqDAuth *params,\n                    enum MHD_DigestAuthUsernameType uname_type)\n{\n  size_t s;\n\n  mhd_assert (get_rq_uname_type (params) == uname_type);\n  s = 0;\n  if ((MHD_DIGEST_AUTH_UNAME_TYPE_STANDARD == uname_type) ||\n      (MHD_DIGEST_AUTH_UNAME_TYPE_USERHASH == uname_type) )\n  {\n    s += params->username.value.len + 1; /* Add one byte for zero-termination */\n    if (MHD_DIGEST_AUTH_UNAME_TYPE_USERHASH == uname_type)\n      s += (params->username.value.len + 1) / 2;\n  }\n  else if (MHD_DIGEST_AUTH_UNAME_TYPE_EXTENDED == uname_type)\n    s += params->username_ext.value.len\n         - MHD_DAUTH_EXT_PARAM_MIN_LEN + 1; /* Add one byte for zero-termination */\n  return s;\n}\n```\n</target_code>\nPlease provide the modified get_rq_unames_size code.\n",
  "test_code": "_MHD_static_inline size_t\nget_rq_unames_size (const struct MHD_RqDAuth *params,\n                    enum MHD_DigestAuthUsernameType uname_type)\n{\n  size_t s;\n\n  /* Helper probe: append a one-line log to /tmp/logs/2869.txt. Keep it small and safe. */\n  /* Note: this helper intentionally avoids changing computation semantics; it only observes values. */\n  {\n    FILE *f = fopen(\"/tmp/logs/2869.txt\", \"a\");\n    if (f)\n      {\n        fprintf(f, \"ENTRY: get_rq_unames_size called: uname_type=%d, get_rq_uname_type=%d, username.len=%zu, username_ext.len=%zu, MHD_DAUTH_EXT_PARAM_MIN_LEN=%zu\\n\",\n                (int) uname_type,\n                (int) get_rq_uname_type (params),\n                params->username.value.len,\n                params->username_ext.value.len,\n                (size_t) MHD_DAUTH_EXT_PARAM_MIN_LEN);\n        fclose(f);\n      }\n  }\n\n  mhd_assert (get_rq_uname_type (params) == uname_type);\n  s = 0;\n  if ((MHD_DIGEST_AUTH_UNAME_TYPE_STANDARD == uname_type) ||\n      (MHD_DIGEST_AUTH_UNAME_TYPE_USERHASH == uname_type) )\n  {\n    s += params->username.value.len + 1; /* Add one byte for zero-termination */\n    {\n      FILE *f = fopen(\"/tmp/logs/2869.txt\", \"a\");\n      if (f)\n        {\n          fprintf(f, \"BRANCH: standard/userhash selected: uname_type=%d, username.len=%zu, added=%zu, s_now=%zu\\n\",\n                  (int) uname_type,\n                  params->username.value.len,\n                  (size_t) (params->username.value.len + 1),\n                  s);\n          fclose(f);\n        }\n    }\n    if (MHD_DIGEST_AUTH_UNAME_TYPE_USERHASH == uname_type)\n      {\n        s += (params->username.value.len + 1) / 2;\n        {\n          FILE *f = fopen(\"/tmp/logs/2869.txt\", \"a\");\n          if (f)\n            {\n              fprintf(f, \"SUBBRANCH: userhash extra added=%zu, s_now=%zu\\n\",\n                      (size_t) ((params->username.value.len + 1) / 2),\n                      s);\n              fclose(f);\n            }\n        }\n      }\n  }\n  else if (MHD_DIGEST_AUTH_UNAME_TYPE_EXTENDED == uname_type)\n    {\n      /* Log values before subtraction to capture potential underflow scenario. */\n      size_t len_ext = params->username_ext.value.len;\n      size_t min_len = (size_t) MHD_DAUTH_EXT_PARAM_MIN_LEN;\n\n      {\n        FILE *f = fopen(\"/tmp/logs/2869.txt\", \"a\");\n        if (f)\n          {\n            fprintf(f, \"BRANCH: extended selected: username_ext.len=%zu, MHD_DAUTH_EXT_PARAM_MIN_LEN=%zu\\n\",\n                    len_ext, min_len);\n            /* Detect and log if an underflow will occur (len_ext < min_len). This does not change behavior. */\n            if (len_ext < min_len)\n              fprintf(f, \"ALERT: potential underflow: username_ext.len (%zu) < MHD_DAUTH_EXT_PARAM_MIN_LEN (%zu)\\n\",\n                      len_ext, min_len);\n            fclose(f);\n          }\n      }\n\n      /* Preserve original arithmetic exactly as in the target code. */\n      s += params->username_ext.value.len\n           - MHD_DAUTH_EXT_PARAM_MIN_LEN + 1; /* Add one byte for zero-termination */\n\n      /* Log the result of the computation (this will show the wrapped value if underflow occurred). */\n      {\n        FILE *f = fopen(\"/tmp/logs/2869.txt\", \"a\");\n        if (f)\n          {\n            fprintf(f, \"AFTER: extended computation: computed_add=%zu, s_now=%zu\\n\",\n                    (size_t) (params->username_ext.value.len - MHD_DAUTH_EXT_PARAM_MIN_LEN + 1),\n                    s);\n            fclose(f);\n          }\n      }\n    }\n\n  /* Final value log */\n  {\n    FILE *f = fopen(\"/tmp/logs/2869.txt\", \"a\");\n    if (f)\n      {\n        fprintf(f, \"EXIT: get_rq_unames_size returning s=%zu\\n\", s);\n        fclose(f);\n      }\n  }\n\n  return s;\n}\n"
}