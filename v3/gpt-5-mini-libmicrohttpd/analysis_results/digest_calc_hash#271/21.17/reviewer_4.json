{
  "user_message": "An agent A claimed that the following digest_calc_hash code violates the MISRA C 2023 rule 21.17.\n<misra_rule>\nMISRA C 2023 Rule 21.17 is Use of the string handling functions from <string.h> shall not result in accesses beyond the bounds of the objects referenced by their pointer parameters.\nThis rule strictly applies to the Standard Library functions in <string.h> such as memcpy, memmove, memset, memcmp, strcpy, strncpy, strcat, strncat, strlen, and strspn.\n</misra_rule>\n<target_code>\nHere is the original code of digest_calc_hash.\n```c\n_MHD_static_inline void\ndigest_calc_hash (struct DigestAlgorithm *da, uint8_t *digest)\n{\n  mhd_assert (! da->uninitialised);\n  mhd_assert (da->algo_selected);\n  mhd_assert (da->ready_for_hashing);\n#ifdef MHD_MD5_SUPPORT\n  if (MHD_DIGEST_BASE_ALGO_MD5 == da->algo)\n  {\n#ifdef MHD_MD5_HAS_FINISH\n    MHD_MD5_finish (&da->ctx.md5_ctx, digest);\n#ifdef _DEBUG\n    da->ready_for_hashing = false;\n#endif /* _DEBUG */\n#else  /* ! MHD_MD5_HAS_FINISH */\n    MHD_MD5_finish_reset (&da->ctx.md5_ctx, digest);\n#ifdef _DEBUG\n    da->ready_for_hashing = true;\n#endif /* _DEBUG */\n#endif /* ! MHD_MD5_HAS_FINISH */\n  }\n  else\n#endif /* MHD_MD5_SUPPORT */\n#ifdef MHD_SHA256_SUPPORT\n  if (MHD_DIGEST_BASE_ALGO_SHA256 == da->algo)\n  {\n#ifdef MHD_SHA256_HAS_FINISH\n    MHD_SHA256_finish (&da->ctx.sha256_ctx, digest);\n#ifdef _DEBUG\n    da->ready_for_hashing = false;\n#endif /* _DEBUG */\n#else  /* ! MHD_SHA256_HAS_FINISH */\n    MHD_SHA256_finish_reset (&da->ctx.sha256_ctx, digest);\n#ifdef _DEBUG\n    da->ready_for_hashing = true;\n#endif /* _DEBUG */\n#endif /* ! MHD_SHA256_HAS_FINISH */\n  }\n  else\n#endif /* MHD_SHA256_SUPPORT */\n#ifdef MHD_SHA512_256_SUPPORT\n  if (MHD_DIGEST_BASE_ALGO_SHA512_256 == da->algo)\n  {\n    MHD_SHA512_256_finish (&da->ctx.sha512_256_ctx, digest);\n#ifdef _DEBUG\n    da->ready_for_hashing = false;\n#endif /* _DEBUG */\n  }\n  else\n#endif /* MHD_SHA512_256_SUPPORT */\n  mhd_assert (0);   /* Should not happen */\n#ifdef _DEBUG\n  da->hashing = false;\n#endif /* _DEBUG */\n}\n```\n</target_code>\n<response format>\nProvide your answer with these fields.\n- explanation: your evaluation of the scenario provided by the agent A.\n- is_report_correct: whether the report is correct or not (true/false). True means there is a violation.\n</response format>\n<scenario>\nThe agent A provided the following violation scenario:\nThe call will violate Rule 21.17 if the pointer 'digest' does not reference an object large enough to receive the SHA-512/256 output (32 bytes). For example, if the caller passes uint8_t digest_buf[16]; and then calls digest_calc_hash(&da, digest_buf); the MHD_SHA512_256_finish implementation will write 32 bytes into digest_buf (likely via memcpy or similar), causing an out\u2011of\u2011bounds access.\n</scenario>\n\n<instruction>\nJudge whether the report is correct or not.\n</instruction>\n",
  "is_report_correct": false,
  "explanation": "MISRA C:2023 Rule 21.17 forbids uses of the <string.h> services that can result in accesses beyond the bounds of the objects referenced by pointer parameters. The shown function digest_calc_hash does not itself call any <string.h> functions, but it passes the digest pointer to algorithm-specific finish functions (e.g. MHD_SHA512_256_finish) that will write the algorithm\u2019s output into that buffer.\n\nSo the scenario described by agent A \u2014 a caller passing a too-small buffer (e.g. 16 bytes) while SHA-512/256 finish writes 32 bytes \u2014 would indeed cause an out-of-bounds write (typically via a memcpy inside the finish implementation) and thus violate 21.17. However, that violation is conditional: it arises only if the caller provides an undersized buffer or if the finish functions perform unchecked copies. From the excerpt alone you cannot prove a rule violation in digest_calc_hash itself because:\n- digest_calc_hash does not directly use any <string.h> functions; the potential unsafe operation is inside the finish implementations, or is due to a caller\u2019s misuse.\n- If the API contract guarantees the caller must supply a buffer of at least the maximum digest size (and that contract is enforced/documented), and the finish functions copy exactly that many bytes, the code is compliant.\n\nConclusion: Agent A\u2019s scenario correctly describes a possible 21.17 violation (an out-of-bounds write) if a too-small buffer is supplied or if the finish functions copy without checking sizes. But the provided digest_calc_hash snippet by itself does not prove a direct MISRA 21.17 violation \u2014 the problem is conditional on the finish implementations and/or the caller\u2019s behavior. Therefore the report, as stated, is not definitively correct for the shown code alone."
}