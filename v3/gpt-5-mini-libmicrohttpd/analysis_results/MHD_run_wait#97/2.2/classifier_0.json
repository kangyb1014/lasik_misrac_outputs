{
  "user_message": "<misra_rule>\nMISRA C 2023 Rule 2.2 is: A project shall not contain dead code.\nAny operation that is executed but whose removal would not affect program behaviour constitutes dead code. Notes:\n1. The behaviour of an embedded sytem is often determined not just by the nature of its actions, but also by the time at which they occur.\n2. unreachable code is not dead code, as it cannot be executed.\n3.Initialization is not the same as an assignment operation and is therfore not a candidate for dead code.\n</misra_rule>\n<response format>\nProvide your answer with these fields.\n- is_rule_violated: whether the rule is violated or not (true/false),\n- scenario: a specific violation scenario.\n</response format>\n<target_code>\nHere is the code of MHD_run_wait:\n```c\n_MHD_EXTERN enum MHD_Result\nMHD_run_wait (struct MHD_Daemon *daemon,\n              int32_t millisec)\n{\n  enum MHD_Result res;\n  if ( (daemon->shutdown) ||\n       MHD_D_IS_USING_THREADS_ (daemon) )\n    return MHD_NO;\n\n  mhd_assert (! MHD_thread_handle_ID_is_valid_handle_ (daemon->tid));\n\n  if (0 > millisec)\n    millisec = -1;\n#ifdef HAVE_POLL\n  if (MHD_D_IS_USING_POLL_ (daemon))\n  {\n    res = MHD_poll_all (daemon, millisec);\n    MHD_cleanup_connections (daemon);\n  }\n  else\n#endif /* HAVE_POLL */\n#ifdef EPOLL_SUPPORT\n  if (MHD_D_IS_USING_EPOLL_ (daemon))\n  {\n    res = MHD_epoll (daemon, millisec);\n    MHD_cleanup_connections (daemon);\n  }\n  else\n#endif\n  if (1)\n  {\n    mhd_assert (MHD_D_IS_USING_SELECT_ (daemon));\n#ifdef HAS_FD_SETSIZE_OVERRIDABLE\n#ifdef HAVE_MESSAGES\n    if (daemon->fdset_size_set_by_app\n        && (((int) FD_SETSIZE) < daemon->fdset_size))\n    {\n      MHD_DLOG (daemon,\n                _ (\"MHD_run()/MHD_run_wait() called for daemon started with \" \\\n                   \"MHD_OPTION_APP_FD_SETSIZE option (%d). \" \\\n                   \"The library was compiled with smaller FD_SETSIZE (%d). \" \\\n                   \"Some socket FDs may be not processed. \" \\\n                   \"Use MHD_run_from_select2() instead of MHD_run() or \" \\\n                   \"do not use MHD_OPTION_APP_FD_SETSIZE option.\\n\"),\n                daemon->fdset_size, (int) FD_SETSIZE);\n    }\n#endif /* HAVE_MESSAGES */\n#endif /* HAS_FD_SETSIZE_OVERRIDABLE */\n\n    res = MHD_select (daemon, millisec);\n    /* MHD_select does MHD_cleanup_connections already */\n  }\n  return res;\n}\n```\n</target_code>\n<target_code>\nHere is the code fragment that you need to analyze:\n```c\nmhd_assert (! MHD_thread_handle_ID_is_valid_handle_ (daemon->tid));\n```\nFocus on the above code fragment and judge whether it violates the rule 2.2 or not.\n</target_code>\n",
  "is_rule_violated": false,
  "scenario": "Not violated: mhd_assert is a diagnostic assertion macro that (when enabled) evaluates the predicate and may affect program behaviour (e.g. abort on failure). Because it can change behaviour when enabled, its presence is not dead code. To comply with MISRA Rule 2.2 ensure the asserted expression has no side effects. Violation scenario (if present): if mhd_assert is a no-op in all build configurations (the assertion is never executed) or the predicate has no side effects and the assertion is permanently compiled out, then the operation would be removable without affecting behaviour and would constitute dead code."
}