{
  "user_message": "An agent A claimed that the following MHD_get_response_header code violates the MISRA C 2023 rule 8.13.\n<misra_rule>\nMISRA C 2023 Rule 8.13 is A pointer should point to a const-qualified type whenever possible.\n\n</misra_rule>\n<target_code>\nHere is the original code of MHD_get_response_header.\n```c\n_MHD_EXTERN const char *\nMHD_get_response_header (struct MHD_Response *response,\n                         const char *key)\n{\n  struct MHD_HTTP_Res_Header *pos;\n  size_t key_size;\n\n  if (NULL == key)\n    return NULL;\n\n  key_size = strlen (key);\n  for (pos = response->first_header;\n       NULL != pos;\n       pos = pos->next)\n  {\n    if ((pos->header_size == key_size) &&\n        (MHD_str_equal_caseless_bin_n_ (pos->header, key, pos->header_size)))\n      return pos->value;\n  }\n  return NULL;\n}\n```\n</target_code>\n<response format>\nProvide your answer with these fields.\n- explanation: your evaluation of the scenario provided by the agent A.\n- is_report_correct: whether the report is correct or not (true/false). True means there is a violation.\n</response format>\n<scenario>\nThe agent A provided the following violation scenario:\nThe code fragment passes pos->header to a string-comparison function but treats the header only as read-only. If the member is declared as a non-const pointer (e.g. 'char *header' in struct MHD_HTTP_Res_Header) then Rule 8.13 is violated because the pointer should be declared to point to a const-qualified type (e.g. 'const char *header'). Also the comparison function should accept const char * parameters. If pos->header is already declared const, there is no violation.\n</scenario>\n\n<execution_log>\nThe agent A also provided the following output log:\nMHD_get_response_header: entry response=0x55738eb40820 key=0x55735b86c01f\nMHD_get_response_header: key=\"Header-Type-A\" key_size=13\niter: pos=0x55738eb40920 header=0x55738eb408e0 header_size=13 value=0x55738eb40900\nmatch: pos=0x55738eb40920 header=\"Header-Type-A\" header_size=13 -> returning value=0x55738eb40900\nMHD_get_response_header: entry response=0x55738eb40820 key=0x55735b86c01f\nMHD_get_response_header: key=\"Header-Type-A\" key_size=13\niter: pos=0x55738eb40920 header=0x55738eb408e0 header_size=13 value=0x55738eb40900\nmatch: pos=0x55738eb40920 header=\"Header-Type-A\" header_size=13 -> returning value=0x55738eb40900\nMHD_get_response_header: entry response=0x55738eb40820 key=0x55735b86c01f\nMHD_get_response_header: key=\"Header-Type-A\" key_size=13\niter: pos=0x55738eb40b80 header=0x55738eb40b40 header_size=13 value=0x55738eb40b60\nmatch: pos=0x55738eb40b80 header=\"Header-Type-A\" header_size=13 -> returning value=0x55738eb40b60\nMHD_get_response_header: entry response=0x55738eb40820 key=0x55735b86c01f\nMHD_get_response_header: key=\"Header-Type-A\" key_size=13\niter: pos=0x55738eb40b80 header=0x55738eb40b40 header_size=13 value=0x55738eb40b60\nmatch: pos=0x55738eb40b80 header=\"Header-Type-A\" header_size=13 -> returning value=0x55738eb40b60\nMHD_get_response_header: entry response=0x55738eb40820 key=0x55735b86c01f\nMHD_get_response_header: key=\"Header-Type-A\" key_size=13\niter: pos=0x55738eb40b80 header=0x55738eb40b40 header_size=13 value=0x55738eb40b60\nmatch: pos=0x55738eb40b80 header=\"Header-Type-A\" header_size=13 -> returning value=0x55738eb40b60\nMHD_get_response_header: entry response=0x55738eb40820 key=0x55735b86c090\nMHD_get_response_header: key=\"Header-Type-B\" key_size=13\niter: pos=0x55738eb40b80 header=0x55738eb40b40 header_size=13 value=0x55738eb40b60\nno-match: pos=0x55738eb40b80 header=\"Header-Type-A\" header_size=13\nMHD_get_response_header: reached end of headers -> returning NULL\nMHD_get_response_header: entry response=0x55738eb40820 key=0x55735b86c0f6\nMHD_get_response_header: key=\"Connection\" key_size=10\niter: pos=0x55738eb40c00 header=0x55738eb40900 header_size=10 value=0x55738eb408e0\nmatch: pos=0x55738eb40c00 header=\"Connection\" header_size=10 -> returning value=0x55738eb408e0\nMHD_get_response_header: entry response=0x55738eb40820 key=0x55735b86c0f6\nMHD_get_response_header: key=\"Connection\" key_size=10\niter: pos=0x55738eb40b80 header=0x55738eb40b40 header_size=13 value=0x55738eb40b60\nno-match: pos=0x55738eb40b80 header=\"Header-Type-A\" header_size=13\nMHD_get_response_header: reached end of headers -> returning NULL\nMHD_get_response_header: entry response=0x55738eb40820 key=0x55735b86c0f6\nMHD_get_response_header: key=\"Connection\" key_size=10\niter: pos=0x55738eb40c70 header=0x55738eb40900 header_size=10 value=0x55738eb40c40\nmatch: pos=0x55738eb40c70 header=\"Connection\" header_size=10 -> returning value=0x55738eb40c40\nMHD_get_response_header: entry response=0x55738eb40820 key=0x55735b86c0f6\nMHD_get_response_header: key=\"Connection\" key_size=10\niter: pos=0x55738eb40b80 header=0x55738eb40b40 header_size=13 value=0x55738eb40b60\nno-match: pos=0x55738eb40b80 header=\"Header-Type-A\" header_size=13\nMHD_get_response_header: reached end of headers -> returning NULL\nMHD_get_response_header: entry response=0x55738eb40820 key=0x55735b86c0f6\nMHD_get_response_header: key=\"Connection\" key_size=10\niter: pos=0x55738eb40cb0 header=0x55738eb40900 header_size=10 value=0x55738eb40c40\nmatch: pos=0x55738eb40cb0 header=\"Connection\" header_size=10 -> returning value=0x55738eb40c40\nMHD_get_response_header: entry response=0x55738eb40820 key=0x55735b86c0f6\nMHD_get_response_header: key=\"Connection\" key_size=10\niter: pos=0x55738eb40cb0 header=0x55738eb40900 header_size=10 value=0x55738eb40c70\nmatch: pos=0x55738eb40cb0 header=\"Connection\" header_size=10 -> returning value=0x55738eb40c70\nMHD_get_response_header: entry response=0x55738eb40820 key=0x55735b86c0f6\nMHD_get_response_header: key=\"Connection\" key_size=10\niter: pos=0x55738eb40cb0 header=0x55738eb40900 header_size=10 value=0x55738eb40c70\nmatch: pos=0x55738eb40cb0 header=\"Connection\" header_size=10 -> re\n</execution_log>\n\n<instruction>\nJudge whether the report is correct or not.\n</instruction>\n",
  "is_report_correct": false,
  "explanation": "Agent A\u2019s claim is incomplete and therefore not correct as stated. The snippet shown does not include the definition of struct MHD_HTTP_Res_Header, so you cannot determine from this function alone whether a Rule 8.13 violation exists. Rule 8.13 recommends that pointers which are used only to read the pointed-to object should be declared to point to const-qualified types. In this function pos->header and pos->value are only read and the function returns a const char * \u2014 so if the struct members are already declared as const char * there is no violation. If, on the other hand, the struct members are declared as plain char * and they are never modified through those members, then the codebase would be inconsistent with the spirit of MISRA 8.13 and the struct member declarations should be changed to const char * (and any helper/comparison functions should take const char * parameters). However, there is no evidence in the provided code that the members are non-const or that they cannot be modified elsewhere, so the report as given is not demonstrably correct."
}