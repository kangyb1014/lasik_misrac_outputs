{
  "user_message": "An agent A claimed that the following MHD_set_connection_value_n_nocheck_ code violates the MISRA C 2023 rule 8.13.\n<misra_rule>\nMISRA C 2023 Rule 8.13 is A pointer should point to a const-qualified type whenever possible.\n\n</misra_rule>\n<target_code>\nHere is the original code of MHD_set_connection_value_n_nocheck_.\n```c\nstatic enum MHD_Result\nMHD_set_connection_value_n_nocheck_ (struct MHD_Connection *connection,\n                                     enum MHD_ValueKind kind,\n                                     const char *key,\n                                     size_t key_size,\n                                     const char *value,\n                                     size_t value_size)\n{\n  struct MHD_HTTP_Req_Header *pos;\n\n  pos = MHD_connection_alloc_memory_ (connection,\n                                      sizeof (struct MHD_HTTP_Res_Header));\n  if (NULL == pos)\n    return MHD_NO;\n  pos->header = key;\n  pos->header_size = key_size;\n  pos->value = value;\n  pos->value_size = value_size;\n  pos->kind = kind;\n  pos->next = NULL;\n  /* append 'pos' to the linked list of headers */\n  if (NULL == connection->rq.headers_received_tail)\n  {\n    connection->rq.headers_received = pos;\n    connection->rq.headers_received_tail = pos;\n  }\n  else\n  {\n    connection->rq.headers_received_tail->next = pos;\n    connection->rq.headers_received_tail = pos;\n  }\n  return MHD_YES;\n}\n```\n</target_code>\n<response format>\nProvide your answer with these fields.\n- explanation: your evaluation of the scenario provided by the agent A.\n- is_report_correct: whether the report is correct or not (true/false). True means there is a violation.\n</response format>\n<scenario>\nThe agent A provided the following violation scenario:\nIf the struct member pos->header is declared as a non-const pointer (e.g. \"char *header\" in struct MHD_HTTP_Req_Header), then the assignment pos->header = key; copies a const char * into a char *, discarding the const qualifier. That violates MISRA C 2023 Rule 8.13 (pointers should point to const-qualified types when possible). (If pos->header is already declared as \"const char *header\" then there is no violation.)\n</scenario>\n\n<execution_log>\nThe agent A also provided the following output log:\nMHD_probe: entry\n  connection=0x55a8e9ba6270\n  pos=(nil)\n  &pos->header=(null)\n  key=0x55a8e9ba64d1, key_size=4\n  key[0..4]='Host'\n  value=0x55a8e9ba64d7, value_size=9\n  value[0..9]='localhost'\n----\nMHD_probe: after_alloc_before_assign\n  connection=0x55a8e9ba6270\n  pos=0x55a8e9bae480\n  &pos->header=0x55a8e9bae490\n  key=0x55a8e9ba64d1, key_size=4\n  key[0..4]='Host'\n  value=0x55a8e9ba64d7, value_size=9\n  value[0..9]='localhost'\n----\nMHD_probe: after_assign\n  connection=0x55a8e9ba6270\n  pos=0x55a8e9bae480\n  &pos->header=0x55a8e9bae490\n  key=0x55a8e9ba64d1, key_size=4\n  key[0..4]='Host'\n  value=0x55a8e9ba64d7, value_size=9\n  value[0..9]='localhost'\n  extra=0x55a8e9ba64d1\n----\nMHD_probe: append_head_empty_before\n  connection=0x55a8e9ba6270\n  pos=0x55a8e9bae480\n  &pos->header=0x55a8e9bae490\n  key=0x55a8e9ba64d1, key_size=4\n  key[0..4]='Host'\n  value=0x55a8e9ba64d7, value_size=9\n  value[0..9]='localhost'\n----\nMHD_probe: append_head_empty_after\n  connection=0x55a8e9ba6270\n  pos=0x55a8e9bae480\n  &pos->header=0x55a8e9bae490\n  key=0x55a8e9ba64d1, key_size=4\n  key[0..4]='Host'\n  value=0x55a8e9ba64d7, value_size=9\n  value[0..9]='localhost'\n  extra=0x55a8e9bae480\n----\nMHD_probe: entry\n  connection=0x55a8e9ba6270\n  pos=(nil)\n  &pos->header=(null)\n  key=0x55a8e9ba64d1, key_size=4\n  key[0..4]='Host'\n  value=0x55a8e9ba64d7, value_size=9\n  value[0..9]='localhost'\n----\nMHD_probe: after_alloc_before_assign\n  connection=0x55a8e9ba6270\n  pos=0x55a8e9bae480\n  &pos->header=0x55a8e9bae490\n  key=0x55a8e9ba64d1, key_size=4\n  key[0..4]='Host'\n  value=0x55a8e9ba64d7, value_size=9\n  value[0..9]='localhost'\n----\nMHD_probe: after_assign\n  connection=0x55a8e9ba6270\n  pos=0x55a8e9bae480\n  &pos->header=0x55a8e9bae490\n  key=0x55a8e9ba64d1, key_size=4\n  key[0..4]='Host'\n  value=0x55a8e9ba64d7, value_size=9\n  value[0..9]='localhost'\n  extra=0x55a8e9ba64d1\n----\nMHD_probe: append_head_empty_before\n  connection=0x55a8e9ba6270\n  pos=0x55a8e9bae480\n  &pos->header=0x55a8e9bae490\n  key=0x55a8e9ba64d1, key_size=4\n  key[0..4]='Host'\n  value=0x55a8e9ba64d7, value_size=9\n  value[0..9]='localhost'\n----\nMHD_probe: append_head_empty_after\n  connection=0x55a8e9ba6270\n  pos=0x55a8e9bae480\n  &pos->header=0x55a8e9bae490\n  key=0x55a8e9ba64d1, key_size=4\n  key[0..4]='Host'\n  value=0x55a8e9ba64d7, value_size=9\n  value[0..9]='localhost'\n  extra=0x55a8e9bae480\n----\nMHD_probe: entry\n  connection=0x55a8e9ba6270\n  pos=(nil)\n  &pos->header=(null)\n  key=0x55a8e9ba64d1, key_size=4\n  key[0..4]='Host'\n  value=0x55a8e9ba64d7, value_size=9\n  value[0..9]='localhost'\n----\nMHD_probe: after_alloc_before_assign\n  connection=0x55a8e9ba6270\n  pos=0x55a8e9bae480\n  &pos->header=0x55a8e9bae490\n  key=0x55a8e9ba64d1, key_size=4\n  key[0..4]='Host'\n  value=0x55a8e9ba64d7, value_size=9\n  value[0..9]='localhost'\n----\nMHD_probe: after_assign\n  connection=0x55a8e9ba6270\n  pos=0x55a8e9bae480\n  &pos->header=0x55a8e9bae490\n  key=0x55a8e9ba64d1, key_size=4\n  key[0..4]='Host'\n  value=0x55a8e9ba64d7, value_size=9\n  value[0..9]='localhost'\n  extra=0x55a8e9ba64d1\n----\nMHD_probe: append_head_empty_before\n  connection=0x55a8e9ba6270\n  pos=0x55a8e9bae480\n  &pos->header=0x55a8e9bae490\n  key=0x55a8e9ba64d1, key_size=4\n  key[0..4]='Host'\n  value=0x55a8e9ba64d7, value_size=9\n  value[0..9]='localhost'\n----\nMHD_probe: append_head_empty_after\n  connection=0x55a8e9ba6270\n  pos=0x55a8e9bae480\n  &pos->header=0x55a8e9bae490\n  key=0x55a8e9ba64d1, key_size=4\n  key[0..4]='Host'\n  value=0x55a8e9ba64d7, value_size=9\n  value[0..9]='localhost'\n  extra=0x55a8e9bae480\n----\nMHD_probe: entry\n  connection=0x55a8e9ba6270\n  pos=(nil)\n  &pos->header=(null)\n  key=0x55a8e9ba64d1, key_size=4\n  key[0..4]='Host'\n  value=0x55a8e9ba64d7, value_size=9\n  value[0..9]='localhost'\n----\nMHD_probe: after_alloc_before_assign\n  connection=0x55a8e9ba6270\n  pos=0x55a8e9bae480\n  &pos->header=0x55a8e9bae490\n  key=0x55a8e9ba64d1, key_size=4\n  key[0..4]='Host'\n  value=0x55a8e9ba64d7, value_size=9\n  value[0..9]='localhost'\n----\nMHD_probe: after_assign\n  connection=0x55a8e9ba6270\n  pos=0x55a8e9bae480\n  &pos->header=0x55a8e9bae490\n  key=0x55a8e9ba64d1, key_size=4\n  key[\n</execution_log>\n\n<instruction>\nJudge whether the report is correct or not.\n</instruction>\n",
  "is_report_correct": true,
  "explanation": "Agent A's report is correct but conditional. The assignment pos->header = key; copies a const char * (the function parameter key) into the struct member pos->header. If pos->header is declared as a non-const pointer (e.g. char *header), this discards the const qualifier and therefore violates the intent of MISRA C 2023 Rule 8.13 (pointers should point to const-qualified types whenever possible). If, however, the struct member is declared as const char *header, there is no violation. The safe corrective action is to make the struct member const-qualified (const char *header) so the types match; using an explicit cast to silence the qualifier mismatch would be non-compliant and is not recommended."
}