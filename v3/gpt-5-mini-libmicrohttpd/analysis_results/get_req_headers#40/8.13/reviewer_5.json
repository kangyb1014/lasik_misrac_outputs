{
  "user_message": "An agent A claimed that the following get_req_headers code violates the MISRA C 2023 rule 8.13.\n<misra_rule>\nMISRA C 2023 Rule 8.13 is A pointer should point to a const-qualified type whenever possible.\n\n</misra_rule>\n<target_code>\nHere is the original code of get_req_headers.\n```c\nstatic bool\nget_req_headers (struct MHD_Connection *c, bool process_footers)\n{\n  do\n  {\n    struct _MHD_str_w_len hdr_name;\n    struct _MHD_str_w_len hdr_value;\n    enum MHD_HdrLineReadRes_ res;\n\n    mhd_assert ((process_footers ? MHD_CONNECTION_FOOTERS_RECEIVING : \\\n                 MHD_CONNECTION_REQ_HEADERS_RECEIVING) == \\\n                c->state);\n\n    #ifdef _DEBUG\n    hdr_name.str = NULL;\n    hdr_value.str = NULL;\n#endif /* _DEBUG */\n    res = get_req_header (c, process_footers, &hdr_name, &hdr_value);\n    if (MHD_HDR_LINE_READING_GOT_HEADER == res)\n    {\n      mhd_assert ((process_footers ? MHD_CONNECTION_FOOTERS_RECEIVING : \\\n                   MHD_CONNECTION_REQ_HEADERS_RECEIVING) == \\\n                  c->state);\n      mhd_assert (NULL != hdr_name.str);\n      mhd_assert (NULL != hdr_value.str);\n      /* Values must be zero-terminated and must not have binary zeros */\n      mhd_assert (strlen (hdr_name.str) == hdr_name.len);\n      mhd_assert (strlen (hdr_value.str) == hdr_value.len);\n      /* Values must not have whitespaces at the start or at the end */\n      mhd_assert ((hdr_name.len == 0) || (hdr_name.str[0] != ' '));\n      mhd_assert ((hdr_name.len == 0) || (hdr_name.str[0] != '\\t'));\n      mhd_assert ((hdr_name.len == 0) || \\\n                  (hdr_name.str[hdr_name.len - 1] != ' '));\n      mhd_assert ((hdr_name.len == 0) || \\\n                  (hdr_name.str[hdr_name.len - 1] != '\\t'));\n      mhd_assert ((hdr_value.len == 0) || (hdr_value.str[0] != ' '));\n      mhd_assert ((hdr_value.len == 0) || (hdr_value.str[0] != '\\t'));\n      mhd_assert ((hdr_value.len == 0) || \\\n                  (hdr_value.str[hdr_value.len - 1] != ' '));\n      mhd_assert ((hdr_value.len == 0) || \\\n                  (hdr_value.str[hdr_value.len - 1] != '\\t'));\n\n      if (MHD_NO ==\n          MHD_set_connection_value_n_nocheck_ (c,\n                                               (! process_footers) ?\n                                               MHD_HEADER_KIND :\n                                               MHD_FOOTER_KIND,\n                                               hdr_name.str, hdr_name.len,\n                                               hdr_value.str, hdr_value.len))\n      {\n        size_t add_element_size;\n\n        mhd_assert (hdr_name.str < hdr_value.str);\n\n#ifdef HAVE_MESSAGES\n        MHD_DLOG (c->daemon,\n                  _ (\"Failed to allocate memory in the connection memory \" \\\n                     \"pool to store %s.\\n\"),\n                  (! process_footers) ? _ (\"header\") : _ (\"footer\"));\n#endif /* HAVE_MESSAGES */\n\n        add_element_size = hdr_value.len\n                           + (size_t) (hdr_value.str - hdr_name.str);\n\n        if (! process_footers)\n          handle_req_headers_no_space (c, hdr_name.str, add_element_size);\n        else\n          handle_req_footers_no_space (c, hdr_name.str, add_element_size);\n\n        mhd_assert (MHD_CONNECTION_FULL_REQ_RECEIVED < c->state);\n        return true;\n      }\n      /* Reset processing state */\n      reset_rq_header_processing_state (c);\n      mhd_assert ((process_footers ? MHD_CONNECTION_FOOTERS_RECEIVING : \\\n                   MHD_CONNECTION_REQ_HEADERS_RECEIVING) == \\\n                  c->state);\n      /* Read the next header (field) line */\n      continue;\n    }\n    else if (MHD_HDR_LINE_READING_NEED_MORE_DATA == res)\n    {\n      mhd_assert ((process_footers ? MHD_CONNECTION_FOOTERS_RECEIVING : \\\n                   MHD_CONNECTION_REQ_HEADERS_RECEIVING) == \\\n                  c->state);\n      return false;\n    }\n    else if (MHD_HDR_LINE_READING_DATA_ERROR == res)\n    {\n      mhd_assert ((process_footers ? \\\n                   MHD_CONNECTION_FOOTERS_RECEIVING : \\\n                   MHD_CONNECTION_REQ_HEADERS_RECEIVING) < c->state);\n      mhd_assert (c->stop_with_error);\n      mhd_assert (c->discard_request);\n      return true;\n    }\n    mhd_assert (MHD_HDR_LINE_READING_GOT_END_OF_HEADER == res);\n    break;\n  } while (1);\n\n#ifdef HAVE_MESSAGES\n  if (1 == c->rq.num_cr_sp_replaced)\n  {\n    MHD_DLOG (c->daemon,\n              _ (\"One bare CR character has been replaced with space \" \\\n                 \"in %s.\\n\"),\n              (! process_footers) ?\n              _ (\"the request line or in the request headers\") :\n              _ (\"the request footers\"));\n  }\n  else if (0 != c->rq.num_cr_sp_replaced)\n  {\n    MHD_DLOG (c->daemon,\n              _ (\"%\" PRIu64 \" bare CR characters have been replaced with \" \\\n                 \"spaces in the request line and/or in the request %s.\\n\"),\n              (uint64_t) c->rq.num_cr_sp_replaced,\n              (! process_footers) ? _ (\"headers\") : _ (\"footers\"));\n  }\n  if (1 == c->rq.skipped_broken_lines)\n  {\n    MHD_DLOG (c->daemon,\n              _ (\"One %s line without colon has been skipped.\\n\"),\n              (! process_footers) ? _ (\"header\") : _ (\"footer\"));\n  }\n  else if (0 != c->rq.skipped_broken_lines)\n  {\n    MHD_DLOG (c->daemon,\n              _ (\"%\" PRIu64 \" %s lines without colons has been skipped.\\n\"),\n              (uint64_t) c->rq.skipped_broken_lines,\n              (! process_footers) ? _ (\"header\") : _ (\"footer\"));\n  }\n#endif /* HAVE_MESSAGES */\n\n  mhd_assert (c->rq.method < c->read_buffer);\n  if (! process_footers)\n  {\n    c->rq.header_size = (size_t) (c->read_buffer - c->rq.method);\n    mhd_assert (NULL != c->rq.field_lines.start);\n    c->rq.field_lines.size =\n      (size_t) ((c->read_buffer - c->rq.field_lines.start) - 1);\n    if ('\\r' == *(c->read_buffer - 2))\n      c->rq.field_lines.size--;\n    c->state = MHD_CONNECTION_HEADERS_RECEIVED;\n\n    if (MHD_BUF_INC_SIZE > c->read_buffer_size)\n    {\n      /* Try to re-use some of the last bytes of the request header */\n      /* Do this only if space in the read buffer is limited AND\n         amount of read ahead data is small. */\n      /**\n       *  The position of the terminating NUL after the last character of\n       *  the last header element.\n       */\n      const char *last_elmnt_end;\n      size_t shift_back_size;\n      if (NULL != c->rq.headers_received_tail)\n        last_elmnt_end =\n          c->rq.headers_received_tail->value\n          + c->rq.headers_received_tail->value_size;\n      else\n        last_elmnt_end = c->rq.version + HTTP_VER_LEN;\n      mhd_assert ((last_elmnt_end + 1) < c->read_buffer);\n      shift_back_size = (size_t) (c->read_buffer - (last_elmnt_end + 1));\n      if (0 != c->read_buffer_offset)\n        memmove (c->read_buffer - shift_back_size,\n                 c->read_buffer,\n                 c->read_buffer_offset);\n      c->read_buffer -= shift_back_size;\n      c->read_buffer_size += shift_back_size;\n    }\n  }\n  else\n    c->state = MHD_CONNECTION_FOOTERS_RECEIVED;\n\n  return true;\n}\n```\n</target_code>\n<response format>\nProvide your answer with these fields.\n- explanation: your evaluation of the scenario provided by the agent A.\n- is_report_correct: whether the report is correct or not (true/false). True means there is a violation.\n</response format>\n<scenario>\nThe agent A provided the following violation scenario:\nA violation occurs if c->rq.field_lines.start is declared as a non-const pointer (e.g. char *start) but is only used for read-only operations (pointer arithmetic and inspections) as shown. In that case the pointer should be declared as const char * to reflect that the pointed-to characters are not modified; keeping it non-const violates MISRA C 2023 Rule 8.13. (Note: to preserve pointer arithmetic without casts, the corresponding read buffer pointer types should be made compatible as well \u2014 e.g. both const char * if neither is modified.)\n</scenario>\n\n<execution_log>\nThe agent A also provided the following output log:\n[get_req_headers] after_get_req_header: process_footers=0 res=0 c=0x55e8fccbe270 state=3 read_buffer=0x55e8fccbe4d1 read_buffer_size=16367\n  hdr_name.str=0x55e8fccbe270 hdr_name.len=72057594037927936  hdr_value.str=0x7fff5044d910 hdr_value.len=140451371930356\n  rq.field_lines.start=0x55e8fccbe4d1 rq.field_lines.size=94459161994449 method=0x55e8fccbe4c0 read_buffer_offset=0\n[get_req_headers] need_more_data: process_footers=0 res=0 c=0x55e8fccbe270 state=3 read_buffer=0x55e8fccbe4d1 read_buffer_size=16367\n  hdr_name.str=0x55e8fccbe270 hdr_name.len=72057594037927936  hdr_value.str=0x7fff5044d910 hdr_value.len=140451371930356\n  rq.field_lines.start=0x55e8fccbe4d1 rq.field_lines.size=94459161994449 method=0x55e8fccbe4c0 read_buffer_offset=0\n[get_req_headers] after_get_req_header: process_footers=0 res=0 c=0x55e8fccbe270 state=3 read_buffer=0x55e8fccbe4d1 read_buffer_size=16367\n  hdr_name.str=0x55e8fccbe270 hdr_name.len=72057594037927936  hdr_value.str=0x7fff5044d910 hdr_value.len=140451371944123\n  rq.field_lines.start=0x55e8fccbe4d1 rq.field_lines.size=94459161994449 method=0x55e8fccbe4c0 read_buffer_offset=0\n[get_req_headers] need_more_data: process_footers=0 res=0 c=0x55e8fccbe270 state=3 read_buffer=0x55e8fccbe4d1 read_buffer_size=16367\n  hdr_name.str=0x55e8fccbe270 hdr_name.len=72057594037927936  hdr_value.str=0x7fff5044d910 hdr_value.len=140451371944123\n  rq.field_lines.start=0x55e8fccbe4d1 rq.field_lines.size=94459161994449 method=0x55e8fccbe4c0 read_buffer_offset=0\n[get_req_headers] after_get_req_header: process_footers=0 res=0 c=0x55e8fccbe270 state=3 read_buffer=0x55e8fccbe4d1 read_buffer_size=16367\n  hdr_name.str=0x55e8fccbe270 hdr_name.len=72057594037927936  hdr_value.str=0x7fff5044d910 hdr_value.len=140451371930356\n  rq.field_lines.start=0x55e8fccbe4d1 rq.field_lines.size=94459161994449 method=0x55e8fccbe4c0 read_buffer_offset=1\n[get_req_headers] need_more_data: process_footers=0 res=0 c=0x55e8fccbe270 state=3 read_buffer=0x55e8fccbe4d1 read_buffer_size=16367\n  hdr_name.str=0x55e8fccbe270 hdr_name.len=72057594037927936  hdr_value.str=0x7fff5044d910 hdr_value.len=140451371930356\n  rq.field_lines.start=0x55e8fccbe4d1 rq.field_lines.size=94459161994449 method=0x55e8fccbe4c0 read_buffer_offset=1\n[get_req_headers] after_get_req_header: process_footers=0 res=0 c=0x55e8fccbe270 state=3 read_buffer=0x55e8fccbe4d1 read_buffer_size=16367\n  hdr_name.str=0x55e8fccbe270 hdr_name.len=72057594037927936  hdr_value.str=0x7fff5044d910 hdr_value.len=140451371944123\n  rq.field_lines.start=0x55e8fccbe4d1 rq.field_lines.size=94459161994449 method=0x55e8fccbe4c0 read_buffer_offset=1\n[get_req_headers] need_more_data: process_footers=0 res=0 c=0x55e8fccbe270 state=3 read_buffer=0x55e8fccbe4d1 read_buffer_size=16367\n  hdr_name.str=0x55e8fccbe270 hdr_name.len=72057594037927936  hdr_value.str=0x7fff5044d910 hdr_value.len=140451371944123\n  rq.field_lines.start=0x55e8fccbe4d1 rq.field_lines.size=94459161994449 method=0x55e8fccbe4c0 read_buffer_offset=1\n[get_req_headers] after_get_req_header: process_footers=0 res=0 c=0x55e8fccbe270 state=3 read_buffer=0x55e8fccbe4d1 read_buffer_size=16367\n  hdr_name.str=0x55e8fccbe270 hdr_name.len=72057594037927936  hdr_value.str=0x7fff5044d910 hdr_value.len=140451371930356\n  rq.field_lines.start=0x55e8fccbe4d1 rq.field_lines.size=94459161994449 method=0x55e8fccbe4c0 read_buffer_offset=2\n[get_req_headers] need_more_data: process_footers=0 res=0 c=0x55e8fccbe270 state=3 read_buffer=0x55e8fccbe4d1 read_buffer_size=16367\n  hdr_name.str=0x55e8fccbe270 hdr_name.len=72057594037927936  hdr_value.str=0x7fff5044d910 hdr_value.len=140451371930356\n  rq.field_lines.start=0x55e8fccbe4d1 rq.field_lines.size=94459161994449 method=0x55e8fccbe4c0 read_buffer_offset=2\n[get_req_headers] after_get_req_header: process_footers=0 res=0 c=0x55e8fccbe270 state=3 read_buffer=0x55e8fccbe4d1 read_buffer_size=16367\n  hdr_name.str=0x55e8fccbe270 hdr_name.len=72057594037927936  hdr_value.str=0x7fff5044d910 hdr_value.len=140451371944123\n  rq.field_lines.start=0x55e8fccbe4d1 rq.field_lines.size=94459161994449 method=0x55e8fccbe4c0 read_buffer\n</execution_log>\n\n<instruction>\nJudge whether the report is correct or not.\n</instruction>\n",
  "is_report_correct": false,
  "explanation": "Agent A\u2019s claim is not verifiable from the supplied snippet alone. Rule 8.13 asks that pointers be declared to point to const-qualified types when they are only used for read access. In get_req_headers the code only reads and does pointer arithmetic/comparisons on c->rq.field_lines.start, so in isolation that usage could be made const. However, whether the current declaration actually violates 8.13 depends on the declaration of c->rq.field_lines.start and on all other writes/assignments to the pointee elsewhere in the program. If the buffer that start points into is ever modified through that member (or that member is passed to APIs that write via it), it must remain non-const; if it is truly read-only across the whole program, then not declaring it const would be a breach of the \u201cshould\u201d guidance. The provided execution log and function body do not show the declaration or other uses, so there is insufficient evidence to conclude a definite MISRA 8.13 violation. Recommendation: inspect the struct field declaration and all uses of field_lines.start; if it is never used to modify the pointed data, change its type to const char * (and make related buffer pointers compatible)."
}