{
  "user_message": "An agent A claimed that the following get_req_headers code violates the MISRA C 2023 rule 21.17.\n<misra_rule>\nMISRA C 2023 Rule 21.17 is Use of the string handling functions from <string.h> shall not result in accesses beyond the bounds of the objects referenced by their pointer parameters.\nThis rule strictly applies to the Standard Library functions in <string.h> such as memcpy, memmove, memset, memcmp, strcpy, strncpy, strcat, strncat, strlen, and strspn.\n</misra_rule>\n<target_code>\nHere is the original code of get_req_headers.\n```c\nstatic bool\nget_req_headers (struct MHD_Connection *c, bool process_footers)\n{\n  do\n  {\n    struct _MHD_str_w_len hdr_name;\n    struct _MHD_str_w_len hdr_value;\n    enum MHD_HdrLineReadRes_ res;\n\n    mhd_assert ((process_footers ? MHD_CONNECTION_FOOTERS_RECEIVING : \\\n                 MHD_CONNECTION_REQ_HEADERS_RECEIVING) == \\\n                c->state);\n\n    #ifdef _DEBUG\n    hdr_name.str = NULL;\n    hdr_value.str = NULL;\n#endif /* _DEBUG */\n    res = get_req_header (c, process_footers, &hdr_name, &hdr_value);\n    if (MHD_HDR_LINE_READING_GOT_HEADER == res)\n    {\n      mhd_assert ((process_footers ? MHD_CONNECTION_FOOTERS_RECEIVING : \\\n                   MHD_CONNECTION_REQ_HEADERS_RECEIVING) == \\\n                  c->state);\n      mhd_assert (NULL != hdr_name.str);\n      mhd_assert (NULL != hdr_value.str);\n      /* Values must be zero-terminated and must not have binary zeros */\n      mhd_assert (strlen (hdr_name.str) == hdr_name.len);\n      mhd_assert (strlen (hdr_value.str) == hdr_value.len);\n      /* Values must not have whitespaces at the start or at the end */\n      mhd_assert ((hdr_name.len == 0) || (hdr_name.str[0] != ' '));\n      mhd_assert ((hdr_name.len == 0) || (hdr_name.str[0] != '\\t'));\n      mhd_assert ((hdr_name.len == 0) || \\\n                  (hdr_name.str[hdr_name.len - 1] != ' '));\n      mhd_assert ((hdr_name.len == 0) || \\\n                  (hdr_name.str[hdr_name.len - 1] != '\\t'));\n      mhd_assert ((hdr_value.len == 0) || (hdr_value.str[0] != ' '));\n      mhd_assert ((hdr_value.len == 0) || (hdr_value.str[0] != '\\t'));\n      mhd_assert ((hdr_value.len == 0) || \\\n                  (hdr_value.str[hdr_value.len - 1] != ' '));\n      mhd_assert ((hdr_value.len == 0) || \\\n                  (hdr_value.str[hdr_value.len - 1] != '\\t'));\n\n      if (MHD_NO ==\n          MHD_set_connection_value_n_nocheck_ (c,\n                                               (! process_footers) ?\n                                               MHD_HEADER_KIND :\n                                               MHD_FOOTER_KIND,\n                                               hdr_name.str, hdr_name.len,\n                                               hdr_value.str, hdr_value.len))\n      {\n        size_t add_element_size;\n\n        mhd_assert (hdr_name.str < hdr_value.str);\n\n#ifdef HAVE_MESSAGES\n        MHD_DLOG (c->daemon,\n                  _ (\"Failed to allocate memory in the connection memory \" \\\n                     \"pool to store %s.\\n\"),\n                  (! process_footers) ? _ (\"header\") : _ (\"footer\"));\n#endif /* HAVE_MESSAGES */\n\n        add_element_size = hdr_value.len\n                           + (size_t) (hdr_value.str - hdr_name.str);\n\n        if (! process_footers)\n          handle_req_headers_no_space (c, hdr_name.str, add_element_size);\n        else\n          handle_req_footers_no_space (c, hdr_name.str, add_element_size);\n\n        mhd_assert (MHD_CONNECTION_FULL_REQ_RECEIVED < c->state);\n        return true;\n      }\n      /* Reset processing state */\n      reset_rq_header_processing_state (c);\n      mhd_assert ((process_footers ? MHD_CONNECTION_FOOTERS_RECEIVING : \\\n                   MHD_CONNECTION_REQ_HEADERS_RECEIVING) == \\\n                  c->state);\n      /* Read the next header (field) line */\n      continue;\n    }\n    else if (MHD_HDR_LINE_READING_NEED_MORE_DATA == res)\n    {\n      mhd_assert ((process_footers ? MHD_CONNECTION_FOOTERS_RECEIVING : \\\n                   MHD_CONNECTION_REQ_HEADERS_RECEIVING) == \\\n                  c->state);\n      return false;\n    }\n    else if (MHD_HDR_LINE_READING_DATA_ERROR == res)\n    {\n      mhd_assert ((process_footers ? \\\n                   MHD_CONNECTION_FOOTERS_RECEIVING : \\\n                   MHD_CONNECTION_REQ_HEADERS_RECEIVING) < c->state);\n      mhd_assert (c->stop_with_error);\n      mhd_assert (c->discard_request);\n      return true;\n    }\n    mhd_assert (MHD_HDR_LINE_READING_GOT_END_OF_HEADER == res);\n    break;\n  } while (1);\n\n#ifdef HAVE_MESSAGES\n  if (1 == c->rq.num_cr_sp_replaced)\n  {\n    MHD_DLOG (c->daemon,\n              _ (\"One bare CR character has been replaced with space \" \\\n                 \"in %s.\\n\"),\n              (! process_footers) ?\n              _ (\"the request line or in the request headers\") :\n              _ (\"the request footers\"));\n  }\n  else if (0 != c->rq.num_cr_sp_replaced)\n  {\n    MHD_DLOG (c->daemon,\n              _ (\"%\" PRIu64 \" bare CR characters have been replaced with \" \\\n                 \"spaces in the request line and/or in the request %s.\\n\"),\n              (uint64_t) c->rq.num_cr_sp_replaced,\n              (! process_footers) ? _ (\"headers\") : _ (\"footers\"));\n  }\n  if (1 == c->rq.skipped_broken_lines)\n  {\n    MHD_DLOG (c->daemon,\n              _ (\"One %s line without colon has been skipped.\\n\"),\n              (! process_footers) ? _ (\"header\") : _ (\"footer\"));\n  }\n  else if (0 != c->rq.skipped_broken_lines)\n  {\n    MHD_DLOG (c->daemon,\n              _ (\"%\" PRIu64 \" %s lines without colons has been skipped.\\n\"),\n              (uint64_t) c->rq.skipped_broken_lines,\n              (! process_footers) ? _ (\"header\") : _ (\"footer\"));\n  }\n#endif /* HAVE_MESSAGES */\n\n  mhd_assert (c->rq.method < c->read_buffer);\n  if (! process_footers)\n  {\n    c->rq.header_size = (size_t) (c->read_buffer - c->rq.method);\n    mhd_assert (NULL != c->rq.field_lines.start);\n    c->rq.field_lines.size =\n      (size_t) ((c->read_buffer - c->rq.field_lines.start) - 1);\n    if ('\\r' == *(c->read_buffer - 2))\n      c->rq.field_lines.size--;\n    c->state = MHD_CONNECTION_HEADERS_RECEIVED;\n\n    if (MHD_BUF_INC_SIZE > c->read_buffer_size)\n    {\n      /* Try to re-use some of the last bytes of the request header */\n      /* Do this only if space in the read buffer is limited AND\n         amount of read ahead data is small. */\n      /**\n       *  The position of the terminating NUL after the last character of\n       *  the last header element.\n       */\n      const char *last_elmnt_end;\n      size_t shift_back_size;\n      if (NULL != c->rq.headers_received_tail)\n        last_elmnt_end =\n          c->rq.headers_received_tail->value\n          + c->rq.headers_received_tail->value_size;\n      else\n        last_elmnt_end = c->rq.version + HTTP_VER_LEN;\n      mhd_assert ((last_elmnt_end + 1) < c->read_buffer);\n      shift_back_size = (size_t) (c->read_buffer - (last_elmnt_end + 1));\n      if (0 != c->read_buffer_offset)\n        memmove (c->read_buffer - shift_back_size,\n                 c->read_buffer,\n                 c->read_buffer_offset);\n      c->read_buffer -= shift_back_size;\n      c->read_buffer_size += shift_back_size;\n    }\n  }\n  else\n    c->state = MHD_CONNECTION_FOOTERS_RECEIVED;\n\n  return true;\n}\n```\n</target_code>\n<response format>\nProvide your answer with these fields.\n- explanation: your evaluation of the scenario provided by the agent A.\n- is_report_correct: whether the report is correct or not (true/false). True means there is a violation.\n</response format>\n<scenario>\nThe agent A provided the following violation scenario:\nThe call strlen(hdr_name.str) assumes hdr_name.str points to a NUL-terminated character array. There is only an mhd_assert(NULL != hdr_name.str) prior to the call; no explicit bound or guarantee that a '\\0' exists within the object. If get_req_header() ever returns hdr_name.str that is not NUL-terminated within the allocated/read buffer (for example the header lies at the end of the buffer and no terminating NUL was inserted), strlen will scan past the object\u2019s bounds and perform an out-of-bounds access.\n</scenario>\n\n<execution_log>\nThe agent A also provided the following output log:\nSTAGE=after_get_req_header res=0 conn_state=3 read_buffer=0x55a41f99e4d1 read_buffer_size=16367 read_buffer_offset=0\nhdr_name: str=0x55a41f99e270 len=72057594037927936\nhdr_value: str=0x7ffc450948f0 len=139921541436148\nhdr_name.str is outside read_buffer range (or read_buffer not set)\nhdr_value.str is outside read_buffer range (or read_buffer not set)\n----\nSTAGE=after_get_req_header res=0 conn_state=3 read_buffer=0x55a41f99e4d1 read_buffer_size=16367 read_buffer_offset=0\nhdr_name: str=0x55a41f99e270 len=72057594037927936\nhdr_value: str=0x7ffc450948f0 len=139921541449483\nhdr_name.str is outside read_buffer range (or read_buffer not set)\nhdr_value.str is outside read_buffer range (or read_buffer not set)\n----\nSTAGE=after_get_req_header res=0 conn_state=3 read_buffer=0x55a41f99e4d1 read_buffer_size=16367 read_buffer_offset=1\nhdr_name: str=0x55a41f99e270 len=72057594037927936\nhdr_value: str=0x7ffc450948f0 len=139921541436148\nhdr_name.str is outside read_buffer range (or read_buffer not set)\nhdr_value.str is outside read_buffer range (or read_buffer not set)\n----\nSTAGE=after_get_req_header res=0 conn_state=3 read_buffer=0x55a41f99e4d1 read_buffer_size=16367 read_buffer_offset=1\nhdr_name: str=0x55a41f99e270 len=72057594037927936\nhdr_value: str=0x7ffc450948f0 len=139921541449483\nhdr_name.str is outside read_buffer range (or read_buffer not set)\nhdr_value.str is outside read_buffer range (or read_buffer not set)\n----\nSTAGE=after_get_req_header res=0 conn_state=3 read_buffer=0x55a41f99e4d1 read_buffer_size=16367 read_buffer_offset=2\nhdr_name: str=0x55a41f99e270 len=72057594037927936\nhdr_value: str=0x7ffc450948f0 len=139921541436148\nhdr_name.str is outside read_buffer range (or read_buffer not set)\nhdr_value.str is outside read_buffer range (or read_buffer not set)\n----\nSTAGE=after_get_req_header res=0 conn_state=3 read_buffer=0x55a41f99e4d1 read_buffer_size=16367 read_buffer_offset=2\nhdr_name: str=0x55a41f99e270 len=72057594037927936\nhdr_value: str=0x7ffc450948f0 len=139921541449483\nhdr_name.str is outside read_buffer range (or read_buffer not set)\nhdr_value.str is outside read_buffer range (or read_buffer not set)\n----\nSTAGE=after_get_req_header res=0 conn_state=3 read_buffer=0x55a41f99e4d1 read_buffer_size=16367 read_buffer_offset=3\nhdr_name: str=0x55a41f99e270 len=72057594037927936\nhdr_value: str=0x7ffc450948f0 len=139921541436148\nhdr_name.str is outside read_buffer range (or read_buffer not set)\nhdr_value.str is outside read_buffer range (or read_buffer not set)\n----\nSTAGE=after_get_req_header res=0 conn_state=3 read_buffer=0x55a41f99e4d1 read_buffer_size=16367 read_buffer_offset=3\nhdr_name: str=0x55a41f99e270 len=72057594037927936\nhdr_value: str=0x7ffc450948f0 len=139921541449483\nhdr_name.str is outside read_buffer range (or read_buffer not set)\nhdr_value.str is outside read_buffer range (or read_buffer not set)\n----\nSTAGE=after_get_req_header res=0 conn_state=3 read_buffer=0x55a41f99e4d1 read_buffer_size=16367 read_buffer_offset=4\nhdr_name: str=0x55a41f99e270 len=72057594037927936\nhdr_value: str=0x7ffc450948f0 len=139921541436148\nhdr_name.str is outside read_buffer range (or read_buffer not set)\nhdr_value.str is outside read_buffer range (or read_buffer not set)\n----\nSTAGE=after_get_req_header res=0 conn_state=3 read_buffer=0x55a41f99e4d1 read_buffer_size=16367 read_buffer_offset=4\nhdr_name: str=0x55a41f99e270 len=72057594037927936\nhdr_value: str=0x7ffc450948f0 len=139921541449483\nhdr_name.str is outside read_buffer range (or read_buffer not set)\nhdr_value.str is outside read_buffer range (or read_buffer not set)\n----\nSTAGE=after_get_req_header res=0 conn_state=3 read_buffer=0x55a41f99e4d1 read_buffer_size=16367 read_buffer_offset=5\nhdr_name: str=0x55a41f99e270 len=72057594037927936\nhdr_value: str=0x7ffc450948f0 len=139921541436148\nhdr_name.str is outside read_buffer range (or read_buffer not set)\nhdr_value.str is outside read_buffer range (or read_buffer not set)\n----\nSTAGE=after_get_req_header res=0 conn_state=3 read_buffer=0x55a41f99e4d1 read_buffer_size=16367 read_buffer_offset=5\nhdr_name: str=0x55a41f99e270 len=72057594\n</execution_log>\n\n<instruction>\nJudge whether the report is correct or not.\n</instruction>\n",
  "is_report_correct": true,
  "explanation": "Agent A is correct. The calls to strlen(hdr_name.str) and strlen(hdr_value.str) can cause out-of-bounds reads unless there is an explicit, provable contract that the pointers returned by get_req_header() point to NUL-terminated objects within known bounds. In the shown function there is only mhd_assert(NULL != hdr_*.str) before calling strlen \u2014 an assertion that may be removed in non-debug builds and does not ensure a terminating '\\0' lies within the referenced object or that the object bounds are known. MISRA C 2023 Rule 21.17 requires that use of string.h functions must not result in accesses beyond the bounds of the referenced objects; calling strlen on an arbitrary pointer without a proven NUL termination or an explicit length violates that requirement.\n\nThe provided execution log further supports the risk: hdr_name.len and hdr_value.len contain implausible values and the pointers appear outside the read buffer range, demonstrating the kind of scenario where strlen would scan past valid memory. To be compliant you must either (a) have a documented and verifiable guarantee from get_req_header() that it always returns pointers into a valid buffer with an embedded terminating NUL within the declared length, and that this guarantee is enforced in production code (not only via asserts), or (b) avoid unbounded string.h calls \u2014 e.g. use a bounded scan (strnlen or memchr with a known maximum length) or explicit bounds checks before calling strlen."
}