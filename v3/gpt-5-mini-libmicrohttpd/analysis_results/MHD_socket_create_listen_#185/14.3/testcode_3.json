{
  "user_message": "<misra_rule>\nMISRA C 2023 Rule 14.3 is: Controlling expressions shall not be invariant.\nHere are exceptions to this rule:\n1. Invariants that are used to create infinite loops are permitted.\n2. A do-while loop with an essentially Boolean controlling expression that evaluates to false and satisfies the constraints and semantics for an integer constant expression is permitted.\n</misra_rule>\n\nAnother agent reported that the target code violated the Rule 14.3.\nHere is the comment from the agent.\n<violation scenario>\nThe controlling expression (! cloexec_set) can be invariant depending on build-time configuration. For example, when MHD_WINSOCK_SOCKETS && WSA_FLAG_NO_HANDLE_INHERIT is defined, cloexec_set is set to !0 (i.e. 1) so (! cloexec_set) is always false; similarly, in the fallback branch cloexec_set = 0 so (! cloexec_set) is always true. In these configurations the if condition is invariant, which violates MISRA C 2023 Rule 14.3 (no applicable exceptions).\n</violation scenario>\n\nYour job is to insert logging code to capture the control flow and state information of the program.\nInsert logging code so that other agents can reproduce and get evidence for the violation scenario.\n<response format>\n- test_code: a modified MHD_socket_create_listen_ code that contains useful probe functions that print useful logs to a file \"/tmp/logs/1855.txt\". The logs should contain the control path and state information of the violation scenario. If test code is not required to validate the scenario, you can leave this blank.\nHere are the constraints for the test code:\n- The test code MUST preserve the original logic of MHD_socket_create_listen_ as much as possible.\nYou CAN just insert probe functions to the original code.\n- DO NOT introduce new violations to demonstrate your scenario.\n- The test code MUST be compilable and executable.\n- The test code MUST include line breaks.\n- You MUST NOT define the main function.\n- You MUST NOT define macros.\n</response format>\n<target_code>\nHere is the code of MHD_socket_create_listen_:\n```c\nMHD_socket\nMHD_socket_create_listen_ (int pf)\n{\n  MHD_socket fd;\n  int cloexec_set;\n#if defined(SOCK_NOSIGPIPE) || defined(MHD_socket_nosignal_)\n  int nosigpipe_set;\n#endif /* SOCK_NOSIGPIPE ||  MHD_socket_nosignal_ */\n\n#if defined(MHD_POSIX_SOCKETS) && (defined(SOCK_CLOEXEC) || \\\n  defined(SOCK_NOSIGPIPE) )\n\n  fd = socket (pf,\n               SOCK_STREAM | SOCK_CLOEXEC | SOCK_NOSIGPIPE_OR_ZERO,\n               0);\n  cloexec_set = (SOCK_CLOEXEC_OR_ZERO != 0);\n#if defined(SOCK_NOSIGPIPE) || defined(MHD_socket_nosignal_)\n  nosigpipe_set = (SOCK_NOSIGPIPE_OR_ZERO != 0);\n#endif /* SOCK_NOSIGPIPE ||  MHD_socket_nosignal_ */\n#elif defined(MHD_WINSOCK_SOCKETS) && defined(WSA_FLAG_NO_HANDLE_INHERIT)\n  fd = WSASocketW (pf,\n                   SOCK_STREAM,\n                   0,\n                   NULL,\n                   0,\n                   WSA_FLAG_OVERLAPPED | WSA_FLAG_NO_HANDLE_INHERIT);\n  cloexec_set = ! 0;\n#else  /* No special socket init function / flags */\n  fd = MHD_INVALID_SOCKET;\n  cloexec_set = 0;\n#if defined(SOCK_NOSIGPIPE) || defined(MHD_socket_nosignal_)\n  nosigpipe_set = 0;\n#endif /* SOCK_NOSIGPIPE ||  MHD_socket_nosignal_ */\n#endif /* No special socket init function / flags */\n  if (MHD_INVALID_SOCKET == fd)\n  {\n    fd = socket (pf,\n                 SOCK_STREAM,\n                 0);\n    cloexec_set = 0;\n#if defined(SOCK_NOSIGPIPE) || defined(MHD_socket_nosignal_)\n    nosigpipe_set = 0;\n#endif /* SOCK_NOSIGPIPE ||  MHD_socket_nosignal_ */\n  }\n  if (MHD_INVALID_SOCKET == fd)\n    return MHD_INVALID_SOCKET;\n\n#if defined(MHD_socket_nosignal_)\n  if ( (! nosigpipe_set) &&\n       (0 == MHD_socket_nosignal_ (fd)) &&\n       (0 == MSG_NOSIGNAL_OR_ZERO) )\n  {\n    /* SIGPIPE disable is possible on this platform\n     * (so application expect that it will be disabled),\n     * but failed to be disabled here and it is not\n     * possible to disable SIGPIPE by MSG_NOSIGNAL. */\n    const int err = MHD_socket_get_error_ ();\n    (void) MHD_socket_close_ (fd);\n    MHD_socket_fset_error_ (err);\n    return MHD_INVALID_SOCKET;\n  }\n#endif /* defined(MHD_socket_nosignal_) */\n  if (! cloexec_set)\n    (void) MHD_socket_noninheritable_ (fd);\n\n  return fd;\n}\n```\n</target_code>\nPlease provide the modified MHD_socket_create_listen_ code.\n",
  "test_code": "#include <stdio.h>\n#include <stdint.h>\n#include <inttypes.h>\n\n/* Probe/logging helper that appends runtime state to /tmp/logs/1855.txt. */\nstatic void MHD_log_probe(const char *stage,\n                          int pf,\n                          MHD_socket fd,\n                          int cloexec_set,\n                          int nosigpipe_set,\n                          int extra)\n{\n  FILE *f = fopen(\"/tmp/logs/1855.txt\", \"a\");\n  if (f != NULL)\n  {\n    /* fd may be an integer-like socket type; print via uintptr_t for portability */\n    fprintf(f, \"stage=%s pf=%d fd=%\" PRIuPTR \" cloexec_set=%d nosigpipe_set=%d extra=%d\\n\",\n            stage, pf, (uintptr_t) fd, cloexec_set, nosigpipe_set, extra);\n    fclose(f);\n  }\n}\n\nMHD_socket\nMHD_socket_create_listen_ (int pf)\n{\n  MHD_socket fd;\n  int cloexec_set;\n#if defined(SOCK_NOSIGPIPE) || defined(MHD_socket_nosignal_)\n  int nosigpipe_set;\n#endif /* SOCK_NOSIGPIPE ||  MHD_socket_nosignal_ */\n\n#if defined(MHD_POSIX_SOCKETS) && (defined(SOCK_CLOEXEC) || \\\n  defined(SOCK_NOSIGPIPE) )\n\n  fd = socket (pf,\n               SOCK_STREAM | SOCK_CLOEXEC | SOCK_NOSIGPIPE_OR_ZERO,\n               0);\n  cloexec_set = (SOCK_CLOEXEC_OR_ZERO != 0);\n#if defined(SOCK_NOSIGPIPE) || defined(MHD_socket_nosignal_)\n  nosigpipe_set = (SOCK_NOSIGPIPE_OR_ZERO != 0);\n#endif /* SOCK_NOSIGPIPE ||  MHD_socket_nosignal_ */\n  /* Log initial attempt with flags */\n  MHD_log_probe(\"after_init_flags\", pf, fd, cloexec_set,\n#if defined(SOCK_NOSIGPIPE) || defined(MHD_socket_nosignal_)\n                nosigpipe_set,\n#else\n                -1,\n#endif\n                0);\n#elif defined(MHD_WINSOCK_SOCKETS) && defined(WSA_FLAG_NO_HANDLE_INHERIT)\n  fd = WSASocketW (pf,\n                   SOCK_STREAM,\n                   0,\n                   NULL,\n                   0,\n                   WSA_FLAG_OVERLAPPED | WSA_FLAG_NO_HANDLE_INHERIT);\n  cloexec_set = ! 0;\n  /* Log path where WSA_FLAG_NO_HANDLE_INHERIT was used */\n  MHD_log_probe(\"winsock_no_inherit\", pf, fd, cloexec_set, -1, 0);\n#else  /* No special socket init function / flags */\n  fd = MHD_INVALID_SOCKET;\n  cloexec_set = 0;\n#if defined(SOCK_NOSIGPIPE) || defined(MHD_socket_nosignal_)\n  nosigpipe_set = 0;\n#endif /* SOCK_NOSIGPIPE ||  MHD_socket_nosignal_ */\n  /* Log fallback initial state */\n  MHD_log_probe(\"no_special_flags\", pf, fd, cloexec_set,\n#if defined(SOCK_NOSIGPIPE) || defined(MHD_socket_nosignal_)\n                nosigpipe_set,\n#else\n                -1,\n#endif\n                0);\n#endif /* No special socket init function / flags */\n  if (MHD_INVALID_SOCKET == fd)\n  {\n    fd = socket (pf,\n                 SOCK_STREAM,\n                 0);\n    cloexec_set = 0;\n#if defined(SOCK_NOSIGPIPE) || defined(MHD_socket_nosignal_)\n    nosigpipe_set = 0;\n#endif /* SOCK_NOSIGPIPE ||  MHD_socket_nosignal_ */\n    /* Log after fallback socket() call */\n    MHD_log_probe(\"after_fallback_socket\", pf, fd, cloexec_set,\n#if defined(SOCK_NOSIGPIPE) || defined(MHD_socket_nosignal_)\n                  nosigpipe_set,\n#else\n                  -1,\n#endif\n                  0);\n  }\n  if (MHD_INVALID_SOCKET == fd)\n  {\n    MHD_log_probe(\"final_invalid_socket\", pf, fd, cloexec_set,\n#if defined(SOCK_NOSIGPIPE) || defined(MHD_socket_nosignal_)\n                  nosigpipe_set,\n#else\n                  -1,\n#endif\n                  0);\n    return MHD_INVALID_SOCKET;\n  }\n\n#if defined(MHD_socket_nosignal_)\n  if ( (! nosigpipe_set) &&\n       (0 == MHD_socket_nosignal_ (fd)) &&\n       (0 == MSG_NOSIGNAL_OR_ZERO) )\n  {\n    /* SIGPIPE disable is possible on this platform\n     * (so application expect that it will be disabled),\n     * but failed to be disabled here and it is not\n     * possible to disable SIGPIPE by MSG_NOSIGNAL. */\n    const int err = MHD_socket_get_error_ ();\n    /* Log nosigpipe failure and error before closing */\n    MHD_log_probe(\"nosigpipe_failed\", pf, fd, cloexec_set, nosigpipe_set, err);\n    (void) MHD_socket_close_ (fd);\n    MHD_socket_fset_error_ (err);\n    return MHD_INVALID_SOCKET;\n  }\n#endif /* defined(MHD_socket_nosignal_) */\n  if (! cloexec_set)\n  {\n    /* Log before calling noninheritable helper */\n    MHD_log_probe(\"before_noninheritable\", pf, fd, cloexec_set,\n#if defined(SOCK_NOSIGPIPE) || defined(MHD_socket_nosignal_)\n                  nosigpipe_set,\n#else\n                  -1,\n#endif\n                  0);\n    int ni_ret = MHD_socket_noninheritable_ (fd);\n    /* Log result of making socket non-inheritable */\n    MHD_log_probe(\"after_noninheritable\", pf, fd, cloexec_set,\n#if defined(SOCK_NOSIGPIPE) || defined(MHD_socket_nosignal_)\n                  nosigpipe_set,\n#else\n                  -1,\n#endif\n                  ni_ret);\n  }\n\n  return fd;\n}\n"
}