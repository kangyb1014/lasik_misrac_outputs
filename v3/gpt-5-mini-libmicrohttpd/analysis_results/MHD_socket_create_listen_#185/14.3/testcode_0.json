{
  "user_message": "<misra_rule>\nMISRA C 2023 Rule 14.3 is: Controlling expressions shall not be invariant.\nHere are exceptions to this rule:\n1. Invariants that are used to create infinite loops are permitted.\n2. A do-while loop with an essentially Boolean controlling expression that evaluates to false and satisfies the constraints and semantics for an integer constant expression is permitted.\n</misra_rule>\n\nAnother agent reported that the target code violated the Rule 14.3.\nHere is the comment from the agent.\n<violation scenario>\nWhen the translation unit is built such that SOCK_NOSIGPIPE_OR_ZERO != 0 (so nosigpipe_set is initialized to true and never modified), the controlling expression becomes constant false because (! nosigpipe_set) is always false (short-circuiting makes the whole conjunction false). In that configuration the if condition is invariant and therefore violates MISRA C 2023 Rule 14.3.\n</violation scenario>\n\nYour job is to insert logging code to capture the control flow and state information of the program.\nInsert logging code so that other agents can reproduce and get evidence for the violation scenario.\n<response format>\n- test_code: a modified MHD_socket_create_listen_ code that contains useful probe functions that print useful logs to a file \"/tmp/logs/1855.txt\". The logs should contain the control path and state information of the violation scenario. If test code is not required to validate the scenario, you can leave this blank.\nHere are the constraints for the test code:\n- The test code MUST preserve the original logic of MHD_socket_create_listen_ as much as possible.\nYou CAN just insert probe functions to the original code.\n- DO NOT introduce new violations to demonstrate your scenario.\n- The test code MUST be compilable and executable.\n- The test code MUST include line breaks.\n- You MUST NOT define the main function.\n- You MUST NOT define macros.\n</response format>\n<target_code>\nHere is the code of MHD_socket_create_listen_:\n```c\nMHD_socket\nMHD_socket_create_listen_ (int pf)\n{\n  MHD_socket fd;\n  int cloexec_set;\n#if defined(SOCK_NOSIGPIPE) || defined(MHD_socket_nosignal_)\n  int nosigpipe_set;\n#endif /* SOCK_NOSIGPIPE ||  MHD_socket_nosignal_ */\n\n#if defined(MHD_POSIX_SOCKETS) && (defined(SOCK_CLOEXEC) || \\\n  defined(SOCK_NOSIGPIPE) )\n\n  fd = socket (pf,\n               SOCK_STREAM | SOCK_CLOEXEC | SOCK_NOSIGPIPE_OR_ZERO,\n               0);\n  cloexec_set = (SOCK_CLOEXEC_OR_ZERO != 0);\n#if defined(SOCK_NOSIGPIPE) || defined(MHD_socket_nosignal_)\n  nosigpipe_set = (SOCK_NOSIGPIPE_OR_ZERO != 0);\n#endif /* SOCK_NOSIGPIPE ||  MHD_socket_nosignal_ */\n#elif defined(MHD_WINSOCK_SOCKETS) && defined(WSA_FLAG_NO_HANDLE_INHERIT)\n  fd = WSASocketW (pf,\n                   SOCK_STREAM,\n                   0,\n                   NULL,\n                   0,\n                   WSA_FLAG_OVERLAPPED | WSA_FLAG_NO_HANDLE_INHERIT);\n  cloexec_set = ! 0;\n#else  /* No special socket init function / flags */\n  fd = MHD_INVALID_SOCKET;\n  cloexec_set = 0;\n#if defined(SOCK_NOSIGPIPE) || defined(MHD_socket_nosignal_)\n  nosigpipe_set = 0;\n#endif /* SOCK_NOSIGPIPE ||  MHD_socket_nosignal_ */\n#endif /* No special socket init function / flags */\n  if (MHD_INVALID_SOCKET == fd)\n  {\n    fd = socket (pf,\n                 SOCK_STREAM,\n                 0);\n    cloexec_set = 0;\n#if defined(SOCK_NOSIGPIPE) || defined(MHD_socket_nosignal_)\n    nosigpipe_set = 0;\n#endif /* SOCK_NOSIGPIPE ||  MHD_socket_nosignal_ */\n  }\n  if (MHD_INVALID_SOCKET == fd)\n    return MHD_INVALID_SOCKET;\n\n#if defined(MHD_socket_nosignal_)\n  if ( (! nosigpipe_set) &&\n       (0 == MHD_socket_nosignal_ (fd)) &&\n       (0 == MSG_NOSIGNAL_OR_ZERO) )\n  {\n    /* SIGPIPE disable is possible on this platform\n     * (so application expect that it will be disabled),\n     * but failed to be disabled here and it is not\n     * possible to disable SIGPIPE by MSG_NOSIGNAL. */\n    const int err = MHD_socket_get_error_ ();\n    (void) MHD_socket_close_ (fd);\n    MHD_socket_fset_error_ (err);\n    return MHD_INVALID_SOCKET;\n  }\n#endif /* defined(MHD_socket_nosignal_) */\n  if (! cloexec_set)\n    (void) MHD_socket_noninheritable_ (fd);\n\n  return fd;\n}\n```\n</target_code>\nPlease provide the modified MHD_socket_create_listen_ code.\n",
  "test_code": "/* Added logging helpers for probing control flow and state. */\n#include <stdio.h>\n#include <stdarg.h>\n\nstatic void MHD_log_probe_(const char *fmt, ...)\n{\n    va_list ap;\n    FILE *f = fopen(\"/tmp/logs/1855.txt\", \"a\");\n    if (f == NULL)\n    {\n        return;\n    }\n    va_start(ap, fmt);\n    (void) vfprintf(f, fmt, ap);\n    va_end(ap);\n    (void) fprintf(f, \"\\n\");\n    (void) fclose(f);\n}\n\nMHD_socket\nMHD_socket_create_listen_ (int pf)\n{\n  MHD_socket fd;\n  int cloexec_set;\n#if defined(SOCK_NOSIGPIPE) || defined(MHD_socket_nosignal_)\n  int nosigpipe_set;\n#endif /* SOCK_NOSIGPIPE ||  MHD_socket_nosignal_ */\n\n  MHD_log_probe_(\"ENTER: MHD_socket_create_listen_ pf=%d\", pf);\n\n#if defined(MHD_POSIX_SOCKETS) && (defined(SOCK_CLOEXEC) || \\\n  defined(SOCK_NOSIGPIPE) )\n\n  fd = socket (pf,\n               SOCK_STREAM | SOCK_CLOEXEC | SOCK_NOSIGPIPE_OR_ZERO,\n               0);\n  cloexec_set = (SOCK_CLOEXEC_OR_ZERO != 0);\n#if defined(SOCK_NOSIGPIPE) || defined(MHD_socket_nosignal_)\n  nosigpipe_set = (SOCK_NOSIGPIPE_OR_ZERO != 0);\n#endif /* SOCK_NOSIGPIPE ||  MHD_socket_nosignal_ */\n  MHD_log_probe_(\"AFTER socket(init flags): fd=%lld, cloexec_set=%d\"\n                 , (long long) fd, cloexec_set);\n#if defined(SOCK_NOSIGPIPE) || defined(MHD_socket_nosignal_)\n  MHD_log_probe_(\"AFTER socket(init flags): nosigpipe_set=%d\", nosigpipe_set);\n#endif\n\n#elif defined(MHD_WINSOCK_SOCKETS) && defined(WSA_FLAG_NO_HANDLE_INHERIT)\n  fd = WSASocketW (pf,\n                   SOCK_STREAM,\n                   0,\n                   NULL,\n                   0,\n                   WSA_FLAG_OVERLAPPED | WSA_FLAG_NO_HANDLE_INHERIT);\n  cloexec_set = ! 0;\n  MHD_log_probe_(\"AFTER WSASocketW: fd=%lld, cloexec_set=%d\"\n                 , (long long) fd, cloexec_set);\n#else  /* No special socket init function / flags */\n  fd = MHD_INVALID_SOCKET;\n  cloexec_set = 0;\n#if defined(SOCK_NOSIGPIPE) || defined(MHD_socket_nosignal_)\n  nosigpipe_set = 0;\n#endif /* SOCK_NOSIGPIPE ||  MHD_socket_nosignal_ */\n  MHD_log_probe_(\"NO special socket init: fd set to MHD_INVALID_SOCKET, cloexec_set=0\");\n#if defined(SOCK_NOSIGPIPE) || defined(MHD_socket_nosignal_)\n  MHD_log_probe_(\"NO special socket init: nosigpipe_set=0\");\n#endif\n#endif /* No special socket init function / flags */\n  if (MHD_INVALID_SOCKET == fd)\n  {\n    MHD_log_probe_(\"FD invalid, attempting fallback socket(pf=%d)\", pf);\n    fd = socket (pf,\n                 SOCK_STREAM,\n                 0);\n    cloexec_set = 0;\n#if defined(SOCK_NOSIGPIPE) || defined(MHD_socket_nosignal_)\n    nosigpipe_set = 0;\n    MHD_log_probe_(\"After fallback socket: fd=%lld, cloexec_set=0, nosigpipe_set=0\",\n                   (long long) fd);\n#else\n    MHD_log_probe_(\"After fallback socket: fd=%lld, cloexec_set=0\",\n                   (long long) fd);\n#endif /* SOCK_NOSIGPIPE ||  MHD_socket_nosignal_ */\n  }\n  if (MHD_INVALID_SOCKET == fd)\n  {\n    MHD_log_probe_(\"RETURN: MHD_INVALID_SOCKET\");\n    return MHD_INVALID_SOCKET;\n  }\n\n#if defined(MHD_socket_nosignal_)\n  /* We must not change the number of calls to MHD_socket_nosignal_ compared to\n   * the original logic. Evaluate it only when (! nosigpipe_set) is true and\n   * capture the result for logging and for the combined condition. */\n  {\n    int mhd_nosig_result = 1; /* non-zero means failure-to-disable from this call perspective */\n    if (! nosigpipe_set)\n    {\n      /* Call exactly once, as in original code's second clause. */\n      mhd_nosig_result = MHD_socket_nosignal_ (fd);\n      MHD_log_probe_(\"EVALUATE: nosigpipe_set=%d, MHD_socket_nosignal_(fd)=%d, MSG_NOSIGNAL_OR_ZERO=%d\",\n                     nosigpipe_set, mhd_nosig_result, (int) MSG_NOSIGNAL_OR_ZERO);\n    }\n    else\n    {\n      MHD_log_probe_(\"SKIP MHD_socket_nosignal_ call because nosigpipe_set=%d\", nosigpipe_set);\n    }\n\n    if ( (! nosigpipe_set) &&\n         (0 == mhd_nosig_result) &&\n         (0 == MSG_NOSIGNAL_OR_ZERO) )\n    {\n      MHD_log_probe_(\"ERROR PATH: SIGPIPE disable expected but failed; fetching error and closing fd=%lld\",\n                     (long long) fd);\n      /* SIGPIPE disable is possible on this platform\n       * (so application expect that it will be disabled),\n       * but failed to be disabled here and it is not\n       * possible to disable SIGPIPE by MSG_NOSIGNAL. */\n      const int err = MHD_socket_get_error_ ();\n      (void) MHD_socket_close_ (fd);\n      MHD_socket_fset_error_ (err);\n      MHD_log_probe_(\"RETURN: MHD_INVALID_SOCKET after SIGPIPE disable failure, saved err=%d\", err);\n      return MHD_INVALID_SOCKET;\n    }\n    else\n    {\n      MHD_log_probe_(\"SIGPIPE path OK or not applicable: nosigpipe_set=%d, mhd_nosig_result=%d, MSG_NOSIGNAL_OR_ZERO=%d\",\n                     nosigpipe_set, mhd_nosig_result, (int) MSG_NOSIGNAL_OR_ZERO);\n    }\n  }\n#endif /* defined(MHD_socket_nosignal_) */\n  if (! cloexec_set)\n  {\n    MHD_log_probe_(\"Setting noninheritable on fd=%lld because cloexec_set=%d\", (long long) fd, cloexec_set);\n    (void) MHD_socket_noninheritable_ (fd);\n  }\n\n  MHD_log_probe_(\"RETURN fd=%lld, cloexec_set=%d\", (long long) fd, cloexec_set);\n\n  return fd;\n}\n"
}