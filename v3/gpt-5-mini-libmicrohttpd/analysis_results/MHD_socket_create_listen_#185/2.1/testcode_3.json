{
  "user_message": "<misra_rule>\nMISRA C 2023 Rule 2.1 is: A project shall not contain unreachable code.\n\n</misra_rule>\n\nAnother agent reported that the target code violated the Rule 2.1.\nHere is the comment from the agent.\n<violation scenario>\nWhen the project is built with MHD_WINSOCK_SOCKETS and WSA_FLAG_NO_HANDLE_INHERIT defined (the Windows branch), cloexec_set is unconditionally set to true (!0). Therefore the test if (!cloexec_set) is always false and the call to MHD_socket_noninheritable_(fd) can never be executed (unreachable). A similar unreachable case can occur on POSIX builds if SOCK_CLOEXEC_OR_ZERO is a non\u2011zero constant, making cloexec_set always true.\n</violation scenario>\n\nYour job is to insert logging code to capture the control flow and state information of the program.\nInsert logging code so that other agents can reproduce and get evidence for the violation scenario.\n<response format>\n- test_code: a modified MHD_socket_create_listen_ code that contains useful probe functions that print useful logs to a file \"/tmp/logs/1851.txt\". The logs should contain the control path and state information of the violation scenario. If test code is not required to validate the scenario, you can leave this blank.\nHere are the constraints for the test code:\n- The test code MUST preserve the original logic of MHD_socket_create_listen_ as much as possible.\nYou CAN just insert probe functions to the original code.\n- DO NOT introduce new violations to demonstrate your scenario.\n- The test code MUST be compilable and executable.\n- The test code MUST include line breaks.\n- You MUST NOT define the main function.\n- You MUST NOT define macros.\n</response format>\n<target_code>\nHere is the code of MHD_socket_create_listen_:\n```c\nMHD_socket\nMHD_socket_create_listen_ (int pf)\n{\n  MHD_socket fd;\n  int cloexec_set;\n#if defined(SOCK_NOSIGPIPE) || defined(MHD_socket_nosignal_)\n  int nosigpipe_set;\n#endif /* SOCK_NOSIGPIPE ||  MHD_socket_nosignal_ */\n\n#if defined(MHD_POSIX_SOCKETS) && (defined(SOCK_CLOEXEC) || \\\n  defined(SOCK_NOSIGPIPE) )\n\n  fd = socket (pf,\n               SOCK_STREAM | SOCK_CLOEXEC | SOCK_NOSIGPIPE_OR_ZERO,\n               0);\n  cloexec_set = (SOCK_CLOEXEC_OR_ZERO != 0);\n#if defined(SOCK_NOSIGPIPE) || defined(MHD_socket_nosignal_)\n  nosigpipe_set = (SOCK_NOSIGPIPE_OR_ZERO != 0);\n#endif /* SOCK_NOSIGPIPE ||  MHD_socket_nosignal_ */\n#elif defined(MHD_WINSOCK_SOCKETS) && defined(WSA_FLAG_NO_HANDLE_INHERIT)\n  fd = WSASocketW (pf,\n                   SOCK_STREAM,\n                   0,\n                   NULL,\n                   0,\n                   WSA_FLAG_OVERLAPPED | WSA_FLAG_NO_HANDLE_INHERIT);\n  cloexec_set = ! 0;\n#else  /* No special socket init function / flags */\n  fd = MHD_INVALID_SOCKET;\n  cloexec_set = 0;\n#if defined(SOCK_NOSIGPIPE) || defined(MHD_socket_nosignal_)\n  nosigpipe_set = 0;\n#endif /* SOCK_NOSIGPIPE ||  MHD_socket_nosignal_ */\n#endif /* No special socket init function / flags */\n  if (MHD_INVALID_SOCKET == fd)\n  {\n    fd = socket (pf,\n                 SOCK_STREAM,\n                 0);\n    cloexec_set = 0;\n#if defined(SOCK_NOSIGPIPE) || defined(MHD_socket_nosignal_)\n    nosigpipe_set = 0;\n#endif /* SOCK_NOSIGPIPE ||  MHD_socket_nosignal_ */\n  }\n  if (MHD_INVALID_SOCKET == fd)\n    return MHD_INVALID_SOCKET;\n\n#if defined(MHD_socket_nosignal_)\n  if ( (! nosigpipe_set) &&\n       (0 == MHD_socket_nosignal_ (fd)) &&\n       (0 == MSG_NOSIGNAL_OR_ZERO) )\n  {\n    /* SIGPIPE disable is possible on this platform\n     * (so application expect that it will be disabled),\n     * but failed to be disabled here and it is not\n     * possible to disable SIGPIPE by MSG_NOSIGNAL. */\n    const int err = MHD_socket_get_error_ ();\n    (void) MHD_socket_close_ (fd);\n    MHD_socket_fset_error_ (err);\n    return MHD_INVALID_SOCKET;\n  }\n#endif /* defined(MHD_socket_nosignal_) */\n  if (! cloexec_set)\n    (void) MHD_socket_noninheritable_ (fd);\n\n  return fd;\n}\n```\n</target_code>\nPlease provide the modified MHD_socket_create_listen_ code.\n",
  "test_code": "#include <stdio.h>\n#include <stdint.h>\n#include <inttypes.h>\n\n/* Probe logging helper: append human-readable state to /tmp/logs/1851.txt */\nstatic void\nMHD_log_probe_state_ (const char *where, void *fd_ptr, int cloexec_set, int nosigpipe_set)\n{\n  FILE *f = fopen(\"/tmp/logs/1851.txt\", \"a\");\n  if (f)\n    {\n      /* fd may be an integer or a handle; print its value as uintptr_t */\n      uintptr_t fd_val = (uintptr_t) fd_ptr;\n      fprintf (f, \"%s: fd=0x%\" PRIxPTR \", cloexec_set=%d, nosigpipe_set=%d\\n\",\n               where, fd_val, cloexec_set, nosigpipe_set);\n      fclose (f);\n    }\n}\n\nMHD_socket\nMHD_socket_create_listen_ (int pf)\n{\n  MHD_socket fd;\n  int cloexec_set;\n#if defined(SOCK_NOSIGPIPE) || defined(MHD_socket_nosignal_)\n  int nosigpipe_set;\n#endif /* SOCK_NOSIGPIPE ||  MHD_socket_nosignal_ */\n\n#if defined(MHD_POSIX_SOCKETS) && (defined(SOCK_CLOEXEC) || \\\n  defined(SOCK_NOSIGPIPE) )\n\n  fd = socket (pf,\n               SOCK_STREAM | SOCK_CLOEXEC | SOCK_NOSIGPIPE_OR_ZERO,\n               0);\n  cloexec_set = (SOCK_CLOEXEC_OR_ZERO != 0);\n#if defined(SOCK_NOSIGPIPE) || defined(MHD_socket_nosignal_)\n  nosigpipe_set = (SOCK_NOSIGPIPE_OR_ZERO != 0);\n#endif /* SOCK_NOSIGPIPE ||  MHD_socket_nosignal_ */\n\n  /* Log state after POSIX-special socket creation attempt */\n  MHD_log_probe_state_(\"after_posix_socket_init\", (void *) (uintptr_t) fd, cloexec_set,\n#if defined(SOCK_NOSIGPIPE) || defined(MHD_socket_nosignal_)\n                       nosigpipe_set\n#else\n                       -1\n#endif\n                       );\n#elif defined(MHD_WINSOCK_SOCKETS) && defined(WSA_FLAG_NO_HANDLE_INHERIT)\n  fd = WSASocketW (pf,\n                   SOCK_STREAM,\n                   0,\n                   NULL,\n                   0,\n                   WSA_FLAG_OVERLAPPED | WSA_FLAG_NO_HANDLE_INHERIT);\n  /* According to the original logic this is unconditionally true here. */\n  cloexec_set = ! 0;\n\n  /* Log state after Windows WSASocket init */\n  MHD_log_probe_state_(\"after_winsock_init\", (void *) (uintptr_t) fd, cloexec_set, -1);\n#else  /* No special socket init function / flags */\n  fd = MHD_INVALID_SOCKET;\n  cloexec_set = 0;\n#if defined(SOCK_NOSIGPIPE) || defined(MHD_socket_nosignal_)\n  nosigpipe_set = 0;\n#endif /* SOCK_NOSIGPIPE ||  MHD_socket_nosignal_ */\n\n  /* Log state for no-special-init branch */\n  MHD_log_probe_state_(\"no_special_init\", (void *) (uintptr_t) fd, cloexec_set,\n#if defined(SOCK_NOSIGPIPE) || defined(MHD_socket_nosignal_)\n                       nosigpipe_set\n#else\n                       -1\n#endif\n                       );\n#endif /* No special socket init function / flags */\n  if (MHD_INVALID_SOCKET == fd)\n  {\n    fd = socket (pf,\n                 SOCK_STREAM,\n                 0);\n    cloexec_set = 0;\n#if defined(SOCK_NOSIGPIPE) || defined(MHD_socket_nosignal_)\n    nosigpipe_set = 0;\n#endif /* SOCK_NOSIGPIPE ||  MHD_socket_nosignal_ */\n\n    /* Log state after fallback socket() call */\n    MHD_log_probe_state_(\"after_fallback_socket\", (void *) (uintptr_t) fd, cloexec_set,\n#if defined(SOCK_NOSIGPIPE) || defined(MHD_socket_nosignal_)\n                         nosigpipe_set\n#else\n                         -1\n#endif\n                         );\n  }\n  if (MHD_INVALID_SOCKET == fd)\n  {\n    MHD_log_probe_state_(\"returning_invalid_socket_pre\", (void *) (uintptr_t) fd, cloexec_set,\n#if defined(SOCK_NOSIGPIPE) || defined(MHD_socket_nosignal_)\n                         nosigpipe_set\n#else\n                         -1\n#endif\n                         );\n    return MHD_INVALID_SOCKET;\n  }\n\n#if defined(MHD_socket_nosignal_)\n  if ( (! nosigpipe_set) &&\n       (0 == MHD_socket_nosignal_ (fd)) &&\n       (0 == MSG_NOSIGNAL_OR_ZERO) )\n  {\n    /* SIGPIPE disable is possible on this platform\n     * (so application expect that it will be disabled),\n     * but failed to be disabled here and it is not\n     * possible to disable SIGPIPE by MSG_NOSIGNAL. */\n    const int err = MHD_socket_get_error_ ();\n    (void) MHD_socket_close_ (fd);\n    MHD_socket_fset_error_ (err);\n\n    /* Log state for nosignal failure path */\n    MHD_log_probe_state_(\"nosigpipe_failure\", (void *) (uintptr_t) fd, cloexec_set, nosigpipe_set);\n    return MHD_INVALID_SOCKET;\n  }\n#endif /* defined(MHD_socket_nosignal_) */\n\n  /* Before attempting to make the socket non-inheritable, record whether the\n     cloexec flag was observed as set. On Windows branch with\n     WSA_FLAG_NO_HANDLE_INHERIT this will be true unconditionally; on POSIX\n     builds it depends on SOCK_CLOEXEC_OR_ZERO. */\n  MHD_log_probe_state_(\"before_noninheritable_check\", (void *) (uintptr_t) fd, cloexec_set,\n#if defined(SOCK_NOSIGPIPE) || defined(MHD_socket_nosignal_)\n                       nosigpipe_set\n#else\n                       -1\n#endif\n                       );\n\n  if (! cloexec_set)\n    (void) MHD_socket_noninheritable_ (fd);\n\n  MHD_log_probe_state_(\"returning_valid_socket\", (void *) (uintptr_t) fd, cloexec_set,\n#if defined(SOCK_NOSIGPIPE) || defined(MHD_socket_nosignal_)\n                       nosigpipe_set\n#else\n                       -1\n#endif\n                       );\n\n  return fd;\n}\n"
}