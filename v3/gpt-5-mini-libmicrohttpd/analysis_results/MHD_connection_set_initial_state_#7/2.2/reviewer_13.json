{
  "user_message": "An agent A claimed that the following MHD_connection_set_initial_state_ code violates the MISRA C 2023 rule 2.2.\n<misra_rule>\nMISRA C 2023 Rule 2.2 is A project shall not contain dead code.\nAny operation that is executed but whose removal would not affect program behaviour constitutes dead code. Notes:\n1. The behaviour of an embedded sytem is often determined not just by the nature of its actions, but also by the time at which they occur.\n2. unreachable code is not dead code, as it cannot be executed.\n3.Initialization is not the same as an assignment operation and is therfore not a candidate for dead code.\n</misra_rule>\n<target_code>\nHere is the original code of MHD_connection_set_initial_state_.\n```c\nvoid\nMHD_connection_set_initial_state_ (struct MHD_Connection *c)\n{\n  size_t read_buf_size;\n\n#ifdef HTTPS_SUPPORT\n  mhd_assert ( (0 == (c->daemon->options & MHD_USE_TLS)) || \\\n               (MHD_TLS_CONN_INIT == c->tls_state) );\n  mhd_assert ( (0 != (c->daemon->options & MHD_USE_TLS)) || \\\n               (MHD_TLS_CONN_NO_TLS == c->tls_state) );\n#endif /* HTTPS_SUPPORT */\n  mhd_assert (MHD_CONNECTION_INIT == c->state);\n\n  c->keepalive = MHD_CONN_KEEPALIVE_UNKOWN;\n  c->event_loop_info = MHD_EVENT_LOOP_INFO_READ;\n\n  memset (&c->rq, 0, sizeof(c->rq));\n  memset (&c->rp, 0, sizeof(c->rp));\n\n  c->write_buffer = NULL;\n  c->write_buffer_size = 0;\n  c->write_buffer_send_offset = 0;\n  c->write_buffer_append_offset = 0;\n\n  c->continue_message_write_offset = 0;\n\n  c->read_buffer_offset = 0;\n  read_buf_size = c->daemon->pool_size / 2;\n  c->read_buffer\n    = MHD_pool_allocate (c->pool,\n                         read_buf_size,\n                         false);\n  c->read_buffer_size = read_buf_size;\n}\n```\n</target_code>\n<response format>\nProvide your answer with these fields.\n- explanation: your evaluation of the scenario provided by the agent A.\n- is_report_correct: whether the report is correct or not (true/false). True means there is a violation.\n</response format>\n<scenario>\nThe agent A provided the following violation scenario:\nThe two mhd_assert(...) calls are purely diagnostic checks: they evaluate conditions about c->daemon->options and c->tls_state but do not modify program state. If these conditions are always true in correct operation, removing the assertions (or having mhd_assert compile to a no-op in non-debug builds) would not change observable program behaviour. Therefore these executed checks meet the definition of dead code under MISRA C 2023 Rule 2.2.\n</scenario>\n\n<execution_log>\nThe agent A also provided the following output log:\nENTRY: MHD_connection_set_initial_state_: c=0x55e97f84e1e0\n  daemon=0x55e97f84d8d0 options=0x00080001 tls_state=0 state=0 pool=0x55e97f84e450 pool_size=32768\nASSERT PRECHECK (STATE): state=0 -> cond_state=1\nALLOC: requesting read buffer of size=16384 (daemon->pool_size=32768)\nALLOC RESULT: read_buffer=0x55e97f84e480 read_buffer_size=16384\nEXIT: MHD_connection_set_initial_state_ for c=0x55e97f84e1e0\nENTRY: MHD_connection_set_initial_state_: c=0x55e97f84f490\n  daemon=0x55e97f84d8d0 options=0x00080001 tls_state=0 state=0 pool=0x55e97f84e450 pool_size=32768\nASSERT PRECHECK (STATE): state=0 -> cond_state=1\nALLOC: requesting read buffer of size=16384 (daemon->pool_size=32768)\nALLOC RESULT: read_buffer=0x55e97f856670 read_buffer_size=16384\nEXIT: MHD_connection_set_initial_state_ for c=0x55e97f84f490\nENTRY: MHD_connection_set_initial_state_: c=0x55e97f84f6e0\n  daemon=0x55e97f84d8d0 options=0x00080001 tls_state=0 state=0 pool=0x55e97f84e450 pool_size=32768\nASSERT PRECHECK (STATE): state=0 -> cond_state=1\nALLOC: requesting read buffer of size=16384 (daemon->pool_size=32768)\nALLOC RESULT: read_buffer=0x55e97f856670 read_buffer_size=16384\nEXIT: MHD_connection_set_initial_state_ for c=0x55e97f84f6e0\nENTRY: MHD_connection_set_initial_state_: c=0x55e97f84f930\n  daemon=0x55e97f84d8d0 options=0x00080001 tls_state=0 state=0 pool=0x55e97f84e450 pool_size=32768\nASSERT PRECHECK (STATE): state=0 -> cond_state=1\nALLOC: requesting read buffer of size=16384 (daemon->pool_size=32768)\nALLOC RESULT: read_buffer=0x55e97f856670 read_buffer_size=16384\nEXIT: MHD_connection_set_initial_state_ for c=0x55e97f84f930\nENTRY: MHD_connection_set_initial_state_: c=0x55e97f84fb80\n  daemon=0x55e97f84d8d0 options=0x00080001 tls_state=0 state=0 pool=0x55e97f84e450 pool_size=32768\nASSERT PRECHECK (STATE): state=0 -> cond_state=1\nALLOC: requesting read buffer of size=16384 (daemon->pool_size=32768)\nALLOC RESULT: read_buffer=0x55e97f856670 read_buffer_size=16384\nEXIT: MHD_connection_set_initial_state_ for c=0x55e97f84fb80\nENTRY: MHD_connection_set_initial_state_: c=0x55e97f84fdd0\n  daemon=0x55e97f84d8d0 options=0x00080001 tls_state=0 state=0 pool=0x55e97f84e450 pool_size=32768\nASSERT PRECHECK (STATE): state=0 -> cond_state=1\nALLOC: requesting read buffer of size=16384 (daemon->pool_size=32768)\nALLOC RESULT: read_buffer=0x55e97f856670 read_buffer_size=16384\nEXIT: MHD_connection_set_initial_state_ for c=0x55e97f84fdd0\nENTRY: MHD_connection_set_initial_state_: c=0x55e97f850020\n  daemon=0x55e97f84d8d0 options=0x00080001 tls_state=0 state=0 pool=0x55e97f84e450 pool_size=32768\nASSERT PRECHECK (STATE): state=0 -> cond_state=1\nALLOC: requesting read buffer of size=16384 (daemon->pool_size=32768)\nALLOC RESULT: read_buffer=0x55e97f856670 read_buffer_size=16384\nEXIT: MHD_connection_set_initial_state_ for c=0x55e97f850020\nENTRY: MHD_connection_set_initial_state_: c=0x55e97f850270\n  daemon=0x55e97f84d8d0 options=0x00080001 tls_state=0 state=0 pool=0x55e97f84e450 pool_size=32768\nASSERT PRECHECK (STATE): state=0 -> cond_state=1\nALLOC: requesting read buffer of size=16384 (daemon->pool_size=32768)\nALLOC RESULT: read_buffer=0x55e97f856670 read_buffer_size=16384\nEXIT: MHD_connection_set_initial_state_ for c=0x55e97f850270\nENTRY: MHD_connection_set_initial_state_: c=0x55e97f850270\n  daemon=0x55e97f84d8d0 options=0x00080001 tls_state=0 state=0 pool=0x55e97f84e450 pool_size=32768\nASSERT PRECHECK (STATE): state=0 -> cond_state=1\nALLOC: requesting read buffer of size=16384 (daemon->pool_size=32768)\nALLOC RESULT: read_buffer=0x55e97f856670 read_buffer_size=16384\nEXIT: MHD_connection_set_initial_state_ for c=0x55e97f850270\nENTRY: MHD_connection_set_initial_state_: c=0x55e97f850270\n  daemon=0x55e97f84d8d0 options=0x00080001 tls_state=0 state=0 pool=0x55e97f84e450 pool_size=32768\nASSERT PRECHECK (STATE): state=0 -> cond_state=1\nALLOC: requesting read buffer of size=16384 (daemon->pool_size=32768)\nALLOC RESULT: read_buffer=0x55e97f856670 read_buffer_size=16384\nEXIT: MHD_connection_set_initial_state_ for c=0x55e97f850270\nENTRY: MHD_connection_set_initial_state_: c=0x55e97f850270\n  daemon=0x55e97f\n</execution_log>\n\n<instruction>\nJudge whether the report is correct or not.\n</instruction>\n",
  "is_report_correct": false,
  "explanation": "The report is not correct. Rule 2.2 forbids executed operations whose removal would not affect program behaviour. The two mhd_assert(...) calls are diagnostic/runtime checks that are executed and do have observable effects in at least some builds: they produce logging (see the execution log lines like \"ASSERT PRECHECK (STATE): ...\") and typically may abort the program on failure. Removing them would therefore change observable behaviour (logging, and the possibility of abort on invariant violation). Even if in a particular correct run the checked conditions always hold, the assertions are not inert: they document invariants, produce diagnostics, and may change control flow on failure. If mhd_assert is implemented as a macro that compiles to a no-op in some build configurations, then in those builds the assertions are not executed at all and therefore cannot be classified as dead code under Rule 2.2 (the rule targets executed operations). In short, these assertions are not dead code under MISRA C 2023 Rule 2.2, so the reported violation is incorrect."
}