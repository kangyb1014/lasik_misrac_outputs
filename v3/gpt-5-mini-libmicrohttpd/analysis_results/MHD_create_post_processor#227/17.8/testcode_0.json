{
  "user_message": "<misra_rule>\nMISRA C 2023 Rule 17.8 is: A function parameter should not be modified.\nNote that the object referred to by a pointer parameter may be modified, but the pointer itself shall not be modified.\n</misra_rule>\n\nAnother agent reported that the target code violated the Rule 17.8.\nHere is the comment from the agent.\n<violation scenario>\nThe function parameter 'buffer_size' is modified with the statement 'buffer_size += 4;', which violates MISRA C 2023 Rule 17.8 (a function parameter should not be modified).\n</violation scenario>\n\nYour job is to insert logging code to capture the control flow and state information of the program.\nInsert logging code so that other agents can reproduce and get evidence for the violation scenario.\n<response format>\n- test_code: a modified MHD_create_post_processor code that contains useful probe functions that print useful logs to a file \"/tmp/logs/2277.txt\". The logs should contain the control path and state information of the violation scenario. If test code is not required to validate the scenario, you can leave this blank.\nHere are the constraints for the test code:\n- The test code MUST preserve the original logic of MHD_create_post_processor as much as possible.\nYou CAN just insert probe functions to the original code.\n- DO NOT introduce new violations to demonstrate your scenario.\n- The test code MUST be compilable and executable.\n- The test code MUST include line breaks.\n- You MUST NOT define the main function.\n- You MUST NOT define macros.\n</response format>\n<target_code>\nHere is the code of MHD_create_post_processor:\n```c\n_MHD_EXTERN struct MHD_PostProcessor *\nMHD_create_post_processor (struct MHD_Connection *connection,\n                           size_t buffer_size,\n                           MHD_PostDataIterator iter,\n                           void *iter_cls)\n{\n  struct MHD_PostProcessor *ret;\n  const char *encoding;\n  const char *boundary;\n  size_t blen;\n\n  if ( (buffer_size < 256) ||\n       (NULL == connection) ||\n       (NULL == iter))\n    MHD_PANIC (_ (\"libmicrohttpd API violation.\\n\"));\n  encoding = NULL;\n  if (MHD_NO ==\n      MHD_lookup_connection_value_n (connection,\n                                     MHD_HEADER_KIND,\n                                     MHD_HTTP_HEADER_CONTENT_TYPE,\n                                     MHD_STATICSTR_LEN_ (\n                                       MHD_HTTP_HEADER_CONTENT_TYPE),\n                                     &encoding,\n                                     NULL))\n    return NULL;\n  mhd_assert (NULL != encoding);\n  boundary = NULL;\n  if (! MHD_str_equal_caseless_n_ (MHD_HTTP_POST_ENCODING_FORM_URLENCODED,\n                                   encoding,\n                                   MHD_STATICSTR_LEN_ (\n                                     MHD_HTTP_POST_ENCODING_FORM_URLENCODED)))\n  {\n    if (! MHD_str_equal_caseless_n_ (MHD_HTTP_POST_ENCODING_MULTIPART_FORMDATA,\n                                     encoding,\n                                     MHD_STATICSTR_LEN_ (\n                                       MHD_HTTP_POST_ENCODING_MULTIPART_FORMDATA)))\n      return NULL;\n    boundary =\n      &encoding[MHD_STATICSTR_LEN_ (MHD_HTTP_POST_ENCODING_MULTIPART_FORMDATA)];\n    /* Q: should this be \"strcasestr\"? */\n    boundary = strstr (boundary, \"boundary=\");\n    if (NULL == boundary)\n      return NULL; /* failed to determine boundary */\n    boundary += MHD_STATICSTR_LEN_ (\"boundary=\");\n    blen = strlen (boundary);\n    if ( (blen < 2) ||\n         (blen * 2 + 2 > buffer_size) )\n      return NULL;              /* (will be) out of memory or invalid boundary */\n    if ( (boundary[0] == '\"') &&\n         (boundary[blen - 1] == '\"') )\n    {\n      /* remove enclosing quotes */\n      ++boundary;\n      blen -= 2;\n    }\n  }\n  else\n    blen = 0;\n  buffer_size += 4; /* round up to get nice block sizes despite boundary search */\n\n  /* add +1 to ensure we ALWAYS have a zero-termination at the end */\n  if (NULL == (ret = MHD_calloc_ (1, sizeof (struct MHD_PostProcessor)\n                                  + buffer_size + 1)))\n    return NULL;\n  ret->connection = connection;\n  ret->ikvi = iter;\n  ret->cls = iter_cls;\n  ret->encoding = encoding;\n  ret->buffer_size = buffer_size;\n  ret->state = PP_Init;\n  ret->blen = blen;\n  ret->boundary = boundary;\n  ret->skip_rn = RN_Inactive;\n  return ret;\n}\n```\n</target_code>\nPlease provide the modified MHD_create_post_processor code.\n",
  "test_code": "#include <stdio.h>\n#include <stdarg.h>\n#include <stddef.h>\n\n/* Probe logging helper: append logs to /tmp/logs/2277.txt */\nstatic void mhd_log_probe(const char *fmt, ...)\n{\n  FILE *f = fopen(\"/tmp/logs/2277.txt\", \"a\");\n  if (NULL == f)\n    return;\n  va_list ap;\n  va_start(ap, fmt);\n  vfprintf(f, fmt, ap);\n  va_end(ap);\n  fputc('\\n', f);\n  fclose(f);\n}\n\n_MHD_EXTERN struct MHD_PostProcessor *\nMHD_create_post_processor (struct MHD_Connection *connection,\n                           size_t buffer_size,\n                           MHD_PostDataIterator iter,\n                           void *iter_cls)\n{\n  struct MHD_PostProcessor *ret;\n  const char *encoding;\n  const char *boundary;\n  size_t blen;\n\n  /* Log entry state */\n  mhd_log_probe(\"ENTER: MHD_create_post_processor: connection=%p buffer_size=%zu iter=%p iter_cls=%p\",\n                (void *)connection, buffer_size, (void *)iter, iter_cls);\n\n  if ( (buffer_size < 256) ||\n       (NULL == connection) ||\n       (NULL == iter))\n    {\n      mhd_log_probe(\"PANIC: API violation detected: connection=%p buffer_size=%zu iter=%p\",\n                    (void *)connection, buffer_size, (void *)iter);\n      MHD_PANIC (_ (\"libmicrohttpd API violation.\\n\"));\n    }\n  encoding = NULL;\n  if (MHD_NO ==\n      MHD_lookup_connection_value_n (connection,\n                                     MHD_HEADER_KIND,\n                                     MHD_HTTP_HEADER_CONTENT_TYPE,\n                                     MHD_STATICSTR_LEN_ (\n                                       MHD_HTTP_HEADER_CONTENT_TYPE),\n                                     &encoding,\n                                     NULL))\n    {\n      mhd_log_probe(\"RETURN NULL: no Content-Type header found\");\n      return NULL;\n    }\n  mhd_assert (NULL != encoding);\n  mhd_log_probe(\"Content-Type header: encoding=%p%s\",\n                (void *)encoding, (encoding != NULL) ? (\" (string present)\") : (\" (NULL)\"));\n\n  boundary = NULL;\n  if (! MHD_str_equal_caseless_n_ (MHD_HTTP_POST_ENCODING_FORM_URLENCODED,\n                                   encoding,\n                                   MHD_STATICSTR_LEN_ (\n                                     MHD_HTTP_POST_ENCODING_FORM_URLENCODED)))\n  {\n    if (! MHD_str_equal_caseless_n_ (MHD_HTTP_POST_ENCODING_MULTIPART_FORMDATA,\n                                     encoding,\n                                     MHD_STATICSTR_LEN_ (\n                                       MHD_HTTP_POST_ENCODING_MULTIPART_FORMDATA)))\n      {\n        mhd_log_probe(\"RETURN NULL: Content-Type not form-urlencoded nor multipart/form-data: encoding=%p\",\n                      (void *)encoding);\n        return NULL;\n      }\n    boundary =\n      &encoding[MHD_STATICSTR_LEN_ (MHD_HTTP_POST_ENCODING_MULTIPART_FORMDATA)];\n    /* Q: should this be \"strcasestr\"? */\n    boundary = strstr (boundary, \"boundary=\");\n    if (NULL == boundary)\n      {\n        mhd_log_probe(\"RETURN NULL: multipart/form-data but no boundary found\");\n        return NULL; /* failed to determine boundary */\n      }\n    boundary += MHD_STATICSTR_LEN_ (\"boundary=\");\n    blen = strlen (boundary);\n    mhd_log_probe(\"boundary parse: boundary=%p blen=%zu buffer_size=%zu\",\n                  (void *)boundary, blen, buffer_size);\n    if ( (blen < 2) ||\n         (blen * 2 + 2 > buffer_size) )\n      {\n        mhd_log_probe(\"RETURN NULL: invalid or too large boundary: blen=%zu (needs %zu) buffer_size=%zu\",\n                      blen, (size_t)(blen * 2 + 2), buffer_size);\n        return NULL;              /* (will be) out of memory or invalid boundary */\n      }\n    if ( (boundary[0] == '\"') &&\n         (boundary[blen - 1] == '\"') )\n    {\n      /* remove enclosing quotes */\n      ++boundary;\n      blen -= 2;\n      mhd_log_probe(\"boundary quoted: new boundary=%p blen=%zu\", (void *)boundary, blen);\n    }\n  }\n  else\n    blen = 0;\n\n  /* Log just before buffer_size adjustment (this is the reported violation point) */\n  mhd_log_probe(\"BEFORE_ADJUST: buffer_size=%zu (will be modified with '+=' in original code)\",\n                buffer_size);\n\n  buffer_size += 4; /* round up to get nice block sizes despite boundary search */\n\n  /* Log after modification */\n  mhd_log_probe(\"AFTER_ADJUST: buffer_size=%zu (parameter variable was modified)\", buffer_size);\n\n  /* add +1 to ensure we ALWAYS have a zero-termination at the end */\n  if (NULL == (ret = MHD_calloc_ (1, sizeof (struct MHD_PostProcessor)\n                                  + buffer_size + 1)))\n    {\n      mhd_log_probe(\"RETURN NULL: allocation failed for size=%zu\", (size_t)(sizeof (struct MHD_PostProcessor) + buffer_size + 1));\n      return NULL;\n    }\n  ret->connection = connection;\n  ret->ikvi = iter;\n  ret->cls = iter_cls;\n  ret->encoding = encoding;\n  ret->buffer_size = buffer_size;\n  ret->state = PP_Init;\n  ret->blen = blen;\n  ret->boundary = boundary;\n  ret->skip_rn = RN_Inactive;\n\n  mhd_log_probe(\"RETURN ret=%p buffer_size=%zu blen=%zu boundary=%p\",\n                (void *)ret, ret->buffer_size, ret->blen, (void *)ret->boundary);\n  return ret;\n}\n"
}