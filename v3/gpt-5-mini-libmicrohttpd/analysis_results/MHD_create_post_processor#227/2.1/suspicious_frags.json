{
  "user_message": "<misra_rule>\nThe target MISRA C 2023 Rule 2.1 is: A project shall not contain unreachable code.\n\n</misra_rule>\n<instruction>\nOther agents will judge whether the code follows the MISRA C 2023 guidelines.\nThey will investigate the code fragments you give.\nYour job is to find code fragments in the code that should be investigated to check whether the code follows the MISRA C rule.\n</instruction>\n<response format>\nProvide your answer with these fields.\n- suspicious_frags: The list of suspicious code fragments in the code.\nIt should contain only the code fragments exists in the code. If you do not find any suspicious code fragments, return an empty list for suspicious_frags\n- explanation: The explanation of why other code fragments should NOT be investigated.\nIt is very important to not miss any suspicious code fragments, so please give a sufficient explanation why other code fragments should not be investigated.\nDO NOT give any explanation for the selected suspicious code fragments.\n</response format>\n<target_code>\nHere is the code of MHD_create_post_processor:\n```c\n_MHD_EXTERN struct MHD_PostProcessor *\nMHD_create_post_processor (struct MHD_Connection *connection,\n                           size_t buffer_size,\n                           MHD_PostDataIterator iter,\n                           void *iter_cls)\n{\n  struct MHD_PostProcessor *ret;\n  const char *encoding;\n  const char *boundary;\n  size_t blen;\n\n  if ( (buffer_size < 256) ||\n       (NULL == connection) ||\n       (NULL == iter))\n    MHD_PANIC (_ (\"libmicrohttpd API violation.\\n\"));\n  encoding = NULL;\n  if (MHD_NO ==\n      MHD_lookup_connection_value_n (connection,\n                                     MHD_HEADER_KIND,\n                                     MHD_HTTP_HEADER_CONTENT_TYPE,\n                                     MHD_STATICSTR_LEN_ (\n                                       MHD_HTTP_HEADER_CONTENT_TYPE),\n                                     &encoding,\n                                     NULL))\n    return NULL;\n  mhd_assert (NULL != encoding);\n  boundary = NULL;\n  if (! MHD_str_equal_caseless_n_ (MHD_HTTP_POST_ENCODING_FORM_URLENCODED,\n                                   encoding,\n                                   MHD_STATICSTR_LEN_ (\n                                     MHD_HTTP_POST_ENCODING_FORM_URLENCODED)))\n  {\n    if (! MHD_str_equal_caseless_n_ (MHD_HTTP_POST_ENCODING_MULTIPART_FORMDATA,\n                                     encoding,\n                                     MHD_STATICSTR_LEN_ (\n                                       MHD_HTTP_POST_ENCODING_MULTIPART_FORMDATA)))\n      return NULL;\n    boundary =\n      &encoding[MHD_STATICSTR_LEN_ (MHD_HTTP_POST_ENCODING_MULTIPART_FORMDATA)];\n    /* Q: should this be \"strcasestr\"? */\n    boundary = strstr (boundary, \"boundary=\");\n    if (NULL == boundary)\n      return NULL; /* failed to determine boundary */\n    boundary += MHD_STATICSTR_LEN_ (\"boundary=\");\n    blen = strlen (boundary);\n    if ( (blen < 2) ||\n         (blen * 2 + 2 > buffer_size) )\n      return NULL;              /* (will be) out of memory or invalid boundary */\n    if ( (boundary[0] == '\"') &&\n         (boundary[blen - 1] == '\"') )\n    {\n      /* remove enclosing quotes */\n      ++boundary;\n      blen -= 2;\n    }\n  }\n  else\n    blen = 0;\n  buffer_size += 4; /* round up to get nice block sizes despite boundary search */\n\n  /* add +1 to ensure we ALWAYS have a zero-termination at the end */\n  if (NULL == (ret = MHD_calloc_ (1, sizeof (struct MHD_PostProcessor)\n                                  + buffer_size + 1)))\n    return NULL;\n  ret->connection = connection;\n  ret->ikvi = iter;\n  ret->cls = iter_cls;\n  ret->encoding = encoding;\n  ret->buffer_size = buffer_size;\n  ret->state = PP_Init;\n  ret->blen = blen;\n  ret->boundary = boundary;\n  ret->skip_rn = RN_Inactive;\n  return ret;\n}\n```\n</target_code>\nPlease find suspicious code fragments in the code and report them. Other agents can not investigate other fragments that you do not report, so it is very important to find all suspicious fragments without missing any. Report the suspicious fragments AS MUCH AS POSSIBLE.",
  "suspicious_frags": [
    "blen = strlen (boundary);\nif ( (blen < 2) ||\n     (blen * 2 + 2 > buffer_size) )\n  return NULL;              /* (will be) out of memory or invalid boundary */",
    "if ( (buffer_size < 256) ||\n     (NULL == connection) ||\n     (NULL == iter))\n  MHD_PANIC (_ (\"libmicrohttpd API violation.\\n\"));",
    "if ( (boundary[0] == '\"') &&\n     (boundary[blen - 1] == '\"') )\n{\n  /* remove enclosing quotes */\n  ++boundary;\n  blen -= 2;\n}",
    "if (NULL == (ret = MHD_calloc_ (1, sizeof (struct MHD_PostProcessor)\n                                + buffer_size + 1)))\n  return NULL;",
    "mhd_assert (NULL != encoding);",
    "boundary =\n  &encoding[MHD_STATICSTR_LEN_ (MHD_HTTP_POST_ENCODING_MULTIPART_FORMDATA)];\n/* Q: should this be \"strcasestr\"? */\nboundary = strstr (boundary, \"boundary=\");\nif (NULL == boundary)\n  return NULL; /* failed to determine boundary */"
  ],
  "explanation": "I marked the fragments that warrant investigation with respect to unreachable code (MISRA C 2023 Rule 2.1) for the following reasons: - The MHD_PANIC invocation is a macro that often does not return (it may terminate the program or longjmp). Whether it is non-returning affects reachability of subsequent code and should be confirmed. - The mhd_assert call may abort when the condition fails; whether it is active or compiled out changes control flow and reachability, so its semantics should be checked. - The boundary parsing sequence (strstr, NULL check, strlen, size checks, and quoted-boundary handling) contains pointer arithmetic and indexed accesses (boundary[blen - 1]) that could be invalid if assumptions about boundary/blen are violated; such violations could cause control flow to terminate early or lead to undefined behavior that effectively makes later statements unreachable. - The allocation call using MHD_calloc_ followed by return NULL on failure is a normal early-exit path; it is included because macros or wrappers around allocation might be implemented in ways that affect flow (e.g., custom allocator that aborts), which would change reachability of the initialization that follows. All other statements in the function are standard conditional returns or sequential initializations that are reachable given the normal semantics of the helper functions/macros used; they do not by themselves indicate code that is unconditionally unreachable. If the investigators confirm the exact semantics (returning vs non-returning) of the macros/functions above and validate the boundary/blen invariants, then no other fragments need to be examined for unreachable-code concerns."
}