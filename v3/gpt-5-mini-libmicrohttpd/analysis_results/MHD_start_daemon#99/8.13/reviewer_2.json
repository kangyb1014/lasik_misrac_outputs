{
  "user_message": "An agent A claimed that the following MHD_start_daemon code violates the MISRA C 2023 rule 8.13.\n<misra_rule>\nMISRA C 2023 Rule 8.13 is A pointer should point to a const-qualified type whenever possible.\n\n</misra_rule>\n<target_code>\nHere is the original code of MHD_start_daemon.\n```c\n_MHD_EXTERN struct MHD_Daemon *\nMHD_start_daemon (unsigned int flags,\n                  uint16_t port,\n                  MHD_AcceptPolicyCallback apc,\n                  void *apc_cls,\n                  MHD_AccessHandlerCallback dh,\n                  void *dh_cls,\n                  ...)\n{\n  struct MHD_Daemon *daemon;\n  va_list ap;\n\n  va_start (ap,\n            dh_cls);\n  daemon = MHD_start_daemon_va (flags,\n                                port,\n                                apc,\n                                apc_cls,\n                                dh,\n                                dh_cls,\n                                ap);\n  va_end (ap);\n  return daemon;\n}\n```\n</target_code>\n<response format>\nProvide your answer with these fields.\n- explanation: your evaluation of the scenario provided by the agent A.\n- is_report_correct: whether the report is correct or not (true/false). True means there is a violation.\n</response format>\n<scenario>\nThe agent A provided the following violation scenario:\nIf MHD_start_daemon does not modify the object pointed to by apc_cls (it only stores and forwards it to callbacks), then apc_cls should be declared as 'const void *apc_cls'. In that case the current declaration 'void *apc_cls' violates MISRA C 2023 Rule 8.13 because the pointer could/should point to a const-qualified type.\n</scenario>\n\n<execution_log>\nThe agent A also provided the following output log:\nENTER MHD_start_daemon: flags=9, port=0, apc=(nil), apc_cls=(nil), dh=0x562b59b6e7e0, dh_cls=(nil)\nBefore call: apc_cls=(nil)\nAfter call: daemon=0x562b5ec30a00\nAfter call: apc_cls=(nil)\nEXIT MHD_start_daemon: returning daemon=0x562b5ec30a00\nENTER MHD_start_daemon: flags=13, port=0, apc=(nil), apc_cls=(nil), dh=0x562b59b6e7e0, dh_cls=(nil)\nBefore call: apc_cls=(nil)\nAfter call: daemon=0x562b5ec30fc0\nAfter call: apc_cls=(nil)\nEXIT MHD_start_daemon: returning daemon=0x562b5ec30fc0\nENTER MHD_start_daemon: flags=9, port=0, apc=(nil), apc_cls=(nil), dh=0x562b59b6e7e0, dh_cls=(nil)\nBefore call: apc_cls=(nil)\nAfter call: daemon=0x562b5ec31440\nAfter call: apc_cls=(nil)\nEXIT MHD_start_daemon: returning daemon=0x562b5ec31440\nENTER MHD_start_daemon: flags=1, port=0, apc=(nil), apc_cls=(nil), dh=0x562b59b6e7e0, dh_cls=(nil)\nBefore call: apc_cls=(nil)\nAfter call: daemon=0x562b5ec318c0\nAfter call: apc_cls=(nil)\nEXIT MHD_start_daemon: returning daemon=0x562b5ec318c0\nENTER MHD_start_daemon: flags=524289, port=0, apc=(nil), apc_cls=(nil), dh=0x562b59b6e7e0, dh_cls=(nil)\nBefore call: apc_cls=(nil)\nAfter call: daemon=0x562b5ec31f60\nAfter call: apc_cls=(nil)\nEXIT MHD_start_daemon: returning daemon=0x562b5ec31f60\nENTER MHD_start_daemon: flags=73, port=0, apc=(nil), apc_cls=(nil), dh=0x562b59b6e7e0, dh_cls=(nil)\nBefore call: apc_cls=(nil)\nAfter call: daemon=0x562b5ec323a0\nAfter call: apc_cls=(nil)\nEXIT MHD_start_daemon: returning daemon=0x562b5ec323a0\nENTER MHD_start_daemon: flags=77, port=0, apc=(nil), apc_cls=(nil), dh=0x562b59b6e7e0, dh_cls=(nil)\nBefore call: apc_cls=(nil)\nAfter call: daemon=0x562b5ec327e0\nAfter call: apc_cls=(nil)\nEXIT MHD_start_daemon: returning daemon=0x562b5ec327e0\nENTER MHD_start_daemon: flags=73, port=0, apc=(nil), apc_cls=(nil), dh=0x562b59b6e7e0, dh_cls=(nil)\nBefore call: apc_cls=(nil)\nAfter call: daemon=0x562b5ec32c20\nAfter call: apc_cls=(nil)\nEXIT MHD_start_daemon: returning daemon=0x562b5ec32c20\nENTER MHD_start_daemon: flags=521, port=0, apc=(nil), apc_cls=(nil), dh=0x562b59b6e7e0, dh_cls=(nil)\nBefore call: apc_cls=(nil)\nAfter call: daemon=0x562b5ec32c20\nAfter call: apc_cls=(nil)\nEXIT MHD_start_daemon: returning daemon=0x562b5ec32c20\nENTER MHD_start_daemon: flags=521, port=0, apc=(nil), apc_cls=(nil), dh=0x562b59b6e7e0, dh_cls=(nil)\nBefore call: apc_cls=(nil)\nAfter call: daemon=0x562b5ec32c20\nAfter call: apc_cls=(nil)\nEXIT MHD_start_daemon: returning daemon=0x562b5ec32c20\nENTER MHD_start_daemon: flags=1, port=0, apc=(nil), apc_cls=(nil), dh=(nil), dh_cls=(nil)\nBefore call: apc_cls=(nil)\nAfter call: daemon=(nil)\nAfter call: apc_cls=(nil)\nEXIT MHD_start_daemon: returning daemon=(nil)\nENTER MHD_start_daemon: flags=9, port=0, apc=0x557a4a48da40, apc_cls=(nil), dh=0x557a4a48da70, dh_cls=(nil)\nBefore call: apc_cls=(nil)\nAfter call: daemon=0x557a663eea00\nAfter call: apc_cls=(nil)\nEXIT MHD_start_daemon: returning daemon=0x557a663eea00\nENTER MHD_start_daemon: flags=1, port=0, apc=0x557a4a48dab0, apc_cls=(nil), dh=0x557a4a48da70, dh_cls=(nil)\nBefore call: apc_cls=(nil)\nAfter call: daemon=0x557a663eefc0\nAfter call: apc_cls=(nil)\nEXIT MHD_start_daemon: returning daemon=0x557a663eefc0\nENTER MHD_start_daemon: flags=524289, port=0, apc=0x557a4a48dab0, apc_cls=(nil), dh=0x557a4a48da70, dh_cls=(nil)\nBefore call: apc_cls=(nil)\nAfter call: daemon=0x557a663ef440\nAfter call: apc_cls=(nil)\nEXIT MHD_start_daemon: returning daemon=0x557a663ef440\nENTER MHD_start_daemon: flags=9, port=0, apc=0x557a4a48dab0, apc_cls=(nil), dh=0x557a4a48da70, dh_cls=(nil)\nBefore call: apc_cls=(nil)\nAfter call: daemon=0x557a663ef8c0\nAfter call: apc_cls=(nil)\nEXIT MHD_start_daemon: returning daemon=0x557a663ef8c0\nENTER MHD_start_daemon: flags=13, port=0, apc=0x557a4a48dab0, apc_cls=(nil), dh=0x557a4a48da70, dh_cls=(nil)\nBefore call: apc_cls=(nil)\nAfter call: daemon=0x557a663efd40\nAfter call: apc_cls=(nil)\nEXIT MHD_start_daemon: returning daemon=0x557a663efd40\nENTER MHD_start_daemon: flags=524289, port=0, apc=(nil), apc_cls=(nil), dh=0x56526863bca0, dh_cls=0x56528a34e820\nBefore call: apc_cls=(nil)\nAfter call: daemon=0x56528a34eab0\nAfter call: apc_cls=(nil)\nEXI\n</execution_log>\n\n<instruction>\nJudge whether the report is correct or not.\n</instruction>\n",
  "is_report_correct": false,
  "explanation": "Not enough evidence to call this a definite MISRA 8.13 violation. Rule 8.13 recommends that pointer parameters be pointer-to-const when the pointed-to object is not modified. In the shown function MHD_start_daemon the parameter apc_cls is not modified \u2014 it is only forwarded to MHD_start_daemon_va \u2014 so at first glance it could be a candidate for being declared const void *. However you cannot determine compliance from this single translation unit alone: MHD_start_daemon_va and the callback types (MHD_AcceptPolicyCallback / MHD_AccessHandlerCallback) must also accept a pointer-to-const for the change to be possible without introducing casts or breaking the API. If those downstream declarations expect void * (and user callbacks may legitimately modify the context), then changing apc_cls here would be incorrect. The execution log only shows apc_cls values (mostly NULL) and does not prove that the pointed-to object is never modified elsewhere. Therefore Agent A's claim is not conclusively correct \u2014 the code only violates 8.13 if the broader API semantics guarantee the pointed object is immutable and the downstream signatures can be made const; otherwise the current declaration may be intentional and required for API compatibility. Recommend reviewing the signatures/usage of MHD_start_daemon_va and the callbacks; if the context is read-only everywhere, change both prototypes to const void * (or document/justify a deviation)."
}