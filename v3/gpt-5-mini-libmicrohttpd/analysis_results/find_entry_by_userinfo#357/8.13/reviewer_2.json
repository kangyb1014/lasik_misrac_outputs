{
  "user_message": "An agent A claimed that the following find_entry_by_userinfo code violates the MISRA C 2023 rule 8.13.\n<misra_rule>\nMISRA C 2023 Rule 8.13 is A pointer should point to a const-qualified type whenever possible.\n\n</misra_rule>\n<target_code>\nHere is the original code of find_entry_by_userinfo.\n```c\nstatic struct UserEntry *\nfind_entry_by_userinfo (const struct MHD_DigestAuthUsernameInfo *username_info)\n{\n  if (MHD_DIGEST_AUTH_UNAME_TYPE_STANDARD <= username_info->uname_type)\n    return find_entry_by_username (username_info->username);\n\n  if (MHD_DIGEST_AUTH_UNAME_TYPE_USERHASH == username_info->uname_type)\n    return find_entry_by_userhash (username_info->algo3,\n                                   username_info->userhash_bin,\n                                   username_info->userhash_hex_len / 2);\n\n  return NULL; /* Should be unreachable as all cases are covered before */\n}\n```\n</target_code>\n<response format>\nProvide your answer with these fields.\n- explanation: your evaluation of the scenario provided by the agent A.\n- is_report_correct: whether the report is correct or not (true/false). True means there is a violation.\n</response format>\n<scenario>\nThe agent A provided the following violation scenario:\nIf struct MHD_DigestAuthUsernameInfo declares username as a non-const pointer (e.g. 'char *username') and/or find_entry_by_username accepts a non-const pointer (e.g. 'char *'), then this call is a violation: a pointer extracted from a const-qualified struct should itself point to a const-qualified type (const char *) so that the constness of the containing object is preserved. In that situation Rule 8.13 is violated. (If, however, username is already declared as 'const char *' and the callee accepts 'const char *', there is no violation.)\n</scenario>\n\n<instruction>\nJudge whether the report is correct or not.\n</instruction>\n",
  "is_report_correct": true,
  "explanation": "Agent A's report is correct in the described scenario. MISRA C:2023 Rule 8.13 requires that pointers should point to const-qualified types whenever possible. In the shown function the parameter is a pointer to a const-qualified struct (const struct MHD_DigestAuthUsernameInfo *). If that struct's member is declared as a non-const pointer (e.g. char *username) and/or the callee find_entry_by_username accepts a non-const pointer (char *), then the code obtains and forwards a non-const char * that originated from a const-qualified object. That situation defeats the constness intent of the containing object and is exactly what Rule 8.13 is intended to avoid. If, however, the member is declared as const char * and the callee accepts const char *, there is no violation. Note that the actual violation would be in the (missing) declarations (the member type and/or callee prototype); the call-site only exhibits the problem when those declarations are non-const as described."
}