{
  "user_message": "An agent A claimed that the following MHD_str_remove_token_caseless_ code violates the MISRA C 2023 rule 21.17.\n<misra_rule>\nMISRA C 2023 Rule 21.17 is Use of the string handling functions from <string.h> shall not result in accesses beyond the bounds of the objects referenced by their pointer parameters.\nThis rule strictly applies to the Standard Library functions in <string.h> such as memcpy, memmove, memset, memcmp, strcpy, strncpy, strcat, strncat, strlen, and strspn.\n</misra_rule>\n<target_code>\nHere is the original code of MHD_str_remove_token_caseless_.\n```c\nbool\nMHD_str_remove_token_caseless_ (const char *str,\n                                size_t str_len,\n                                const char *const token,\n                                const size_t token_len,\n                                char *buf,\n                                ssize_t *buf_size)\n{\n  const char *s1; /**< the \"input\" string / character */\n  char *s2;       /**< the \"output\" string / character */\n  size_t t_pos;   /**< position of matched character in the token */\n  bool token_removed;\n\n  mhd_assert (NULL == memchr (token, 0, token_len));\n  mhd_assert (NULL == memchr (token, ' ', token_len));\n  mhd_assert (NULL == memchr (token, '\\t', token_len));\n  mhd_assert (NULL == memchr (token, ',', token_len));\n  mhd_assert (0 <= *buf_size);\n\n  if (SSIZE_MAX <= ((str_len / 2) * 3 + 3))\n  {\n    /* The return value may overflow, refuse */\n    *buf_size = (ssize_t) -1;\n    return false;\n  }\n  s1 = str;\n  s2 = buf;\n  token_removed = false;\n\n  while ((size_t) (s1 - str) < str_len)\n  {\n    const char *cur_token; /**< the first char of current token */\n    size_t copy_size;\n\n    /* Skip any initial whitespaces and empty tokens */\n    while ( ((size_t) (s1 - str) < str_len) &&\n            ((' ' == *s1) || ('\\t' == *s1) || (',' == *s1)) )\n      s1++;\n\n    /* 's1' points to the first char of token in the input string or\n     * points just beyond the end of the input string */\n\n    if ((size_t) (s1 - str) >= str_len)\n      break; /* Nothing to copy, end of the input string */\n\n    /* 's1' points to the first char of token in the input string */\n\n    cur_token = s1; /* the first char of input token */\n\n    /* Check the token with case-insensetive match */\n    t_pos = 0;\n    while ( ((size_t) (s1 - str) < str_len) && (token_len > t_pos) &&\n            (charsequalcaseless (*s1, token[t_pos])) )\n    {\n      s1++;\n      t_pos++;\n    }\n    /* s1 may point just beyond the end of the input string */\n    if ( (token_len == t_pos) && (0 != token_len) )\n    {\n      /* 'token' matched, check that current input token does not have\n       * any suffixes */\n      while ( ((size_t) (s1 - str) < str_len) &&\n              ((' ' == *s1) || ('\\t' == *s1)) )\n        s1++;\n      /* 's1' points to the first non-whitespace char after the token matched\n       * requested token or points just beyond the end of the input string after\n       * the requested token */\n      if (((size_t) (s1 - str) == str_len) || (',' == *s1))\n      {/* full token match, do not copy current token to the output */\n        token_removed = true;\n        continue;\n      }\n    }\n\n    /* 's1' points to first non-whitespace char, to some char after\n     * first non-whitespace char in the token in the input string, to\n     * the ',', or just beyond the end of the input string */\n    /* The current token in the input string does not match the token\n     * to exclude, it must be copied to the output string */\n    /* the current token size excluding leading whitespaces and current char */\n    copy_size = (size_t) (s1 - cur_token);\n    if (buf == s2)\n    { /* The first token to copy to the output */\n      if ((size_t) *buf_size < copy_size)\n      { /* Not enough space in the output buffer */\n        *buf_size = (ssize_t) -1;\n        return false;\n      }\n    }\n    else\n    { /* Some token was already copied to the output buffer */\n      mhd_assert (s2 > buf);\n      if ((size_t) *buf_size < ((size_t) (s2 - buf)) + copy_size + 2)\n      { /* Not enough space in the output buffer */\n        *buf_size = (ssize_t) -1;\n        return false;\n      }\n      *(s2++) = ',';\n      *(s2++) = ' ';\n    }\n    /* Copy non-matched token to the output */\n    if (0 != copy_size)\n    {\n      memcpy (s2, cur_token, copy_size);\n      s2 += copy_size;\n    }\n\n    while ( ((size_t) (s1 - str) < str_len) && (',' != *s1))\n    {\n      /* 's1' points to first non-whitespace char, to some char after\n       * first non-whitespace char in the token in the input string */\n      /* Copy all non-whitespace chars from the current token in\n       * the input string */\n      while ( ((size_t) (s1 - str) < str_len) &&\n              (',' != *s1) && (' ' != *s1) && ('\\t' != *s1) )\n      {\n        mhd_assert (s2 >= buf);\n        if ((size_t) *buf_size <= (size_t) (s2 - buf)) /* '<= s2' equals '< s2 + 1' */\n        { /* Not enough space in the output buffer */\n          *buf_size = (ssize_t) -1;\n          return false;\n        }\n        *(s2++) = *(s1++);\n      }\n      /* 's1' points to some whitespace char in the token in the input\n       * string, to the ',', or just beyond the end of the input string */\n      /* Skip all whitespaces */\n      while ( ((size_t) (s1 - str) < str_len) &&\n              ((' ' == *s1) || ('\\t' == *s1)) )\n        s1++;\n\n      /* 's1' points to the first non-whitespace char in the input string\n       * after whitespace chars, to the ',', or just beyond the end of\n       * the input string */\n      if (((size_t) (s1 - str) < str_len) && (',' != *s1))\n      { /* Not the end of the current token */\n        mhd_assert (s2 >= buf);\n        if ((size_t) *buf_size <= (size_t) (s2 - buf)) /* '<= s2' equals '< s2 + 1' */\n        { /* Not enough space in the output buffer */\n          *buf_size = (ssize_t) -1;\n          return false;\n        }\n        *(s2++) = ' ';\n      }\n    }\n  }\n  mhd_assert (((ssize_t) (s2 - buf)) <= *buf_size);\n  *buf_size = (ssize_t) (s2 - buf);\n  return token_removed;\n}\n```\n</target_code>\n<response format>\nProvide your answer with these fields.\n- explanation: your evaluation of the scenario provided by the agent A.\n- is_report_correct: whether the report is correct or not (true/false). True means there is a violation.\n</response format>\n<scenario>\nThe agent A provided the following violation scenario:\nThe call memchr(token, ' ', token_len) reads token_len bytes starting at token. If token does not actually point to an object of at least token_len bytes (for example token points to a 3-byte object but token_len == 5, or token is a short NUL-terminated string while token_len is larger than its storage), memchr will access beyond the object bounds and cause an out-of-bounds read. Therefore this usage can violate Rule 21.17 (e.g. token = \"ab\" with actual storage 3 bytes but token_len = 5).\n</scenario>\n\n<execution_log>\nThe agent A also provided the following output log:\nENTRY: MHD_str_remove_token_caseless_: str=0x7ffff44746e0 str_len=6 token=0x7ffff44745e0 token_len=6 buf=0x7ffff44741e0 buf_size_ptr=0x7ffff44741c8 buf_size=*yes?\nASSERT_CHECK: memchr(token, 0, token_len) -> token=0x7ffff44745e0 token_len=6\nASSERT_CHECK: memchr(token, ' ', token_len) -> token=0x7ffff44745e0 token_len=6\nASSERT_CHECK: memchr(token, '\t', token_len) -> token=0x7ffff44745e0 token_len=6\nASSERT_CHECK: memchr(token, ',', token_len) -> token=0x7ffff44745e0 token_len=6\nASSERTS_PASSED: buf_size_initial=0\nLOOP_ENTER: iter=1 s1=0x7ffff44746e0 s1_offset=0\nMATCH_CHECK: iter=1 t_pos=6 token_len=6 s1_offset=6\nTOKEN_REMOVED: iter=1 cur_token_offset=0 token_len=6 s1_offset=6\nEXIT: token_removed=1 final_buf_size=0\nENTRY: MHD_str_remove_token_caseless_: str=0x7ffff44746e0 str_len=6 token=0x7ffff44745e0 token_len=6 buf=0x7ffff44741e0 buf_size_ptr=0x7ffff44741c8 buf_size=*yes?\nASSERT_CHECK: memchr(token, 0, token_len) -> token=0x7ffff44745e0 token_len=6\nASSERT_CHECK: memchr(token, ' ', token_len) -> token=0x7ffff44745e0 token_len=6\nASSERT_CHECK: memchr(token, '\t', token_len) -> token=0x7ffff44745e0 token_len=6\nASSERT_CHECK: memchr(token, ',', token_len) -> token=0x7ffff44745e0 token_len=6\nASSERTS_PASSED: buf_size_initial=1\nLOOP_ENTER: iter=1 s1=0x7ffff44746e0 s1_offset=0\nMATCH_CHECK: iter=1 t_pos=6 token_len=6 s1_offset=6\nTOKEN_REMOVED: iter=1 cur_token_offset=0 token_len=6 s1_offset=6\nEXIT: token_removed=1 final_buf_size=0\nENTRY: MHD_str_remove_token_caseless_: str=0x7ffff44746e0 str_len=6 token=0x7ffff44745e0 token_len=6 buf=0x7ffff44741e0 buf_size_ptr=0x7ffff44741c8 buf_size=*yes?\nASSERT_CHECK: memchr(token, 0, token_len) -> token=0x7ffff44745e0 token_len=6\nASSERT_CHECK: memchr(token, ' ', token_len) -> token=0x7ffff44745e0 token_len=6\nASSERT_CHECK: memchr(token, '\t', token_len) -> token=0x7ffff44745e0 token_len=6\nASSERT_CHECK: memchr(token, ',', token_len) -> token=0x7ffff44745e0 token_len=6\nASSERTS_PASSED: buf_size_initial=2\nLOOP_ENTER: iter=1 s1=0x7ffff44746e0 s1_offset=0\nMATCH_CHECK: iter=1 t_pos=6 token_len=6 s1_offset=6\nTOKEN_REMOVED: iter=1 cur_token_offset=0 token_len=6 s1_offset=6\nEXIT: token_removed=1 final_buf_size=0\nENTRY: MHD_str_remove_token_caseless_: str=0x7ffff44746e0 str_len=6 token=0x7ffff44745e0 token_len=6 buf=0x7ffff44741e0 buf_size_ptr=0x7ffff44741c8 buf_size=*yes?\nASSERT_CHECK: memchr(token, 0, token_len) -> token=0x7ffff44745e0 token_len=6\nASSERT_CHECK: memchr(token, ' ', token_len) -> token=0x7ffff44745e0 token_len=6\nASSERT_CHECK: memchr(token, '\t', token_len) -> token=0x7ffff44745e0 token_len=6\nASSERT_CHECK: memchr(token, ',', token_len) -> token=0x7ffff44745e0 token_len=6\nASSERTS_PASSED: buf_size_initial=3\nLOOP_ENTER: iter=1 s1=0x7ffff44746e0 s1_offset=0\nMATCH_CHECK: iter=1 t_pos=6 token_len=6 s1_offset=6\nTOKEN_REMOVED: iter=1 cur_token_offset=0 token_len=6 s1_offset=6\nEXIT: token_removed=1 final_buf_size=0\nENTRY: MHD_str_remove_token_caseless_: str=0x7ffff44746e0 str_len=6 token=0x7ffff44745e0 token_len=6 buf=0x7ffff44741e0 buf_size_ptr=0x7ffff44741c8 buf_size=*yes?\nASSERT_CHECK: memchr(token, 0, token_len) -> token=0x7ffff44745e0 token_len=6\nASSERT_CHECK: memchr(token, ' ', token_len) -> token=0x7ffff44745e0 token_len=6\nASSERT_CHECK: memchr(token, '\t', token_len) -> token=0x7ffff44745e0 token_len=6\nASSERT_CHECK: memchr(token, ',', token_len) -> token=0x7ffff44745e0 token_len=6\nASSERTS_PASSED: buf_size_initial=0\nLOOP_ENTER: iter=1 s1=0x7ffff44746e0 s1_offset=0\nMATCH_CHECK: iter=1 t_pos=6 token_len=6 s1_offset=6\nTOKEN_REMOVED: iter=1 cur_token_offset=0 token_len=6 s1_offset=6\nEXIT: token_removed=1 final_buf_size=0\nENTRY: MHD_str_remove_token_caseless_: str=0x7ffff44746e0 str_len=6 token=0x7ffff44745e0 token_len=6 buf=0x7ffff44741e0 buf_size_ptr=0x7ffff44741c8 buf_size=*yes?\nASSERT_CHECK: memchr(token, 0, token_len) -> token=0x7ffff44745e0 token_len=6\nASSERT_CHECK: memchr(token, ' ', token_len) -> token=0x7ffff44745e0 token_len=6\nASSERT_CHECK: memchr(token, '\t', token_len) -> token=0x7ffff44745e0 token_len=6\nASSERT_CHECK: memchr(token, ',', token_len) -> token=0x7ffff44745e0 token_len=6\nASSERTS_PA\n</execution_log>\n\n<instruction>\nJudge whether the report is correct or not.\n</instruction>\n",
  "is_report_correct": true,
  "explanation": "Agent A is correct. The function calls memchr(token, ..., token_len) (four times at the top) and later indexes token[t_pos] while assuming token has at least token_len bytes of storage. There is no check or guarantee in the function that the object pointed to by token actually contains token_len bytes; the mhd_assert lines themselves call memchr and therefore perform the potentially out\u2011of\u2011bounds reads. An assertion does not prevent the out\u2011of\u2011bounds access (and may be compiled out), so the code can cause reads beyond the bounds of the object referenced by token if the caller passes a token pointer whose actual storage is smaller than token_len (for example a NUL\u2011terminated string of length < token_len). That is exactly what MISRA C 2023 Rule 21.17 forbids, so the report is correct."
}