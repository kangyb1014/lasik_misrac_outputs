{
  "user_message": "An agent A claimed that the following MHD_str_remove_token_caseless_ code violates the MISRA C 2023 rule 21.17.\n<misra_rule>\nMISRA C 2023 Rule 21.17 is Use of the string handling functions from <string.h> shall not result in accesses beyond the bounds of the objects referenced by their pointer parameters.\nThis rule strictly applies to the Standard Library functions in <string.h> such as memcpy, memmove, memset, memcmp, strcpy, strncpy, strcat, strncat, strlen, and strspn.\n</misra_rule>\n<target_code>\nHere is the original code of MHD_str_remove_token_caseless_.\n```c\nbool\nMHD_str_remove_token_caseless_ (const char *str,\n                                size_t str_len,\n                                const char *const token,\n                                const size_t token_len,\n                                char *buf,\n                                ssize_t *buf_size)\n{\n  const char *s1; /**< the \"input\" string / character */\n  char *s2;       /**< the \"output\" string / character */\n  size_t t_pos;   /**< position of matched character in the token */\n  bool token_removed;\n\n  mhd_assert (NULL == memchr (token, 0, token_len));\n  mhd_assert (NULL == memchr (token, ' ', token_len));\n  mhd_assert (NULL == memchr (token, '\\t', token_len));\n  mhd_assert (NULL == memchr (token, ',', token_len));\n  mhd_assert (0 <= *buf_size);\n\n  if (SSIZE_MAX <= ((str_len / 2) * 3 + 3))\n  {\n    /* The return value may overflow, refuse */\n    *buf_size = (ssize_t) -1;\n    return false;\n  }\n  s1 = str;\n  s2 = buf;\n  token_removed = false;\n\n  while ((size_t) (s1 - str) < str_len)\n  {\n    const char *cur_token; /**< the first char of current token */\n    size_t copy_size;\n\n    /* Skip any initial whitespaces and empty tokens */\n    while ( ((size_t) (s1 - str) < str_len) &&\n            ((' ' == *s1) || ('\\t' == *s1) || (',' == *s1)) )\n      s1++;\n\n    /* 's1' points to the first char of token in the input string or\n     * points just beyond the end of the input string */\n\n    if ((size_t) (s1 - str) >= str_len)\n      break; /* Nothing to copy, end of the input string */\n\n    /* 's1' points to the first char of token in the input string */\n\n    cur_token = s1; /* the first char of input token */\n\n    /* Check the token with case-insensetive match */\n    t_pos = 0;\n    while ( ((size_t) (s1 - str) < str_len) && (token_len > t_pos) &&\n            (charsequalcaseless (*s1, token[t_pos])) )\n    {\n      s1++;\n      t_pos++;\n    }\n    /* s1 may point just beyond the end of the input string */\n    if ( (token_len == t_pos) && (0 != token_len) )\n    {\n      /* 'token' matched, check that current input token does not have\n       * any suffixes */\n      while ( ((size_t) (s1 - str) < str_len) &&\n              ((' ' == *s1) || ('\\t' == *s1)) )\n        s1++;\n      /* 's1' points to the first non-whitespace char after the token matched\n       * requested token or points just beyond the end of the input string after\n       * the requested token */\n      if (((size_t) (s1 - str) == str_len) || (',' == *s1))\n      {/* full token match, do not copy current token to the output */\n        token_removed = true;\n        continue;\n      }\n    }\n\n    /* 's1' points to first non-whitespace char, to some char after\n     * first non-whitespace char in the token in the input string, to\n     * the ',', or just beyond the end of the input string */\n    /* The current token in the input string does not match the token\n     * to exclude, it must be copied to the output string */\n    /* the current token size excluding leading whitespaces and current char */\n    copy_size = (size_t) (s1 - cur_token);\n    if (buf == s2)\n    { /* The first token to copy to the output */\n      if ((size_t) *buf_size < copy_size)\n      { /* Not enough space in the output buffer */\n        *buf_size = (ssize_t) -1;\n        return false;\n      }\n    }\n    else\n    { /* Some token was already copied to the output buffer */\n      mhd_assert (s2 > buf);\n      if ((size_t) *buf_size < ((size_t) (s2 - buf)) + copy_size + 2)\n      { /* Not enough space in the output buffer */\n        *buf_size = (ssize_t) -1;\n        return false;\n      }\n      *(s2++) = ',';\n      *(s2++) = ' ';\n    }\n    /* Copy non-matched token to the output */\n    if (0 != copy_size)\n    {\n      memcpy (s2, cur_token, copy_size);\n      s2 += copy_size;\n    }\n\n    while ( ((size_t) (s1 - str) < str_len) && (',' != *s1))\n    {\n      /* 's1' points to first non-whitespace char, to some char after\n       * first non-whitespace char in the token in the input string */\n      /* Copy all non-whitespace chars from the current token in\n       * the input string */\n      while ( ((size_t) (s1 - str) < str_len) &&\n              (',' != *s1) && (' ' != *s1) && ('\\t' != *s1) )\n      {\n        mhd_assert (s2 >= buf);\n        if ((size_t) *buf_size <= (size_t) (s2 - buf)) /* '<= s2' equals '< s2 + 1' */\n        { /* Not enough space in the output buffer */\n          *buf_size = (ssize_t) -1;\n          return false;\n        }\n        *(s2++) = *(s1++);\n      }\n      /* 's1' points to some whitespace char in the token in the input\n       * string, to the ',', or just beyond the end of the input string */\n      /* Skip all whitespaces */\n      while ( ((size_t) (s1 - str) < str_len) &&\n              ((' ' == *s1) || ('\\t' == *s1)) )\n        s1++;\n\n      /* 's1' points to the first non-whitespace char in the input string\n       * after whitespace chars, to the ',', or just beyond the end of\n       * the input string */\n      if (((size_t) (s1 - str) < str_len) && (',' != *s1))\n      { /* Not the end of the current token */\n        mhd_assert (s2 >= buf);\n        if ((size_t) *buf_size <= (size_t) (s2 - buf)) /* '<= s2' equals '< s2 + 1' */\n        { /* Not enough space in the output buffer */\n          *buf_size = (ssize_t) -1;\n          return false;\n        }\n        *(s2++) = ' ';\n      }\n    }\n  }\n  mhd_assert (((ssize_t) (s2 - buf)) <= *buf_size);\n  *buf_size = (ssize_t) (s2 - buf);\n  return token_removed;\n}\n```\n</target_code>\n<response format>\nProvide your answer with these fields.\n- explanation: your evaluation of the scenario provided by the agent A.\n- is_report_correct: whether the report is correct or not (true/false). True means there is a violation.\n</response format>\n<scenario>\nThe agent A provided the following violation scenario:\nmemchr() reads up to token_len bytes from token. If token does not actually reference an object of at least token_len bytes (for example: token is a NUL-terminated string \"abc\" allocated 4 bytes but token_len == 10), memchr(token, '\\t', token_len) will read beyond the bounds of token and invoke undefined behavior. This is a violation of MISRA C 2023 Rule 21.17.\n</scenario>\n\n<execution_log>\nThe agent A also provided the following output log:\nENTER MHD_str_remove_token_caseless_: str=0x7ffcecc6cd60 str_len=6 token=0x7ffcecc6cc60 token_len=6 buf=0x7ffcecc6c860 buf_size=0x7ffcecc6c848 (*buf_size=0)\nAbout to perform memchr checks on token 0x7ffcecc6cc60 with token_len=6 (checks: 0, ' ', '\t', ',')\nLOOP: offset=0 str_len=6 token_removed=0 s1=0x7ffcecc6cd60 s2=0x7ffcecc6c860\nChecking token match: cur_token=0x7ffcecc6cd60 token_len=6 t_pos=0\nAfter match loop: s1_off=6 t_pos=6 token_len=6\nToken matched and removed at offset=0 token_len=6\nEXIT MHD_str_remove_token_caseless_: returning 1 final_buf_size=0\nENTER MHD_str_remove_token_caseless_: str=0x7ffcecc6cd60 str_len=6 token=0x7ffcecc6cc60 token_len=6 buf=0x7ffcecc6c860 buf_size=0x7ffcecc6c848 (*buf_size=1)\nAbout to perform memchr checks on token 0x7ffcecc6cc60 with token_len=6 (checks: 0, ' ', '\t', ',')\nLOOP: offset=0 str_len=6 token_removed=0 s1=0x7ffcecc6cd60 s2=0x7ffcecc6c860\nChecking token match: cur_token=0x7ffcecc6cd60 token_len=6 t_pos=0\nAfter match loop: s1_off=6 t_pos=6 token_len=6\nToken matched and removed at offset=0 token_len=6\nEXIT MHD_str_remove_token_caseless_: returning 1 final_buf_size=0\nENTER MHD_str_remove_token_caseless_: str=0x7ffcecc6cd60 str_len=6 token=0x7ffcecc6cc60 token_len=6 buf=0x7ffcecc6c860 buf_size=0x7ffcecc6c848 (*buf_size=2)\nAbout to perform memchr checks on token 0x7ffcecc6cc60 with token_len=6 (checks: 0, ' ', '\t', ',')\nLOOP: offset=0 str_len=6 token_removed=0 s1=0x7ffcecc6cd60 s2=0x7ffcecc6c860\nChecking token match: cur_token=0x7ffcecc6cd60 token_len=6 t_pos=0\nAfter match loop: s1_off=6 t_pos=6 token_len=6\nToken matched and removed at offset=0 token_len=6\nEXIT MHD_str_remove_token_caseless_: returning 1 final_buf_size=0\nENTER MHD_str_remove_token_caseless_: str=0x7ffcecc6cd60 str_len=6 token=0x7ffcecc6cc60 token_len=6 buf=0x7ffcecc6c860 buf_size=0x7ffcecc6c848 (*buf_size=3)\nAbout to perform memchr checks on token 0x7ffcecc6cc60 with token_len=6 (checks: 0, ' ', '\t', ',')\nLOOP: offset=0 str_len=6 token_removed=0 s1=0x7ffcecc6cd60 s2=0x7ffcecc6c860\nChecking token match: cur_token=0x7ffcecc6cd60 token_len=6 t_pos=0\nAfter match loop: s1_off=6 t_pos=6 token_len=6\nToken matched and removed at offset=0 token_len=6\nEXIT MHD_str_remove_token_caseless_: returning 1 final_buf_size=0\nENTER MHD_str_remove_token_caseless_: str=0x7ffcecc6cd60 str_len=6 token=0x7ffcecc6cc60 token_len=6 buf=0x7ffcecc6c860 buf_size=0x7ffcecc6c848 (*buf_size=0)\nAbout to perform memchr checks on token 0x7ffcecc6cc60 with token_len=6 (checks: 0, ' ', '\t', ',')\nLOOP: offset=0 str_len=6 token_removed=0 s1=0x7ffcecc6cd60 s2=0x7ffcecc6c860\nChecking token match: cur_token=0x7ffcecc6cd60 token_len=6 t_pos=0\nAfter match loop: s1_off=6 t_pos=6 token_len=6\nToken matched and removed at offset=0 token_len=6\nEXIT MHD_str_remove_token_caseless_: returning 1 final_buf_size=0\nENTER MHD_str_remove_token_caseless_: str=0x7ffcecc6cd60 str_len=6 token=0x7ffcecc6cc60 token_len=6 buf=0x7ffcecc6c860 buf_size=0x7ffcecc6c848 (*buf_size=1)\nAbout to perform memchr checks on token 0x7ffcecc6cc60 with token_len=6 (checks: 0, ' ', '\t', ',')\nLOOP: offset=0 str_len=6 token_removed=0 s1=0x7ffcecc6cd60 s2=0x7ffcecc6c860\nChecking token match: cur_token=0x7ffcecc6cd60 token_len=6 t_pos=0\nAfter match loop: s1_off=6 t_pos=6 token_len=6\nToken matched and removed at offset=0 token_len=6\nEXIT MHD_str_remove_token_caseless_: returning 1 final_buf_size=0\nENTER MHD_str_remove_token_caseless_: str=0x7ffcecc6cd60 str_len=6 token=0x7ffcecc6cc60 token_len=6 buf=0x7ffcecc6c860 buf_size=0x7ffcecc6c848 (*buf_size=2)\nAbout to perform memchr checks on token 0x7ffcecc6cc60 with token_len=6 (checks: 0, ' ', '\t', ',')\nLOOP: offset=0 str_len=6 token_removed=0 s1=0x7ffcecc6cd60 s2=0x7ffcecc6c860\nChecking token match: cur_token=0x7ffcecc6cd60 token_len=6 t_pos=0\nAfter match loop: s1_off=6 t_pos=6 token_len=6\nToken matched and removed at offset=0 token_len=6\nEXIT MHD_str_remove_token_caseless_: returning 1 final_buf_size=0\nENTER MHD_str_remove_token_caseless_: str=0x7ffcecc6cd60 str_len=6 token=0x7ffcecc6cc60 token_len=6 buf=0x7ffcecc6c860 buf_size=0x7ffcecc6c848 (*buf_size=3\n</execution_log>\n\n<instruction>\nJudge whether the report is correct or not.\n</instruction>\n",
  "is_report_correct": true,
  "explanation": "Agent A is correct. The calls memchr(token, ..., token_len) read up to token_len bytes starting at token; nothing in the shown function guarantees that the object pointed to by token actually has token_len bytes. If token refers to a shorter object (e.g. a NUL-terminated \"abc\" buffer of 4 bytes while token_len==10), memchr will access beyond the object and invoke undefined behaviour, which violates MISRA C 2023 Rule 21.17. The mhd_assert calls do not remove the problem: they themselves call memchr (so they cause the same out\u2011of\u2011bounds access when assertions are enabled), and if the assert macro is disabled in production builds the checks disappear (but that does not make the memchr usage safe). Compliance requires either a documented and enforced precondition that token points to at least token_len bytes, or adding explicit, provable bounds checks (or otherwise restructuring the code) so that memchr cannot read past the object bounds."
}