{
  "user_message": "<misra_rule>\nThe target MISRA C 2023 Rule 8.13 is: A pointer should point to a const-qualified type whenever possible.\n\n</misra_rule>\n<instruction>\nOther agents will judge whether the code follows the MISRA C 2023 guidelines.\nThey will investigate the code fragments you give.\nYour job is to find code fragments in the code that should be investigated to check whether the code follows the MISRA C rule.\n</instruction>\n<response format>\nProvide your answer with these fields.\n- suspicious_frags: The list of suspicious code fragments in the code.\nIt should contain only the code fragments exists in the code. If you do not find any suspicious code fragments, return an empty list for suspicious_frags\n- explanation: The explanation of why other code fragments should NOT be investigated.\nIt is very important to not miss any suspicious code fragments, so please give a sufficient explanation why other code fragments should not be investigated.\nDO NOT give any explanation for the selected suspicious code fragments.\n</response format>\n<target_code>\nHere is the code of MHD_str_remove_token_caseless_:\n```c\nbool\nMHD_str_remove_token_caseless_ (const char *str,\n                                size_t str_len,\n                                const char *const token,\n                                const size_t token_len,\n                                char *buf,\n                                ssize_t *buf_size)\n{\n  const char *s1; /**< the \"input\" string / character */\n  char *s2;       /**< the \"output\" string / character */\n  size_t t_pos;   /**< position of matched character in the token */\n  bool token_removed;\n\n  mhd_assert (NULL == memchr (token, 0, token_len));\n  mhd_assert (NULL == memchr (token, ' ', token_len));\n  mhd_assert (NULL == memchr (token, '\\t', token_len));\n  mhd_assert (NULL == memchr (token, ',', token_len));\n  mhd_assert (0 <= *buf_size);\n\n  if (SSIZE_MAX <= ((str_len / 2) * 3 + 3))\n  {\n    /* The return value may overflow, refuse */\n    *buf_size = (ssize_t) -1;\n    return false;\n  }\n  s1 = str;\n  s2 = buf;\n  token_removed = false;\n\n  while ((size_t) (s1 - str) < str_len)\n  {\n    const char *cur_token; /**< the first char of current token */\n    size_t copy_size;\n\n    /* Skip any initial whitespaces and empty tokens */\n    while ( ((size_t) (s1 - str) < str_len) &&\n            ((' ' == *s1) || ('\\t' == *s1) || (',' == *s1)) )\n      s1++;\n\n    /* 's1' points to the first char of token in the input string or\n     * points just beyond the end of the input string */\n\n    if ((size_t) (s1 - str) >= str_len)\n      break; /* Nothing to copy, end of the input string */\n\n    /* 's1' points to the first char of token in the input string */\n\n    cur_token = s1; /* the first char of input token */\n\n    /* Check the token with case-insensetive match */\n    t_pos = 0;\n    while ( ((size_t) (s1 - str) < str_len) && (token_len > t_pos) &&\n            (charsequalcaseless (*s1, token[t_pos])) )\n    {\n      s1++;\n      t_pos++;\n    }\n    /* s1 may point just beyond the end of the input string */\n    if ( (token_len == t_pos) && (0 != token_len) )\n    {\n      /* 'token' matched, check that current input token does not have\n       * any suffixes */\n      while ( ((size_t) (s1 - str) < str_len) &&\n              ((' ' == *s1) || ('\\t' == *s1)) )\n        s1++;\n      /* 's1' points to the first non-whitespace char after the token matched\n       * requested token or points just beyond the end of the input string after\n       * the requested token */\n      if (((size_t) (s1 - str) == str_len) || (',' == *s1))\n      {/* full token match, do not copy current token to the output */\n        token_removed = true;\n        continue;\n      }\n    }\n\n    /* 's1' points to first non-whitespace char, to some char after\n     * first non-whitespace char in the token in the input string, to\n     * the ',', or just beyond the end of the input string */\n    /* The current token in the input string does not match the token\n     * to exclude, it must be copied to the output string */\n    /* the current token size excluding leading whitespaces and current char */\n    copy_size = (size_t) (s1 - cur_token);\n    if (buf == s2)\n    { /* The first token to copy to the output */\n      if ((size_t) *buf_size < copy_size)\n      { /* Not enough space in the output buffer */\n        *buf_size = (ssize_t) -1;\n        return false;\n      }\n    }\n    else\n    { /* Some token was already copied to the output buffer */\n      mhd_assert (s2 > buf);\n      if ((size_t) *buf_size < ((size_t) (s2 - buf)) + copy_size + 2)\n      { /* Not enough space in the output buffer */\n        *buf_size = (ssize_t) -1;\n        return false;\n      }\n      *(s2++) = ',';\n      *(s2++) = ' ';\n    }\n    /* Copy non-matched token to the output */\n    if (0 != copy_size)\n    {\n      memcpy (s2, cur_token, copy_size);\n      s2 += copy_size;\n    }\n\n    while ( ((size_t) (s1 - str) < str_len) && (',' != *s1))\n    {\n      /* 's1' points to first non-whitespace char, to some char after\n       * first non-whitespace char in the token in the input string */\n      /* Copy all non-whitespace chars from the current token in\n       * the input string */\n      while ( ((size_t) (s1 - str) < str_len) &&\n              (',' != *s1) && (' ' != *s1) && ('\\t' != *s1) )\n      {\n        mhd_assert (s2 >= buf);\n        if ((size_t) *buf_size <= (size_t) (s2 - buf)) /* '<= s2' equals '< s2 + 1' */\n        { /* Not enough space in the output buffer */\n          *buf_size = (ssize_t) -1;\n          return false;\n        }\n        *(s2++) = *(s1++);\n      }\n      /* 's1' points to some whitespace char in the token in the input\n       * string, to the ',', or just beyond the end of the input string */\n      /* Skip all whitespaces */\n      while ( ((size_t) (s1 - str) < str_len) &&\n              ((' ' == *s1) || ('\\t' == *s1)) )\n        s1++;\n\n      /* 's1' points to the first non-whitespace char in the input string\n       * after whitespace chars, to the ',', or just beyond the end of\n       * the input string */\n      if (((size_t) (s1 - str) < str_len) && (',' != *s1))\n      { /* Not the end of the current token */\n        mhd_assert (s2 >= buf);\n        if ((size_t) *buf_size <= (size_t) (s2 - buf)) /* '<= s2' equals '< s2 + 1' */\n        { /* Not enough space in the output buffer */\n          *buf_size = (ssize_t) -1;\n          return false;\n        }\n        *(s2++) = ' ';\n      }\n    }\n  }\n  mhd_assert (((ssize_t) (s2 - buf)) <= *buf_size);\n  *buf_size = (ssize_t) (s2 - buf);\n  return token_removed;\n}\n```\n</target_code>\nPlease find suspicious code fragments in the code and report them. Other agents can not investigate other fragments that you do not report, so it is very important to find all suspicious fragments without missing any. Report the suspicious fragments AS MUCH AS POSSIBLE.",
  "suspicious_frags": [],
  "explanation": "I found no fragments that need investigation for MISRA C 2023 Rule 8.13. Every pointer that can and should be const is declared const; pointers that are non-const are used to modify the pointed-to object and therefore must not be const:\n\n- Function parameters:\n  - const char *str: correctly const because the function only reads from the input string.\n  - const char *const token: correctly const-qualified (both the pointed-to characters and the pointer itself are const) and used only for reading (memchr, indexing, comparisons).\n  - char *buf: correctly non-const because the function writes output into the buffer (writes via s2 and memcpy dest).\n  - ssize_t *buf_size: correctly non-const because the function updates *buf_size to report buffer usage or error.\n\n- Local variables:\n  - const char *s1: correctly const; used only to traverse/read from the input string.\n  - char *s2: correctly non-const; used to write output characters into the buffer.\n  - const char *cur_token: correctly const; points into the input string and is only read.\n\n- Library calls and usage are consistent with const-correctness (memcpy dest is non-const s2, src is const cur_token; memchr is called with const token pointer which matches memchr's const void * parameter).\n\nBecause all pointer declarations either already include the appropriate const qualifier or intentionally omit it because the pointee is modified, there are no code fragments in this function that violate or require further investigation under Rule 8.13."
}