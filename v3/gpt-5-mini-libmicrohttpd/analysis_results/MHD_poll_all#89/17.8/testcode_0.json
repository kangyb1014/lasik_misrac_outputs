{
  "user_message": "<misra_rule>\nMISRA C 2023 Rule 17.8 is: A function parameter should not be modified.\nNote that the object referred to by a pointer parameter may be modified, but the pointer itself shall not be modified.\n</misra_rule>\n\nAnother agent reported that the target code violated the Rule 17.8.\nHere is the comment from the agent.\n<violation scenario>\nThe value of the function parameter 'millisec' (int32_t millisec) is assigned to (millisec = 0;) inside MHD_poll_all. Rule 17.8 forbids modifying function parameters; the pointer exception does not apply here because millisec is not a pointer. This direct assignment violates MISRA C 2023 Rule 17.8.\n</violation scenario>\n\nYour job is to insert logging code to capture the control flow and state information of the program.\nInsert logging code so that other agents can reproduce and get evidence for the violation scenario.\n<response format>\n- test_code: a modified MHD_poll_all code that contains useful probe functions that print useful logs to a file \"/tmp/logs/897.txt\". The logs should contain the control path and state information of the violation scenario. If test code is not required to validate the scenario, you can leave this blank.\nHere are the constraints for the test code:\n- The test code MUST preserve the original logic of MHD_poll_all as much as possible.\nYou CAN just insert probe functions to the original code.\n- DO NOT introduce new violations to demonstrate your scenario.\n- The test code MUST be compilable and executable.\n- The test code MUST include line breaks.\n- You MUST NOT define the main function.\n- You MUST NOT define macros.\n</response format>\n<target_code>\nHere is the code of MHD_poll_all:\n```c\nstatic enum MHD_Result\nMHD_poll_all (struct MHD_Daemon *daemon,\n              int32_t millisec)\n{\n  unsigned int num_connections;\n  struct MHD_Connection *pos;\n  struct MHD_Connection *prev;\n#if defined(HTTPS_SUPPORT) && defined(UPGRADE_SUPPORT)\n  struct MHD_UpgradeResponseHandle *urh;\n  struct MHD_UpgradeResponseHandle *urhn;\n#endif /* HTTPS_SUPPORT && UPGRADE_SUPPORT */\n\n  mhd_assert ((0 == (daemon->options & MHD_USE_SELECT_INTERNALLY)) || \\\n              (MHD_thread_handle_ID_is_valid_ID_ (daemon->tid)));\n  mhd_assert ((0 != (daemon->options & MHD_USE_SELECT_INTERNALLY)) || \\\n              (! MHD_thread_handle_ID_is_valid_ID_ (daemon->tid)));\n  mhd_assert ((0 == (daemon->options & MHD_USE_SELECT_INTERNALLY)) || \\\n              (MHD_thread_handle_ID_is_current_thread_ (daemon->tid)));\n\n  if ( (0 != (daemon->options & MHD_TEST_ALLOW_SUSPEND_RESUME)) &&\n       (MHD_NO != resume_suspended_connections (daemon)) )\n    millisec = 0;\n\n  /* count number of connections and thus determine poll set size */\n  num_connections = 0;\n  for (pos = daemon->connections_head; NULL != pos; pos = pos->next)\n    num_connections++;\n#if defined(HTTPS_SUPPORT) && defined(UPGRADE_SUPPORT)\n  for (urh = daemon->urh_head; NULL != urh; urh = urh->next)\n    num_connections += 2;\n#endif /* HTTPS_SUPPORT && UPGRADE_SUPPORT */\n  {\n    unsigned int i;\n    int timeout;\n    unsigned int poll_server;\n    int poll_listen;\n    int poll_itc_idx;\n    struct pollfd *p;\n    MHD_socket ls;\n\n    p = MHD_calloc_ ((2 + (size_t) num_connections),\n                     sizeof (struct pollfd));\n    if (NULL == p)\n    {\n#ifdef HAVE_MESSAGES\n      MHD_DLOG (daemon,\n                _ (\"Error allocating memory: %s\\n\"),\n                MHD_strerror_ (errno));\n#endif\n      return MHD_NO;\n    }\n    poll_server = 0;\n    poll_listen = -1;\n    if ( (MHD_INVALID_SOCKET != (ls = daemon->listen_fd)) &&\n         (! daemon->was_quiesced) &&\n         (daemon->connections < daemon->connection_limit) &&\n         (! daemon->at_limit) )\n    {\n      /* only listen if we are not at the connection limit */\n      p[poll_server].fd = ls;\n      p[poll_server].events = POLLIN;\n      p[poll_server].revents = 0;\n      poll_listen = (int) poll_server;\n      poll_server++;\n    }\n    poll_itc_idx = -1;\n    if (MHD_ITC_IS_VALID_ (daemon->itc))\n    {\n      p[poll_server].fd = MHD_itc_r_fd_ (daemon->itc);\n      p[poll_server].events = POLLIN;\n      p[poll_server].revents = 0;\n      poll_itc_idx = (int) poll_server;\n      poll_server++;\n    }\n\n    timeout = get_timeout_millisec_int (daemon, millisec);\n\n    i = 0;\n    for (pos = daemon->connections_tail; NULL != pos; pos = pos->prev)\n    {\n      p[poll_server + i].fd = pos->socket_fd;\n      switch (pos->event_loop_info)\n      {\n      case MHD_EVENT_LOOP_INFO_READ:\n      case MHD_EVENT_LOOP_INFO_PROCESS_READ:\n        p[poll_server + i].events |= POLLIN | MHD_POLL_EVENTS_ERR_DISC;\n        break;\n      case MHD_EVENT_LOOP_INFO_WRITE:\n        p[poll_server + i].events |= POLLOUT | MHD_POLL_EVENTS_ERR_DISC;\n        break;\n      case MHD_EVENT_LOOP_INFO_PROCESS:\n        p[poll_server + i].events |=  MHD_POLL_EVENTS_ERR_DISC;\n        break;\n      case MHD_EVENT_LOOP_INFO_CLEANUP:\n        timeout = 0; /* clean up \"pos\" immediately */\n        break;\n      }\n      i++;\n    }\n#if defined(HTTPS_SUPPORT) && defined(UPGRADE_SUPPORT)\n    for (urh = daemon->urh_tail; NULL != urh; urh = urh->prev)\n    {\n      urh_to_pollfd (urh, &(p[poll_server + i]));\n      i += 2;\n    }\n#endif /* HTTPS_SUPPORT && UPGRADE_SUPPORT */\n    if (0 == poll_server + num_connections)\n    {\n      free (p);\n      return MHD_YES;\n    }\n    if (MHD_sys_poll_ (p,\n                       poll_server + num_connections,\n                       timeout) < 0)\n    {\n      const int err = MHD_socket_get_error_ ();\n      if (MHD_SCKT_ERR_IS_EINTR_ (err))\n      {\n        free (p);\n        return MHD_YES;\n      }\n#ifdef HAVE_MESSAGES\n      MHD_DLOG (daemon,\n                _ (\"poll failed: %s\\n\"),\n                MHD_socket_strerr_ (err));\n#endif\n      free (p);\n      return MHD_NO;\n    }\n\n    /* handle ITC FD */\n    /* do it before any other processing so\n       new signals will be processed in next loop */\n    if ( (-1 != poll_itc_idx) &&\n         (0 != (p[poll_itc_idx].revents & POLLIN)) )\n      MHD_itc_clear_ (daemon->itc);\n\n    /* handle shutdown */\n    if (daemon->shutdown)\n    {\n      free (p);\n      return MHD_NO;\n    }\n\n    /* Process externally added connection if any */\n    if (daemon->have_new)\n      new_connections_list_process_ (daemon);\n\n    /* handle 'listen' FD */\n    if ( (-1 != poll_listen) &&\n         (0 != (p[poll_listen].revents & POLLIN)) )\n      (void) MHD_accept_connection (daemon);\n\n    /* Reset. New value will be set when connections are processed. */\n    daemon->data_already_pending = false;\n\n    i = 0;\n    prev = daemon->connections_tail;\n    while (NULL != (pos = prev))\n    {\n      prev = pos->prev;\n      /* first, sanity checks */\n      if (i >= num_connections)\n        break;     /* connection list changed somehow, retry later ... */\n      if (p[poll_server + i].fd != pos->socket_fd)\n        continue;  /* fd mismatch, something else happened, retry later ... */\n      call_handlers (pos,\n                     0 != (p[poll_server + i].revents & POLLIN),\n                     0 != (p[poll_server + i].revents & POLLOUT),\n                     0 != (p[poll_server + i].revents\n                           & MHD_POLL_REVENTS_ERR_DISC));\n      i++;\n    }\n#if defined(HTTPS_SUPPORT) && defined(UPGRADE_SUPPORT)\n    for (urh = daemon->urh_tail; NULL != urh; urh = urhn)\n    {\n      if (i >= num_connections)\n        break;   /* connection list changed somehow, retry later ... */\n\n      /* Get next connection here as connection can be removed\n       * from 'daemon->urh_head' list. */\n      urhn = urh->prev;\n      /* Check for fd mismatch. FIXME: required for safety? */\n      if ((p[poll_server + i].fd != urh->connection->socket_fd) ||\n          (p[poll_server + i + 1].fd != urh->mhd.socket))\n        break;\n      urh_from_pollfd (urh,\n                       &p[poll_server + i]);\n      i += 2;\n      process_urh (urh);\n      /* Finished forwarding? */\n      if ( (0 == urh->in_buffer_size) &&\n           (0 == urh->out_buffer_size) &&\n           (0 == urh->in_buffer_used) &&\n           (0 == urh->out_buffer_used) )\n      {\n        /* MHD_connection_finish_forward_() will remove connection from\n         * 'daemon->urh_head' list. */\n        MHD_connection_finish_forward_ (urh->connection);\n        urh->clean_ready = true;\n        /* If 'urh->was_closed' already was set to true, connection will be\n         * moved immediately to cleanup list. Otherwise connection\n         * will stay in suspended list until 'urh' will be marked\n         * with 'was_closed' by application. */\n        MHD_resume_connection (urh->connection);\n      }\n    }\n#endif /* HTTPS_SUPPORT && UPGRADE_SUPPORT */\n\n    free (p);\n  }\n  return MHD_YES;\n}\n```\n</target_code>\nPlease provide the modified MHD_poll_all code.\n",
  "test_code": "static enum MHD_Result\nMHD_poll_all (struct MHD_Daemon *daemon,\n              int32_t millisec)\n{\n  unsigned int num_connections;\n  struct MHD_Connection *pos;\n  struct MHD_Connection *prev;\n#if defined(HTTPS_SUPPORT) && defined(UPGRADE_SUPPORT)\n  struct MHD_UpgradeResponseHandle *urh;\n  struct MHD_UpgradeResponseHandle *urhn;\n#endif /* HTTPS_SUPPORT && UPGRADE_SUPPORT */\n\n  /* Probe: log entry and initial state (daemon pointer, incoming millisec,\n     options flags). Append mode so successive calls accumulate evidence. */\n  {\n    FILE *logf = fopen(\"/tmp/logs/897.txt\", \"a\");\n    if (NULL != logf)\n    {\n      /* Cast to (void*) for pointer printing and to (int) for millisec */\n      fprintf(logf, \"ENTRY: MHD_poll_all daemon=%p initial_millisec=%d options=0x%08x\\n\",\n              (void *) daemon, (int) millisec, (unsigned) daemon->options);\n      fclose(logf);\n    }\n  }\n\n  mhd_assert ((0 == (daemon->options & MHD_USE_SELECT_INTERNALLY)) || \\\n              (MHD_thread_handle_ID_is_valid_ID_ (daemon->tid)));\n  mhd_assert ((0 != (daemon->options & MHD_USE_SELECT_INTERNALLY)) || \\\n              (! MHD_thread_handle_ID_is_valid_ID_ (daemon->tid)));\n  mhd_assert ((0 == (daemon->options & MHD_USE_SELECT_INTERNALLY)) || \\\n              (MHD_thread_handle_ID_is_current_thread_ (daemon->tid)));\n\n  /* Preserve original short-circuit behavior: only call resume_suspended_connections\n     when the TEST_ALLOW_SUSPEND_RESUME option is set. Capture the return value\n     and log the decision that leads to the assignment of the function parameter. */\n  if (0 != (daemon->options & MHD_TEST_ALLOW_SUSPEND_RESUME))\n  {\n    int resume_res = resume_suspended_connections (daemon);\n\n    /* Log the result of resume_suspended_connections and the decision */\n    {\n      FILE *logf = fopen(\"/tmp/logs/897.txt\", \"a\");\n      if (NULL != logf)\n      {\n        fprintf(logf, \"DEBUG: resume_suspended_connections returned=%d\\n\", resume_res);\n        fclose(logf);\n      }\n    }\n\n    if (MHD_NO != resume_res)\n    {\n      /* Log the exact moment and values where the function parameter is modified. */\n      {\n        FILE *logf = fopen(\"/tmp/logs/897.txt\", \"a\");\n        if (NULL != logf)\n        {\n          fprintf(logf, \"VIOLATION_EVIDENCE: about to assign to function parameter 'millisec': old_millisec=%d -> new_millisec=0\\n\",\n                  (int) millisec);\n          fclose(logf);\n        }\n      }\n\n      millisec = 0;\n\n      /* Log after assignment to capture resulting state */\n      {\n        FILE *logf = fopen(\"/tmp/logs/897.txt\", \"a\");\n        if (NULL != logf)\n        {\n          fprintf(logf, \"AFTER_ASSIGN: millisec=%d\\n\", (int) millisec);\n          fclose(logf);\n        }\n      }\n    }\n    else\n    {\n      /* Log that no assignment was performed */\n      FILE *logf = fopen(\"/tmp/logs/897.txt\", \"a\");\n      if (NULL != logf)\n      {\n        fprintf(logf, \"DEBUG: no assignment to 'millisec' (resume_res==MHD_NO)\\n\");\n        fclose(logf);\n      }\n    }\n  }\n\n  /* count number of connections and thus determine poll set size */\n  num_connections = 0;\n  for (pos = daemon->connections_head; NULL != pos; pos = pos->next)\n    num_connections++;\n#if defined(HTTPS_SUPPORT) && defined(UPGRADE_SUPPORT)\n  for (urh = daemon->urh_head; NULL != urh; urh = urh->next)\n    num_connections += 2;\n#endif /* HTTPS_SUPPORT && UPGRADE_SUPPORT */\n  {\n    unsigned int i;\n    int timeout;\n    unsigned int poll_server;\n    int poll_listen;\n    int poll_itc_idx;\n    struct pollfd *p;\n    MHD_socket ls;\n\n    p = MHD_calloc_ ((2 + (size_t) num_connections),\n                     sizeof (struct pollfd));\n    if (NULL == p)\n    {\n#ifdef HAVE_MESSAGES\n      MHD_DLOG (daemon,\n                _ (\"Error allocating memory: %s\\n\"),\n                MHD_strerror_ (errno));\n#endif\n      return MHD_NO;\n    }\n    poll_server = 0;\n    poll_listen = -1;\n    if ( (MHD_INVALID_SOCKET != (ls = daemon->listen_fd)) &&\n         (! daemon->was_quiesced) &&\n         (daemon->connections < daemon->connection_limit) &&\n         (! daemon->at_limit) )\n    {\n      /* only listen if we are not at the connection limit */\n      p[poll_server].fd = ls;\n      p[poll_server].events = POLLIN;\n      p[poll_server].revents = 0;\n      poll_listen = (int) poll_server;\n      poll_server++;\n    }\n    poll_itc_idx = -1;\n    if (MHD_ITC_IS_VALID_ (daemon->itc))\n    {\n      p[poll_server].fd = MHD_itc_r_fd_ (daemon->itc);\n      p[poll_server].events = POLLIN;\n      p[poll_server].revents = 0;\n      poll_itc_idx = (int) poll_server;\n      poll_server++;\n    }\n\n    timeout = get_timeout_millisec_int (daemon, millisec);\n\n    i = 0;\n    for (pos = daemon->connections_tail; NULL != pos; pos = pos->prev)\n    {\n      p[poll_server + i].fd = pos->socket_fd;\n      switch (pos->event_loop_info)\n      {\n      case MHD_EVENT_LOOP_INFO_READ:\n      case MHD_EVENT_LOOP_INFO_PROCESS_READ:\n        p[poll_server + i].events |= POLLIN | MHD_POLL_EVENTS_ERR_DISC;\n        break;\n      case MHD_EVENT_LOOP_INFO_WRITE:\n        p[poll_server + i].events |= POLLOUT | MHD_POLL_EVENTS_ERR_DISC;\n        break;\n      case MHD_EVENT_LOOP_INFO_PROCESS:\n        p[poll_server + i].events |=  MHD_POLL_EVENTS_ERR_DISC;\n        break;\n      case MHD_EVENT_LOOP_INFO_CLEANUP:\n        timeout = 0; /* clean up \"pos\" immediately */\n        break;\n      }\n      i++;\n    }\n#if defined(HTTPS_SUPPORT) && defined(UPGRADE_SUPPORT)\n    for (urh = daemon->urh_tail; NULL != urh; urh = urh->prev)\n    {\n      urh_to_pollfd (urh, &(p[poll_server + i]));\n      i += 2;\n    }\n#endif /* HTTPS_SUPPORT && UPGRADE_SUPPORT */\n    if (0 == poll_server + num_connections)\n    {\n      free (p);\n      return MHD_YES;\n    }\n    if (MHD_sys_poll_ (p,\n                       poll_server + num_connections,\n                       timeout) < 0)\n    {\n      const int err = MHD_socket_get_error_ ();\n      if (MHD_SCKT_ERR_IS_EINTR_ (err))\n      {\n        free (p);\n        return MHD_YES;\n      }\n#ifdef HAVE_MESSAGES\n      MHD_DLOG (daemon,\n                _ (\"poll failed: %s\\n\"),\n                MHD_socket_strerr_ (err));\n#endif\n      free (p);\n      return MHD_NO;\n    }\n\n    /* handle ITC FD */\n    /* do it before any other processing so\n       new signals will be processed in next loop */\n    if ( (-1 != poll_itc_idx) &&\n         (0 != (p[poll_itc_idx].revents & POLLIN)) )\n      MHD_itc_clear_ (daemon->itc);\n\n    /* handle shutdown */\n    if (daemon->shutdown)\n    {\n      free (p);\n      return MHD_NO;\n    }\n\n    /* Process externally added connection if any */\n    if (daemon->have_new)\n      new_connections_list_process_ (daemon);\n\n    /* handle 'listen' FD */\n    if ( (-1 != poll_listen) &&\n         (0 != (p[poll_listen].revents & POLLIN)) )\n      (void) MHD_accept_connection (daemon);\n\n    /* Reset. New value will be set when connections are processed. */\n    daemon->data_already_pending = false;\n\n    i = 0;\n    prev = daemon->connections_tail;\n    while (NULL != (pos = prev))\n    {\n      prev = pos->prev;\n      /* first, sanity checks */\n      if (i >= num_connections)\n        break;     /* connection list changed somehow, retry later ... */\n      if (p[poll_server + i].fd != pos->socket_fd)\n        continue;  /* fd mismatch, something else happened, retry later ... */\n      call_handlers (pos,\n                     0 != (p[poll_server + i].revents & POLLIN),\n                     0 != (p[poll_server + i].revents & POLLOUT),\n                     0 != (p[poll_server + i].revents\n                           & MHD_POLL_REVENTS_ERR_DISC));\n      i++;\n    }\n#if defined(HTTPS_SUPPORT) && defined(UPGRADE_SUPPORT)\n    for (urh = daemon->urh_tail; NULL != urh; urh = urhn)\n    {\n      if (i >= num_connections)\n        break;   /* connection list changed somehow, retry later ... */\n\n      /* Get next connection here as connection can be removed\n       * from 'daemon->urh_head' list. */\n      urhn = urh->prev;\n      /* Check for fd mismatch. FIXME: required for safety? */\n      if ((p[poll_server + i].fd != urh->connection->socket_fd) ||\n          (p[poll_server + i + 1].fd != urh->mhd.socket))\n        break;\n      urh_from_pollfd (urh,\n                       &p[poll_server + i]);\n      i += 2;\n      process_urh (urh);\n      /* Finished forwarding? */\n      if ( (0 == urh->in_buffer_size) &&\n           (0 == urh->out_buffer_size) &&\n           (0 == urh->in_buffer_used) &&\n           (0 == urh->out_buffer_used) )\n      {\n        /* MHD_connection_finish_forward_() will remove connection from\n         * 'daemon->urh_head' list. */\n        MHD_connection_finish_forward_ (urh->connection);\n        urh->clean_ready = true;\n        /* If 'urh->was_closed' already was set to true, connection will be\n         * moved immediately to cleanup list. Otherwise connection\n         * will stay in suspended list until 'urh' will be marked\n         * with 'was_closed' by application. */\n        MHD_resume_connection (urh->connection);\n      }\n    }\n#endif /* HTTPS_SUPPORT && UPGRADE_SUPPORT */\n\n    free (p);\n  }\n\n  return MHD_YES;\n}\n"
}