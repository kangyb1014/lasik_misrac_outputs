{
  "user_message": "<misra_rule>\nMISRA C 2023 Rule 17.2 is: Functions shall not call themselves, either directly or indirectly.\n\n</misra_rule>\n<response format>\nProvide your answer with these fields.\n- is_rule_violated: whether the rule is violated or not (true/false),\n- scenario: a specific violation scenario.\n</response format>\n<target_code>\nHere is the code of MHD_pool_allocate:\n```c\nvoid *\nMHD_pool_allocate (struct MemoryPool *pool,\n                   size_t size,\n                   bool from_end)\n{\n  void *ret;\n  size_t asize;\n\n  mhd_assert (pool->end >= pool->pos);\n  mhd_assert (pool->size >= pool->end - pool->pos);\n  mhd_assert (pool->pos == ROUND_TO_ALIGN (pool->pos));\n  asize = ROUND_TO_ALIGN_PLUS_RED_ZONE (size);\n  if ( (0 == asize) && (0 != size) )\n    return NULL; /* size too close to SIZE_MAX */\n  if (asize > pool->end - pool->pos)\n    return NULL;\n  if (from_end)\n  {\n    ret = &pool->memory[pool->end - asize];\n    pool->end -= asize;\n  }\n  else\n  {\n    ret = &pool->memory[pool->pos];\n    pool->pos += asize;\n  }\n  _MHD_UNPOISON_MEMORY (ret, size);\n  return ret;\n}\n```\n</target_code>\n<target_code>\nHere is the code fragment that you need to analyze:\n```c\n_MHD_UNPOISON_MEMORY (ret, size);\n```\nFocus on the above code fragment and judge whether it violates the rule 17.2 or not.\n</target_code>\n",
  "is_rule_violated": false,
  "scenario": "As written, the call to _MHD_UNPOISON_MEMORY(ret, size) does not itself violate Rule 17.2. A function may call other functions or macros; Rule 17.2 is only violated if a function ends up calling itself directly or indirectly. No definition of _MHD_UNPOISON_MEMORY is provided, so there is no evidence here of recursion. \n\nSpecific violation scenario (if it existed): if _MHD_UNPOISON_MEMORY is a function or macro that (directly) calls MHD_pool_allocate, or (indirectly) calls another function that eventually calls MHD_pool_allocate, then MHD_pool_allocate would indirectly call itself and Rule 17.2 would be violated. For example:\n- if _MHD_UNPOISON_MEMORY is defined as a function that calls MHD_pool_allocate(...), or\n- if _MHD_UNPOISON_MEMORY expands to a call sequence that eventually invokes MHD_pool_allocate,\nthen the rule would be violated."
}