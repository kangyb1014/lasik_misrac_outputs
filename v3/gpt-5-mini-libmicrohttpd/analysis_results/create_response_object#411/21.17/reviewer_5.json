{
  "user_message": "An agent A claimed that the following create_response_object code violates the MISRA C 2023 rule 21.17.\n<misra_rule>\nMISRA C 2023 Rule 21.17 is Use of the string handling functions from <string.h> shall not result in accesses beyond the bounds of the objects referenced by their pointer parameters.\nThis rule strictly applies to the Standard Library functions in <string.h> such as memcpy, memmove, memset, memcmp, strcpy, strncpy, strcat, strncat, strlen, and strspn.\n</misra_rule>\n<target_code>\nHere is the original code of create_response_object.\n```c\nstatic struct MHD_Response *\ncreate_response_object (void)\n{\n#if MHD_VERSION >= 0x00097701\n  if (NULL != body_dyn)\n    return MHD_create_response_from_buffer_static (body_dyn_size,\n                                                   body_dyn);\n  else if (tool_params.empty)\n    return MHD_create_response_empty (MHD_RF_NONE);\n\n  return MHD_create_response_from_buffer_static (MHD_STATICSTR_LEN_ (tiny_body),\n                                                 tiny_body);\n\n#else  /* MHD_VERSION < 0x00097701 */\n  if (NULL != body_dyn)\n    return MHD_create_response_from_buffer (body_dyn_size,\n                                            (void *) body_dyn,\n                                            MHD_RESPMEM_PERSISTENT);\n  else if (tool_params.empty)\n    return MHD_create_response_from_buffer (0,\n                                            (void *) tiny_body,\n                                            MHD_RESPMEM_PERSISTENT);\n\n  return MHD_create_response_from_buffer (MHD_STATICSTR_LEN_ (tiny_body),\n                                          (void *) tiny_body,\n                                          MHD_RESPMEM_PERSISTENT);\n#endif /* MHD_VERSION < 0x00097701 */\n}\n```\n</target_code>\n<response format>\nProvide your answer with these fields.\n- explanation: your evaluation of the scenario provided by the agent A.\n- is_report_correct: whether the report is correct or not (true/false). True means there is a violation.\n</response format>\n<scenario>\nThe agent A provided the following violation scenario:\nPassing a non-NULL pointer with a length of 0 to the library function can lead to out-of-bounds accesses if the library ignores the supplied length and calls string.h functions on the pointer. For example, if MHD_create_response_from_buffer((size_t)0, (void *)tiny_body, ...) internally uses strlen((char *)tiny_body) or otherwise reads the buffer as a C string, and tiny_body is not a valid NUL-terminated string or its storage has no accessible bytes beyond its declared size, strlen will read past the object bounds and violate Rule 21.17.\n</scenario>\n\n<instruction>\nJudge whether the report is correct or not.\n</instruction>\n",
  "is_report_correct": false,
  "explanation": "The report is not correct for this snippet. MISRA C:2023 Rule 21.17 concerns the use of the string.h routines (memcpy, strlen, strcpy, etc.) and requires that those calls do not read or write beyond the bounds of the objects referenced by their pointer parameters. The code shown does not call any functions from <string.h>; it only calls the external library function MHD_create_response_from_buffer (or the _static variant). Whether a runtime out\u2011of\u2011bounds access can occur depends entirely on the implementation/contract of MHD_create_response_from_buffer \u2014 e.g. if that library function were to ignore the supplied length and call strlen on the pointer, that would be a bug in the library (and a violation of 21.17 in the library code), not a direct violation in this caller.\n\nIf you cannot guarantee the library\u2019s behavior, you can mitigate the risk in the caller (for older MHD versions) by passing NULL when size==0 or otherwise ensuring the pointer points to a valid NUL\u2011terminated object per the library\u2019s API. But based solely on the provided code, Agent A\u2019s claim that this code itself violates MISRA 21.17 is not correct."
}