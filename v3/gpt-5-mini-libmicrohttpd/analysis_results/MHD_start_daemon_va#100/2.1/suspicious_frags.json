{
  "user_message": "<misra_rule>\nThe target MISRA C 2023 Rule 2.1 is: A project shall not contain unreachable code.\n\n</misra_rule>\n<instruction>\nOther agents will judge whether the code follows the MISRA C 2023 guidelines.\nThey will investigate the code fragments you give.\nYour job is to find code fragments in the code that should be investigated to check whether the code follows the MISRA C rule.\n</instruction>\n<response format>\nProvide your answer with these fields.\n- suspicious_frags: The list of suspicious code fragments in the code.\nIt should contain only the code fragments exists in the code. If you do not find any suspicious code fragments, return an empty list for suspicious_frags\n- explanation: The explanation of why other code fragments should NOT be investigated.\nIt is very important to not miss any suspicious code fragments, so please give a sufficient explanation why other code fragments should not be investigated.\nDO NOT give any explanation for the selected suspicious code fragments.\n</response format>\n<target_code>\nHere is the code of MHD_start_daemon_va:\n```c\n_MHD_EXTERN struct MHD_Daemon *\nMHD_start_daemon_va (unsigned int flags,\n                     uint16_t port,\n                     MHD_AcceptPolicyCallback apc,\n                     void *apc_cls,\n                     MHD_AccessHandlerCallback dh,\n                     void *dh_cls,\n                     va_list ap)\n{\n  const MHD_SCKT_OPT_BOOL_ on = 1;\n  struct MHD_Daemon *daemon;\n  MHD_socket listen_fd = MHD_INVALID_SOCKET;\n  const struct sockaddr *pservaddr = NULL;\n  socklen_t addrlen;\n#if defined(MHD_USE_POSIX_THREADS) || defined(MHD_USE_W32_THREADS)\n  unsigned int i;\n#endif\n  enum MHD_FLAG eflags; /* same type as in MHD_Daemon */\n  enum MHD_FLAG *pflags;\n  struct MHD_InterimParams_ *interim_params;\n\n  MHD_check_global_init_ ();\n  eflags = (enum MHD_FLAG) flags;\n  pflags = &eflags;\n\n  if (0 != (*pflags & MHD_USE_THREAD_PER_CONNECTION))\n    *pflags |= MHD_USE_INTERNAL_POLLING_THREAD; /* Force enable, log warning later if needed */\n\n#ifndef HAVE_INET6\n  if (0 != (*pflags & MHD_USE_IPv6))\n    return NULL;\n#endif\n#ifndef HAVE_POLL\n  if (0 != (*pflags & MHD_USE_POLL))\n    return NULL;\n#endif\n#ifndef EPOLL_SUPPORT\n  if (0 != (*pflags & MHD_USE_EPOLL))\n    return NULL;\n#endif /* ! EPOLL_SUPPORT */\n#ifndef HTTPS_SUPPORT\n  if (0 != (*pflags & MHD_USE_TLS))\n    return NULL;\n#endif /* ! HTTPS_SUPPORT */\n#ifndef TCP_FASTOPEN\n  if (0 != (*pflags & MHD_USE_TCP_FASTOPEN))\n    return NULL;\n#endif\n  if (0 != (*pflags & MHD_ALLOW_UPGRADE))\n  {\n#ifdef UPGRADE_SUPPORT\n    *pflags |= MHD_ALLOW_SUSPEND_RESUME;\n#else  /* ! UPGRADE_SUPPORT */\n    return NULL;\n#endif /* ! UPGRADE_SUPPORT */\n  }\n#ifdef MHD_USE_THREADS\n  if ((MHD_USE_NO_THREAD_SAFETY | MHD_USE_INTERNAL_POLLING_THREAD) ==\n      ((MHD_USE_NO_THREAD_SAFETY | MHD_USE_INTERNAL_POLLING_THREAD)\n       & *pflags))\n    return NULL; /* Cannot be thread-unsafe with multiple threads */\n#else  /* ! MHD_USE_THREADS */\n  if (0 != (*pflags & MHD_USE_INTERNAL_POLLING_THREAD))\n    return NULL;\n#endif /* ! MHD_USE_THREADS */\n\n  if (NULL == dh)\n    return NULL;\n\n  /* Check for invalid combinations of flags. */\n  if ((0 != (*pflags & MHD_USE_POLL)) && (0 != (*pflags & MHD_USE_EPOLL)))\n    return NULL;\n  if ((0 != (*pflags & MHD_USE_EPOLL)) &&\n      (0 != (*pflags & MHD_USE_THREAD_PER_CONNECTION)))\n    return NULL;\n  if ((0 != (*pflags & MHD_USE_POLL)) &&\n      (0 == (*pflags & (MHD_USE_INTERNAL_POLLING_THREAD\n                        | MHD_USE_THREAD_PER_CONNECTION))))\n    return NULL;\n  if ((0 != (*pflags & MHD_USE_AUTO)) &&\n      (0 != (*pflags & (MHD_USE_POLL | MHD_USE_EPOLL))))\n    return NULL;\n\n  if (0 != (*pflags & MHD_USE_AUTO))\n  {\n#if defined(EPOLL_SUPPORT) && defined(HAVE_POLL)\n    if (0 != (*pflags & MHD_USE_THREAD_PER_CONNECTION))\n      *pflags |= MHD_USE_POLL;\n    else\n      *pflags |= MHD_USE_EPOLL; /* Including \"external select\" mode */\n#elif defined(HAVE_POLL)\n    if (0 != (*pflags & MHD_USE_INTERNAL_POLLING_THREAD))\n      *pflags |= MHD_USE_POLL; /* Including thread-per-connection */\n#elif defined(EPOLL_SUPPORT)\n    if (0 == (*pflags & MHD_USE_THREAD_PER_CONNECTION))\n      *pflags |= MHD_USE_EPOLL; /* Including \"external select\" mode */\n#else\n    /* No choice: use select() for any mode - do not modify flags */\n#endif\n  }\n\n  if (0 != (*pflags & MHD_USE_NO_THREAD_SAFETY))\n    *pflags = (*pflags & ~((enum MHD_FLAG) MHD_USE_ITC)); /* useless in single-threaded environment */\n  else if (0 != (*pflags & MHD_USE_INTERNAL_POLLING_THREAD))\n  {\n#ifdef HAVE_LISTEN_SHUTDOWN\n    if (0 != (*pflags & MHD_USE_NO_LISTEN_SOCKET))\n#endif\n    *pflags |= MHD_USE_ITC;       /* yes, must use ITC to signal thread */\n  }\n\n  if (NULL == (daemon = MHD_calloc_ (1, sizeof (struct MHD_Daemon))))\n    return NULL;\n  interim_params = (struct MHD_InterimParams_ *) \\\n                   MHD_calloc_ (1, sizeof (struct MHD_InterimParams_));\n  if (NULL == interim_params)\n  {\n    int err_num = errno;\n    free (daemon);\n    errno = err_num;\n    return NULL;\n  }\n#ifdef EPOLL_SUPPORT\n  daemon->epoll_fd = -1;\n#if defined(HTTPS_SUPPORT) && defined(UPGRADE_SUPPORT)\n  daemon->epoll_upgrade_fd = -1;\n#endif /* HTTPS_SUPPORT && UPGRADE_SUPPORT */\n#endif\n  /* try to open listen socket */\n#ifdef HTTPS_SUPPORT\n  daemon->priority_cache = NULL;\n#endif /* HTTPS_SUPPORT */\n  daemon->listen_fd = MHD_INVALID_SOCKET;\n  daemon->listen_is_unix = _MHD_NO;\n  daemon->listening_address_reuse = 0;\n  daemon->options = *pflags;\n  pflags = &daemon->options;\n  daemon->client_discipline = (0 != (*pflags & MHD_USE_PEDANTIC_CHECKS)) ?\n                              1 : 0;\n  daemon->port = port;\n  daemon->apc = apc;\n  daemon->apc_cls = apc_cls;\n  daemon->default_handler = dh;\n  daemon->default_handler_cls = dh_cls;\n  daemon->connections = 0;\n  daemon->connection_limit = MHD_MAX_CONNECTIONS_DEFAULT;\n  daemon->pool_size = MHD_POOL_SIZE_DEFAULT;\n  daemon->pool_increment = MHD_BUF_INC_SIZE;\n  daemon->unescape_callback = &unescape_wrapper;\n  daemon->connection_timeout_ms = 0;       /* no timeout */\n  MHD_itc_set_invalid_ (daemon->itc);\n#ifdef MHD_USE_THREADS\n  MHD_thread_handle_ID_set_invalid_ (&daemon->tid);\n#endif /* MHD_USE_THREADS */\n#ifdef SOMAXCONN\n  daemon->listen_backlog_size = SOMAXCONN;\n#else  /* !SOMAXCONN */\n  daemon->listen_backlog_size = 511; /* should be safe value */\n#endif /* !SOMAXCONN */\n#ifdef HAVE_MESSAGES\n  daemon->custom_error_log = &MHD_default_logger_;\n  daemon->custom_error_log_cls = stderr;\n#endif\n#ifndef MHD_WINSOCK_SOCKETS\n  daemon->sigpipe_blocked = false;\n#else  /* MHD_WINSOCK_SOCKETS */\n  /* There is no SIGPIPE on W32, nothing to block. */\n  daemon->sigpipe_blocked = true;\n#endif /* _WIN32 && ! __CYGWIN__ */\n#if defined(_DEBUG) && defined(HAVE_ACCEPT4)\n  daemon->avoid_accept4 = false;\n#endif /* _DEBUG */\n#ifdef HAS_FD_SETSIZE_OVERRIDABLE\n  daemon->fdset_size = (int) FD_SETSIZE;\n  daemon->fdset_size_set_by_app = false;\n#endif /* HAS_FD_SETSIZE_OVERRIDABLE */\n\n#ifdef DAUTH_SUPPORT\n  daemon->digest_auth_rand_size = 0;\n  daemon->digest_auth_random = NULL;\n  daemon->nonce_nc_size = 4; /* tiny */\n  daemon->dauth_def_nonce_timeout = MHD_DAUTH_DEF_TIMEOUT_;\n  daemon->dauth_def_max_nc = MHD_DAUTH_DEF_MAX_NC_;\n#endif\n#ifdef HTTPS_SUPPORT\n  if (0 != (*pflags & MHD_USE_TLS))\n  {\n    daemon->cred_type = GNUTLS_CRD_CERTIFICATE;\n  }\n#endif /* HTTPS_SUPPORT */\n\n  interim_params->num_opts = 0;\n  interim_params->fdset_size_set = false;\n  interim_params->fdset_size = 0;\n  interim_params->listen_fd_set = false;\n  interim_params->listen_fd = MHD_INVALID_SOCKET;\n  interim_params->pserver_addr_set = false;\n  interim_params->pserver_addr = NULL;\n  interim_params->server_addr_len_set = false;\n  interim_params->server_addr_len = 0;\n\n  if (MHD_NO == parse_options_va (daemon,\n                                  interim_params,\n                                  ap))\n  {\n#ifdef HTTPS_SUPPORT\n    if ( (0 != (*pflags & MHD_USE_TLS)) &&\n         (NULL != daemon->priority_cache) )\n      gnutls_priority_deinit (daemon->priority_cache);\n#endif /* HTTPS_SUPPORT */\n    free (interim_params);\n    free (daemon);\n    return NULL;\n  }\n  if (! process_interim_params (daemon,\n                                &pservaddr,\n                                &addrlen,\n                                interim_params))\n  {\n    free (interim_params);\n    free (daemon);\n    return NULL;\n  }\n  free (interim_params);\n  interim_params = NULL;\n#ifdef HTTPS_SUPPORT\n  if ((0 != (*pflags & MHD_USE_TLS))\n      && (NULL == daemon->priority_cache)\n      && ! daemon_tls_priorities_init_default (daemon))\n  {\n#ifdef HAVE_MESSAGES\n    MHD_DLOG (daemon,\n              _ (\"Failed to initialise GnuTLS priorities.\\n\"));\n#endif /* HAVE_MESSAGES */\n    free (daemon);\n    return NULL;\n  }\n#endif /* HTTPS_SUPPORT */\n\n#ifdef HAVE_MESSAGES\n  if ( (0 != (flags & MHD_USE_THREAD_PER_CONNECTION)) &&\n       (0 == (flags & MHD_USE_INTERNAL_POLLING_THREAD)) )\n  {\n    MHD_DLOG (daemon,\n              _ (\"Warning: MHD_USE_THREAD_PER_CONNECTION must be used \" \\\n                 \"only with MHD_USE_INTERNAL_POLLING_THREAD. \" \\\n                 \"Flag MHD_USE_INTERNAL_POLLING_THREAD was added. \" \\\n                 \"Consider setting MHD_USE_INTERNAL_POLLING_THREAD \" \\\n                 \"explicitly.\\n\"));\n  }\n#endif\n\n  if (MHD_D_IS_USING_THREAD_PER_CONN_ (daemon)\n      && ((NULL != daemon->notify_completed)\n          || (NULL != daemon->notify_connection)) )\n    *pflags |= MHD_USE_ITC; /* requires ITC */\n\n#ifdef _DEBUG\n#ifdef HAVE_MESSAGES\n  MHD_DLOG (daemon,\n            _ (\"Using debug build of libmicrohttpd.\\n\") );\n#endif /* HAVE_MESSAGES */\n#endif /* _DEBUG */\n\n  if ( (0 != (*pflags & MHD_USE_ITC))\n#if defined(MHD_USE_POSIX_THREADS) || defined(MHD_USE_W32_THREADS)\n       && (0 == daemon->worker_pool_size)\n#endif\n       )\n  {\n    if (! MHD_itc_init_ (daemon->itc))\n    {\n#ifdef HAVE_MESSAGES\n      MHD_DLOG (daemon,\n                _ (\"Failed to create inter-thread communication channel: %s\\n\"),\n                MHD_itc_last_strerror_ ());\n#endif\n#ifdef HTTPS_SUPPORT\n      if (NULL != daemon->priority_cache)\n        gnutls_priority_deinit (daemon->priority_cache);\n#endif /* HTTPS_SUPPORT */\n      free (daemon);\n      return NULL;\n    }\n    if (MHD_D_IS_USING_SELECT_ (daemon) &&\n        (! MHD_D_DOES_SCKT_FIT_FDSET_ (MHD_itc_r_fd_ (daemon->itc), daemon)) )\n    {\n#ifdef HAVE_MESSAGES\n      MHD_DLOG (daemon,\n                _ (\"file descriptor for inter-thread communication \" \\\n                   \"channel exceeds maximum value.\\n\"));\n#endif\n      MHD_itc_destroy_chk_ (daemon->itc);\n#ifdef HTTPS_SUPPORT\n      if (NULL != daemon->priority_cache)\n        gnutls_priority_deinit (daemon->priority_cache);\n#endif /* HTTPS_SUPPORT */\n      free (daemon);\n      return NULL;\n    }\n  }\n\n#ifdef DAUTH_SUPPORT\n  if (NULL != daemon->digest_auth_random_copy)\n  {\n    mhd_assert (daemon == daemon->digest_auth_random_copy);\n    daemon->digest_auth_random_copy = malloc (daemon->digest_auth_rand_size);\n    if (NULL == daemon->digest_auth_random_copy)\n    {\n#ifdef HTTPS_SUPPORT\n      if (0 != (*pflags & MHD_USE_TLS))\n        gnutls_priority_deinit (daemon->priority_cache);\n#endif /* HTTPS_SUPPORT */\n      free (daemon);\n      return NULL;\n    }\n    memcpy (daemon->digest_auth_random_copy,\n            daemon->digest_auth_random,\n            daemon->digest_auth_rand_size);\n    daemon->digest_auth_random = daemon->digest_auth_random_copy;\n  }\n  if (daemon->nonce_nc_size > 0)\n  {\n    if ( ( (size_t) (daemon->nonce_nc_size * sizeof (struct MHD_NonceNc)))\n         / sizeof(struct MHD_NonceNc) != daemon->nonce_nc_size)\n    {\n#ifdef HAVE_MESSAGES\n      MHD_DLOG (daemon,\n                _ (\"Specified value for NC_SIZE too large.\\n\"));\n#endif\n#ifdef HTTPS_SUPPORT\n      if (0 != (*pflags & MHD_USE_TLS))\n        gnutls_priority_deinit (daemon->priority_cache);\n#endif /* HTTPS_SUPPORT */\n      free (daemon->digest_auth_random_copy);\n      free (daemon);\n      return NULL;\n    }\n    daemon->nnc = MHD_calloc_ (daemon->nonce_nc_size,\n                               sizeof (struct MHD_NonceNc));\n    if (NULL == daemon->nnc)\n    {\n#ifdef HAVE_MESSAGES\n      MHD_DLOG (daemon,\n                _ (\"Failed to allocate memory for nonce-nc map: %s\\n\"),\n                MHD_strerror_ (errno));\n#endif\n#ifdef HTTPS_SUPPORT\n      if (0 != (*pflags & MHD_USE_TLS))\n        gnutls_priority_deinit (daemon->priority_cache);\n#endif /* HTTPS_SUPPORT */\n      free (daemon->digest_auth_random_copy);\n      free (daemon);\n      return NULL;\n    }\n  }\n\n#if defined(MHD_USE_POSIX_THREADS) || defined(MHD_USE_W32_THREADS)\n  if (! MHD_mutex_init_ (&daemon->nnc_lock))\n  {\n#ifdef HAVE_MESSAGES\n    MHD_DLOG (daemon,\n              _ (\"MHD failed to initialize nonce-nc mutex.\\n\"));\n#endif\n#ifdef HTTPS_SUPPORT\n    if (0 != (*pflags & MHD_USE_TLS))\n      gnutls_priority_deinit (daemon->priority_cache);\n#endif /* HTTPS_SUPPORT */\n    free (daemon->digest_auth_random_copy);\n    free (daemon->nnc);\n    free (daemon);\n    return NULL;\n  }\n#endif\n#endif\n\n  /* Thread polling currently works only with internal select thread mode */\n#if defined(MHD_USE_POSIX_THREADS) || defined(MHD_USE_W32_THREADS)\n  if ( (! MHD_D_IS_USING_THREADS_ (daemon)) &&\n       (daemon->worker_pool_size > 0) )\n  {\n#ifdef HAVE_MESSAGES\n    MHD_DLOG (daemon,\n              _ (\"MHD thread polling only works with \" \\\n                 \"MHD_USE_INTERNAL_POLLING_THREAD.\\n\"));\n#endif\n    goto free_and_fail;\n  }\n#endif\n\n  if ( (MHD_INVALID_SOCKET == daemon->listen_fd) &&\n       (0 == (*pflags & MHD_USE_NO_LISTEN_SOCKET)) )\n  {\n    /* try to open listen socket */\n    struct sockaddr_in servaddr4;\n#ifdef HAVE_INET6\n    struct sockaddr_in6 servaddr6;\n    const bool use_ipv6 = (0 != (*pflags & MHD_USE_IPv6));\n#else  /* ! HAVE_INET6 */\n    const bool use_ipv6 = false;\n#endif /* ! HAVE_INET6 */\n    int domain;\n\n    if (NULL != pservaddr)\n    {\n#ifdef HAVE_STRUCT_SOCKADDR_SA_LEN\n      const socklen_t sa_len = pservaddr->sa_len;\n#endif /* HAVE_STRUCT_SOCKADDR_SA_LEN */\n#ifdef HAVE_INET6\n      if (use_ipv6 && (AF_INET6 != pservaddr->sa_family))\n      {\n#ifdef HAVE_MESSAGES\n        MHD_DLOG (daemon,\n                  _ (\"MHD_USE_IPv6 is enabled, but 'struct sockaddr *' \" \\\n                     \"specified for MHD_OPTION_SOCK_ADDR_LEN or \" \\\n                     \"MHD_OPTION_SOCK_ADDR is not IPv6 address.\\n\"));\n#endif /* HAVE_MESSAGES */\n        goto free_and_fail;\n      }\n#endif /* HAVE_INET6 */\n      switch (pservaddr->sa_family)\n      {\n      case AF_INET:\n        if (1)\n        {\n          struct sockaddr_in sa4;\n          uint16_t sa4_port;\n          if ((0 != addrlen)\n              && (((socklen_t) sizeof(sa4)) > addrlen))\n          {\n#ifdef HAVE_MESSAGES\n            MHD_DLOG (daemon,\n                      _ (\"The size specified for MHD_OPTION_SOCK_ADDR_LEN \" \\\n                         \"option is wrong.\\n\"));\n#endif /* HAVE_MESSAGES */\n            goto free_and_fail;\n          }\n#ifdef HAVE_STRUCT_SOCKADDR_SA_LEN\n          if (0 != sa_len)\n          {\n            if (((socklen_t) sizeof(sa4)) > sa_len)\n            {\n#ifdef HAVE_MESSAGES\n              MHD_DLOG (daemon,\n                        _ (\"The value of 'struct sockaddr.sa_len' provided \" \\\n                           \"via MHD_OPTION_SOCK_ADDR_LEN option is not zero \" \\\n                           \"and does not match 'sa_family' value of the \" \\\n                           \"same structure.\\n\"));\n#endif /* HAVE_MESSAGES */\n              goto free_and_fail;\n            }\n            if ((0 == addrlen) || (sa_len < addrlen))\n              addrlen = sa_len; /* Use smaller value for safety */\n          }\n#endif /* HAVE_STRUCT_SOCKADDR_SA_LEN */\n          if (0 == addrlen)\n            addrlen = sizeof(sa4);\n          memcpy (&sa4, pservaddr, sizeof(sa4));  /* Required due to stronger alignment */\n          sa4_port = (uint16_t) ntohs (sa4.sin_port);\n#ifndef MHD_USE_GETSOCKNAME\n          if (0 != sa4_port)\n#endif /* ! MHD_USE_GETSOCKNAME */\n          daemon->port = sa4_port;\n          domain = PF_INET;\n        }\n        break;\n#ifdef HAVE_INET6\n      case AF_INET6:\n        if (1)\n        {\n          struct sockaddr_in6 sa6;\n          uint16_t sa6_port;\n          if ((0 != addrlen)\n              && (((socklen_t) sizeof(sa6)) > addrlen))\n          {\n#ifdef HAVE_MESSAGES\n            MHD_DLOG (daemon,\n                      _ (\"The size specified for MHD_OPTION_SOCK_ADDR_LEN \" \\\n                         \"option is wrong.\\n\"));\n#endif /* HAVE_MESSAGES */\n            goto free_and_fail;\n          }\n#ifdef HAVE_STRUCT_SOCKADDR_SA_LEN\n          if (0 != sa_len)\n          {\n            if (((socklen_t) sizeof(sa6)) > sa_len)\n            {\n#ifdef HAVE_MESSAGES\n              MHD_DLOG (daemon,\n                        _ (\"The value of 'struct sockaddr.sa_len' provided \" \\\n                           \"via MHD_OPTION_SOCK_ADDR_LEN option is not zero \" \\\n                           \"and does not match 'sa_family' value of the \" \\\n                           \"same structure.\\n\"));\n#endif /* HAVE_MESSAGES */\n              goto free_and_fail;\n            }\n            if ((0 == addrlen) || (sa_len < addrlen))\n              addrlen = sa_len; /* Use smaller value for safety */\n          }\n#endif /* HAVE_STRUCT_SOCKADDR_SA_LEN */\n          if (0 == addrlen)\n            addrlen = sizeof(sa6);\n          memcpy (&sa6, pservaddr, sizeof(sa6));  /* Required due to stronger alignment */\n          sa6_port = (uint16_t) ntohs (sa6.sin6_port);\n#ifndef MHD_USE_GETSOCKNAME\n          if (0 != sa6_port)\n#endif /* ! MHD_USE_GETSOCKNAME */\n          daemon->port = sa6_port;\n          domain = PF_INET6;\n          *pflags |= ((enum MHD_FLAG) MHD_USE_IPv6);\n        }\n        break;\n#endif /* HAVE_INET6 */\n#ifdef AF_UNIX\n      case AF_UNIX:\n#endif /* AF_UNIX */\n      default:\n#ifdef HAVE_STRUCT_SOCKADDR_SA_LEN\n        if (0 == addrlen)\n          addrlen = sa_len;\n        else if ((0 != sa_len) && (sa_len < addrlen))\n          addrlen = sa_len; /* Use smaller value for safety */\n#endif /* HAVE_STRUCT_SOCKADDR_SA_LEN */\n        if (0 >= addrlen)\n        {\n#ifdef HAVE_MESSAGES\n          MHD_DLOG (daemon,\n                    _ (\"The 'sa_family' of the 'struct sockaddr' provided \" \\\n                       \"via MHD_OPTION_SOCK_ADDR option is not supported.\\n\"));\n#endif /* HAVE_MESSAGES */\n          goto free_and_fail;\n        }\n#ifdef AF_UNIX\n        if (AF_UNIX == pservaddr->sa_family)\n        {\n          daemon->port = 0;     /* special value for UNIX domain sockets */\n          daemon->listen_is_unix = _MHD_YES;\n#ifdef PF_UNIX\n          domain = PF_UNIX;\n#else /* ! PF_UNIX */\n          domain = AF_UNIX;\n#endif /* ! PF_UNIX */\n        }\n        else /* combined with the next 'if' */\n#endif /* AF_UNIX */\n        if (1)\n        {\n          daemon->port = 0;     /* ugh */\n          daemon->listen_is_unix = _MHD_UNKNOWN;\n          /* Assumed the same values for AF_* and PF_* */\n          domain = pservaddr->sa_family;\n        }\n        break;\n      }\n    }\n    else\n    {\n      if (! use_ipv6)\n      {\n        memset (&servaddr4,\n                0,\n                sizeof (struct sockaddr_in));\n        servaddr4.sin_family = AF_INET;\n        servaddr4.sin_port = htons (port);\n        if (0 != INADDR_ANY)\n          servaddr4.sin_addr.s_addr = htonl (INADDR_ANY);\n#ifdef HAVE_STRUCT_SOCKADDR_IN_SIN_LEN\n        servaddr4.sin_len = sizeof (struct sockaddr_in);\n#endif\n        pservaddr = (struct sockaddr *) &servaddr4;\n        addrlen = (socklen_t) sizeof(servaddr4);\n        daemon->listen_is_unix = _MHD_NO;\n        domain = PF_INET;\n      }\n#ifdef HAVE_INET6\n      else\n      {\n#ifdef IN6ADDR_ANY_INIT\n        static const struct in6_addr static_in6any = IN6ADDR_ANY_INIT;\n#endif\n        memset (&servaddr6,\n                0,\n                sizeof (struct sockaddr_in6));\n        servaddr6.sin6_family = AF_INET6;\n        servaddr6.sin6_port = htons (port);\n#ifdef IN6ADDR_ANY_INIT\n        servaddr6.sin6_addr = static_in6any;\n#endif\n#ifdef HAVE_STRUCT_SOCKADDR_IN6_SIN6_LEN\n        servaddr6.sin6_len = sizeof (struct sockaddr_in6);\n#endif\n        pservaddr = (struct sockaddr *) &servaddr6;\n        addrlen = (socklen_t) sizeof (servaddr6);\n        daemon->listen_is_unix = _MHD_NO;\n        domain = PF_INET6;\n      }\n#endif /* HAVE_INET6 */\n    }\n\n    listen_fd = MHD_socket_create_listen_ (domain);\n    if (MHD_INVALID_SOCKET == listen_fd)\n    {\n#ifdef HAVE_MESSAGES\n      MHD_DLOG (daemon,\n                _ (\"Failed to create socket for listening: %s\\n\"),\n                MHD_socket_last_strerr_ ());\n#endif\n      goto free_and_fail;\n    }\n    if (MHD_D_IS_USING_SELECT_ (daemon) &&\n        (! MHD_D_DOES_SCKT_FIT_FDSET_ (listen_fd, daemon)) )\n    {\n#ifdef HAVE_MESSAGES\n      MHD_DLOG (daemon,\n                _ (\"Listen socket descriptor (%d) is not \" \\\n                   \"less than daemon FD_SETSIZE value (%d).\\n\"),\n                (int) listen_fd,\n                (int) MHD_D_GET_FD_SETSIZE_ (daemon));\n#endif\n      MHD_socket_close_chk_ (listen_fd);\n      listen_fd = MHD_INVALID_SOCKET;\n      goto free_and_fail;\n    }\n\n    /* Apply the socket options according to listening_address_reuse. */\n    if (0 == daemon->listening_address_reuse)\n    {\n#ifndef MHD_WINSOCK_SOCKETS\n      /* No user requirement, use \"traditional\" default SO_REUSEADDR\n       * on non-W32 platforms, and do not fail if it doesn't work.\n       * Don't use it on W32, because on W32 it will allow multiple\n       * bind to the same address:port, like SO_REUSEPORT on others. */\n      if (0 > setsockopt (listen_fd,\n                          SOL_SOCKET,\n                          SO_REUSEADDR,\n                          (const void *) &on, sizeof (on)))\n      {\n#ifdef HAVE_MESSAGES\n        MHD_DLOG (daemon,\n                  _ (\"setsockopt failed: %s\\n\"),\n                  MHD_socket_last_strerr_ ());\n#endif\n      }\n#endif /* ! MHD_WINSOCK_SOCKETS */\n    }\n    else if (daemon->listening_address_reuse > 0)\n    {\n      /* User requested to allow reusing listening address:port. */\n#ifndef MHD_WINSOCK_SOCKETS\n      /* Use SO_REUSEADDR on non-W32 platforms, and do not fail if\n       * it doesn't work. */\n      if (0 > setsockopt (listen_fd,\n                          SOL_SOCKET,\n                          SO_REUSEADDR,\n                          (const void *) &on, sizeof (on)))\n      {\n#ifdef HAVE_MESSAGES\n        MHD_DLOG (daemon,\n                  _ (\"setsockopt failed: %s\\n\"),\n                  MHD_socket_last_strerr_ ());\n#endif\n      }\n#endif /* ! MHD_WINSOCK_SOCKETS */\n      /* Use SO_REUSEADDR on Windows and SO_REUSEPORT on most platforms.\n       * Fail if SO_REUSEPORT is not defined or setsockopt fails.\n       */\n      /* SO_REUSEADDR on W32 has the same semantics\n         as SO_REUSEPORT on BSD/Linux */\n#if defined(MHD_WINSOCK_SOCKETS) || defined(SO_REUSEPORT)\n      if (0 > setsockopt (listen_fd,\n                          SOL_SOCKET,\n#ifndef MHD_WINSOCK_SOCKETS\n                          SO_REUSEPORT,\n#else  /* MHD_WINSOCK_SOCKETS */\n                          SO_REUSEADDR,\n#endif /* MHD_WINSOCK_SOCKETS */\n                          (const void *) &on,\n                          sizeof (on)))\n      {\n#ifdef HAVE_MESSAGES\n        MHD_DLOG (daemon,\n                  _ (\"setsockopt failed: %s\\n\"),\n                  MHD_socket_last_strerr_ ());\n#endif\n        goto free_and_fail;\n      }\n#else  /* !MHD_WINSOCK_SOCKETS && !SO_REUSEPORT */\n      /* we're supposed to allow address:port re-use, but\n         on this platform we cannot; fail hard */\n#ifdef HAVE_MESSAGES\n      MHD_DLOG (daemon,\n                _ (\"Cannot allow listening address reuse: \" \\\n                   \"SO_REUSEPORT not defined.\\n\"));\n#endif\n      goto free_and_fail;\n#endif /* !MHD_WINSOCK_SOCKETS && !SO_REUSEPORT */\n    }\n    else   /* if (daemon->listening_address_reuse < 0) */\n    {\n      /* User requested to disallow reusing listening address:port.\n       * Do nothing except for Windows where SO_EXCLUSIVEADDRUSE\n       * is used and Solaris with SO_EXCLBIND.\n       * Fail if MHD was compiled for W32 without SO_EXCLUSIVEADDRUSE\n       * or setsockopt fails.\n       */\n#if (defined(MHD_WINSOCK_SOCKETS) && defined(SO_EXCLUSIVEADDRUSE)) || \\\n      (defined(__sun) && defined(SO_EXCLBIND))\n      if (0 > setsockopt (listen_fd,\n                          SOL_SOCKET,\n#ifdef SO_EXCLUSIVEADDRUSE\n                          SO_EXCLUSIVEADDRUSE,\n#else  /* SO_EXCLBIND */\n                          SO_EXCLBIND,\n#endif /* SO_EXCLBIND */\n                          (const void *) &on,\n                          sizeof (on)))\n      {\n#ifdef HAVE_MESSAGES\n        MHD_DLOG (daemon,\n                  _ (\"setsockopt failed: %s\\n\"),\n                  MHD_socket_last_strerr_ ());\n#endif\n        goto free_and_fail;\n      }\n#elif defined(MHD_WINSOCK_SOCKETS) /* SO_EXCLUSIVEADDRUSE not defined on W32? */\n#ifdef HAVE_MESSAGES\n      MHD_DLOG (daemon,\n                _ (\"Cannot disallow listening address reuse: \" \\\n                   \"SO_EXCLUSIVEADDRUSE not defined.\\n\"));\n#endif\n      goto free_and_fail;\n#endif /* MHD_WINSOCK_SOCKETS */\n    }\n\n    /* check for user supplied sockaddr */\n    daemon->listen_fd = listen_fd;\n\n    if (0 != (*pflags & MHD_USE_IPv6))\n    {\n#ifdef IPPROTO_IPV6\n#ifdef IPV6_V6ONLY\n      /* Note: \"IPV6_V6ONLY\" is declared by Windows Vista ff., see \"IPPROTO_IPV6 Socket Options\"\n         (http://msdn.microsoft.com/en-us/library/ms738574%28v=VS.85%29.aspx);\n         and may also be missing on older POSIX systems; good luck if you have any of those,\n         your IPv6 socket may then also bind against IPv4 anyway... */\n      const MHD_SCKT_OPT_BOOL_ v6_only =\n        (MHD_USE_DUAL_STACK != (*pflags & MHD_USE_DUAL_STACK));\n      if (0 > setsockopt (listen_fd,\n                          IPPROTO_IPV6, IPV6_V6ONLY,\n                          (const void *) &v6_only,\n                          sizeof (v6_only)))\n      {\n#ifdef HAVE_MESSAGES\n        MHD_DLOG (daemon,\n                  _ (\"setsockopt failed: %s\\n\"),\n                  MHD_socket_last_strerr_ ());\n#endif\n      }\n#endif\n#endif\n    }\n    if (0 != bind (listen_fd, pservaddr, addrlen))\n    {\n#ifdef HAVE_MESSAGES\n      MHD_DLOG (daemon,\n                _ (\"Failed to bind to port %u: %s\\n\"),\n                (unsigned int) port,\n                MHD_socket_last_strerr_ ());\n#endif\n      MHD_socket_close_chk_ (listen_fd);\n      listen_fd = MHD_INVALID_SOCKET;\n      goto free_and_fail;\n    }\n#ifdef TCP_FASTOPEN\n    if (0 != (*pflags & MHD_USE_TCP_FASTOPEN))\n    {\n      if (0 == daemon->fastopen_queue_size)\n        daemon->fastopen_queue_size = MHD_TCP_FASTOPEN_QUEUE_SIZE_DEFAULT;\n      if (0 != setsockopt (listen_fd,\n                           IPPROTO_TCP,\n                           TCP_FASTOPEN,\n                           (const void *) &daemon->fastopen_queue_size,\n                           sizeof (daemon->fastopen_queue_size)))\n      {\n#ifdef HAVE_MESSAGES\n        MHD_DLOG (daemon,\n                  _ (\"setsockopt failed: %s\\n\"),\n                  MHD_socket_last_strerr_ ());\n#endif\n      }\n    }\n#endif\n    if (0 != listen (listen_fd,\n                     (int) daemon->listen_backlog_size))\n    {\n#ifdef HAVE_MESSAGES\n      MHD_DLOG (daemon,\n                _ (\"Failed to listen for connections: %s\\n\"),\n                MHD_socket_last_strerr_ ());\n#endif\n      MHD_socket_close_chk_ (listen_fd);\n      listen_fd = MHD_INVALID_SOCKET;\n      goto free_and_fail;\n    }\n  }\n  else\n  {\n    if (MHD_D_IS_USING_SELECT_ (daemon) &&\n        (! MHD_D_DOES_SCKT_FIT_FDSET_ (daemon->listen_fd, daemon)) )\n    {\n#ifdef HAVE_MESSAGES\n      MHD_DLOG (daemon,\n                _ (\"Listen socket descriptor (%d) is not \" \\\n                   \"less than daemon FD_SETSIZE value (%d).\\n\"),\n                (int) daemon->listen_fd,\n                (int) MHD_D_GET_FD_SETSIZE_ (daemon));\n#endif\n      goto free_and_fail;\n    }\n    else\n    {\n#if defined(SOL_SOCKET) && (defined(SO_DOMAIN) || defined(SO_PROTOCOL_INFOW))\n      int af;\n      int opt_name;\n      void *poptval;\n      socklen_t optval_size;\n#ifdef SO_DOMAIN\n      opt_name = SO_DOMAIN;\n      poptval = &af;\n      optval_size = (socklen_t) sizeof (af);\n#else  /* SO_PROTOCOL_INFOW */\n      WSAPROTOCOL_INFOW prot_info;\n      opt_name = SO_PROTOCOL_INFOW;\n      poptval = &prot_info;\n      optval_size = (socklen_t) sizeof (prot_info);\n#endif /* SO_PROTOCOL_INFOW */\n\n      if (0 == getsockopt (daemon->listen_fd,\n                           SOL_SOCKET,\n                           opt_name,\n                           poptval,\n                           &optval_size))\n      {\n#ifndef SO_DOMAIN\n        af = prot_info.iAddressFamily;\n#endif /* SO_DOMAIN */\n        switch (af)\n        {\n        case AF_INET:\n          daemon->listen_is_unix = _MHD_NO;\n          break;\n#ifdef HAVE_INET6\n        case AF_INET6:\n          *pflags |= MHD_USE_IPv6;\n          daemon->listen_is_unix = _MHD_NO;\n          break;\n#endif /* HAVE_INET6 */\n#ifdef AF_UNIX\n        case AF_UNIX:\n          daemon->port = 0;     /* special value for UNIX domain sockets */\n          daemon->listen_is_unix = _MHD_YES;\n          break;\n#endif /* AF_UNIX */\n        default:\n          daemon->port = 0;     /* ugh */\n          daemon->listen_is_unix = _MHD_UNKNOWN;\n          break;\n        }\n      }\n      else\n#endif /* SOL_SOCKET && (SO_DOMAIN || SO_PROTOCOL_INFOW)) */\n      daemon->listen_is_unix = _MHD_UNKNOWN;\n    }\n\n    listen_fd = daemon->listen_fd;\n#ifdef MHD_USE_GETSOCKNAME\n    daemon->port = 0;  /* Force use of autodetection */\n#endif /* MHD_USE_GETSOCKNAME */\n  }\n\n#ifdef MHD_USE_GETSOCKNAME\n  if ( (0 == daemon->port) &&\n       (0 == (*pflags & MHD_USE_NO_LISTEN_SOCKET)) &&\n       (_MHD_YES != daemon->listen_is_unix) )\n  {   /* Get port number. */\n    struct sockaddr_storage bindaddr;\n\n    memset (&bindaddr,\n            0,\n            sizeof (struct sockaddr_storage));\n    addrlen = sizeof (struct sockaddr_storage);\n#ifdef HAVE_STRUCT_SOCKADDR_STORAGE_SS_LEN\n    bindaddr.ss_len = (socklen_t) addrlen;\n#endif\n    if (0 != getsockname (listen_fd,\n                          (struct sockaddr *) &bindaddr,\n                          &addrlen))\n    {\n#ifdef HAVE_MESSAGES\n      MHD_DLOG (daemon,\n                _ (\"Failed to get listen port number: %s\\n\"),\n                MHD_socket_last_strerr_ ());\n#endif /* HAVE_MESSAGES */\n    }\n#ifdef MHD_POSIX_SOCKETS\n    else if (sizeof (bindaddr) < addrlen)\n    {\n      /* should be impossible with `struct sockaddr_storage` */\n#ifdef HAVE_MESSAGES\n      MHD_DLOG (daemon,\n                _ (\"Failed to get listen port number \" \\\n                   \"(`struct sockaddr_storage` too small!?).\\n\"));\n#endif /* HAVE_MESSAGES */\n    }\n#ifndef __linux__\n    else if (0 == addrlen)\n    {\n      /* Many non-Linux-based platforms return zero addrlen\n       * for AF_UNIX sockets */\n      daemon->port = 0;     /* special value for UNIX domain sockets */\n      if (_MHD_UNKNOWN == daemon->listen_is_unix)\n        daemon->listen_is_unix = _MHD_YES;\n    }\n#endif /* __linux__ */\n#endif /* MHD_POSIX_SOCKETS */\n    else\n    {\n      switch (bindaddr.ss_family)\n      {\n      case AF_INET:\n        {\n          struct sockaddr_in *s4 = (struct sockaddr_in *) &bindaddr;\n\n          daemon->port = ntohs (s4->sin_port);\n          daemon->listen_is_unix = _MHD_NO;\n          break;\n        }\n#ifdef HAVE_INET6\n      case AF_INET6:\n        {\n          struct sockaddr_in6 *s6 = (struct sockaddr_in6 *) &bindaddr;\n\n          daemon->port = ntohs (s6->sin6_port);\n          daemon->listen_is_unix = _MHD_NO;\n          mhd_assert (0 != (*pflags & MHD_USE_IPv6));\n          break;\n        }\n#endif /* HAVE_INET6 */\n#ifdef AF_UNIX\n      case AF_UNIX:\n        daemon->port = 0;     /* special value for UNIX domain sockets */\n        daemon->listen_is_unix = _MHD_YES;\n        break;\n#endif\n      default:\n#ifdef HAVE_MESSAGES\n        MHD_DLOG (daemon,\n                  _ (\"Listen socket has unknown address family!\\n\"));\n#endif\n        daemon->port = 0;     /* ugh */\n        daemon->listen_is_unix = _MHD_UNKNOWN;\n        break;\n      }\n    }\n  }\n#endif /* MHD_USE_GETSOCKNAME */\n\n  if (MHD_INVALID_SOCKET != listen_fd)\n  {\n    mhd_assert (0 == (*pflags & MHD_USE_NO_LISTEN_SOCKET));\n    if (! MHD_socket_nonblocking_ (listen_fd))\n    {\n#ifdef HAVE_MESSAGES\n      MHD_DLOG (daemon,\n                _ (\"Failed to set nonblocking mode on listening socket: %s\\n\"),\n                MHD_socket_last_strerr_ ());\n#endif\n      if (MHD_D_IS_USING_EPOLL_ (daemon)\n#if defined(MHD_USE_POSIX_THREADS) || defined(MHD_USE_W32_THREADS)\n          || (daemon->worker_pool_size > 0)\n#endif\n          )\n      {\n        /* Accept must be non-blocking. Multiple children may wake up\n         * to handle a new connection, but only one will win the race.\n         * The others must immediately return. */\n        MHD_socket_close_chk_ (listen_fd);\n        listen_fd = MHD_INVALID_SOCKET;\n        goto free_and_fail;\n      }\n      daemon->listen_nonblk = false;\n    }\n    else\n      daemon->listen_nonblk = true;\n  }\n  else\n  {\n    mhd_assert (0 != (*pflags & MHD_USE_NO_LISTEN_SOCKET));\n    daemon->listen_nonblk = false; /* Actually listen socket does not exist */\n  }\n\n#ifdef EPOLL_SUPPORT\n  if (MHD_D_IS_USING_EPOLL_ (daemon)\n#if defined(MHD_USE_POSIX_THREADS) || defined(MHD_USE_W32_THREADS)\n      && (0 == daemon->worker_pool_size)\n#endif\n      )\n  {\n    if (MHD_D_IS_USING_THREAD_PER_CONN_ (daemon))\n    {\n#ifdef HAVE_MESSAGES\n      MHD_DLOG (daemon,\n                _ (\"Combining MHD_USE_THREAD_PER_CONNECTION and \" \\\n                   \"MHD_USE_EPOLL is not supported.\\n\"));\n#endif\n      goto free_and_fail;\n    }\n    if (MHD_NO == setup_epoll_to_listen (daemon))\n      goto free_and_fail;\n  }\n#endif /* EPOLL_SUPPORT */\n\n#if defined(MHD_USE_POSIX_THREADS) || defined(MHD_USE_W32_THREADS)\n  if (! MHD_mutex_init_ (&daemon->per_ip_connection_mutex))\n  {\n#ifdef HAVE_MESSAGES\n    MHD_DLOG (daemon,\n              _ (\"MHD failed to initialize IP connection limit mutex.\\n\"));\n#endif\n    if (MHD_INVALID_SOCKET != listen_fd)\n      MHD_socket_close_chk_ (listen_fd);\n    goto free_and_fail;\n  }\n#endif\n\n#ifdef HTTPS_SUPPORT\n  /* initialize HTTPS daemon certificate aspects & send / recv functions */\n  if ( (0 != (*pflags & MHD_USE_TLS)) &&\n       (0 != MHD_TLS_init (daemon)) )\n  {\n#ifdef HAVE_MESSAGES\n    MHD_DLOG (daemon,\n              _ (\"Failed to initialize TLS support.\\n\"));\n#endif\n    if (MHD_INVALID_SOCKET != listen_fd)\n      MHD_socket_close_chk_ (listen_fd);\n#if defined(MHD_USE_POSIX_THREADS) || defined(MHD_USE_W32_THREADS)\n    MHD_mutex_destroy_chk_ (&daemon->per_ip_connection_mutex);\n#endif\n    goto free_and_fail;\n  }\n#endif /* HTTPS_SUPPORT */\n#if defined(MHD_USE_POSIX_THREADS) || defined(MHD_USE_W32_THREADS)\n  /* Start threads if requested by parameters */\n  if (MHD_D_IS_USING_THREADS_ (daemon))\n  {\n    /* Internal thread (or threads) is used.\n     * Make sure that MHD will be able to communicate with threads. */\n    /* If using a thread pool ITC will be initialised later\n     * for each individual worker thread. */\n#ifdef HAVE_LISTEN_SHUTDOWN\n    mhd_assert ((1 < daemon->worker_pool_size) || \\\n                (MHD_ITC_IS_VALID_ (daemon->itc)) || \\\n                (MHD_INVALID_SOCKET != daemon->listen_fd));\n#else  /* ! HAVE_LISTEN_SHUTDOWN */\n    mhd_assert ((1 < daemon->worker_pool_size) || \\\n                (MHD_ITC_IS_VALID_ (daemon->itc)));\n#endif /* ! HAVE_LISTEN_SHUTDOWN */\n    if (0 == daemon->worker_pool_size)\n    {\n      if (! MHD_mutex_init_ (&daemon->cleanup_connection_mutex))\n      {\n#ifdef HAVE_MESSAGES\n        MHD_DLOG (daemon,\n                  _ (\"Failed to initialise internal lists mutex.\\n\"));\n#endif\n        MHD_mutex_destroy_chk_ (&daemon->per_ip_connection_mutex);\n        if (MHD_INVALID_SOCKET != listen_fd)\n          MHD_socket_close_chk_ (listen_fd);\n        goto free_and_fail;\n      }\n      if (! MHD_mutex_init_ (&daemon->new_connections_mutex))\n      {\n#ifdef HAVE_MESSAGES\n        MHD_DLOG (daemon,\n                  _ (\"Failed to initialise mutex.\\n\"));\n#endif\n        MHD_mutex_destroy_chk_ (&daemon->per_ip_connection_mutex);\n        MHD_mutex_destroy_chk_ (&daemon->cleanup_connection_mutex);\n        if (MHD_INVALID_SOCKET != listen_fd)\n          MHD_socket_close_chk_ (listen_fd);\n        goto free_and_fail;\n      }\n      if (! MHD_create_named_thread_ (&daemon->tid,\n                                      MHD_D_IS_USING_THREAD_PER_CONN_ (daemon) ?\n                                      \"MHD-listen\" : \"MHD-single\",\n                                      daemon->thread_stack_size,\n                                      &MHD_polling_thread,\n                                      daemon) )\n      {\n#ifdef HAVE_MESSAGES\n#ifdef EAGAIN\n        if (EAGAIN == errno)\n          MHD_DLOG (daemon,\n                    _ (\"Failed to create a new thread because it would have \" \\\n                       \"exceeded the system limit on the number of threads or \" \\\n                       \"no system resources available.\\n\"));\n        else\n#endif /* EAGAIN */\n        MHD_DLOG (daemon,\n                  _ (\"Failed to create listen thread: %s\\n\"),\n                  MHD_strerror_ (errno));\n#endif /* HAVE_MESSAGES */\n        MHD_mutex_destroy_chk_ (&daemon->new_connections_mutex);\n        MHD_mutex_destroy_chk_ (&daemon->per_ip_connection_mutex);\n        MHD_mutex_destroy_chk_ (&daemon->cleanup_connection_mutex);\n        if (MHD_INVALID_SOCKET != listen_fd)\n          MHD_socket_close_chk_ (listen_fd);\n        goto free_and_fail;\n      }\n    }\n    else   /* 0 < daemon->worker_pool_size */\n    {\n      /* Coarse-grained count of connections per thread (note error\n       * due to integer division). Also keep track of how many\n       * connections are leftover after an equal split. */\n      unsigned int conns_per_thread = daemon->connection_limit\n                                      / daemon->worker_pool_size;\n      unsigned int leftover_conns = daemon->connection_limit\n                                    % daemon->worker_pool_size;\n\n      mhd_assert (2 <= daemon->worker_pool_size);\n      i = 0;     /* we need this in case fcntl or malloc fails */\n\n      /* Allocate memory for pooled objects */\n      daemon->worker_pool = malloc (sizeof (struct MHD_Daemon)\n                                    * daemon->worker_pool_size);\n      if (NULL == daemon->worker_pool)\n        goto thread_failed;\n\n      /* Start the workers in the pool */\n      for (i = 0; i < daemon->worker_pool_size; ++i)\n      {\n        /* Create copy of the Daemon object for each worker */\n        struct MHD_Daemon *d = &daemon->worker_pool[i];\n\n        memcpy (d, daemon, sizeof (struct MHD_Daemon));\n        /* Adjust polling params for worker daemons; note that memcpy()\n           has already copied MHD_USE_INTERNAL_POLLING_THREAD thread mode into\n           the worker threads. */\n        d->master = daemon;\n        d->worker_pool_size = 0;\n        d->worker_pool = NULL;\n        if (! MHD_mutex_init_ (&d->cleanup_connection_mutex))\n        {\n#ifdef HAVE_MESSAGES\n          MHD_DLOG (daemon,\n                    _ (\"Failed to initialise internal lists mutex.\\n\"));\n#endif\n          goto thread_failed;\n        }\n        if (! MHD_mutex_init_ (&d->new_connections_mutex))\n        {\n#ifdef HAVE_MESSAGES\n          MHD_DLOG (daemon,\n                    _ (\"Failed to initialise mutex.\\n\"));\n#endif\n          MHD_mutex_destroy_chk_ (&d->cleanup_connection_mutex);\n          goto thread_failed;\n        }\n        if (0 != (*pflags & MHD_USE_ITC))\n        {\n          if (! MHD_itc_init_ (d->itc))\n          {\n#ifdef HAVE_MESSAGES\n            MHD_DLOG (daemon,\n                      _ (\"Failed to create worker inter-thread \" \\\n                         \"communication channel: %s\\n\"),\n                      MHD_itc_last_strerror_ () );\n#endif\n            MHD_mutex_destroy_chk_ (&d->new_connections_mutex);\n            MHD_mutex_destroy_chk_ (&d->cleanup_connection_mutex);\n            goto thread_failed;\n          }\n          if (MHD_D_IS_USING_SELECT_ (d) &&\n              (! MHD_D_DOES_SCKT_FIT_FDSET_ (MHD_itc_r_fd_ (d->itc), daemon)) )\n          {\n#ifdef HAVE_MESSAGES\n            MHD_DLOG (daemon,\n                      _ (\"File descriptor for worker inter-thread \" \\\n                         \"communication channel exceeds maximum value.\\n\"));\n#endif\n            MHD_itc_destroy_chk_ (d->itc);\n            MHD_mutex_destroy_chk_ (&d->new_connections_mutex);\n            MHD_mutex_destroy_chk_ (&d->cleanup_connection_mutex);\n            goto thread_failed;\n          }\n        }\n        else\n          MHD_itc_set_invalid_ (d->itc);\n\n#ifdef HAVE_LISTEN_SHUTDOWN\n        mhd_assert ((MHD_ITC_IS_VALID_ (d->itc)) || \\\n                    (MHD_INVALID_SOCKET != d->listen_fd));\n#else  /* ! HAVE_LISTEN_SHUTDOWN */\n        mhd_assert (MHD_ITC_IS_VALID_ (d->itc));\n#endif /* ! HAVE_LISTEN_SHUTDOWN */\n\n        /* Divide available connections evenly amongst the threads.\n         * Thread indexes in [0, leftover_conns) each get one of the\n         * leftover connections. */\n        d->connection_limit = conns_per_thread;\n        if (i < leftover_conns)\n          ++d->connection_limit;\n#ifdef EPOLL_SUPPORT\n        if (MHD_D_IS_USING_EPOLL_ (d) &&\n            (MHD_NO == setup_epoll_to_listen (d)) )\n        {\n          if (MHD_ITC_IS_VALID_ (d->itc))\n            MHD_itc_destroy_chk_ (d->itc);\n          MHD_mutex_destroy_chk_ (&d->new_connections_mutex);\n          MHD_mutex_destroy_chk_ (&d->cleanup_connection_mutex);\n          goto thread_failed;\n        }\n#endif\n        /* Some members must be used only in master daemon */\n#if defined(MHD_USE_THREADS)\n        memset (&d->per_ip_connection_mutex, 0x7F,\n                sizeof(d->per_ip_connection_mutex));\n#endif /* MHD_USE_THREADS */\n#ifdef DAUTH_SUPPORT\n        d->nnc = NULL;\n        d->nonce_nc_size = 0;\n        d->digest_auth_random_copy = NULL;\n#if defined(MHD_USE_THREADS)\n        memset (&d->nnc_lock, 0x7F, sizeof(d->nnc_lock));\n#endif /* MHD_USE_THREADS */\n#endif /* DAUTH_SUPPORT */\n\n        /* Spawn the worker thread */\n        if (! MHD_create_named_thread_ (&d->tid,\n                                        \"MHD-worker\",\n                                        daemon->thread_stack_size,\n                                        &MHD_polling_thread,\n                                        d))\n        {\n#ifdef HAVE_MESSAGES\n#ifdef EAGAIN\n          if (EAGAIN == errno)\n            MHD_DLOG (daemon,\n                      _ (\"Failed to create a new pool thread because it would \" \\\n                         \"have exceeded the system limit on the number of \" \\\n                         \"threads or no system resources available.\\n\"));\n          else\n#endif /* EAGAIN */\n          MHD_DLOG (daemon,\n                    _ (\"Failed to create pool thread: %s\\n\"),\n                    MHD_strerror_ (errno));\n#endif\n          /* Free memory for this worker; cleanup below handles\n           * all previously-created workers. */\n          MHD_mutex_destroy_chk_ (&d->cleanup_connection_mutex);\n          if (MHD_ITC_IS_VALID_ (d->itc))\n            MHD_itc_destroy_chk_ (d->itc);\n          MHD_mutex_destroy_chk_ (&d->new_connections_mutex);\n          MHD_mutex_destroy_chk_ (&d->cleanup_connection_mutex);\n          goto thread_failed;\n        }\n      }\n    }\n  }\n  else\n  { /* Daemon without internal threads */\n    if (! MHD_mutex_init_ (&daemon->cleanup_connection_mutex))\n    {\n#ifdef HAVE_MESSAGES\n      MHD_DLOG (daemon,\n                _ (\"Failed to initialise internal lists mutex.\\n\"));\n#endif\n      MHD_mutex_destroy_chk_ (&daemon->per_ip_connection_mutex);\n      if (MHD_INVALID_SOCKET != listen_fd)\n        MHD_socket_close_chk_ (listen_fd);\n      goto free_and_fail;\n    }\n    if (! MHD_mutex_init_ (&daemon->new_connections_mutex))\n    {\n#ifdef HAVE_MESSAGES\n      MHD_DLOG (daemon,\n                _ (\"Failed to initialise mutex.\\n\"));\n#endif\n      MHD_mutex_destroy_chk_ (&daemon->cleanup_connection_mutex);\n      MHD_mutex_destroy_chk_ (&daemon->per_ip_connection_mutex);\n      if (MHD_INVALID_SOCKET != listen_fd)\n        MHD_socket_close_chk_ (listen_fd);\n      goto free_and_fail;\n    }\n  }\n#endif\n#ifdef HTTPS_SUPPORT\n  /* API promises to never use the password after initialization,\n     so we additionally NULL it here to not deref a dangling pointer. */\n  daemon->https_key_password = NULL;\n#endif /* HTTPS_SUPPORT */\n\n  return daemon;\n\n#if defined(MHD_USE_POSIX_THREADS) || defined(MHD_USE_W32_THREADS)\nthread_failed:\n  /* If no worker threads created, then shut down normally. Calling\n     MHD_stop_daemon (as we do below) doesn't work here since it\n     assumes a 0-sized thread pool means we had been in the default\n     MHD_USE_INTERNAL_POLLING_THREAD mode. */\n  if (0 == i)\n  {\n    if (MHD_INVALID_SOCKET != listen_fd)\n      MHD_socket_close_chk_ (listen_fd);\n    listen_fd = MHD_INVALID_SOCKET;\n    MHD_mutex_destroy_chk_ (&daemon->per_ip_connection_mutex);\n    if (NULL != daemon->worker_pool)\n      free (daemon->worker_pool);\n    goto free_and_fail;\n  }\n\n  /* Shutdown worker threads we've already created. Pretend\n     as though we had fully initialized our daemon, but\n     with a smaller number of threads than had been\n     requested. */\n  daemon->worker_pool_size = i;\n  MHD_stop_daemon (daemon);\n  return NULL;\n#endif\n\nfree_and_fail:\n  /* clean up basic memory state in 'daemon' and return NULL to\n     indicate failure */\n#ifdef EPOLL_SUPPORT\n#if defined(HTTPS_SUPPORT) && defined(UPGRADE_SUPPORT)\n  if (daemon->upgrade_fd_in_epoll)\n  {\n    if (0 != epoll_ctl (daemon->epoll_fd,\n                        EPOLL_CTL_DEL,\n                        daemon->epoll_upgrade_fd,\n                        NULL))\n      MHD_PANIC (_ (\"Failed to remove FD from epoll set.\\n\"));\n    daemon->upgrade_fd_in_epoll = false;\n  }\n#endif /* HTTPS_SUPPORT && UPGRADE_SUPPORT */\n  if (-1 != daemon->epoll_fd)\n    close (daemon->epoll_fd);\n#if defined(HTTPS_SUPPORT) && defined(UPGRADE_SUPPORT)\n  if (-1 != daemon->epoll_upgrade_fd)\n    close (daemon->epoll_upgrade_fd);\n#endif /* HTTPS_SUPPORT && UPGRADE_SUPPORT */\n#endif /* EPOLL_SUPPORT */\n#ifdef DAUTH_SUPPORT\n  free (daemon->digest_auth_random_copy);\n  free (daemon->nnc);\n#if defined(MHD_USE_POSIX_THREADS) || defined(MHD_USE_W32_THREADS)\n  MHD_mutex_destroy_chk_ (&daemon->nnc_lock);\n#endif\n#endif\n#ifdef HTTPS_SUPPORT\n  if (0 != (*pflags & MHD_USE_TLS))\n  {\n    gnutls_priority_deinit (daemon->priority_cache);\n    if (daemon->x509_cred)\n      gnutls_certificate_free_credentials (daemon->x509_cred);\n    if (daemon->psk_cred)\n      gnutls_psk_free_server_credentials (daemon->psk_cred);\n  }\n#endif /* HTTPS_SUPPORT */\n  if (MHD_ITC_IS_VALID_ (daemon->itc))\n    MHD_itc_destroy_chk_ (daemon->itc);\n  if (MHD_INVALID_SOCKET != listen_fd)\n    (void) MHD_socket_close_ (listen_fd);\n  if ((MHD_INVALID_SOCKET != daemon->listen_fd) &&\n      (listen_fd != daemon->listen_fd))\n    (void) MHD_socket_close_ (daemon->listen_fd);\n  free (daemon);\n  return NULL;\n}\n```\n</target_code>\nPlease find suspicious code fragments in the code and report them. Other agents can not investigate other fragments that you do not report, so it is very important to find all suspicious fragments without missing any. Report the suspicious fragments AS MUCH AS POSSIBLE.",
  "suspicious_frags": [
    "free_and_fail:\n  /* clean up basic memory state in 'daemon' and return NULL to\n     indicate failure */\n#ifdef EPOLL_SUPPORT\n#if defined(HTTPS_SUPPORT) && defined(UPGRADE_SUPPORT)\n  if (daemon->upgrade_fd_in_epoll)\n  {\n    if (0 != epoll_ctl (daemon->epoll_fd,\n                        EPOLL_CTL_DEL,\n                        daemon->epoll_upgrade_fd,\n                        NULL))\n      MHD_PANIC (_ (\"Failed to remove FD from epoll set.\\n\"));\n    daemon->upgrade_fd_in_epoll = false;\n  }\n#endif /* HTTPS_SUPPORT && UPGRADE_SUPPORT */\n  if (-1 != daemon->epoll_fd)\n    close (daemon->epoll_fd);\n#if defined(HTTPS_SUPPORT) && defined(UPGRADE_SUPPORT)\n  if (-1 != daemon->epoll_upgrade_fd)\n    close (daemon->epoll_upgrade_fd);\n#endif /* HTTPS_SUPPORT && UPGRADE_SUPPORT */\n#endif /* EPOLL_SUPPORT */\n#ifdef DAUTH_SUPPORT\n  free (daemon->digest_auth_random_copy);\n  free (daemon->nnc);\n#if defined(MHD_USE_POSIX_THREADS) || defined(MHD_USE_W32_THREADS)\n  MHD_mutex_destroy_chk_ (&daemon->nnc_lock);\n#endif\n#endif\n#ifdef HTTPS_SUPPORT\n  if (0 != (*pflags & MHD_USE_TLS))\n  {\n    gnutls_priority_deinit (daemon->priority_cache);\n    if (daemon->x509_cred)\n      gnutls_certificate_free_credentials (daemon->x509_cred);\n    if (daemon->psk_cred)\n      gnutls_psk_free_server_credentials (daemon->psk_cred);\n  }\n#endif /* HTTPS_SUPPORT */\n  if (MHD_ITC_IS_VALID_ (daemon->itc))\n    MHD_itc_destroy_chk_ (daemon->itc);\n  if (MHD_INVALID_SOCKET != listen_fd)\n    (void) MHD_socket_close_ (listen_fd);\n  if ((MHD_INVALID_SOCKET != daemon->listen_fd) &&\n      (listen_fd != daemon->listen_fd))\n    (void) MHD_socket_close_ (daemon->listen_fd);\n  free (daemon);\n  return NULL;\n}",
    "  return daemon;\n\n\n#if defined(MHD_USE_POSIX_THREADS) || defined(MHD_USE_W32_THREADS)\nthread_failed:\n  /* If no worker threads created, then shut down normally. Calling\n     MHD_stop_daemon (as we do below) doesn't work here since it\n     assumes a 0-sized thread pool means we had been in the default\n     MHD_USE_INTERNAL_POLLING_THREAD mode. */\n  if (0 == i)\n  {\n    if (MHD_INVALID_SOCKET != listen_fd)\n      MHD_socket_close_chk_ (listen_fd);\n    listen_fd = MHD_INVALID_SOCKET;\n    MHD_mutex_destroy_chk_ (&daemon->per_ip_connection_mutex);\n    if (NULL != daemon->worker_pool)\n      free (daemon->worker_pool);\n    goto free_and_fail;\n  }\n\n  /* Shutdown worker threads we've already created. Pretend\n     as though we had fully initialized our daemon, but\n     with a smaller number of threads than had been\n     requested. */\n  daemon->worker_pool_size = i;\n  MHD_stop_daemon (daemon);\n  return NULL;\n#endif",
    "  if (1)\n        {\n          struct sockaddr_in sa4;\n          uint16_t sa4_port;\n          if ((0 != addrlen)\n              && (((socklen_t) sizeof(sa4)) > addrlen))\n          {\n#ifdef HAVE_MESSAGES\n            MHD_DLOG (daemon,\n                      _ (\"The size specified for MHD_OPTION_SOCK_ADDR_LEN \" \\\n                         \"option is wrong.\\n\"));\n#endif /* HAVE_MESSAGES */\n            goto free_and_fail;\n          }\n#ifdef HAVE_STRUCT_SOCKADDR_SA_LEN\n          if (0 != sa_len)\n          {\n            if (((socklen_t) sizeof(sa4)) > sa_len)\n            {\n#ifdef HAVE_MESSAGES\n              MHD_DLOG (daemon,\n                        _ (\"The value of 'struct sockaddr.sa_len' provided \" \\\n                           \"via MHD_OPTION_SOCK_ADDR_LEN option is not zero \" \\\n                           \"and does not match 'sa_family' value of the \" \\\n                           \"same structure.\\n\"));\n#endif /* HAVE_MESSAGES */\n              goto free_and_fail;\n            }\n            if ((0 == addrlen) || (sa_len < addrlen))\n              addrlen = sa_len; /* Use smaller value for safety */\n          }\n#endif /* HAVE_STRUCT_SOCKADDR_SA_LEN */\n          if (0 == addrlen)\n            addrlen = sizeof(sa4);\n          memcpy (&sa4, pservaddr, sizeof(sa4));  /* Required due to stronger alignment */\n          sa4_port = (uint16_t) ntohs (sa4.sin_port);\n#ifndef MHD_USE_GETSOCKNAME\n          if (0 != sa4_port)\n#endif /* ! MHD_USE_GETSOCKNAME */\n          daemon->port = sa4_port;\n          domain = PF_INET;\n        }\n        break;"
  ],
  "explanation": "I focused on code regions that are likely to be unreachable or suspicious with respect to control flow and the presence of unconditional returns / labels. In particular: (1) the immediate return (\"return daemon;\") followed by the thread_failed label and its block \u2014 code after an unconditional return is often reported as unreachable unless a goto can transfer control; this construct requires careful inspection to ensure all gotos that target the label are present in the same build configurations and that no truly unreachable statements remain. (2) the free_and_fail cleanup label and long cleanup block which exists after the return; many gotos target this label, but its location after the return warrants verification that all paths that jump there are valid in all configurations. (3) the AF_INET case contains an \"if (1)\" block with multiple goto free_and_fail branches; although \"if (1)\" is always true, the inner gotos make control flow non-trivial and warrant checking for any unreachable statements resulting from earlier unconditional returns or preprocessor variations.\n\nI did not mark other fragments for investigation because I found no obvious, purely unconditional unreachable code (e.g. statements that are provably never executed for all possible configurations) elsewhere in this function: many branches are conditional on runtime values or on feature macros (preprocessor guards), and code excluded by preprocessor conditions is outside the compiled project and thus not considered unreachable in the compiled artifact. The flagged fragments are the places where the function has unconditional returns and subsequent labels/blocks that rely on gotos \u2014 these are the most likely sources of inadvertent unreachable code violations and should be inspected under the build configurations of interest."
}