{
  "user_message": "An agent A claimed that the following MHD_stop_daemon code violates the MISRA C 2023 rule 8.13.\n<misra_rule>\nMISRA C 2023 Rule 8.13 is A pointer should point to a const-qualified type whenever possible.\n\n</misra_rule>\n<target_code>\nHere is the original code of MHD_stop_daemon.\n```c\n_MHD_EXTERN void\nMHD_stop_daemon (struct MHD_Daemon *daemon)\n{\n  MHD_socket fd;\n#if defined(MHD_USE_POSIX_THREADS) || defined(MHD_USE_W32_THREADS)\n  unsigned int i;\n#endif\n\n  if (NULL == daemon)\n    return;\n  if ( (daemon->shutdown) && (NULL == daemon->master) )\n    MHD_PANIC (_ (\"MHD_stop_daemon() was called twice.\"));\n\n  mhd_assert ((0 == (daemon->options & MHD_USE_SELECT_INTERNALLY)) || \\\n              (NULL != daemon->worker_pool) || \\\n              (MHD_thread_handle_ID_is_valid_handle_ (daemon->tid)));\n  mhd_assert (((0 != (daemon->options & MHD_USE_SELECT_INTERNALLY)) &&\n               (NULL == daemon->worker_pool)) || \\\n              (! MHD_thread_handle_ID_is_valid_handle_ (daemon->tid)));\n\n  /* Slave daemons must be stopped by master daemon. */\n  mhd_assert ( (NULL == daemon->master) || (daemon->shutdown) );\n\n  daemon->shutdown = true;\n  if (daemon->was_quiesced)\n    fd = MHD_INVALID_SOCKET; /* Do not use FD if daemon was quiesced */\n  else\n    fd = daemon->listen_fd;\n\n#if defined(MHD_USE_POSIX_THREADS) || defined(MHD_USE_W32_THREADS)\n  if (NULL != daemon->worker_pool)\n  {   /* Master daemon with worker pool. */\n    mhd_assert (1 < daemon->worker_pool_size);\n    mhd_assert (MHD_D_IS_USING_THREADS_ (daemon));\n\n    /* Let workers shutdown in parallel. */\n    for (i = 0; i < daemon->worker_pool_size; ++i)\n    {\n      daemon->worker_pool[i].shutdown = true;\n      if (MHD_ITC_IS_VALID_ (daemon->worker_pool[i].itc))\n      {\n        if (! MHD_itc_activate_ (daemon->worker_pool[i].itc,\n                                 \"e\"))\n          MHD_PANIC (_ (\"Failed to signal shutdown via inter-thread \" \\\n                        \"communication channel.\\n\"));\n      }\n      else\n        mhd_assert (MHD_INVALID_SOCKET != fd);\n    }\n#ifdef HAVE_LISTEN_SHUTDOWN\n    if (MHD_INVALID_SOCKET != fd)\n    {\n      (void) shutdown (fd,\n                       SHUT_RDWR);\n    }\n#endif /* HAVE_LISTEN_SHUTDOWN */\n    for (i = 0; i < daemon->worker_pool_size; ++i)\n    {\n      MHD_stop_daemon (&daemon->worker_pool[i]);\n    }\n    free (daemon->worker_pool);\n    mhd_assert (MHD_ITC_IS_INVALID_ (daemon->itc));\n#ifdef EPOLL_SUPPORT\n    mhd_assert (-1 == daemon->epoll_fd);\n#if defined(HTTPS_SUPPORT) && defined(UPGRADE_SUPPORT)\n    mhd_assert (-1 == daemon->epoll_upgrade_fd);\n#endif /* HTTPS_SUPPORT && UPGRADE_SUPPORT */\n#endif /* EPOLL_SUPPORT */\n  }\n  else\n#endif\n  {   /* Worker daemon or single daemon. */\n#if defined(MHD_USE_POSIX_THREADS) || defined(MHD_USE_W32_THREADS)\n    if (MHD_D_IS_USING_THREADS_ (daemon))\n    {     /* Worker daemon or single daemon with internal thread(s). */\n      mhd_assert (0 == daemon->worker_pool_size);\n      /* Separate thread(s) is used for polling sockets. */\n      if (MHD_ITC_IS_VALID_ (daemon->itc))\n      {\n        if (! MHD_itc_activate_ (daemon->itc,\n                                 \"e\"))\n          MHD_PANIC (_ (\"Failed to signal shutdown via inter-thread \" \\\n                        \"communication channel.\\n\"));\n      }\n      else\n      {\n#ifdef HAVE_LISTEN_SHUTDOWN\n        if (MHD_INVALID_SOCKET != fd)\n        {\n          if (NULL == daemon->master)\n            (void) shutdown (fd,\n                             SHUT_RDWR);\n        }\n        else\n#endif /* HAVE_LISTEN_SHUTDOWN */\n        mhd_assert (false); /* Should never happen */\n      }\n\n      if (! MHD_thread_handle_ID_join_thread_ (daemon->tid))\n      {\n        MHD_PANIC (_ (\"Failed to join a thread.\\n\"));\n      }\n      /* close_all_connections() was called in daemon thread. */\n    }\n    else\n#endif\n    {\n      /* No internal threads are used for polling sockets. */\n      close_all_connections (daemon);\n    }\n    mhd_assert (NULL == daemon->connections_head);\n    mhd_assert (NULL == daemon->cleanup_head);\n    mhd_assert (NULL == daemon->suspended_connections_head);\n    mhd_assert (NULL == daemon->new_connections_head);\n#if defined(UPGRADE_SUPPORT) && defined(HTTPS_SUPPORT)\n    mhd_assert (NULL == daemon->urh_head);\n#endif /* UPGRADE_SUPPORT && HTTPS_SUPPORT */\n\n    if (MHD_ITC_IS_VALID_ (daemon->itc))\n      MHD_itc_destroy_chk_ (daemon->itc);\n\n#ifdef EPOLL_SUPPORT\n    if (MHD_D_IS_USING_EPOLL_ (daemon) &&\n        (-1 != daemon->epoll_fd) )\n      MHD_socket_close_chk_ (daemon->epoll_fd);\n#if defined(HTTPS_SUPPORT) && defined(UPGRADE_SUPPORT)\n    if (MHD_D_IS_USING_EPOLL_ (daemon) &&\n        (-1 != daemon->epoll_upgrade_fd) )\n      MHD_socket_close_chk_ (daemon->epoll_upgrade_fd);\n#endif /* HTTPS_SUPPORT && UPGRADE_SUPPORT */\n#endif /* EPOLL_SUPPORT */\n\n#if defined(MHD_USE_POSIX_THREADS) || defined(MHD_USE_W32_THREADS)\n    MHD_mutex_destroy_chk_ (&daemon->cleanup_connection_mutex);\n    MHD_mutex_destroy_chk_ (&daemon->new_connections_mutex);\n#endif\n  }\n\n  if (NULL == daemon->master)\n  {   /* Cleanup that should be done only one time in master/single daemon.\n       * Do not perform this cleanup in worker daemons. */\n\n    if (MHD_INVALID_SOCKET != fd)\n      MHD_socket_close_chk_ (fd);\n\n    /* TLS clean up */\n#ifdef HTTPS_SUPPORT\n    if (daemon->have_dhparams)\n    {\n      gnutls_dh_params_deinit (daemon->https_mem_dhparams);\n      daemon->have_dhparams = false;\n    }\n    if (0 != (daemon->options & MHD_USE_TLS))\n    {\n      gnutls_priority_deinit (daemon->priority_cache);\n      if (daemon->x509_cred)\n        gnutls_certificate_free_credentials (daemon->x509_cred);\n      if (daemon->psk_cred)\n        gnutls_psk_free_server_credentials (daemon->psk_cred);\n    }\n#endif /* HTTPS_SUPPORT */\n\n#ifdef DAUTH_SUPPORT\n    free (daemon->digest_auth_random_copy);\n    free (daemon->nnc);\n#if defined(MHD_USE_POSIX_THREADS) || defined(MHD_USE_W32_THREADS)\n    MHD_mutex_destroy_chk_ (&daemon->nnc_lock);\n#endif\n#endif\n#if defined(MHD_USE_POSIX_THREADS) || defined(MHD_USE_W32_THREADS)\n    MHD_mutex_destroy_chk_ (&daemon->per_ip_connection_mutex);\n#endif\n    free (daemon);\n  }\n}\n```\n</target_code>\n<response format>\nProvide your answer with these fields.\n- explanation: your evaluation of the scenario provided by the agent A.\n- is_report_correct: whether the report is correct or not (true/false). True means there is a violation.\n</response format>\n<scenario>\nThe agent A provided the following violation scenario:\nIf the struct member daemon->master is declared as a non-const pointer (e.g. `struct MHD_Daemon *master;`) but is only ever inspected (compared to NULL, read-only uses) and never used to modify the pointed-to object, then it should have been declared to point to a const-qualified type (e.g. `const struct MHD_Daemon *master;`). In that situation the use `if (NULL == daemon->master)` indicates a read-only usage and the non-const declaration would violate MISRA C 2023 Rule 8.13.\n</scenario>\n\n<execution_log>\nThe agent A also provided the following output log:\nEVENT: enter MHD_stop_daemon\n  daemon ptr = 0x561a31a3d820\n  master ptr = (nil)\n  shutdown = 0\n  was_quiesced = 0\n  worker_pool ptr = (nil)\n  worker_pool_size = 0\n  itc ptr = 0x561a31a3da18\n  tid = 0x561a31a3d978\n----\nEVENT: before master-only cleanup check\n  daemon ptr = 0x561a31a3d820\n  master ptr = (nil)\n  shutdown = 1\n  was_quiesced = 0\n  worker_pool ptr = (nil)\n  worker_pool_size = 0\n  itc ptr = 0x561a31a3da18\n  tid = 0x561a31a3d978\n----\nEVENT: enter master cleanup branch (master == NULL)\n  daemon ptr = 0x561a31a3d820\n  master ptr = (nil)\n  shutdown = 1\n  was_quiesced = 0\n  worker_pool ptr = (nil)\n  worker_pool_size = 0\n  itc ptr = 0x561a31a3da18\n  tid = 0x561a31a3d978\n----\nEVENT: exit MHD_stop_daemon\n  daemon ptr = (nil)\n----\nEVENT: enter MHD_stop_daemon\n  daemon ptr = 0x561a31a3dfc0\n  master ptr = (nil)\n  shutdown = 0\n  was_quiesced = 0\n  worker_pool ptr = (nil)\n  worker_pool_size = 0\n  itc ptr = 0x561a31a3e1b8\n  tid = 0x561a31a3e118\n----\nEVENT: before master-only cleanup check\n  daemon ptr = 0x561a31a3dfc0\n  master ptr = (nil)\n  shutdown = 1\n  was_quiesced = 0\n  worker_pool ptr = (nil)\n  worker_pool_size = 0\n  itc ptr = 0x561a31a3e1b8\n  tid = 0x561a31a3e118\n----\nEVENT: enter master cleanup branch (master == NULL)\n  daemon ptr = 0x561a31a3dfc0\n  master ptr = (nil)\n  shutdown = 1\n  was_quiesced = 0\n  worker_pool ptr = (nil)\n  worker_pool_size = 0\n  itc ptr = 0x561a31a3e1b8\n  tid = 0x561a31a3e118\n----\nEVENT: exit MHD_stop_daemon\n  daemon ptr = (nil)\n----\nEVENT: enter MHD_stop_daemon\n  daemon ptr = 0x561a31a3e440\n  master ptr = (nil)\n  shutdown = 0\n  was_quiesced = 0\n  worker_pool ptr = 0x561a31a3e8c0\n  worker_pool_size = 2\n  itc ptr = 0x561a31a3e638\n  tid = 0x561a31a3e598\n----\nEVENT: enter worker_pool branch (master with pool)\n  daemon ptr = 0x561a31a3e440\n  master ptr = (nil)\n  shutdown = 1\n  was_quiesced = 0\n  worker_pool ptr = 0x561a31a3e8c0\n  worker_pool_size = 2\n  itc ptr = 0x561a31a3e638\n  tid = 0x561a31a3e598\n----\nEVENT: about to call MHD_stop_daemon on worker\n  daemon ptr = 0x561a31a3e8c0\n  master ptr = 0x561a31a3e440\n  shutdown = 1\n  was_quiesced = 0\n  worker_pool ptr = (nil)\n  worker_pool_size = 0\n  itc ptr = 0x561a31a3eab8\n  tid = 0x561a31a3ea18\n----\nEVENT: enter MHD_stop_daemon\n  daemon ptr = 0x561a31a3e8c0\n  master ptr = 0x561a31a3e440\n  shutdown = 1\n  was_quiesced = 0\n  worker_pool ptr = (nil)\n  worker_pool_size = 0\n  itc ptr = 0x561a31a3eab8\n  tid = 0x561a31a3ea18\n----\nEVENT: before master-only cleanup check\n  daemon ptr = 0x561a31a3e8c0\n  master ptr = 0x561a31a3e440\n  shutdown = 1\n  was_quiesced = 0\n  worker_pool ptr = (nil)\n  worker_pool_size = 0\n  itc ptr = 0x561a31a3eab8\n  tid = 0x561a31a3ea18\n----\nEVENT: exit MHD_stop_daemon\n  daemon ptr = (nil)\n----\nEVENT: about to call MHD_stop_daemon on worker\n  daemon ptr = 0x561a31a3eb68\n  master ptr = 0x561a31a3e440\n  shutdown = 1\n  was_quiesced = 0\n  worker_pool ptr = (nil)\n  worker_pool_size = 0\n  itc ptr = 0x561a31a3ed60\n  tid = 0x561a31a3ecc0\n----\nEVENT: enter MHD_stop_daemon\n  daemon ptr = 0x561a31a3eb68\n  master ptr = 0x561a31a3e440\n  shutdown = 1\n  was_quiesced = 0\n  worker_pool ptr = (nil)\n  worker_pool_size = 0\n  itc ptr = 0x561a31a3ed60\n  tid = 0x561a31a3ecc0\n----\nEVENT: before master-only cleanup check\n  daemon ptr = 0x561a31a3eb68\n  master ptr = 0x561a31a3e440\n  shutdown = 1\n  was_quiesced = 0\n  worker_pool ptr = (nil)\n  worker_pool_size = 0\n  itc ptr = 0x561a31a3ed60\n  tid = 0x561a31a3ecc0\n----\nEVENT: exit MHD_stop_daemon\n  daemon ptr = (nil)\n----\nEVENT: before master-only cleanup check\n  daemon ptr = 0x561a31a3e440\n  master ptr = (nil)\n  shutdown = 1\n  was_quiesced = 0\n  worker_pool ptr = 0x561a31a3e8c0\n  worker_pool_size = 2\n  itc ptr = 0x561a31a3e638\n  tid = 0x561a31a3e598\n----\nEVENT: enter master cleanup branch (master == NULL)\n  daemon ptr = 0x561a31a3e440\n  master ptr = (nil)\n  shutdown = 1\n  was_quiesced = 0\n  worker_pool ptr = 0x561a31a3e8c0\n  worker_pool_size = 2\n  itc ptr = 0x561a31a3e638\n  tid = 0x561a31a3e598\n----\nEVENT: exit MHD_stop_daemon\n  daemon ptr = (nil)\n----\nEVENT: enter MHD_stop_daemon\n  daemon ptr = 0x561a31a3e8c0\n  maste\n</execution_log>\n\n<instruction>\nJudge whether the report is correct or not.\n</instruction>\n",
  "is_report_correct": false,
  "explanation": "MISRA C:2023 Rule 8.13 recommends that a pointer type should be const-qualified where the pointed-to object is not modified through that pointer. In MHD_stop_daemon the member daemon->master is only inspected (compared to NULL) and never dereferenced for modification, so the function\u2019s usage of daemon->master is read-only \u2014 making the agent A scenario plausible for this function.\n\nHowever, the rule applies to the declaration of the pointer (the struct member) across its actual uses in the program. To assert a MISRA violation you must show that the member is declared as a non-const pointer while it could be const for all uses in the whole program (or translation unit). The provided code and execution log only show read-only use inside MHD_stop_daemon; they do not demonstrate that daemon->master is never used to modify the pointed-to object elsewhere. Therefore we cannot conclude a definite MISRA 8.13 violation from the given evidence alone. If a project-wide review shows the member is indeed never used to modify the pointed object, then the declaration should be changed to const and the report would be correct. As presented, the report is not proven correct."
}