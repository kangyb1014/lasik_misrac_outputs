{
  "user_message": "An agent A claimed that the following MHD_stop_daemon code violates the MISRA C 2023 rule 14.2.\n<misra_rule>\nMISRA C 2023 Rule 14.2 is A for loop shall be well-formed.\nThe three clauses of a for statement are the:\n1. First clause shall be empty or an expression whose set the value of the loop counter or define and intialize the loop counter.\n2. Second clause shall be an expression that has no persistent side effects, and shall use the loop counter and optionally loop control flags, and shall not use any other object that is modified in the for loop body.\n3.Third clause shall be an expression whose modify only the value of the loop counter, and shall not use objects that are modified in the for loop body.\n4. There shall only be one loop counter in a for loop, which shall not be modified in for loop body. A loop control flag is defined as single identifier denoting an object with Boolean type that is used in the second clause. The behaviour of a for loop body includes the behaviour of any functions called within that statement. \n</misra_rule>\n<target_code>\nHere is the original code of MHD_stop_daemon.\n```c\n_MHD_EXTERN void\nMHD_stop_daemon (struct MHD_Daemon *daemon)\n{\n  MHD_socket fd;\n#if defined(MHD_USE_POSIX_THREADS) || defined(MHD_USE_W32_THREADS)\n  unsigned int i;\n#endif\n\n  if (NULL == daemon)\n    return;\n  if ( (daemon->shutdown) && (NULL == daemon->master) )\n    MHD_PANIC (_ (\"MHD_stop_daemon() was called twice.\"));\n\n  mhd_assert ((0 == (daemon->options & MHD_USE_SELECT_INTERNALLY)) || \\\n              (NULL != daemon->worker_pool) || \\\n              (MHD_thread_handle_ID_is_valid_handle_ (daemon->tid)));\n  mhd_assert (((0 != (daemon->options & MHD_USE_SELECT_INTERNALLY)) &&\n               (NULL == daemon->worker_pool)) || \\\n              (! MHD_thread_handle_ID_is_valid_handle_ (daemon->tid)));\n\n  /* Slave daemons must be stopped by master daemon. */\n  mhd_assert ( (NULL == daemon->master) || (daemon->shutdown) );\n\n  daemon->shutdown = true;\n  if (daemon->was_quiesced)\n    fd = MHD_INVALID_SOCKET; /* Do not use FD if daemon was quiesced */\n  else\n    fd = daemon->listen_fd;\n\n#if defined(MHD_USE_POSIX_THREADS) || defined(MHD_USE_W32_THREADS)\n  if (NULL != daemon->worker_pool)\n  {   /* Master daemon with worker pool. */\n    mhd_assert (1 < daemon->worker_pool_size);\n    mhd_assert (MHD_D_IS_USING_THREADS_ (daemon));\n\n    /* Let workers shutdown in parallel. */\n    for (i = 0; i < daemon->worker_pool_size; ++i)\n    {\n      daemon->worker_pool[i].shutdown = true;\n      if (MHD_ITC_IS_VALID_ (daemon->worker_pool[i].itc))\n      {\n        if (! MHD_itc_activate_ (daemon->worker_pool[i].itc,\n                                 \"e\"))\n          MHD_PANIC (_ (\"Failed to signal shutdown via inter-thread \" \\\n                        \"communication channel.\\n\"));\n      }\n      else\n        mhd_assert (MHD_INVALID_SOCKET != fd);\n    }\n#ifdef HAVE_LISTEN_SHUTDOWN\n    if (MHD_INVALID_SOCKET != fd)\n    {\n      (void) shutdown (fd,\n                       SHUT_RDWR);\n    }\n#endif /* HAVE_LISTEN_SHUTDOWN */\n    for (i = 0; i < daemon->worker_pool_size; ++i)\n    {\n      MHD_stop_daemon (&daemon->worker_pool[i]);\n    }\n    free (daemon->worker_pool);\n    mhd_assert (MHD_ITC_IS_INVALID_ (daemon->itc));\n#ifdef EPOLL_SUPPORT\n    mhd_assert (-1 == daemon->epoll_fd);\n#if defined(HTTPS_SUPPORT) && defined(UPGRADE_SUPPORT)\n    mhd_assert (-1 == daemon->epoll_upgrade_fd);\n#endif /* HTTPS_SUPPORT && UPGRADE_SUPPORT */\n#endif /* EPOLL_SUPPORT */\n  }\n  else\n#endif\n  {   /* Worker daemon or single daemon. */\n#if defined(MHD_USE_POSIX_THREADS) || defined(MHD_USE_W32_THREADS)\n    if (MHD_D_IS_USING_THREADS_ (daemon))\n    {     /* Worker daemon or single daemon with internal thread(s). */\n      mhd_assert (0 == daemon->worker_pool_size);\n      /* Separate thread(s) is used for polling sockets. */\n      if (MHD_ITC_IS_VALID_ (daemon->itc))\n      {\n        if (! MHD_itc_activate_ (daemon->itc,\n                                 \"e\"))\n          MHD_PANIC (_ (\"Failed to signal shutdown via inter-thread \" \\\n                        \"communication channel.\\n\"));\n      }\n      else\n      {\n#ifdef HAVE_LISTEN_SHUTDOWN\n        if (MHD_INVALID_SOCKET != fd)\n        {\n          if (NULL == daemon->master)\n            (void) shutdown (fd,\n                             SHUT_RDWR);\n        }\n        else\n#endif /* HAVE_LISTEN_SHUTDOWN */\n        mhd_assert (false); /* Should never happen */\n      }\n\n      if (! MHD_thread_handle_ID_join_thread_ (daemon->tid))\n      {\n        MHD_PANIC (_ (\"Failed to join a thread.\\n\"));\n      }\n      /* close_all_connections() was called in daemon thread. */\n    }\n    else\n#endif\n    {\n      /* No internal threads are used for polling sockets. */\n      close_all_connections (daemon);\n    }\n    mhd_assert (NULL == daemon->connections_head);\n    mhd_assert (NULL == daemon->cleanup_head);\n    mhd_assert (NULL == daemon->suspended_connections_head);\n    mhd_assert (NULL == daemon->new_connections_head);\n#if defined(UPGRADE_SUPPORT) && defined(HTTPS_SUPPORT)\n    mhd_assert (NULL == daemon->urh_head);\n#endif /* UPGRADE_SUPPORT && HTTPS_SUPPORT */\n\n    if (MHD_ITC_IS_VALID_ (daemon->itc))\n      MHD_itc_destroy_chk_ (daemon->itc);\n\n#ifdef EPOLL_SUPPORT\n    if (MHD_D_IS_USING_EPOLL_ (daemon) &&\n        (-1 != daemon->epoll_fd) )\n      MHD_socket_close_chk_ (daemon->epoll_fd);\n#if defined(HTTPS_SUPPORT) && defined(UPGRADE_SUPPORT)\n    if (MHD_D_IS_USING_EPOLL_ (daemon) &&\n        (-1 != daemon->epoll_upgrade_fd) )\n      MHD_socket_close_chk_ (daemon->epoll_upgrade_fd);\n#endif /* HTTPS_SUPPORT && UPGRADE_SUPPORT */\n#endif /* EPOLL_SUPPORT */\n\n#if defined(MHD_USE_POSIX_THREADS) || defined(MHD_USE_W32_THREADS)\n    MHD_mutex_destroy_chk_ (&daemon->cleanup_connection_mutex);\n    MHD_mutex_destroy_chk_ (&daemon->new_connections_mutex);\n#endif\n  }\n\n  if (NULL == daemon->master)\n  {   /* Cleanup that should be done only one time in master/single daemon.\n       * Do not perform this cleanup in worker daemons. */\n\n    if (MHD_INVALID_SOCKET != fd)\n      MHD_socket_close_chk_ (fd);\n\n    /* TLS clean up */\n#ifdef HTTPS_SUPPORT\n    if (daemon->have_dhparams)\n    {\n      gnutls_dh_params_deinit (daemon->https_mem_dhparams);\n      daemon->have_dhparams = false;\n    }\n    if (0 != (daemon->options & MHD_USE_TLS))\n    {\n      gnutls_priority_deinit (daemon->priority_cache);\n      if (daemon->x509_cred)\n        gnutls_certificate_free_credentials (daemon->x509_cred);\n      if (daemon->psk_cred)\n        gnutls_psk_free_server_credentials (daemon->psk_cred);\n    }\n#endif /* HTTPS_SUPPORT */\n\n#ifdef DAUTH_SUPPORT\n    free (daemon->digest_auth_random_copy);\n    free (daemon->nnc);\n#if defined(MHD_USE_POSIX_THREADS) || defined(MHD_USE_W32_THREADS)\n    MHD_mutex_destroy_chk_ (&daemon->nnc_lock);\n#endif\n#endif\n#if defined(MHD_USE_POSIX_THREADS) || defined(MHD_USE_W32_THREADS)\n    MHD_mutex_destroy_chk_ (&daemon->per_ip_connection_mutex);\n#endif\n    free (daemon);\n  }\n}\n```\n</target_code>\n<response format>\nProvide your answer with these fields.\n- explanation: your evaluation of the scenario provided by the agent A.\n- is_report_correct: whether the report is correct or not (true/false). True means there is a violation.\n</response format>\n<scenario>\nThe agent A provided the following violation scenario:\nThe loop condition uses daemon->worker_pool_size (i < daemon->worker_pool_size) which is an object other than the loop counter. The loop body calls MHD_stop_daemon(&daemon->worker_pool[i]) which may modify the daemon object or its worker pool (or fields thereof). Rule 14.2 requires the second clause to use only the loop counter and optional loop-control flags and not use other objects that are modified by the loop body. Because the condition depends on daemon->worker_pool_size which can be affected by the body (calls to MHD_stop_daemon), the for loop is not well-formed under MISRA C 2023 Rule 14.2.\n</scenario>\n\n<execution_log>\nThe agent A also provided the following output log:\nENTER MHD_stop_daemon: daemon=0x55930256d820\n  master=(nil), worker_pool=(nil), worker_pool_size=0, shutdown=0\nfreeing-daemon: daemon=0x55930256d820 (master==NULL)\nEXIT MHD_stop_daemon: daemon=0x55930256d820\nENTER MHD_stop_daemon: daemon=0x55930256dfc0\n  master=(nil), worker_pool=(nil), worker_pool_size=0, shutdown=0\nfreeing-daemon: daemon=0x55930256dfc0 (master==NULL)\nEXIT MHD_stop_daemon: daemon=0x55930256dfc0\nENTER MHD_stop_daemon: daemon=0x55930256e440\n  master=(nil), worker_pool=0x55930256e8c0, worker_pool_size=2, shutdown=0\npre-shutdown-loop-1: i=0, worker_pool_size=2, worker_ptr=0x55930256e8c0\npost-shutdown-loop-1: i=0, worker_pool_size=2, shutdown_flag=1\npre-shutdown-loop-1: i=1, worker_pool_size=2, worker_ptr=0x55930256eb68\npost-shutdown-loop-1: i=1, worker_pool_size=2, shutdown_flag=1\nabout-to-call-MHD_stop_daemon: i=0, worker_pool_size_before=2, worker_addr=0x55930256e8c0\nENTER MHD_stop_daemon: daemon=0x55930256e8c0\n  master=0x55930256e440, worker_pool=(nil), worker_pool_size=0, shutdown=1\nEXIT MHD_stop_daemon: daemon=0x55930256e8c0\nreturned-from-MHD_stop_daemon: i=0, worker_pool_size_after=2\nabout-to-call-MHD_stop_daemon: i=1, worker_pool_size_before=2, worker_addr=0x55930256eb68\nENTER MHD_stop_daemon: daemon=0x55930256eb68\n  master=0x55930256e440, worker_pool=(nil), worker_pool_size=0, shutdown=1\nEXIT MHD_stop_daemon: daemon=0x55930256eb68\nreturned-from-MHD_stop_daemon: i=1, worker_pool_size_after=2\nfreeing-worker_pool: ptr=0x55930256e8c0, size=2\nfreeing-daemon: daemon=0x55930256e440 (master==NULL)\nEXIT MHD_stop_daemon: daemon=0x55930256e440\nENTER MHD_stop_daemon: daemon=0x55930256e8c0\n  master=(nil), worker_pool=(nil), worker_pool_size=0, shutdown=0\nfreeing-daemon: daemon=0x55930256e8c0 (master==NULL)\nEXIT MHD_stop_daemon: daemon=0x55930256e8c0\nENTER MHD_stop_daemon: daemon=0x55930256ef60\n  master=(nil), worker_pool=(nil), worker_pool_size=0, shutdown=0\nfreeing-daemon: daemon=0x55930256ef60 (master==NULL)\nEXIT MHD_stop_daemon: daemon=0x55930256ef60\nENTER MHD_stop_daemon: daemon=0x55930256f3a0\n  master=(nil), worker_pool=(nil), worker_pool_size=0, shutdown=0\nfreeing-daemon: daemon=0x55930256f3a0 (master==NULL)\nEXIT MHD_stop_daemon: daemon=0x55930256f3a0\nENTER MHD_stop_daemon: daemon=0x55930256f7e0\n  master=(nil), worker_pool=(nil), worker_pool_size=0, shutdown=0\nfreeing-daemon: daemon=0x55930256f7e0 (master==NULL)\nEXIT MHD_stop_daemon: daemon=0x55930256f7e0\nENTER MHD_stop_daemon: daemon=0x55930256fc20\n  master=(nil), worker_pool=0x559302570060, worker_pool_size=2, shutdown=0\npre-shutdown-loop-1: i=0, worker_pool_size=2, worker_ptr=0x559302570060\npost-shutdown-loop-1: i=0, worker_pool_size=2, shutdown_flag=1\npre-shutdown-loop-1: i=1, worker_pool_size=2, worker_ptr=0x559302570308\npost-shutdown-loop-1: i=1, worker_pool_size=2, shutdown_flag=1\nabout-to-call-MHD_stop_daemon: i=0, worker_pool_size_before=2, worker_addr=0x559302570060\nENTER MHD_stop_daemon: daemon=0x559302570060\n  master=0x55930256fc20, worker_pool=(nil), worker_pool_size=0, shutdown=1\nEXIT MHD_stop_daemon: daemon=0x559302570060\nreturned-from-MHD_stop_daemon: i=0, worker_pool_size_after=2\nabout-to-call-MHD_stop_daemon: i=1, worker_pool_size_before=2, worker_addr=0x559302570308\nENTER MHD_stop_daemon: daemon=0x559302570308\n  master=0x55930256fc20, worker_pool=(nil), worker_pool_size=0, shutdown=1\nEXIT MHD_stop_daemon: daemon=0x559302570308\nreturned-from-MHD_stop_daemon: i=1, worker_pool_size_after=2\nfreeing-worker_pool: ptr=0x559302570060, size=2\nfreeing-daemon: daemon=0x55930256fc20 (master==NULL)\nEXIT MHD_stop_daemon: daemon=0x55930256fc20\nENTER MHD_stop_daemon: daemon=0x55930256fc20\n  master=(nil), worker_pool=(nil), worker_pool_size=0, shutdown=0\nfreeing-daemon: daemon=0x55930256fc20 (master==NULL)\nEXIT MHD_stop_daemon: daemon=0x55930256fc20\nENTER MHD_stop_daemon: daemon=0x55930256fc20\n  master=(nil), worker_pool=0x559302570060, worker_pool_size=2, shutdown=0\npre-shutdown-loop-1: i=0, worker_pool_size=2, worker_ptr=0x559302570060\npost-shutdown-loop-1: i=0, worker_pool_size=2, shutdown_flag=1\npre-shutdown-loop-1: i=1, worker_pool_size=2, worker_pt\n</execution_log>\n\n<instruction>\nJudge whether the report is correct or not.\n</instruction>\n",
  "is_report_correct": false,
  "explanation": "Not correct. Rule 14.2 forbids the loop condition from depending on objects that are (directly or indirectly via called functions) modified in the loop body. In this code the loop condition is i < daemon->worker_pool_size. The loop body modifies elements daemon->worker_pool[i] (and calls MHD_stop_daemon on those worker elements), but it does not modify the master daemon\u2019s worker_pool_size field that appears in the second clause. The called MHD_stop_daemon operates on the worker element passed (&daemon->worker_pool[i]) and does not change daemon->worker_pool_size of the master; the execution log even shows worker_pool_size remains 2 before and after each call. Therefore the second clause does not reference an object that is modified by the loop body and the for loop is well-formed with respect to MISRA C 2023 Rule 14.2. (If the called function did modify daemon->worker_pool_size, that would be a violation, but that is not the case here.)"
}