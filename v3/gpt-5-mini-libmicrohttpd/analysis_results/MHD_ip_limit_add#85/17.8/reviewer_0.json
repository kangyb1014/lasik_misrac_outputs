{
  "user_message": "An agent A claimed that the following MHD_ip_limit_add code violates the MISRA C 2023 rule 17.8.\n<misra_rule>\nMISRA C 2023 Rule 17.8 is A function parameter should not be modified.\nNote that the object referred to by a pointer parameter may be modified, but the pointer itself shall not be modified.\n</misra_rule>\n<target_code>\nHere is the original code of MHD_ip_limit_add.\n```c\nstatic enum MHD_Result\nMHD_ip_limit_add (struct MHD_Daemon *daemon,\n                  const struct sockaddr_storage *addr,\n                  socklen_t addrlen)\n{\n  struct MHD_IPCount *newkeyp;\n  struct MHD_IPCount *keyp;\n  struct MHD_IPCount **nodep;\n  enum MHD_Result result;\n\n  daemon = MHD_get_master (daemon);\n  /* Ignore if no connection limit assigned */\n  if (0 == daemon->per_ip_connection_limit)\n    return MHD_YES;\n\n  newkeyp = (struct MHD_IPCount *) malloc (sizeof(struct MHD_IPCount));\n  if (NULL == newkeyp)\n    return MHD_NO;\n\n  /* Initialize key */\n  if (MHD_NO == MHD_ip_addr_to_key (addr,\n                                    addrlen,\n                                    newkeyp))\n  {\n    free (newkeyp);\n    return MHD_YES; /* Allow unhandled address types through */\n  }\n\n  MHD_ip_count_lock (daemon);\n\n  /* Search for the IP address */\n  nodep = (struct MHD_IPCount **) tsearch (newkeyp,\n                                           &daemon->per_ip_connection_count,\n                                           &MHD_ip_addr_compare);\n  if (NULL == nodep)\n  {\n    MHD_ip_count_unlock (daemon);\n    free (newkeyp);\n#ifdef HAVE_MESSAGES\n    MHD_DLOG (daemon,\n              _ (\"Failed to add IP connection count node.\\n\"));\n#endif\n    return MHD_NO;\n  }\n  keyp = *nodep;\n  /* Test if there is room for another connection; if so,\n   * increment count */\n  result = (keyp->count < daemon->per_ip_connection_limit) ? MHD_YES : MHD_NO;\n  if (MHD_NO != result)\n    ++keyp->count;\n  MHD_ip_count_unlock (daemon);\n\n  /* If we got an existing node back, free the one we created */\n  if (keyp != newkeyp)\n    free (newkeyp);\n\n  return result;\n}\n```\n</target_code>\n<response format>\nProvide your answer with these fields.\n- explanation: your evaluation of the scenario provided by the agent A.\n- is_report_correct: whether the report is correct or not (true/false). True means there is a violation.\n</response format>\n<scenario>\nThe agent A provided the following violation scenario:\nThe statement 'daemon = MHD_get_master(daemon);' reassigns the function parameter 'daemon' (the pointer itself). MISRA C 2023 Rule 17.8 forbids modifying a function parameter variable; only the object referred to by a pointer parameter may be modified. Reassigning the pointer violates the rule. (Fix: use a local copy, e.g. 'struct MHD_Daemon *master = MHD_get_master(daemon);')\n</scenario>\n\n<execution_log>\nThe agent A also provided the following output log:\nbefore MHD_get_master: daemon=0x560f84c078d0\n  per_ip_connection_limit=0\nafter MHD_get_master: daemon=0x560f84c078d0\n  per_ip_connection_limit=0\nper_ip_connection_limit == 0, returning MHD_YES\nbefore MHD_get_master: daemon=0x560f84c078d0\n  per_ip_connection_limit=0\nafter MHD_get_master: daemon=0x560f84c078d0\n  per_ip_connection_limit=0\nper_ip_connection_limit == 0, returning MHD_YES\nbefore MHD_get_master: daemon=0x560f84c078d0\n  per_ip_connection_limit=0\nafter MHD_get_master: daemon=0x560f84c078d0\n  per_ip_connection_limit=0\nper_ip_connection_limit == 0, returning MHD_YES\nbefore MHD_get_master: daemon=0x560f84c078d0\n  per_ip_connection_limit=0\nafter MHD_get_master: daemon=0x560f84c078d0\n  per_ip_connection_limit=0\nper_ip_connection_limit == 0, returning MHD_YES\nbefore MHD_get_master: daemon=0x560f84c078d0\n  per_ip_connection_limit=0\nafter MHD_get_master: daemon=0x560f84c078d0\n  per_ip_connection_limit=0\nper_ip_connection_limit == 0, returning MHD_YES\nbefore MHD_get_master: daemon=0x560f84c078d0\n  per_ip_connection_limit=0\nafter MHD_get_master: daemon=0x560f84c078d0\n  per_ip_connection_limit=0\nper_ip_connection_limit == 0, returning MHD_YES\nbefore MHD_get_master: daemon=0x560f84c078d0\n  per_ip_connection_limit=0\nafter MHD_get_master: daemon=0x560f84c078d0\n  per_ip_connection_limit=0\nper_ip_connection_limit == 0, returning MHD_YES\nbefore MHD_get_master: daemon=0x560f84c078d0\n  per_ip_connection_limit=0\nafter MHD_get_master: daemon=0x560f84c078d0\n  per_ip_connection_limit=0\nper_ip_connection_limit == 0, returning MHD_YES\nbefore MHD_get_master: daemon=0x560f84c078d0\n  per_ip_connection_limit=0\nafter MHD_get_master: daemon=0x560f84c078d0\n  per_ip_connection_limit=0\nper_ip_connection_limit == 0, returning MHD_YES\nbefore MHD_get_master: daemon=0x560f84c078d0\n  per_ip_connection_limit=0\nafter MHD_get_master: daemon=0x560f84c078d0\n  per_ip_connection_limit=0\nper_ip_connection_limit == 0, returning MHD_YES\nbefore MHD_get_master: daemon=0x560f84c078d0\n  per_ip_connection_limit=0\nafter MHD_get_master: daemon=0x560f84c078d0\n  per_ip_connection_limit=0\nper_ip_connection_limit == 0, returning MHD_YES\nbefore MHD_get_master: daemon=0x560f84c078d0\n  per_ip_connection_limit=0\nafter MHD_get_master: daemon=0x560f84c078d0\n  per_ip_connection_limit=0\nper_ip_connection_limit == 0, returning MHD_YES\nbefore MHD_get_master: daemon=0x560f84c078d0\n  per_ip_connection_limit=0\nafter MHD_get_master: daemon=0x560f84c078d0\n  per_ip_connection_limit=0\nper_ip_connection_limit == 0, returning MHD_YES\nbefore MHD_get_master: daemon=0x560f84c078d0\n  per_ip_connection_limit=0\nafter MHD_get_master: daemon=0x560f84c078d0\n  per_ip_connection_limit=0\nper_ip_connection_limit == 0, returning MHD_YES\nbefore MHD_get_master: daemon=0x560f84c078d0\n  per_ip_connection_limit=0\nafter MHD_get_master: daemon=0x560f84c078d0\n  per_ip_connection_limit=0\nper_ip_connection_limit == 0, returning MHD_YES\nbefore MHD_get_master: daemon=0x560f84c078d0\n  per_ip_connection_limit=0\nafter MHD_get_master: daemon=0x560f84c078d0\n  per_ip_connection_limit=0\nper_ip_connection_limit == 0, returning MHD_YES\nbefore MHD_get_master: daemon=0x560f84c078d0\n  per_ip_connection_limit=0\nafter MHD_get_master: daemon=0x560f84c078d0\n  per_ip_connection_limit=0\nper_ip_connection_limit == 0, returning MHD_YES\nbefore MHD_get_master: daemon=0x560f84c078d0\n  per_ip_connection_limit=0\nafter MHD_get_master: daemon=0x560f84c078d0\n  per_ip_connection_limit=0\nper_ip_connection_limit == 0, returning MHD_YES\nbefore MHD_get_master: daemon=0x560f84c078d0\n  per_ip_connection_limit=0\nafter MHD_get_master: daemon=0x560f84c078d0\n  per_ip_connection_limit=0\nper_ip_connection_limit == 0, returning MHD_YES\nbefore MHD_get_master: daemon=0x560f84c078d0\n  per_ip_connection_limit=0\nafter MHD_get_master: daemon=0x560f84c078d0\n  per_ip_connection_limit=0\nper_ip_connection_limit == 0, returning MHD_YES\nbefore MHD_get_master: daemon=0x560f84c078d0\n  per_ip_connection_limit=0\nafter MHD_get_master: daemon=0x560f84c078d0\n  per_ip_connection_limit=0\nper_ip_connection_limit == 0, returning MHD_YES\nbefore MHD_get_master: daemon=0x560f84c078d\n</execution_log>\n\n<instruction>\nJudge whether the report is correct or not.\n</instruction>\n",
  "is_report_correct": true,
  "explanation": "Correct. MISRA C 2023 Rule 17.8 prohibits modifying a function parameter variable itself; only the object pointed to by a pointer parameter may be changed. The statement\n  daemon = MHD_get_master(daemon);\nreassigns the parameter variable 'daemon' (the pointer), which is a direct violation of Rule 17.8 even if the new value happens to equal the old one at runtime. The proper fix is to use a local variable, e.g.:\n  struct MHD_Daemon *master = MHD_get_master(daemon);\nand use 'master' thereafter (or otherwise avoid assigning to the parameter)."
}