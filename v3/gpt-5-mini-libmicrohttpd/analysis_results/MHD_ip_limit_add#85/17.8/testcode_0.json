{
  "user_message": "<misra_rule>\nMISRA C 2023 Rule 17.8 is: A function parameter should not be modified.\nNote that the object referred to by a pointer parameter may be modified, but the pointer itself shall not be modified.\n</misra_rule>\n\nAnother agent reported that the target code violated the Rule 17.8.\nHere is the comment from the agent.\n<violation scenario>\nThe statement 'daemon = MHD_get_master(daemon);' reassigns the function parameter 'daemon' (the pointer itself). MISRA C 2023 Rule 17.8 forbids modifying a function parameter variable; only the object referred to by a pointer parameter may be modified. Reassigning the pointer violates the rule. (Fix: use a local copy, e.g. 'struct MHD_Daemon *master = MHD_get_master(daemon);')\n</violation scenario>\n\nYour job is to insert logging code to capture the control flow and state information of the program.\nInsert logging code so that other agents can reproduce and get evidence for the violation scenario.\n<response format>\n- test_code: a modified MHD_ip_limit_add code that contains useful probe functions that print useful logs to a file \"/tmp/logs/857.txt\". The logs should contain the control path and state information of the violation scenario. If test code is not required to validate the scenario, you can leave this blank.\nHere are the constraints for the test code:\n- The test code MUST preserve the original logic of MHD_ip_limit_add as much as possible.\nYou CAN just insert probe functions to the original code.\n- DO NOT introduce new violations to demonstrate your scenario.\n- The test code MUST be compilable and executable.\n- The test code MUST include line breaks.\n- You MUST NOT define the main function.\n- You MUST NOT define macros.\n</response format>\n<target_code>\nHere is the code of MHD_ip_limit_add:\n```c\nstatic enum MHD_Result\nMHD_ip_limit_add (struct MHD_Daemon *daemon,\n                  const struct sockaddr_storage *addr,\n                  socklen_t addrlen)\n{\n  struct MHD_IPCount *newkeyp;\n  struct MHD_IPCount *keyp;\n  struct MHD_IPCount **nodep;\n  enum MHD_Result result;\n\n  daemon = MHD_get_master (daemon);\n  /* Ignore if no connection limit assigned */\n  if (0 == daemon->per_ip_connection_limit)\n    return MHD_YES;\n\n  newkeyp = (struct MHD_IPCount *) malloc (sizeof(struct MHD_IPCount));\n  if (NULL == newkeyp)\n    return MHD_NO;\n\n  /* Initialize key */\n  if (MHD_NO == MHD_ip_addr_to_key (addr,\n                                    addrlen,\n                                    newkeyp))\n  {\n    free (newkeyp);\n    return MHD_YES; /* Allow unhandled address types through */\n  }\n\n  MHD_ip_count_lock (daemon);\n\n  /* Search for the IP address */\n  nodep = (struct MHD_IPCount **) tsearch (newkeyp,\n                                           &daemon->per_ip_connection_count,\n                                           &MHD_ip_addr_compare);\n  if (NULL == nodep)\n  {\n    MHD_ip_count_unlock (daemon);\n    free (newkeyp);\n#ifdef HAVE_MESSAGES\n    MHD_DLOG (daemon,\n              _ (\"Failed to add IP connection count node.\\n\"));\n#endif\n    return MHD_NO;\n  }\n  keyp = *nodep;\n  /* Test if there is room for another connection; if so,\n   * increment count */\n  result = (keyp->count < daemon->per_ip_connection_limit) ? MHD_YES : MHD_NO;\n  if (MHD_NO != result)\n    ++keyp->count;\n  MHD_ip_count_unlock (daemon);\n\n  /* If we got an existing node back, free the one we created */\n  if (keyp != newkeyp)\n    free (newkeyp);\n\n  return result;\n}\n```\n</target_code>\nPlease provide the modified MHD_ip_limit_add code.\n",
  "test_code": "#include <stdio.h>\n#include <stddef.h>\n\n/* Probe helpers: write simple, best-effort diagnostic logs to /tmp/logs/857.txt\n   These helpers assume the surrounding compilation unit defines the relevant\n   types (struct MHD_Daemon, struct MHD_IPCount, enum MHD_Result, etc.). */\nstatic void mhd_log_msg(const char *msg)\n{\n  FILE *f = fopen(\"/tmp/logs/857.txt\", \"a\");\n  if (f != NULL)\n  {\n    fprintf(f, \"%s\\n\", msg);\n    fclose(f);\n  }\n}\n\nstatic void mhd_log_daemon(const char *tag, struct MHD_Daemon *d)\n{\n  FILE *f = fopen(\"/tmp/logs/857.txt\", \"a\");\n  if (f != NULL)\n  {\n    fprintf(f, \"%s: daemon=%p\\n\", tag, (void *) d);\n    if (d != NULL)\n      fprintf(f, \"  per_ip_connection_limit=%d\\n\", d->per_ip_connection_limit);\n    fclose(f);\n  }\n}\n\nstatic void mhd_log_ipcount(const char *tag, struct MHD_IPCount *k)\n{\n  FILE *f = fopen(\"/tmp/logs/857.txt\", \"a\");\n  if (f != NULL)\n  {\n    if (k != NULL)\n      fprintf(f, \"%s: MHD_IPCount=%p count=%d\\n\", tag, (void *) k, k->count);\n    else\n      fprintf(f, \"%s: MHD_IPCount=NULL\\n\", tag);\n    fclose(f);\n  }\n}\n\nstatic enum MHD_Result\nMHD_ip_limit_add (struct MHD_Daemon *daemon,\n                  const struct sockaddr_storage *addr,\n                  socklen_t addrlen)\n{\n  struct MHD_IPCount *newkeyp;\n  struct MHD_IPCount *keyp;\n  struct MHD_IPCount **nodep;\n  enum MHD_Result result;\n\n  /* Log daemon pointer before calling MHD_get_master */\n  mhd_log_daemon(\"before MHD_get_master\", daemon);\n\n  /* NOTE: the following reassignment of the parameter 'daemon' is the\n     operation reported as a violation of MISRA C 2023 Rule 17.8. We keep\n     the original behaviour but log the pointer before and after. */\n  daemon = MHD_get_master (daemon);\n\n  /* Log daemon pointer after calling MHD_get_master */\n  mhd_log_daemon(\"after MHD_get_master\", daemon);\n\n  /* Ignore if no connection limit assigned */\n  if (0 == daemon->per_ip_connection_limit)\n  {\n    mhd_log_msg(\"per_ip_connection_limit == 0, returning MHD_YES\");\n    return MHD_YES;\n  }\n\n  newkeyp = (struct MHD_IPCount *) malloc (sizeof(struct MHD_IPCount));\n  if (NULL == newkeyp)\n  {\n    mhd_log_msg(\"malloc for newkeyp failed, returning MHD_NO\");\n    return MHD_NO;\n  }\n\n  /* Initialize key */\n  if (MHD_NO == MHD_ip_addr_to_key (addr,\n                                    addrlen,\n                                    newkeyp))\n  {\n    mhd_log_msg(\"MHD_ip_addr_to_key failed for addr; freeing newkeyp and allowing through (MHD_YES)\");\n    free (newkeyp);\n    return MHD_YES; /* Allow unhandled address types through */\n  }\n\n  mhd_log_msg(\"MHD_ip_addr_to_key succeeded; locking ip count\");\n  MHD_ip_count_lock (daemon);\n\n  /* Search for the IP address */\n  nodep = (struct MHD_IPCount **) tsearch (newkeyp,\n                                           &daemon->per_ip_connection_count,\n                                           &MHD_ip_addr_compare);\n  if (NULL == nodep)\n  {\n    mhd_log_msg(\"tsearch returned NULL; unlocking, freeing newkeyp, returning MHD_NO\");\n    MHD_ip_count_unlock (daemon);\n    free (newkeyp);\n#ifdef HAVE_MESSAGES\n    MHD_DLOG (daemon,\n              _ (\"Failed to add IP connection count node.\\n\"));\n#endif\n    return MHD_NO;\n  }\n\n  keyp = *nodep;\n  mhd_log_ipcount(\"Found node (keyp)\", keyp);\n\n  /* Test if there is room for another connection; if so,\n   * increment count */\n  result = (keyp->count < daemon->per_ip_connection_limit) ? MHD_YES : MHD_NO;\n  if (MHD_NO != result)\n  {\n    ++keyp->count;\n    mhd_log_ipcount(\"Incremented keyp count to\", keyp);\n  }\n  else\n  {\n    mhd_log_ipcount(\"Not incrementing keyp (limit reached); current\", keyp);\n  }\n\n  MHD_ip_count_unlock (daemon);\n\n  /* If we got an existing node back, free the one we created */\n  if (keyp != newkeyp)\n  {\n    mhd_log_msg(\"keyp != newkeyp; freeing newkeyp\");\n    free (newkeyp);\n  }\n\n  {\n    char buf[128];\n    snprintf(buf, sizeof(buf), \"Returning result=%d\", (int) result);\n    mhd_log_msg(buf);\n  }\n\n  return result;\n}\n"
}