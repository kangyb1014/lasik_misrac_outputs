{
  "user_message": "An agent A claimed that the following MHD_SHA512_256_update code violates the MISRA C 2023 rule 8.13.\n<misra_rule>\nMISRA C 2023 Rule 8.13 is A pointer should point to a const-qualified type whenever possible.\n\n</misra_rule>\n<target_code>\nHere is the original code of MHD_SHA512_256_update.\n```c\nvoid\nMHD_SHA512_256_update (struct Sha512_256Ctx *ctx,\n                       const uint8_t *data,\n                       size_t length)\n{\n  unsigned int bytes_have; /**< Number of bytes in the context buffer */\n  uint64_t count_hi; /**< The high part to be moved to another variable */\n\n  mhd_assert ((data != NULL) || (length == 0));\n\n#ifndef MHD_FAVOR_SMALL_CODE\n  if (0 == length)\n    return; /* Shortcut, do nothing */\n#endif /* ! MHD_FAVOR_SMALL_CODE */\n\n  /* Note: (count & (SHA512_256_BLOCK_SIZE-1))\n           equals (count % SHA512_256_BLOCK_SIZE) for this block size. */\n  bytes_have = (unsigned int) (ctx->count & (SHA512_256_BLOCK_SIZE - 1));\n  ctx->count += length;\n#if SIZEOF_SIZE_T > 7\n  if (length > ctx->count)\n    ctx->count_bits_hi += 1U << 3; /* Value wrap */\n#endif /* SIZEOF_SIZE_T > 7 */\n  count_hi = ctx->count >> 61;\n  if (0 != count_hi)\n  {\n    ctx->count_bits_hi += count_hi;\n    ctx->count &= UINT64_C (0x1FFFFFFFFFFFFFFF);\n  }\n\n  if (0 != bytes_have)\n  {\n    unsigned int bytes_left = SHA512_256_BLOCK_SIZE - bytes_have;\n    if (length >= bytes_left)\n    {     /* Combine new data with data in the buffer and\n             process the full block. */\n      memcpy (((uint8_t *) ctx->buffer) + bytes_have,\n              data,\n              bytes_left);\n      data += bytes_left;\n      length -= bytes_left;\n      sha512_256_transform (ctx->H, ctx->buffer);\n      bytes_have = 0;\n    }\n  }\n\n  while (SHA512_256_BLOCK_SIZE <= length)\n  {   /* Process any full blocks of new data directly,\n         without copying to the buffer. */\n    sha512_256_transform (ctx->H, data);\n    data += SHA512_256_BLOCK_SIZE;\n    length -= SHA512_256_BLOCK_SIZE;\n  }\n\n  if (0 != length)\n  {   /* Copy incomplete block of new data (if any)\n         to the buffer. */\n    memcpy (((uint8_t *) ctx->buffer) + bytes_have, data, length);\n  }\n}\n```\n</target_code>\n<response format>\nProvide your answer with these fields.\n- explanation: your evaluation of the scenario provided by the agent A.\n- is_report_correct: whether the report is correct or not (true/false). True means there is a violation.\n</response format>\n<scenario>\nThe agent A provided the following violation scenario:\nThis call violates Rule 8.13 when sha512_256_transform is declared to accept a non-const pointer (e.g. void sha512_256_transform(uint64_t H[], uint8_t *block)). The local variable data has type const uint8_t *; passing it to a parameter of type uint8_t * discards the const qualifier, so the pointer does not point to a const-qualified type as required. (If sha512_256_transform's parameter is already declared as const uint8_t *, then no violation occurs.)\n</scenario>\n\n<execution_log>\nThe agent A also provided the following output log:\nevent=entry\n  ctx=0x7ffd9e7eb9c8\n  ctx->count=0x0\n  ctx->count_bits_hi=0x0\n  count_hi=0x0\n  bytes_have=0\n  length=3\n  data=0x556f9b5ef01b\n  ctx->buffer=0x7ffd9e7eba08\n  ctx->H=0x7ffd9e7eb9c8\nevent=after_counts\n  ctx=0x7ffd9e7eb9c8\n  ctx->count=0x3\n  ctx->count_bits_hi=0x0\n  count_hi=0x0\n  bytes_have=0\n  length=3\n  data=0x556f9b5ef01b\n  ctx->buffer=0x7ffd9e7eba08\n  ctx->H=0x7ffd9e7eb9c8\nevent=final_partial_copy\n  ctx=0x7ffd9e7eb9c8\n  ctx->count=0x3\n  ctx->count_bits_hi=0x0\n  count_hi=0x0\n  bytes_have=0\n  length=3\n  data=0x556f9b5ef01b\n  ctx->buffer=0x7ffd9e7eba08\n  ctx->H=0x7ffd9e7eb9c8\nevent=exit\n  ctx=0x7ffd9e7eb9c8\n  ctx->count=0x3\n  ctx->count_bits_hi=0x0\n  count_hi=0x0\n  bytes_have=0\n  length=3\n  data=0x556f9b5ef01b\n  ctx->buffer=0x7ffd9e7eba08\n  ctx->H=0x7ffd9e7eb9c8\nevent=entry\n  ctx=0x7ffd9e7eb9c8\n  ctx->count=0x0\n  ctx->count_bits_hi=0x0\n  count_hi=0x0\n  bytes_have=0\n  length=112\n  data=0x556f9b5ef01f\n  ctx->buffer=0x7ffd9e7eba08\n  ctx->H=0x7ffd9e7eb9c8\nevent=after_counts\n  ctx=0x7ffd9e7eb9c8\n  ctx->count=0x70\n  ctx->count_bits_hi=0x0\n  count_hi=0x0\n  bytes_have=0\n  length=112\n  data=0x556f9b5ef01f\n  ctx->buffer=0x7ffd9e7eba08\n  ctx->H=0x7ffd9e7eb9c8\nevent=final_partial_copy\n  ctx=0x7ffd9e7eb9c8\n  ctx->count=0x70\n  ctx->count_bits_hi=0x0\n  count_hi=0x0\n  bytes_have=0\n  length=112\n  data=0x556f9b5ef01f\n  ctx->buffer=0x7ffd9e7eba08\n  ctx->H=0x7ffd9e7eb9c8\nevent=exit\n  ctx=0x7ffd9e7eb9c8\n  ctx->count=0x70\n  ctx->count_bits_hi=0x0\n  count_hi=0x0\n  bytes_have=0\n  length=112\n  data=0x556f9b5ef01f\n  ctx->buffer=0x7ffd9e7eba08\n  ctx->H=0x7ffd9e7eb9c8\nevent=entry\n  ctx=0x7ffd9e7eb9c8\n  ctx->count=0x0\n  ctx->count_bits_hi=0x0\n  count_hi=0x0\n  bytes_have=0\n  length=0\n  data=0x556f9b5f2611\n  ctx->buffer=0x7ffd9e7eba08\n  ctx->H=0x7ffd9e7eb9c8\nevent=entry\n  ctx=0x7ffd9e7eb9c8\n  ctx->count=0x0\n  ctx->count_bits_hi=0x0\n  count_hi=0x0\n  bytes_have=0\n  length=28\n  data=0x556f9b5ef090\n  ctx->buffer=0x7ffd9e7eba08\n  ctx->H=0x7ffd9e7eb9c8\nevent=after_counts\n  ctx=0x7ffd9e7eb9c8\n  ctx->count=0x1c\n  ctx->count_bits_hi=0x0\n  count_hi=0x0\n  bytes_have=0\n  length=28\n  data=0x556f9b5ef090\n  ctx->buffer=0x7ffd9e7eba08\n  ctx->H=0x7ffd9e7eb9c8\nevent=final_partial_copy\n  ctx=0x7ffd9e7eb9c8\n  ctx->count=0x1c\n  ctx->count_bits_hi=0x0\n  count_hi=0x0\n  bytes_have=0\n  length=28\n  data=0x556f9b5ef090\n  ctx->buffer=0x7ffd9e7eba08\n  ctx->H=0x7ffd9e7eb9c8\nevent=exit\n  ctx=0x7ffd9e7eb9c8\n  ctx->count=0x1c\n  ctx->count_bits_hi=0x0\n  count_hi=0x0\n  bytes_have=0\n  length=28\n  data=0x556f9b5ef090\n  ctx->buffer=0x7ffd9e7eba08\n  ctx->H=0x7ffd9e7eb9c8\nevent=entry\n  ctx=0x7ffd9e7eb9c8\n  ctx->count=0x0\n  ctx->count_bits_hi=0x0\n  count_hi=0x0\n  bytes_have=0\n  length=14\n  data=0x556f9b5ef0ad\n  ctx->buffer=0x7ffd9e7eba08\n  ctx->H=0x7ffd9e7eb9c8\nevent=after_counts\n  ctx=0x7ffd9e7eb9c8\n  ctx->count=0xe\n  ctx->count_bits_hi=0x0\n  count_hi=0x0\n  bytes_have=0\n  length=14\n  data=0x556f9b5ef0ad\n  ctx->buffer=0x7ffd9e7eba08\n  ctx->H=0x7ffd9e7eb9c8\nevent=final_partial_copy\n  ctx=0x7ffd9e7eb9c8\n  ctx->count=0xe\n  ctx->count_bits_hi=0x0\n  count_hi=0x0\n  bytes_have=0\n  length=14\n  data=0x556f9b5ef0ad\n  ctx->buffer=0x7ffd9e7eba08\n  ctx->H=0x7ffd9e7eb9c8\nevent=exit\n  ctx=0x7ffd9e7eb9c8\n  ctx->count=0xe\n  ctx->count_bits_hi=0x0\n  count_hi=0x0\n  bytes_have=0\n  length=14\n  data=0x556f9b5ef0ad\n  ctx->buffer=0x7ffd9e7eba08\n  ctx->H=0x7ffd9e7eb9c8\nevent=entry\n  ctx=0x7ffd9e7eb9c8\n  ctx->count=0x0\n  ctx->count_bits_hi=0x0\n  count_hi=0x0\n  bytes_have=0\n  length=26\n  data=0x556f9b5ef0bc\n  ctx->buffer=0x7ffd9e7eba08\n  ctx->H=0x7ffd9e7eb9c8\nevent=after_counts\n  ctx=0x7ffd9e7eb9c8\n  ctx->count=0x1a\n  ctx->count_bits_hi=0x0\n  count_hi=0x0\n  bytes_have=0\n  length=26\n  data=0x556f9b5ef0bc\n  ctx->buffer=0x7ffd9e7eba08\n  ctx->H=0x7ffd9e7eb9c8\nevent=final_partial_copy\n  ctx=0x7ffd9e7eb9c8\n  ctx->count=0x1a\n  ctx->count_bits_hi=0x0\n  count_hi=0x0\n  bytes_have=0\n  length=26\n  data=0x556f9b5ef0bc\n  ctx->buffer=0x7ffd9e7eba08\n  ctx->H=0x7ffd9e7eb9c8\nevent=exit\n  ctx=0x7ffd9e7eb9c8\n  ctx->count=0x1a\n  ctx->count_bits_hi=0x0\n  count_hi=0x0\n  bytes_have=0\n  length=26\n  data=0x556f9b5ef0bc\n  ctx->buffer=\n</execution_log>\n\n<instruction>\nJudge whether the report is correct or not.\n</instruction>\n",
  "is_report_correct": true,
  "explanation": "Agent A's report is correct in the scenario they describe. The parameter data in MHD_SHA512_256_update is declared as const uint8_t *; if sha512_256_transform is declared to accept a non-const uint8_t * (e.g. void sha512_256_transform(uint64_t H[], uint8_t *block)), then passing data to that function would discard the const qualifier. That is both a C type-qualifier mismatch (and normally a compiler diagnostic) and falls afoul of MISRA C 2023 Rule 8.13: a pointer should point to a const-qualified type whenever possible. (If sha512_256_transform is declared to accept a const uint8_t * there is no violation.) Note also that the memcpy calls shown are fine because memcpy's source parameter is const void *, so passing data there does not cause a qualifier discard. The correct remediation is to declare sha512_256_transform's block parameter as const uint8_t * if it does not modify the pointed-to data; inserting a cast to suppress the qualifier would hide the problem and is not recommended."
}