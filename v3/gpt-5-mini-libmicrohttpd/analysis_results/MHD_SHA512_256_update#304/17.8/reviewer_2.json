{
  "user_message": "An agent A claimed that the following MHD_SHA512_256_update code violates the MISRA C 2023 rule 17.8.\n<misra_rule>\nMISRA C 2023 Rule 17.8 is A function parameter should not be modified.\nNote that the object referred to by a pointer parameter may be modified, but the pointer itself shall not be modified.\n</misra_rule>\n<target_code>\nHere is the original code of MHD_SHA512_256_update.\n```c\nvoid\nMHD_SHA512_256_update (struct Sha512_256Ctx *ctx,\n                       const uint8_t *data,\n                       size_t length)\n{\n  unsigned int bytes_have; /**< Number of bytes in the context buffer */\n  uint64_t count_hi; /**< The high part to be moved to another variable */\n\n  mhd_assert ((data != NULL) || (length == 0));\n\n#ifndef MHD_FAVOR_SMALL_CODE\n  if (0 == length)\n    return; /* Shortcut, do nothing */\n#endif /* ! MHD_FAVOR_SMALL_CODE */\n\n  /* Note: (count & (SHA512_256_BLOCK_SIZE-1))\n           equals (count % SHA512_256_BLOCK_SIZE) for this block size. */\n  bytes_have = (unsigned int) (ctx->count & (SHA512_256_BLOCK_SIZE - 1));\n  ctx->count += length;\n#if SIZEOF_SIZE_T > 7\n  if (length > ctx->count)\n    ctx->count_bits_hi += 1U << 3; /* Value wrap */\n#endif /* SIZEOF_SIZE_T > 7 */\n  count_hi = ctx->count >> 61;\n  if (0 != count_hi)\n  {\n    ctx->count_bits_hi += count_hi;\n    ctx->count &= UINT64_C (0x1FFFFFFFFFFFFFFF);\n  }\n\n  if (0 != bytes_have)\n  {\n    unsigned int bytes_left = SHA512_256_BLOCK_SIZE - bytes_have;\n    if (length >= bytes_left)\n    {     /* Combine new data with data in the buffer and\n             process the full block. */\n      memcpy (((uint8_t *) ctx->buffer) + bytes_have,\n              data,\n              bytes_left);\n      data += bytes_left;\n      length -= bytes_left;\n      sha512_256_transform (ctx->H, ctx->buffer);\n      bytes_have = 0;\n    }\n  }\n\n  while (SHA512_256_BLOCK_SIZE <= length)\n  {   /* Process any full blocks of new data directly,\n         without copying to the buffer. */\n    sha512_256_transform (ctx->H, data);\n    data += SHA512_256_BLOCK_SIZE;\n    length -= SHA512_256_BLOCK_SIZE;\n  }\n\n  if (0 != length)\n  {   /* Copy incomplete block of new data (if any)\n         to the buffer. */\n    memcpy (((uint8_t *) ctx->buffer) + bytes_have, data, length);\n  }\n}\n```\n</target_code>\n<response format>\nProvide your answer with these fields.\n- explanation: your evaluation of the scenario provided by the agent A.\n- is_report_correct: whether the report is correct or not (true/false). True means there is a violation.\n</response format>\n<scenario>\nThe agent A provided the following violation scenario:\nThe statement 'length -= bytes_left;' modifies the formal parameter 'length' (a size_t function parameter). MISRA C 2023 Rule 17.8 states that a function parameter should not be modified, so decrementing the parameter inside the function violates the rule. (Compliant code should use a local copy\u2014e.g. 'size_t rem = length'\u2014and modify that.)\n</scenario>\n\n<execution_log>\nThe agent A also provided the following output log:\nENTER MHD_SHA512_256_update: ctx=0x7ffc00e22ff8 data=0x5610ad54901b length=3 ctx->count=0 ctx->count_bits_hi=0\nafter bytes_have calc: bytes_have=0 ctx->count(before)=0\nafter ctx->count += length: added=3 ctx->count(after)=3\nfinal copy into buffer: bytes_have=0 remaining length=3 data=0x5610ad54901b\nEXIT MHD_SHA512_256_update: final length=3 ctx->count=3 ctx->count_bits_hi=0\nENTER MHD_SHA512_256_update: ctx=0x7ffc00e22ff8 data=0x5610ad54901f length=112 ctx->count=0 ctx->count_bits_hi=0\nafter bytes_have calc: bytes_have=0 ctx->count(before)=0\nafter ctx->count += length: added=112 ctx->count(after)=112\nfinal copy into buffer: bytes_have=0 remaining length=112 data=0x5610ad54901f\nEXIT MHD_SHA512_256_update: final length=112 ctx->count=112 ctx->count_bits_hi=0\nENTER MHD_SHA512_256_update: ctx=0x7ffc00e22ff8 data=0x5610ad54c8b1 length=0 ctx->count=0 ctx->count_bits_hi=0\nEARLY RETURN: length is zero\nENTER MHD_SHA512_256_update: ctx=0x7ffc00e22ff8 data=0x5610ad549090 length=28 ctx->count=0 ctx->count_bits_hi=0\nafter bytes_have calc: bytes_have=0 ctx->count(before)=0\nafter ctx->count += length: added=28 ctx->count(after)=28\nfinal copy into buffer: bytes_have=0 remaining length=28 data=0x5610ad549090\nEXIT MHD_SHA512_256_update: final length=28 ctx->count=28 ctx->count_bits_hi=0\nENTER MHD_SHA512_256_update: ctx=0x7ffc00e22ff8 data=0x5610ad5490ad length=14 ctx->count=0 ctx->count_bits_hi=0\nafter bytes_have calc: bytes_have=0 ctx->count(before)=0\nafter ctx->count += length: added=14 ctx->count(after)=14\nfinal copy into buffer: bytes_have=0 remaining length=14 data=0x5610ad5490ad\nEXIT MHD_SHA512_256_update: final length=14 ctx->count=14 ctx->count_bits_hi=0\nENTER MHD_SHA512_256_update: ctx=0x7ffc00e22ff8 data=0x5610ad5490bc length=26 ctx->count=0 ctx->count_bits_hi=0\nafter bytes_have calc: bytes_have=0 ctx->count(before)=0\nafter ctx->count += length: added=26 ctx->count(after)=26\nfinal copy into buffer: bytes_have=0 remaining length=26 data=0x5610ad5490bc\nEXIT MHD_SHA512_256_update: final length=26 ctx->count=26 ctx->count_bits_hi=0\nENTER MHD_SHA512_256_update: ctx=0x7ffc00e22ff8 data=0x5610ad549125 length=26 ctx->count=0 ctx->count_bits_hi=0\nafter bytes_have calc: bytes_have=0 ctx->count(before)=0\nafter ctx->count += length: added=26 ctx->count(after)=26\nfinal copy into buffer: bytes_have=0 remaining length=26 data=0x5610ad549125\nEXIT MHD_SHA512_256_update: final length=26 ctx->count=26 ctx->count_bits_hi=0\nENTER MHD_SHA512_256_update: ctx=0x7ffc00e22ff8 data=0x5610ad5490d7 length=104 ctx->count=0 ctx->count_bits_hi=0\nafter bytes_have calc: bytes_have=0 ctx->count(before)=0\nafter ctx->count += length: added=104 ctx->count(after)=104\nfinal copy into buffer: bytes_have=0 remaining length=104 data=0x5610ad5490d7\nEXIT MHD_SHA512_256_update: final length=104 ctx->count=104 ctx->count_bits_hi=0\nENTER MHD_SHA512_256_update: ctx=0x7ffc00e22ff8 data=0x5610ad549140 length=378 ctx->count=0 ctx->count_bits_hi=0\nafter bytes_have calc: bytes_have=0 ctx->count(before)=0\nafter ctx->count += length: added=378 ctx->count(after)=378\nwhile-loop iteration: length=378 data=0x5610ad549140 (processing one block)\nabout to decrement length by SHA512_256_BLOCK_SIZE (128): length(before)=378\nafter decrement in while-loop: length=250 data=0x5610ad5491c0\nwhile-loop iteration: length=250 data=0x5610ad5491c0 (processing one block)\nabout to decrement length by SHA512_256_BLOCK_SIZE (128): length(before)=250\nafter decrement in while-loop: length=122 data=0x5610ad549240\nfinal copy into buffer: bytes_have=0 remaining length=122 data=0x5610ad549240\nEXIT MHD_SHA512_256_update: final length=122 ctx->count=378 ctx->count_bits_hi=0\nENTER MHD_SHA512_256_update: ctx=0x7ffc00e22ff8 data=0x5610ad5493b0 length=26 ctx->count=0 ctx->count_bits_hi=0\nafter bytes_have calc: bytes_have=0 ctx->count(before)=0\nafter ctx->count += length: added=26 ctx->count(after)=26\nfinal copy into buffer: bytes_have=0 remaining length=26 data=0x5610ad5493b0\nEXIT MHD_SHA512_256_update: final length=26 ctx->count=26 ctx->count_bits_hi=0\nENTER MHD_SHA512_256_update: ctx=0x7ffc00e22ff8 data=0x5610ad5495d8\n</execution_log>\n\n<instruction>\nJudge whether the report is correct or not.\n</instruction>\n",
  "is_report_correct": true,
  "explanation": "Agent A is correct. MISRA C 2023 Rule 17.8 forbids modification of function parameters. In MHD_SHA512_256_update the scalar parameter 'length' is modified (e.g. \"length -= bytes_left;\" and \"length -= SHA512_256_BLOCK_SIZE;\"), which is a direct breach of 17.8. Additionally the pointer parameter 'data' is advanced (\"data += bytes_left;\" and \"data += SHA512_256_BLOCK_SIZE;\"), which also violates the second sentence of the rule because the pointer object itself is being changed (only the object referred to by a pointer parameter may be modified, not the pointer). The remedy is to make local copies (for example: const uint8_t *p = data; size_t rem = length;) and operate on those locals instead."
}