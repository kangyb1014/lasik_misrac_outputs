{
  "user_message": "An agent A claimed that the following MHD_SHA512_256_update code violates the MISRA C 2023 rule 21.17.\n<misra_rule>\nMISRA C 2023 Rule 21.17 is Use of the string handling functions from <string.h> shall not result in accesses beyond the bounds of the objects referenced by their pointer parameters.\nThis rule strictly applies to the Standard Library functions in <string.h> such as memcpy, memmove, memset, memcmp, strcpy, strncpy, strcat, strncat, strlen, and strspn.\n</misra_rule>\n<target_code>\nHere is the original code of MHD_SHA512_256_update.\n```c\nvoid\nMHD_SHA512_256_update (struct Sha512_256Ctx *ctx,\n                       const uint8_t *data,\n                       size_t length)\n{\n  unsigned int bytes_have; /**< Number of bytes in the context buffer */\n  uint64_t count_hi; /**< The high part to be moved to another variable */\n\n  mhd_assert ((data != NULL) || (length == 0));\n\n#ifndef MHD_FAVOR_SMALL_CODE\n  if (0 == length)\n    return; /* Shortcut, do nothing */\n#endif /* ! MHD_FAVOR_SMALL_CODE */\n\n  /* Note: (count & (SHA512_256_BLOCK_SIZE-1))\n           equals (count % SHA512_256_BLOCK_SIZE) for this block size. */\n  bytes_have = (unsigned int) (ctx->count & (SHA512_256_BLOCK_SIZE - 1));\n  ctx->count += length;\n#if SIZEOF_SIZE_T > 7\n  if (length > ctx->count)\n    ctx->count_bits_hi += 1U << 3; /* Value wrap */\n#endif /* SIZEOF_SIZE_T > 7 */\n  count_hi = ctx->count >> 61;\n  if (0 != count_hi)\n  {\n    ctx->count_bits_hi += count_hi;\n    ctx->count &= UINT64_C (0x1FFFFFFFFFFFFFFF);\n  }\n\n  if (0 != bytes_have)\n  {\n    unsigned int bytes_left = SHA512_256_BLOCK_SIZE - bytes_have;\n    if (length >= bytes_left)\n    {     /* Combine new data with data in the buffer and\n             process the full block. */\n      memcpy (((uint8_t *) ctx->buffer) + bytes_have,\n              data,\n              bytes_left);\n      data += bytes_left;\n      length -= bytes_left;\n      sha512_256_transform (ctx->H, ctx->buffer);\n      bytes_have = 0;\n    }\n  }\n\n  while (SHA512_256_BLOCK_SIZE <= length)\n  {   /* Process any full blocks of new data directly,\n         without copying to the buffer. */\n    sha512_256_transform (ctx->H, data);\n    data += SHA512_256_BLOCK_SIZE;\n    length -= SHA512_256_BLOCK_SIZE;\n  }\n\n  if (0 != length)\n  {   /* Copy incomplete block of new data (if any)\n         to the buffer. */\n    memcpy (((uint8_t *) ctx->buffer) + bytes_have, data, length);\n  }\n}\n```\n</target_code>\n<response format>\nProvide your answer with these fields.\n- explanation: your evaluation of the scenario provided by the agent A.\n- is_report_correct: whether the report is correct or not (true/false). True means there is a violation.\n</response format>\n<scenario>\nThe agent A provided the following violation scenario:\nIf the debug assertion mhd_assert is compiled out (as in production) and the caller passes data == NULL with length > 0, the memcpy call will dereference a NULL source pointer and access beyond the bounds of the object referenced by 'data'. Equally, if the invariant that ctx->buffer is at least SHA512_256_BLOCK_SIZE bytes is violated (or bytes_have + length > SHA512_256_BLOCK_SIZE due to corrupted ctx->count), the memcpy destination would overflow the buffer.\n</scenario>\n\n<execution_log>\nThe agent A also provided the following output log:\nENTRY: ctx=0x7ffcc9c35ba8 data=0x5586139e701b length=3\nSTATE before count update: ctx=0x7ffcc9c35ba8 bytes_have=0 ctx->count(before)=0\nSTATE after count update: ctx=0x7ffcc9c35ba8 bytes_have=0 ctx->count=3 ctx->count_bits_hi=0 count_hi=0\nCOPY2: dest=(0x7ffcc9c35be8)+0 length=3 data=0x5586139e701b\nCOPY2_DONE: dest=(0x7ffcc9c35be8)+0 copied=3\nEXIT: ctx=0x7ffcc9c35ba8 remaining_length=3\nENTRY: ctx=0x7ffcc9c35ba8 data=0x5586139e701f length=112\nSTATE before count update: ctx=0x7ffcc9c35ba8 bytes_have=0 ctx->count(before)=0\nSTATE after count update: ctx=0x7ffcc9c35ba8 bytes_have=0 ctx->count=112 ctx->count_bits_hi=0 count_hi=0\nCOPY2: dest=(0x7ffcc9c35be8)+0 length=112 data=0x5586139e701f\nCOPY2_DONE: dest=(0x7ffcc9c35be8)+0 copied=112\nEXIT: ctx=0x7ffcc9c35ba8 remaining_length=112\nENTRY: ctx=0x7ffcc9c35ba8 data=0x5586139ea7c1 length=0\nENTRY: ctx=0x7ffcc9c35ba8 data=0x5586139e7090 length=28\nSTATE before count update: ctx=0x7ffcc9c35ba8 bytes_have=0 ctx->count(before)=0\nSTATE after count update: ctx=0x7ffcc9c35ba8 bytes_have=0 ctx->count=28 ctx->count_bits_hi=0 count_hi=0\nCOPY2: dest=(0x7ffcc9c35be8)+0 length=28 data=0x5586139e7090\nCOPY2_DONE: dest=(0x7ffcc9c35be8)+0 copied=28\nEXIT: ctx=0x7ffcc9c35ba8 remaining_length=28\nENTRY: ctx=0x7ffcc9c35ba8 data=0x5586139e70ad length=14\nSTATE before count update: ctx=0x7ffcc9c35ba8 bytes_have=0 ctx->count(before)=0\nSTATE after count update: ctx=0x7ffcc9c35ba8 bytes_have=0 ctx->count=14 ctx->count_bits_hi=0 count_hi=0\nCOPY2: dest=(0x7ffcc9c35be8)+0 length=14 data=0x5586139e70ad\nCOPY2_DONE: dest=(0x7ffcc9c35be8)+0 copied=14\nEXIT: ctx=0x7ffcc9c35ba8 remaining_length=14\nENTRY: ctx=0x7ffcc9c35ba8 data=0x5586139e70bc length=26\nSTATE before count update: ctx=0x7ffcc9c35ba8 bytes_have=0 ctx->count(before)=0\nSTATE after count update: ctx=0x7ffcc9c35ba8 bytes_have=0 ctx->count=26 ctx->count_bits_hi=0 count_hi=0\nCOPY2: dest=(0x7ffcc9c35be8)+0 length=26 data=0x5586139e70bc\nCOPY2_DONE: dest=(0x7ffcc9c35be8)+0 copied=26\nEXIT: ctx=0x7ffcc9c35ba8 remaining_length=26\nENTRY: ctx=0x7ffcc9c35ba8 data=0x5586139e7125 length=26\nSTATE before count update: ctx=0x7ffcc9c35ba8 bytes_have=0 ctx->count(before)=0\nSTATE after count update: ctx=0x7ffcc9c35ba8 bytes_have=0 ctx->count=26 ctx->count_bits_hi=0 count_hi=0\nCOPY2: dest=(0x7ffcc9c35be8)+0 length=26 data=0x5586139e7125\nCOPY2_DONE: dest=(0x7ffcc9c35be8)+0 copied=26\nEXIT: ctx=0x7ffcc9c35ba8 remaining_length=26\nENTRY: ctx=0x7ffcc9c35ba8 data=0x5586139e70d7 length=104\nSTATE before count update: ctx=0x7ffcc9c35ba8 bytes_have=0 ctx->count(before)=0\nSTATE after count update: ctx=0x7ffcc9c35ba8 bytes_have=0 ctx->count=104 ctx->count_bits_hi=0 count_hi=0\nCOPY2: dest=(0x7ffcc9c35be8)+0 length=104 data=0x5586139e70d7\nCOPY2_DONE: dest=(0x7ffcc9c35be8)+0 copied=104\nEXIT: ctx=0x7ffcc9c35ba8 remaining_length=104\nENTRY: ctx=0x7ffcc9c35ba8 data=0x5586139e7140 length=378\nSTATE before count update: ctx=0x7ffcc9c35ba8 bytes_have=0 ctx->count(before)=0\nSTATE after count update: ctx=0x7ffcc9c35ba8 bytes_have=0 ctx->count=378 ctx->count_bits_hi=0 count_hi=0\nTRANSFORM: full block at data=0x5586139e7140 remaining_length=378\nTRANSFORM: full block at data=0x5586139e71c0 remaining_length=250\nCOPY2: dest=(0x7ffcc9c35be8)+0 length=122 data=0x5586139e7240\nCOPY2_DONE: dest=(0x7ffcc9c35be8)+0 copied=122\nEXIT: ctx=0x7ffcc9c35ba8 remaining_length=122\nENTRY: ctx=0x7ffcc9c35ba8 data=0x5586139e73b0 length=26\nSTATE before count update: ctx=0x7ffcc9c35ba8 bytes_have=0 ctx->count(before)=0\nSTATE after count update: ctx=0x7ffcc9c35ba8 bytes_have=0 ctx->count=26 ctx->count_bits_hi=0 count_hi=0\nCOPY2: dest=(0x7ffcc9c35be8)+0 length=26 data=0x5586139e73b0\nCOPY2_DONE: dest=(0x7ffcc9c35be8)+0 copied=26\nEXIT: ctx=0x7ffcc9c35ba8 remaining_length=26\nENTRY: ctx=0x7ffcc9c35ba8 data=0x5586139e75d8 length=72\nSTATE before count update: ctx=0x7ffcc9c35ba8 bytes_have=0 ctx->count(before)=0\nSTATE after count update: ctx=0x7ffcc9c35ba8 bytes_have=0 ctx->count=72 ctx->count_bits_hi=0 count_hi=0\nCOPY2: dest=(0x7ffcc9c35be8)+0 length=72 data=0x5586139e75d8\nCOPY2_DONE: dest=(0x7ffcc9c35be8)+0 copied=72\nEXIT: ctx=0x7ffcc9c35ba8\n</execution_log>\n\n<instruction>\nJudge whether the report is correct or not.\n</instruction>\n",
  "is_report_correct": true,
  "explanation": "Agent A is correct. The function calls memcpy twice with sizes derived from the caller-supplied length and ctx state but contains no runtime checks that the source pointer is non-NULL when length>0 nor that the destination buffer is large enough for the requested copy. The only protection for the source is mhd_assert((data != NULL) || (length == 0)), which can be compiled out; if data == NULL and length > 0 memcpy will attempt to read through a NULL pointer (out-of-bounds access). Likewise the code assumes ctx->buffer has at least SHA512_256_BLOCK_SIZE bytes and that bytes_have+length will not exceed that, but there is no defensive check in the function \u2014 if those invariants are violated (for example by a corrupted ctx->count or an incorrectly sized ctx->buffer) the memcpy destination can be written out of bounds. Both situations would result in accesses beyond the bounds of the objects referenced by memcpy parameters and therefore violate MISRA C 2023 Rule 21.17."
}