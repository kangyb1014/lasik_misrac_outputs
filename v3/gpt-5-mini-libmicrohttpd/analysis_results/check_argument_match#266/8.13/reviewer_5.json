{
  "user_message": "An agent A claimed that the following check_argument_match code violates the MISRA C 2023 rule 8.13.\n<misra_rule>\nMISRA C 2023 Rule 8.13 is A pointer should point to a const-qualified type whenever possible.\n\n</misra_rule>\n<target_code>\nHere is the original code of check_argument_match.\n```c\nstatic bool\ncheck_argument_match (struct MHD_Connection *connection,\n                      char *args)\n{\n  struct MHD_HTTP_Req_Header *pos;\n  enum MHD_Result ret;\n  struct test_header_param param;\n\n  param.connection = connection;\n  param.num_headers = 0;\n  ret = MHD_parse_arguments_ (connection,\n                              MHD_GET_ARGUMENT_KIND,\n                              args,\n                              &test_header,\n                              &param);\n  if (MHD_NO == ret)\n  {\n    return false;\n  }\n  /* also check that the number of headers matches */\n  for (pos = connection->rq.headers_received; NULL != pos; pos = pos->next)\n  {\n    if (MHD_GET_ARGUMENT_KIND != pos->kind)\n      continue;\n    param.num_headers--;\n  }\n  if (0 != param.num_headers)\n  {\n    /* argument count mismatch */\n    return false;\n  }\n  return true;\n}\n```\n</target_code>\n<response format>\nProvide your answer with these fields.\n- explanation: your evaluation of the scenario provided by the agent A.\n- is_report_correct: whether the report is correct or not (true/false). True means there is a violation.\n</response format>\n<scenario>\nThe agent A provided the following violation scenario:\nThe loop iterates over connection->rq.headers_received only to read fields (pos->kind, pos->next) and does not modify the pointed-to header objects. The local pointer pos is declared as struct MHD_HTTP_Req_Header * but could be declared as pointer to const (const struct MHD_HTTP_Req_Header *pos). Per MISRA C 2023 Rule 8.13, a pointer should point to a const-qualified type whenever possible, so this is a violation.\n</scenario>\n\n<execution_log>\nThe agent A also provided the following output log:\n[check_argument_match] ENTER: connection=0x7f13a4000b70 args=key=value&more=even%20more&empty&=no_key&&same=one&&same=two\n[check_argument_match] parse_result: connection=0x7f13a4000b70 ret=1 num_headers=8 args=key\n[check_argument_match] loop: pos=0x7f13a4008db0 kind=8 next=0x7f13a4008d70 num_headers_before=8\n[check_argument_match] loop: pos=0x7f13a4008db0 kind=8 next=0x7f13a4008d70 num_headers_before=7\n[check_argument_match] loop: pos=0x7f13a4008d70 kind=8 next=0x7f13a4008d30 num_headers_before=7\n[check_argument_match] loop: pos=0x7f13a4008d70 kind=8 next=0x7f13a4008d30 num_headers_before=6\n[check_argument_match] loop: pos=0x7f13a4008d30 kind=8 next=0x7f13a4008cf0 num_headers_before=6\n[check_argument_match] loop: pos=0x7f13a4008d30 kind=8 next=0x7f13a4008cf0 num_headers_before=5\n[check_argument_match] loop: pos=0x7f13a4008cf0 kind=8 next=0x7f13a4008cb0 num_headers_before=5\n[check_argument_match] loop: pos=0x7f13a4008cf0 kind=8 next=0x7f13a4008cb0 num_headers_before=4\n[check_argument_match] loop: pos=0x7f13a4008cb0 kind=8 next=0x7f13a4008c70 num_headers_before=4\n[check_argument_match] loop: pos=0x7f13a4008cb0 kind=8 next=0x7f13a4008c70 num_headers_before=3\n[check_argument_match] loop: pos=0x7f13a4008c70 kind=8 next=0x7f13a4008c30 num_headers_before=3\n[check_argument_match] loop: pos=0x7f13a4008c70 kind=8 next=0x7f13a4008c30 num_headers_before=2\n[check_argument_match] loop: pos=0x7f13a4008c30 kind=8 next=0x7f13a4008bf0 num_headers_before=2\n[check_argument_match] loop: pos=0x7f13a4008c30 kind=8 next=0x7f13a4008bf0 num_headers_before=1\n[check_argument_match] loop: pos=0x7f13a4008bf0 kind=8 next=0x7f13a4008bb0 num_headers_before=1\n[check_argument_match] loop: pos=0x7f13a4008bf0 kind=8 next=0x7f13a4008bb0 num_headers_before=0\n[check_argument_match] loop: pos=0x7f13a4008bb0 kind=1 next=0x7f13a4008b70 num_headers_before=0\n[check_argument_match] loop: pos=0x7f13a4008b70 kind=1 next=0x7f13a4008b30 num_headers_before=0\n[check_argument_match] loop: pos=0x7f13a4008b30 kind=1 next=(nil) num_headers_before=0\n[check_argument_match] EXIT: connection=0x7f13a4000b70 result=true args=key\n[check_argument_match] ENTER: connection=0x7f1b80000b70 args=key=value\n[check_argument_match] parse_result: connection=0x7f1b80000b70 ret=1 num_headers=1 args=key\n[check_argument_match] loop: pos=0x7f1b80008db0 kind=8 next=0x7f1b80008d70 num_headers_before=1\n[check_argument_match] loop: pos=0x7f1b80008db0 kind=8 next=0x7f1b80008d70 num_headers_before=0\n[check_argument_match] loop: pos=0x7f1b80008d70 kind=1 next=0x7f1b80008d30 num_headers_before=0\n[check_argument_match] loop: pos=0x7f1b80008d30 kind=1 next=0x7f1b80008cf0 num_headers_before=0\n[check_argument_match] loop: pos=0x7f1b80008cf0 kind=1 next=(nil) num_headers_before=0\n[check_argument_match] EXIT: connection=0x7f1b80000b70 result=true args=key\n\n</execution_log>\n\n<instruction>\nJudge whether the report is correct or not.\n</instruction>\n",
  "is_report_correct": true,
  "explanation": "The report is correct. In the loop pos is only used to read fields (pos->kind, pos->next) and the code never modifies the pointee object via pos. Per MISRA C:2023 Rule 8.13, the pointer should point to a const-qualified type whenever possible, so the local variable should be declared as\n\n    const struct MHD_HTTP_Req_Header *pos;\n\nAssigning connection->rq.headers_received (a non-const pointer) to a pointer-to-const is allowed, and pos = pos->next is also compatible. There is no shown use that would require a pointer-to-mutable pointee, so the current declaration violates Rule 8.13 and should be changed as above (or an appropriate justification/suppression provided)."
}