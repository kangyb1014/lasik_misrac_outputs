{
  "user_message": "<misra_rule>\nMISRA C 2023 Rule 8.13 is: A pointer should point to a const-qualified type whenever possible.\n\n</misra_rule>\n\nAnother agent reported that the target code violated the Rule 8.13.\nHere is the comment from the agent.\n<violation scenario>\nThe local pointer pNow is declared as 'struct tm *pNow' but is only used to read the data returned by gmtime() (checked for NULL and copied into 'now' with 'now = *pNow'). It is not used to modify the pointed-to object, so it should be declared 'const struct tm *pNow' to satisfy MISRA C 2023 Rule 8.13.\n</violation scenario>\n\nYour job is to insert logging code to capture the control flow and state information of the program.\nInsert logging code so that other agents can reproduce and get evidence for the violation scenario.\n<response format>\n- test_code: a modified get_date_str code that contains useful probe functions that print useful logs to a file \"/tmp/logs/373.txt\". The logs should contain the control path and state information of the violation scenario. If test code is not required to validate the scenario, you can leave this blank.\nHere are the constraints for the test code:\n- The test code MUST preserve the original logic of get_date_str as much as possible.\nYou CAN just insert probe functions to the original code.\n- DO NOT introduce new violations to demonstrate your scenario.\n- The test code MUST be compilable and executable.\n- The test code MUST include line breaks.\n- You MUST NOT define the main function.\n- You MUST NOT define macros.\n</response format>\n<target_code>\nHere is the code of get_date_str:\n```c\nstatic bool\nget_date_str (char *date)\n{\n  static const char *const days[] = {\n    \"Sun\", \"Mon\", \"Tue\", \"Wed\", \"Thu\", \"Fri\", \"Sat\"\n  };\n  static const char *const mons[] = {\n    \"Jan\", \"Feb\", \"Mar\", \"Apr\", \"May\", \"Jun\",\n    \"Jul\", \"Aug\", \"Sep\", \"Oct\", \"Nov\", \"Dec\"\n  };\n  static const size_t buf_len = 29;\n  struct tm now;\n  time_t t;\n  const char *src;\n#if ! defined(HAVE_C11_GMTIME_S) && ! defined(HAVE_W32_GMTIME_S) && \\\n  ! defined(HAVE_GMTIME_R)\n  struct tm *pNow;\n#endif\n\n  if ((time_t) -1 == time (&t))\n    return false;\n#if defined(HAVE_C11_GMTIME_S)\n  if (NULL == gmtime_s (&t,\n                        &now))\n    return false;\n#elif defined(HAVE_W32_GMTIME_S)\n  if (0 != gmtime_s (&now,\n                     &t))\n    return false;\n#elif defined(HAVE_GMTIME_R)\n  if (NULL == gmtime_r (&t,\n                        &now))\n    return false;\n#else\n  pNow = gmtime (&t);\n  if (NULL == pNow)\n    return false;\n  now = *pNow;\n#endif\n\n  /* Day of the week */\n  src = days[now.tm_wday % 7];\n  date[0] = src[0];\n  date[1] = src[1];\n  date[2] = src[2];\n  date[3] = ',';\n  date[4] = ' ';\n  /* Day of the month */\n  if (2 != MHD_uint8_to_str_pad ((uint8_t) now.tm_mday, 2,\n                                 date + 5, buf_len - 5))\n    return false;\n  date[7] = ' ';\n  /* Month */\n  src = mons[now.tm_mon % 12];\n  date[8] = src[0];\n  date[9] = src[1];\n  date[10] = src[2];\n  date[11] = ' ';\n  /* Year */\n  if (4 != MHD_uint16_to_str ((uint16_t) (1900 + now.tm_year), date + 12,\n                              buf_len - 12))\n    return false;\n  date[16] = ' ';\n  /* Time */\n  MHD_uint8_to_str_pad ((uint8_t) now.tm_hour, 2, date + 17, buf_len - 17);\n  date[19] = ':';\n  MHD_uint8_to_str_pad ((uint8_t) now.tm_min, 2, date + 20, buf_len - 20);\n  date[22] = ':';\n  MHD_uint8_to_str_pad ((uint8_t) now.tm_sec, 2, date + 23, buf_len - 23);\n  date[25] = ' ';\n  date[26] = 'G';\n  date[27] = 'M';\n  date[28] = 'T';\n\n  return true;\n}\n```\n</target_code>\nPlease provide the modified get_date_str code.\n",
  "test_code": "#include <stdio.h>\n#include <stdarg.h>\n#include <time.h>\n#include <stdint.h>\n#include <stdbool.h>\n#include <string.h>\n#include <sys/stat.h>\n#include <errno.h>\n\n/* Helper: append a formatted message to the probe log. */\nstatic void\nlog_msg (const char *fmt, ...)\n{\n  FILE *f;\n  va_list ap;\n\n  /* Attempt to create the logs directory; ignore errors. */\n  (void) mkdir(\"/tmp/logs\", 0777);\n\n  f = fopen (\"/tmp/logs/373.txt\", \"a\");\n  if (NULL == f)\n    return;\n\n  va_start (ap, fmt);\n  (void) vfprintf (f, fmt, ap);\n  va_end (ap);\n  (void) fputc ('\\n', f);\n  (void) fclose (f);\n}\n\n/* Helper: log selected fields from a struct tm. */\nstatic void\nlog_tm (const char *label, const struct tm *tp)\n{\n  if (tp == NULL)\n    {\n      log_msg (\"%s: <NULL>\", label);\n      return;\n    }\n  log_msg (\"%s: tm_year=%d tm_mon=%d tm_mday=%d tm_hour=%d tm_min=%d tm_sec=%d tm_wday=%d\",\n           label,\n           (int) tp->tm_year,\n           (int) tp->tm_mon,\n           (int) tp->tm_mday,\n           (int) tp->tm_hour,\n           (int) tp->tm_min,\n           (int) tp->tm_sec,\n           (int) tp->tm_wday);\n}\n\nstatic bool\nget_date_str (char *date)\n{\n  static const char *const days[] = {\n    \"Sun\", \"Mon\", \"Tue\", \"Wed\", \"Thu\", \"Fri\", \"Sat\"\n  };\n  static const char *const mons[] = {\n    \"Jan\", \"Feb\", \"Mar\", \"Apr\", \"May\", \"Jun\",\n    \"Jul\", \"Aug\", \"Sep\", \"Oct\", \"Nov\", \"Dec\"\n  };\n  static const size_t buf_len = 29;\n  struct tm now;\n  time_t t;\n  const char *src;\n#if ! defined(HAVE_C11_GMTIME_S) && ! defined(HAVE_W32_GMTIME_S) && \\\n  ! defined(HAVE_GMTIME_R)\n  struct tm *pNow;\n#endif\n\n  log_msg (\"get_date_str: entry\");\n\n  if ((time_t) -1 == time (&t))\n    {\n      log_msg (\"get_date_str: time() returned -1 -> fail\");\n      return false;\n    }\n\n  log_msg (\"get_date_str: time() succeeded, t=%lld\", (long long) t);\n\n#if defined(HAVE_C11_GMTIME_S)\n  if (NULL == gmtime_s (&t,\n                        &now))\n    return false;\n  /* Log the obtained broken-down time */\n  log_tm (\"get_date_str: gmtime_s -> now\", &now);\n#elif defined(HAVE_W32_GMTIME_S)\n  if (0 != gmtime_s (&now,\n                     &t))\n    return false;\n  /* Log the obtained broken-down time */\n  log_tm (\"get_date_str: w32 gmtime_s -> now\", &now);\n#elif defined(HAVE_GMTIME_R)\n  if (NULL == gmtime_r (&t,\n                        &now))\n    return false;\n  /* Log the obtained broken-down time */\n  log_tm (\"get_date_str: gmtime_r -> now\", &now);\n#else\n  pNow = gmtime (&t);\n  log_msg (\"get_date_str: gmtime(&t) returned pointer %p\", (void *) pNow);\n  if (NULL == pNow)\n    {\n      log_msg (\"get_date_str: gmtime returned NULL -> fail\");\n      return false;\n    }\n  /* Log the fields read from the non-const pointer before copying */\n  log_tm (\"get_date_str: fields pointed-to by pNow (before copy)\", pNow);\n  now = *pNow;\n  /* Log the fields after copying into 'now' */\n  log_tm (\"get_date_str: now (after copy)\", &now);\n#endif\n\n  /* Day of the week */\n  src = days[now.tm_wday % 7];\n  date[0] = src[0];\n  date[1] = src[1];\n  date[2] = src[2];\n  date[3] = ',';\n  date[4] = ' ';\n  /* Day of the month */\n  if (2 != MHD_uint8_to_str_pad ((uint8_t) now.tm_mday, 2,\n                                 date + 5, buf_len - 5))\n    return false;\n  date[7] = ' ';\n  /* Month */\n  src = mons[now.tm_mon % 12];\n  date[8] = src[0];\n  date[9] = src[1];\n  date[10] = src[2];\n  date[11] = ' ';\n  /* Year */\n  if (4 != MHD_uint16_to_str ((uint16_t) (1900 + now.tm_year), date + 12,\n                              buf_len - 12))\n    return false;\n  date[16] = ' ';\n  /* Time */\n  MHD_uint8_to_str_pad ((uint8_t) now.tm_hour, 2, date + 17, buf_len - 17);\n  date[19] = ':';\n  MHD_uint8_to_str_pad ((uint8_t) now.tm_min, 2, date + 20, buf_len - 20);\n  date[22] = ':';\n  MHD_uint8_to_str_pad ((uint8_t) now.tm_sec, 2, date + 23, buf_len - 23);\n  date[25] = ' ';\n  date[26] = 'G';\n  date[27] = 'M';\n  date[28] = 'T';\n\n  log_msg (\"get_date_str: success, date string constructed: %.29s\", date);\n\n  return true;\n}\n"
}