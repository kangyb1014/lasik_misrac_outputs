{
  "user_message": "An agent A claimed that the following lfs_fs_stat_ code violates the MISRA C 2023 rule 8.13.\n<misra_rule>\nMISRA C 2023 Rule 8.13 is A pointer should point to a const-qualified type whenever possible.\n\n</misra_rule>\n<target_code>\nHere is the original code of lfs_fs_stat_.\n```c\nstatic int lfs_fs_stat_(lfs_t *lfs, struct lfs_fsinfo *fsinfo) {\n    // if the superblock is up-to-date, we must be on the most recent\n    // minor version of littlefs\n    if (!lfs_gstate_needssuperblock(&lfs->gstate)) {\n        fsinfo->disk_version = lfs_fs_disk_version(lfs);\n\n    // otherwise we need to read the minor version on disk\n    } else {\n        // fetch the superblock\n        lfs_mdir_t dir;\n        int err = lfs_dir_fetch(lfs, &dir, lfs->root);\n        if (err) {\n            return err;\n        }\n\n        lfs_superblock_t superblock;\n        lfs_stag_t tag = lfs_dir_get(lfs, &dir, LFS_MKTAG(0x7ff, 0x3ff, 0),\n                LFS_MKTAG(LFS_TYPE_INLINESTRUCT, 0, sizeof(superblock)),\n                &superblock);\n        if (tag < 0) {\n            return tag;\n        }\n        lfs_superblock_fromle32(&superblock);\n\n        // read the on-disk version\n        fsinfo->disk_version = superblock.version;\n    }\n\n    // filesystem geometry\n    fsinfo->block_size = lfs->cfg->block_size;\n    fsinfo->block_count = lfs->block_count;\n\n    // other on-disk configuration, we cache all of these for internal use\n    fsinfo->name_max = lfs->name_max;\n    fsinfo->file_max = lfs->file_max;\n    fsinfo->attr_max = lfs->attr_max;\n\n    return 0;\n}\n```\n</target_code>\n<response format>\nProvide your answer with these fields.\n- explanation: your evaluation of the scenario provided by the agent A.\n- is_report_correct: whether the report is correct or not (true/false). True means there is a violation.\n</response format>\n<scenario>\nThe agent A provided the following violation scenario:\nThe call passes &dir (type lfs_mdir_t *) to lfs_dir_get. If lfs_dir_get only reads the directory (does not modify it), the pointer should be to a const-qualified type (const lfs_mdir_t *). In that case the non-const pointer argument violates MISRA C 2023 Rule 8.13. (The &superblock argument is an output buffer and correctly remains non-const.)\n</scenario>\n<additional code>Here are the definitions of symbols that are close to the target function lfs_fs_stat_:\nstruct lfs_fsinfo {\n    // On-disk version.\n    uint32_t disk_version;\n\n    // Size of a logical block in bytes.\n    lfs_size_t block_size;\n\n    // Number of logical blocks in filesystem.\n    lfs_size_t block_count;\n\n    // Upper limit on the length of file names in bytes.\n    lfs_size_t name_max;\n\n    // Upper limit on the size of files in bytes.\n    lfs_size_t file_max;\n\n    // Upper limit on the size of custom attributes in bytes.\n    lfs_size_t attr_max;\n}\n...\ntypedef struct lfs_mdir {\n    lfs_block_t pair[2];\n    uint32_t rev;\n    lfs_off_t off;\n    uint32_t etag;\n    uint16_t count;\n    bool erased;\n    bool split;\n    lfs_block_t tail[2];\n} lfs_mdir_t\n...\ntypedef int32_t lfs_stag_t\n...\ntypedef struct lfs_superblock {\n    uint32_t version;\n    lfs_size_t block_size;\n    lfs_size_t block_count;\n    lfs_size_t name_max;\n    lfs_size_t file_max;\n    lfs_size_t attr_max;\n} lfs_superblock_t\n</additional code>\n\n<instruction>\nJudge whether the report is correct or not.\n</instruction>\n",
  "is_report_correct": false,
  "explanation": "MISRA C:2023 Rule 8.13 requires pointers to be const-qualified where possible. That obligation is about the declaration of pointer types (e.g. function parameters) not about a single call site. The claim that this call violates Rule 8.13 therefore depends on the declaration/implementation of lfs_dir_get: if lfs_dir_get does not modify the lfs_mdir_t argument, then its prototype should use const lfs_mdir_t * and that prototype would be the place to fix the rule. From the code shown you only have the call site; you do not have lfs_dir_get\u2019s prototype or body. Moreover, it is plausible that lfs_dir_get may modify the dir (update offsets, revs, cached fields, etc.), in which case a non-const pointer is required and there is no violation. Consequently the report is not substantiated by the evidence provided \u2014 you cannot determine a Rule 8.13 violation from this call alone. To decide definitively, inspect the declaration/implementation of lfs_dir_get to see whether it modifies the lfs_mdir_t object; if it does not, change its parameter to const lfs_mdir_t * (and then all call sites would use a const-qualified pointer)."
}