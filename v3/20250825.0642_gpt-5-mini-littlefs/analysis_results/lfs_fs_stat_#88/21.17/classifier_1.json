{
  "user_message": "<misra_rule>\nMISRA C 2023 Rule 21.17 is: Use of the string handling functions from <string.h> shall not result in accesses beyond the bounds of the objects referenced by their pointer parameters.\nThis rule strictly applies to the Standard Library functions in <string.h> such as memcpy, memmove, memset, memcmp, strcpy, strncpy, strcat, strncat, strlen, and strspn.\n</misra_rule>\n<response format>\nProvide your answer with these fields.\n- is_rule_violated: whether the rule is violated or not (true/false),\n- scenario: a specific violation scenario.\n</response format>\n<target_code>\nHere is the code of lfs_fs_stat_:\n```c\nstatic int lfs_fs_stat_(lfs_t *lfs, struct lfs_fsinfo *fsinfo) {\n    // if the superblock is up-to-date, we must be on the most recent\n    // minor version of littlefs\n    if (!lfs_gstate_needssuperblock(&lfs->gstate)) {\n        fsinfo->disk_version = lfs_fs_disk_version(lfs);\n\n    // otherwise we need to read the minor version on disk\n    } else {\n        // fetch the superblock\n        lfs_mdir_t dir;\n        int err = lfs_dir_fetch(lfs, &dir, lfs->root);\n        if (err) {\n            return err;\n        }\n\n        lfs_superblock_t superblock;\n        lfs_stag_t tag = lfs_dir_get(lfs, &dir, LFS_MKTAG(0x7ff, 0x3ff, 0),\n                LFS_MKTAG(LFS_TYPE_INLINESTRUCT, 0, sizeof(superblock)),\n                &superblock);\n        if (tag < 0) {\n            return tag;\n        }\n        lfs_superblock_fromle32(&superblock);\n\n        // read the on-disk version\n        fsinfo->disk_version = superblock.version;\n    }\n\n    // filesystem geometry\n    fsinfo->block_size = lfs->cfg->block_size;\n    fsinfo->block_count = lfs->block_count;\n\n    // other on-disk configuration, we cache all of these for internal use\n    fsinfo->name_max = lfs->name_max;\n    fsinfo->file_max = lfs->file_max;\n    fsinfo->attr_max = lfs->attr_max;\n\n    return 0;\n}\n```\n</target_code>\n<additional code>Here are the definitions of symbols that are close to the target function lfs_fs_stat_:\nstatic inline bool lfs_gstate_needssuperblock(const lfs_gstate_t *a) {\n    return lfs_tag_size(a->tag) >> 9;\n}\n...\nstatic inline lfs_size_t lfs_tag_size(lfs_tag_t tag) {\n    return tag & 0x000003ff;\n}\n...\nstatic uint32_t lfs_fs_disk_version(lfs_t *lfs) {\n    (void)lfs;\n#ifdef LFS_MULTIVERSION\n    if (lfs->cfg->disk_version) {\n        return lfs->cfg->disk_version;\n    } else\n#endif\n    {\n        return LFS_DISK_VERSION;\n    }\n}\n...\nstatic int lfs_dir_fetch(lfs_t *lfs,\n        lfs_mdir_t *dir, const lfs_block_t pair[2]) {\n    // note, mask=-1, tag=-1 can never match a tag since this\n    // pattern has the invalid bit set\n    return (int)lfs_dir_fetchmatch(lfs, dir, pair,\n            (lfs_tag_t)-1, (lfs_tag_t)-1, NULL, NULL, NULL);\n}\n...\nstatic lfs_stag_t lfs_dir_fetchmatch(lfs_t *lfs,\n        lfs_mdir_t *dir, const lfs_block_t pair[2],\n        lfs_tag_t fmask, lfs_tag_t ftag, uint16_t *id,\n        int (*cb)(void *data, lfs_tag_t tag, const void *buffer), void *data) {\n    // we can find tag very efficiently during a fetch, since we're already\n    // scanning the entire directory\n    lfs_stag_t besttag = -1;\n\n    // if either block address is invalid we return LFS_ERR_CORRUPT here,\n    // otherwise later writes to the pair could fail\n    if (lfs->block_count \n            && (pair[0] >= lfs->block_count || pair[1] >= lfs->block_count)) {\n        return LFS_ERR_CORRUPT;\n    }\n\n    // find the block with the most recent revision\n    uint32_t revs[2] = {0, 0};\n    int r = 0;\n    for (int i = 0; i < 2; i++) {\n        int err = lfs_bd_read(lfs,\n                NULL, &lfs->rcache, sizeof(revs[i]),\n                pair[i], 0, &revs[i], sizeof(revs[i]));\n        revs[i] = lfs_fromle32(revs[i]);\n        if (err && err != LFS_ERR_CORRUPT) {\n            return err;\n        }\n\n        if (err != LFS_ERR_CORRUPT &&\n                lfs_scmp(revs[i], revs[(i+1)%2]) > 0) {\n            r = i;\n        }\n    }\n\n    dir->pair[0] = pair[(r+0)%2];\n    dir->pair[1] = pair[(r+1)%2];\n    dir->rev = revs[(r+0)%2];\n    dir->off = 0; // nonzero = found some commits\n\n    // now scan tags to fetch the actual dir and find possible match\n    for (int i = 0; i < 2; i++) {\n        lfs_off_t off = 0;\n        lfs_tag_t ptag = 0xffffffff;\n\n        uint16_t tempcount = 0;\n        lfs_block_t temptail[2] = {LFS_BLOCK_NULL, LFS_BLOCK_NULL};\n        bool tempsplit = false;\n        lfs_stag_t tempbesttag = besttag;\n\n        // assume not erased until proven otherwise\n        bool maybeerased = false;\n        bool hasfcrc = false;\n        struct lfs_fcrc fcrc;\n\n        dir->rev = lfs_tole32(dir->rev);\n        uint32_t crc = lfs_crc(0xffffffff, &dir->rev, sizeof(dir->rev));\n        dir->rev = lfs_fromle32(dir->rev);\n\n        while (true) {\n            // extract next tag\n            lfs_tag_t tag;\n            off += lfs_tag_dsize(ptag);\n            int err = lfs_bd_read(lfs,\n                    NULL, &lfs->rcache, lfs->cfg->block_size,\n                    dir->pair[0], off, &tag, sizeof(tag));\n            if (err) {\n                if (err == LFS_ERR_CORRUPT) {\n                    // can't continue?\n                    break;\n                }\n                return err;\n            }\n\n            crc = lfs_crc(crc, &tag, sizeof(tag));\n            tag = lfs_frombe32(tag) ^ ptag;\n\n            // next commit not yet programmed?\n            if (!lfs_tag_isvalid(tag)) {\n                // we only might be erased if the last tag was a crc\n                maybeerased = (lfs_tag_type2(ptag) == LFS_TYPE_CCRC);\n                break;\n            // out of range?\n            } else if (off + lfs_tag_dsize(tag) > lfs->cfg->block_size) {\n                break;\n            }\n\n            ptag = tag;\n\n            if (lfs_tag_type2(tag) == LFS_TYPE_CCRC) {\n                // check the crc attr\n                uint32_t dcrc;\n                err = lfs_bd_read(lfs,\n                        NULL, &lfs->rcache, lfs->cfg->block_size,\n                        dir->pair[0], off+sizeof(tag), &dcrc, sizeof(dcrc));\n                if (err) {\n                    if (err == LFS_ERR_CORRUPT) {\n                        break;\n                    }\n                    return err;\n                }\n                dcrc = lfs_fromle32(dcrc);\n\n                if (crc != dcrc) {\n                    break;\n                }\n\n                // reset the next bit if we need to\n                ptag ^= (lfs_tag_t)(lfs_tag_chunk(tag) & 1U) << 31;\n\n                // toss our crc into the filesystem seed for\n                // pseudorandom numbers, note we use another crc here\n                // as a collection function because it is sufficiently\n                // random and convenient\n                lfs->seed = lfs_crc(lfs->seed, &crc, sizeof(crc));\n\n                // update with what's found so far\n                besttag = tempbesttag;\n                dir->off = off + lfs_tag_dsize(tag);\n                dir->etag = ptag;\n                dir->count = tempcount;\n                dir->tail[0] = temptail[0];\n                dir->tail[1] = temptail[1];\n                dir->split = tempsplit;\n\n                // reset crc, hasfcrc\n                crc = 0xffffffff;\n                continue;\n            }\n\n            // crc the entry first, hopefully leaving it in the cache\n            err = lfs_bd_crc(lfs,\n                    NULL, &lfs->rcache, lfs->cfg->block_size,\n                    dir->pair[0], off+sizeof(tag),\n                    lfs_tag_dsize(tag)-sizeof(tag), &crc);\n            if (err) {\n                if (err == LFS_ERR_CORRUPT) {\n                    break;\n                }\n                return err;\n            }\n\n            // directory modification tags?\n            if (lfs_tag_type1(tag) == LFS_TYPE_NAME) {\n                // increase count of files if necessary\n                if (lfs_tag_id(tag) >= tempcount) {\n                    tempcount = lfs_tag_id(tag) + 1;\n                }\n            } else if (lfs_tag_type1(tag) == LFS_TYPE_SPLICE) {\n                tempcount += lfs_tag_splice(tag);\n\n                if (tag == (LFS_MKTAG(LFS_TYPE_DELETE, 0, 0) |\n                        (LFS_MKTAG(0, 0x3ff, 0) & tempbesttag))) {\n                    tempbesttag |= 0x80000000;\n                } else if (tempbesttag != -1 &&\n                        lfs_tag_id(tag) <= lfs_tag_id(tempbesttag)) {\n                    tempbesttag += LFS_MKTAG(0, lfs_tag_splice(tag), 0);\n                }\n            } else if (lfs_tag_type1(tag) == LFS_TYPE_TAIL) {\n                tempsplit = (lfs_tag_chunk(tag) & 1);\n\n                err = lfs_bd_read(lfs,\n                        NULL, &lfs->rcache, lfs->cfg->block_size,\n                        dir->pair[0], off+sizeof(tag), &temptail, 8);\n                if (err) {\n                    if (err == LFS_ERR_CORRUPT) {\n                        break;\n                    }\n                    return err;\n                }\n                lfs_pair_fromle32(temptail);\n            } else if (lfs_tag_type3(tag) == LFS_TYPE_FCRC) {\n                err = lfs_bd_read(lfs,\n                        NULL, &lfs->rcache, lfs->cfg->block_size,\n                        dir->pair[0], off+sizeof(tag),\n                        &fcrc, sizeof(fcrc));\n                if (err) {\n                    if (err == LFS_ERR_CORRUPT) {\n                        break;\n                    }\n                }\n\n                lfs_fcrc_fromle32(&fcrc);\n                hasfcrc = true;\n            }\n\n            // found a match for our fetcher?\n            if ((fmask & tag) == (fmask & ftag)) {\n                int res = cb(data, tag, &(struct lfs_diskoff){\n                        dir->pair[0], off+sizeof(tag)});\n                if (res < 0) {\n                    if (res == LFS_ERR_CORRUPT) {\n                        break;\n                    }\n                    return res;\n                }\n\n                if (res == LFS_CMP_EQ) {\n                    // found a match\n                    tempbesttag = tag;\n                } else if ((LFS_MKTAG(0x7ff, 0x3ff, 0) & tag) ==\n                        (LFS_MKTAG(0x7ff, 0x3ff, 0) & tempbesttag)) {\n                    // found an identical tag, but contents didn't match\n                    // this must mean that our besttag has been overwritten\n                    tempbesttag = -1;\n                } else if (res == LFS_CMP_GT &&\n                        lfs_tag_id(tag) <= lfs_tag_id(tempbesttag)) {\n                    // found a greater match, keep track to keep things sorted\n                    tempbesttag = tag | 0x80000000;\n                }\n            }\n        }\n\n        // found no valid commits?\n        if (dir->off == 0) {\n            // try the other block?\n            lfs_pair_swap(dir->pair);\n            dir->rev = revs[(r+1)%2];\n            continue;\n        }\n\n        // did we end on a valid commit? we may have an erased block\n        dir->erased = false;\n        if (maybeerased && dir->off % lfs->cfg->prog_size == 0) {\n        #ifdef LFS_MULTIVERSION\n            // note versions < lfs2.1 did not have fcrc tags, if\n            // we're < lfs2.1 treat missing fcrc as erased data\n            //\n            // we don't strictly need to do this, but otherwise writing\n            // to lfs2.0 disks becomes very inefficient\n            if (lfs_fs_disk_version(lfs) < 0x00020001) {\n                dir->erased = true;\n\n            } else\n        #endif\n            if (hasfcrc) {\n                // check for an fcrc matching the next prog's erased state, if\n                // this failed most likely a previous prog was interrupted, we\n                // need a new erase\n                uint32_t fcrc_ = 0xffffffff;\n                int err = lfs_bd_crc(lfs,\n                        NULL, &lfs->rcache, lfs->cfg->block_size,\n                        dir->pair[0], dir->off, fcrc.size, &fcrc_);\n                if (err && err != LFS_ERR_CORRUPT) {\n                    return err;\n                }\n\n                // found beginning of erased part?\n                dir->erased = (fcrc_ == fcrc.crc);\n            }\n        }\n\n        // synthetic move\n        if (lfs_gstate_hasmovehere(&lfs->gdisk, dir->pair)) {\n            if (lfs_tag_id(lfs->gdisk.tag) == lfs_tag_id(besttag)) {\n                besttag |= 0x80000000;\n            } else if (besttag != -1 &&\n                    lfs_tag_id(lfs->gdisk.tag) < lfs_tag_id(besttag)) {\n                besttag -= LFS_MKTAG(0, 1, 0);\n            }\n        }\n\n        // found tag? or found best id?\n        if (id) {\n            *id = lfs_min(lfs_tag_id(besttag), dir->count);\n        }\n\n        if (lfs_tag_isvalid(besttag)) {\n            return besttag;\n        } else if (lfs_tag_id(besttag) < dir->count) {\n            return LFS_ERR_NOENT;\n        } else {\n            return 0;\n        }\n    }\n\n    LFS_ERROR(\"Corrupted dir pair at {0x%\"PRIx32\", 0x%\"PRIx32\"}\",\n            dir->pair[0], dir->pair[1]);\n    return LFS_ERR_CORRUPT;\n}\n...\nstatic lfs_stag_t lfs_dir_get(lfs_t *lfs, const lfs_mdir_t *dir,\n        lfs_tag_t gmask, lfs_tag_t gtag, void *buffer) {\n    return lfs_dir_getslice(lfs, dir,\n            gmask, gtag,\n            0, buffer, lfs_tag_size(gtag));\n}\n...\nstatic lfs_stag_t lfs_dir_getslice(lfs_t *lfs, const lfs_mdir_t *dir,\n        lfs_tag_t gmask, lfs_tag_t gtag,\n        lfs_off_t goff, void *gbuffer, lfs_size_t gsize) {\n    lfs_off_t off = dir->off;\n    lfs_tag_t ntag = dir->etag;\n    lfs_stag_t gdiff = 0;\n\n    // synthetic moves\n    if (lfs_gstate_hasmovehere(&lfs->gdisk, dir->pair) &&\n            lfs_tag_id(gmask) != 0) {\n        if (lfs_tag_id(lfs->gdisk.tag) == lfs_tag_id(gtag)) {\n            return LFS_ERR_NOENT;\n        } else if (lfs_tag_id(lfs->gdisk.tag) < lfs_tag_id(gtag)) {\n            gdiff -= LFS_MKTAG(0, 1, 0);\n        }\n    }\n\n    // iterate over dir block backwards (for faster lookups)\n    while (off >= sizeof(lfs_tag_t) + lfs_tag_dsize(ntag)) {\n        off -= lfs_tag_dsize(ntag);\n        lfs_tag_t tag = ntag;\n        int err = lfs_bd_read(lfs,\n                NULL, &lfs->rcache, sizeof(ntag),\n                dir->pair[0], off, &ntag, sizeof(ntag));\n        if (err) {\n            return err;\n        }\n\n        ntag = (lfs_frombe32(ntag) ^ tag) & 0x7fffffff;\n\n        if (lfs_tag_id(gmask) != 0 &&\n                lfs_tag_type1(tag) == LFS_TYPE_SPLICE &&\n                lfs_tag_id(tag) <= lfs_tag_id(gtag - gdiff)) {\n            if (tag == (LFS_MKTAG(LFS_TYPE_CREATE, 0, 0) |\n                    (LFS_MKTAG(0, 0x3ff, 0) & (gtag - gdiff)))) {\n                // found where we were created\n                return LFS_ERR_NOENT;\n            }\n\n            // move around splices\n            gdiff += LFS_MKTAG(0, lfs_tag_splice(tag), 0);\n        }\n\n        if ((gmask & tag) == (gmask & (gtag - gdiff))) {\n            if (lfs_tag_isdelete(tag)) {\n                return LFS_ERR_NOENT;\n            }\n\n            lfs_size_t diff = lfs_min(lfs_tag_size(tag), gsize);\n            err = lfs_bd_read(lfs,\n                    NULL, &lfs->rcache, diff,\n                    dir->pair[0], off+sizeof(tag)+goff, gbuffer, diff);\n            if (err) {\n                return err;\n            }\n\n            memset((uint8_t*)gbuffer + diff, 0, gsize - diff);\n\n            return tag + gdiff;\n        }\n    }\n\n    return LFS_ERR_NOENT;\n}\n...\nstatic inline void lfs_superblock_fromle32(lfs_superblock_t *superblock) {\n    superblock->version     = lfs_fromle32(superblock->version);\n    superblock->block_size  = lfs_fromle32(superblock->block_size);\n    superblock->block_count = lfs_fromle32(superblock->block_count);\n    superblock->name_max    = lfs_fromle32(superblock->name_max);\n    superblock->file_max    = lfs_fromle32(superblock->file_max);\n    superblock->attr_max    = lfs_fromle32(superblock->attr_max);\n}\n...\n#define LFS_MKTAG(type, id, size) (((lfs_tag_t)(type)<<20)|((lfs_tag_t)(id)<<10)|(lfs_tag_t)(size))\n...\ntypedef struct lfs {\n    lfs_cache_t rcache;\n    lfs_cache_t pcache;\n\n    lfs_block_t root[2];\n    struct lfs_mlist {\n        struct lfs_mlist *next;\n        uint16_t id;\n        uint8_t type;\n        lfs_mdir_t m;\n    } *mlist;\n    uint32_t seed;\n\n    lfs_gstate_t gstate;\n    lfs_gstate_t gdisk;\n    lfs_gstate_t gdelta;\n\n    struct lfs_lookahead {\n        lfs_block_t start;\n        lfs_block_t size;\n        lfs_block_t next;\n        lfs_block_t ckpoint;\n        uint8_t *buffer;\n    } lookahead;\n\n    const struct lfs_config *cfg;\n    lfs_size_t block_count;\n    lfs_size_t name_max;\n    lfs_size_t file_max;\n    lfs_size_t attr_max;\n    lfs_size_t inline_max;\n\n#ifdef LFS_MIGRATE\n    struct lfs1 *lfs1;\n#endif\n} lfs_t\n...\nstruct lfs_fsinfo {\n    // On-disk version.\n    uint32_t disk_version;\n\n    // Size of a logical block in bytes.\n    lfs_size_t block_size;\n\n    // Number of logical blocks in filesystem.\n    lfs_size_t block_count;\n\n    // Upper limit on the length of file names in bytes.\n    lfs_size_t name_max;\n\n    // Upper limit on the size of files in bytes.\n    lfs_size_t file_max;\n\n    // Upper limit on the size of custom attributes in bytes.\n    lfs_size_t attr_max;\n}\n...\ntypedef struct lfs_mdir {\n    lfs_block_t pair[2];\n    uint32_t rev;\n    lfs_off_t off;\n    uint32_t etag;\n    uint16_t count;\n    bool erased;\n    bool split;\n    lfs_block_t tail[2];\n} lfs_mdir_t\n...\ntypedef struct lfs_superblock {\n    uint32_t version;\n    lfs_size_t block_size;\n    lfs_size_t block_count;\n    lfs_size_t name_max;\n    lfs_size_t file_max;\n    lfs_size_t attr_max;\n} lfs_superblock_t\n...\ntypedef int32_t lfs_stag_t\n...\nstruct lfs_config {\n    // Opaque user provided context that can be used to pass\n    // information to the block device operations\n    void *context;\n\n    // Read a region in a block. Negative error codes are propagated\n    // to the user.\n    int (*read)(const struct lfs_config *c, lfs_block_t block,\n            lfs_off_t off, void *buffer, lfs_size_t size);\n\n    // Program a region in a block. The block must have previously\n    // been erased. Negative error codes are propagated to the user.\n    // May return LFS_ERR_CORRUPT if the block should be considered bad.\n    int (*prog)(const struct lfs_config *c, lfs_block_t block,\n            lfs_off_t off, const void *buffer, lfs_size_t size);\n\n    // Erase a block. A block must be erased before being programmed.\n    // The state of an erased block is undefined. Negative error codes\n    // are propagated to the user.\n    // May return LFS_ERR_CORRUPT if the block should be considered bad.\n    int (*erase)(const struct lfs_config *c, lfs_block_t block);\n\n    // Sync the state of the underlying block device. Negative error codes\n    // are propagated to the user.\n    int (*sync)(const struct lfs_config *c);\n\n#ifdef LFS_THREADSAFE\n    // Lock the underlying block device. Negative error codes\n    // are propagated to the user.\n    int (*lock)(const struct lfs_config *c);\n\n    // Unlock the underlying block device. Negative error codes\n    // are propagated to the user.\n    int (*unlock)(const struct lfs_config *c);\n#endif\n\n    // Minimum size of a block read in bytes. All read operations will be a\n    // multiple of this value.\n    lfs_size_t read_size;\n\n    // Minimum size of a block program in bytes. All program operations will be\n    // a multiple of this value.\n    lfs_size_t prog_size;\n\n    // Size of an erasable block in bytes. This does not impact ram consumption\n    // and may be larger than the physical erase size. However, non-inlined\n    // files take up at minimum one block. Must be a multiple of the read and\n    // program sizes.\n    lfs_size_t block_size;\n\n    // Number of erasable blocks on the device. Defaults to block_count stored\n    // on disk when zero.\n    lfs_size_t block_count;\n\n    // Number of erase cycles before littlefs evicts metadata logs and moves\n    // the metadata to another block. Suggested values are in the\n    // range 100-1000, with large values having better performance at the cost\n    // of less consistent wear distribution.\n    //\n    // Set to -1 to disable block-level wear-leveling.\n    int32_t block_cycles;\n\n    // Size of block caches in bytes. Each cache buffers a portion of a block in\n    // RAM. The littlefs needs a read cache, a program cache, and one additional\n    // cache per file. Larger caches can improve performance by storing more\n    // data and reducing the number of disk accesses. Must be a multiple of the\n    // read and program sizes, and a factor of the block size.\n    lfs_size_t cache_size;\n\n    // Size of the lookahead buffer in bytes. A larger lookahead buffer\n    // increases the number of blocks found during an allocation pass. The\n    // lookahead buffer is stored as a compact bitmap, so each byte of RAM\n    // can track 8 blocks.\n    lfs_size_t lookahead_size;\n\n    // Threshold for metadata compaction during lfs_fs_gc in bytes. Metadata\n    // pairs that exceed this threshold will be compacted during lfs_fs_gc.\n    // Defaults to ~88% block_size when zero, though the default may change\n    // in the future.\n    //\n    // Note this only affects lfs_fs_gc. Normal compactions still only occur\n    // when full.\n    //\n    // Set to -1 to disable metadata compaction during lfs_fs_gc.\n    lfs_size_t compact_thresh;\n\n    // Optional statically allocated read buffer. Must be cache_size.\n    // By default lfs_malloc is used to allocate this buffer.\n    void *read_buffer;\n\n    // Optional statically allocated program buffer. Must be cache_size.\n    // By default lfs_malloc is used to allocate this buffer.\n    void *prog_buffer;\n\n    // Optional statically allocated lookahead buffer. Must be lookahead_size.\n    // By default lfs_malloc is used to allocate this buffer.\n    void *lookahead_buffer;\n\n    // Optional upper limit on length of file names in bytes. No downside for\n    // larger names except the size of the info struct which is controlled by\n    // the LFS_NAME_MAX define. Defaults to LFS_NAME_MAX or name_max stored on\n    // disk when zero.\n    lfs_size_t name_max;\n\n    // Optional upper limit on files in bytes. No downside for larger files\n    // but must be <= LFS_FILE_MAX. Defaults to LFS_FILE_MAX or file_max stored\n    // on disk when zero.\n    lfs_size_t file_max;\n\n    // Optional upper limit on custom attributes in bytes. No downside for\n    // larger attributes size but must be <= LFS_ATTR_MAX. Defaults to\n    // LFS_ATTR_MAX or attr_max stored on disk when zero.\n    lfs_size_t attr_max;\n\n    // Optional upper limit on total space given to metadata pairs in bytes. On\n    // devices with large blocks (e.g. 128kB) setting this to a low size (2-8kB)\n    // can help bound the metadata compaction time. Must be <= block_size.\n    // Defaults to block_size when zero.\n    lfs_size_t metadata_max;\n\n    // Optional upper limit on inlined files in bytes. Inlined files live in\n    // metadata and decrease storage requirements, but may be limited to\n    // improve metadata-related performance. Must be <= cache_size, <=\n    // attr_max, and <= block_size/8. Defaults to the largest possible\n    // inline_max when zero.\n    //\n    // Set to -1 to disable inlined files.\n    lfs_size_t inline_max;\n\n#ifdef LFS_MULTIVERSION\n    // On-disk version to use when writing in the form of 16-bit major version\n    // + 16-bit minor version. This limiting metadata to what is supported by\n    // older minor versions. Note that some features will be lost. Defaults to \n    // to the most recent minor version when zero.\n    uint32_t disk_version;\n#endif\n}\n</additional code>\n<target_code>\nHere is the code fragment that you need to analyze:\n```c\nlfs_stag_t tag = lfs_dir_get(lfs, &dir, LFS_MKTAG(0x7ff, 0x3ff, 0),\n                LFS_MKTAG(LFS_TYPE_INLINESTRUCT, 0, sizeof(superblock)),\n                &superblock);\n```\nFocus on the above code fragment and judge whether it violates the rule 21.17 or not.\n</target_code>\n",
  "is_rule_violated": false,
  "scenario": "No violation in this fragment. lfs_dir_getslice() uses gsize = lfs_tag_size(gtag) (the size encoded in the LFS_MKTAG passed here) and only reads/writes up to gsize bytes into the supplied buffer. In the call shown the buffer is &superblock and the encoded size is sizeof(superblock), so the subsequent lfs_bd_read and memset operations cannot write beyond the bounds of superblock. (A potential violation WOULD occur if the encoded tag size did not match the actual buffer capacity \u2014 e.g. if a smaller buffer were passed while gtag encoded a larger size \u2014 because the function uses memset((uint8_t*)gbuffer + diff, 0, gsize - diff) which would then overflow.)"
}