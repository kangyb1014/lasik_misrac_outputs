{
  "user_message": "An agent A claimed that the following lfs_dir_commitcrc code violates the MISRA C 2023 rule 8.13.\n<misra_rule>\nMISRA C 2023 Rule 8.13 is A pointer should point to a const-qualified type whenever possible.\n\n</misra_rule>\n<target_code>\nHere is the original code of lfs_dir_commitcrc.\n```c\nstatic int lfs_dir_commitcrc(lfs_t *lfs, struct lfs_commit *commit) {\n    // align to program units\n    //\n    // this gets a bit complex as we have two types of crcs:\n    // - 5-word crc with fcrc to check following prog (middle of block)\n    // - 2-word crc with no following prog (end of block)\n    const lfs_off_t end = lfs_alignup(\n            lfs_min(commit->off + 5*sizeof(uint32_t), lfs->cfg->block_size),\n            lfs->cfg->prog_size);\n\n    lfs_off_t off1 = 0;\n    uint32_t crc1 = 0;\n\n    // create crc tags to fill up remainder of commit, note that\n    // padding is not crced, which lets fetches skip padding but\n    // makes committing a bit more complicated\n    while (commit->off < end) {\n        lfs_off_t noff = (\n                lfs_min(end - (commit->off+sizeof(lfs_tag_t)), 0x3fe)\n                + (commit->off+sizeof(lfs_tag_t)));\n        // too large for crc tag? need padding commits\n        if (noff < end) {\n            noff = lfs_min(noff, end - 5*sizeof(uint32_t));\n        }\n\n        // space for fcrc?\n        uint8_t eperturb = (uint8_t)-1;\n        if (noff >= end && noff <= lfs->cfg->block_size - lfs->cfg->prog_size) {\n            // first read the leading byte, this always contains a bit\n            // we can perturb to avoid writes that don't change the fcrc\n            int err = lfs_bd_read(lfs,\n                    NULL, &lfs->rcache, lfs->cfg->prog_size,\n                    commit->block, noff, &eperturb, 1);\n            if (err && err != LFS_ERR_CORRUPT) {\n                return err;\n            }\n\n        #ifdef LFS_MULTIVERSION\n            // unfortunately fcrcs break mdir fetching < lfs2.1, so only write\n            // these if we're a >= lfs2.1 filesystem\n            if (lfs_fs_disk_version(lfs) <= 0x00020000) {\n                // don't write fcrc\n            } else\n        #endif\n            {\n                // find the expected fcrc, don't bother avoiding a reread\n                // of the eperturb, it should still be in our cache\n                struct lfs_fcrc fcrc = {\n                    .size = lfs->cfg->prog_size,\n                    .crc = 0xffffffff\n                };\n                err = lfs_bd_crc(lfs,\n                        NULL, &lfs->rcache, lfs->cfg->prog_size,\n                        commit->block, noff, fcrc.size, &fcrc.crc);\n                if (err && err != LFS_ERR_CORRUPT) {\n                    return err;\n                }\n\n                lfs_fcrc_tole32(&fcrc);\n                err = lfs_dir_commitattr(lfs, commit,\n                        LFS_MKTAG(LFS_TYPE_FCRC, 0x3ff, sizeof(struct lfs_fcrc)),\n                        &fcrc);\n                if (err) {\n                    return err;\n                }\n            }\n        }\n\n        // build commit crc\n        struct {\n            lfs_tag_t tag;\n            uint32_t crc;\n        } ccrc;\n        lfs_tag_t ntag = LFS_MKTAG(\n                LFS_TYPE_CCRC + (((uint8_t)~eperturb) >> 7), 0x3ff,\n                noff - (commit->off+sizeof(lfs_tag_t)));\n        ccrc.tag = lfs_tobe32(ntag ^ commit->ptag);\n        commit->crc = lfs_crc(commit->crc, &ccrc.tag, sizeof(lfs_tag_t));\n        ccrc.crc = lfs_tole32(commit->crc);\n\n        int err = lfs_bd_prog(lfs,\n                &lfs->pcache, &lfs->rcache, false,\n                commit->block, commit->off, &ccrc, sizeof(ccrc));\n        if (err) {\n            return err;\n        }\n\n        // keep track of non-padding checksum to verify\n        if (off1 == 0) {\n            off1 = commit->off + sizeof(lfs_tag_t);\n            crc1 = commit->crc;\n        }\n\n        commit->off = noff;\n        // perturb valid bit?\n        commit->ptag = ntag ^ ((0x80UL & ~eperturb) << 24);\n        // reset crc for next commit\n        commit->crc = 0xffffffff;\n\n        // manually flush here since we don't prog the padding, this confuses\n        // the caching layer\n        if (noff >= end || noff >= lfs->pcache.off + lfs->cfg->cache_size) {\n            // flush buffers\n            int err = lfs_bd_sync(lfs, &lfs->pcache, &lfs->rcache, false);\n            if (err) {\n                return err;\n            }\n        }\n    }\n\n    // successful commit, check checksums to make sure\n    //\n    // note that we don't need to check padding commits, worst\n    // case if they are corrupted we would have had to compact anyways\n    lfs_off_t off = commit->begin;\n    uint32_t crc = 0xffffffff;\n    int err = lfs_bd_crc(lfs,\n            NULL, &lfs->rcache, off1+sizeof(uint32_t),\n            commit->block, off, off1-off, &crc);\n    if (err) {\n        return err;\n    }\n\n    // check non-padding commits against known crc\n    if (crc != crc1) {\n        return LFS_ERR_CORRUPT;\n    }\n\n    // make sure to check crc in case we happen to pick\n    // up an unrelated crc (frozen block?)\n    err = lfs_bd_crc(lfs,\n            NULL, &lfs->rcache, sizeof(uint32_t),\n            commit->block, off1, sizeof(uint32_t), &crc);\n    if (err) {\n        return err;\n    }\n\n    if (crc != 0) {\n        return LFS_ERR_CORRUPT;\n    }\n\n    return 0;\n}\n```\n</target_code>\n<response format>\nProvide your answer with these fields.\n- explanation: your evaluation of the scenario provided by the agent A.\n- is_report_correct: whether the report is correct or not (true/false). True means there is a violation.\n</response format>\n<scenario>\nThe agent A provided the following violation scenario:\nThe function lfs_bd_read takes a non-const pointer lfs_t *lfs but the function only reads from lfs (accesses cfg, block_count, etc.) and does not modify the lfs object. According to MISRA C 2023 Rule 8.13, that pointer should be const-qualified (const lfs_t *lfs) when possible. pcache is already const and rcache and buffer are non-const appropriately, so the remaining violation is the non-const lfs parameter.\n</scenario>\n\n<execution_log>\nThe agent A also provided the following output log:\nENTER lfs_dir_commitcrc: lfs=0x7fffec305728, cfg=0x7fffec3060b0, block_size=512, prog_size=16, commit(off=44, block=0, begin=0, ptag=0x20100018, crc=0xbe1d36a6)\nComputed end=64\nLoop start: commit->off=44, calculated noff=64\nlfs_bd_read returned err=0, eperturb=0xff\nlfs_bd_crc for fcrc returned err=0, fcrc.size=16, fcrc.crc=0xc04c39e5\nCalling lfs_dir_commitattr to write fcrc: block=0, noff=64, fcrc.size=16, fcrc.crc=0xc04c39e5\nlfs_dir_commitattr returned err=0\nPrepared CCRC: ntag=0x500ffc04, ptag=0x5ffffc08, commit->crc=0x0bade05e, ccrc.crc=0x0bade05e\nlfs_bd_prog returned err=0 for block=0 off=56 size=8\nSet off1=60, crc1=0x0bade05e\nAfter update: commit->off=64, commit->ptag=0x500ffc04, commit->crc=0xffffffff\nlfs_bd_sync returned err=0\nlfs_bd_crc final check returned err=0, off=0, len=60, crc=0x0bade05e\nlfs_bd_crc second check returned err=0, crc=0x00000000\nEXIT lfs_dir_commitcrc success: commit->block=0, begin=0, end=64\nENTER lfs_dir_commitcrc: lfs=0x7fffec305728, cfg=0x7fffec3060b0, block_size=512, prog_size=16, commit(off=44, block=1, begin=0, ptag=0x20100018, crc=0x94350ec4)\nComputed end=64\nLoop start: commit->off=44, calculated noff=64\nlfs_bd_read returned err=0, eperturb=0xff\nlfs_bd_crc for fcrc returned err=0, fcrc.size=16, fcrc.crc=0xc04c39e5\nCalling lfs_dir_commitattr to write fcrc: block=1, noff=64, fcrc.size=16, fcrc.crc=0xc04c39e5\nlfs_dir_commitattr returned err=0\nPrepared CCRC: ntag=0x500ffc04, ptag=0x5ffffc08, commit->crc=0xc17e6ed1, ccrc.crc=0xc17e6ed1\nlfs_bd_prog returned err=0 for block=1 off=56 size=8\nSet off1=60, crc1=0xc17e6ed1\nAfter update: commit->off=64, commit->ptag=0x500ffc04, commit->crc=0xffffffff\nlfs_bd_sync returned err=0\nlfs_bd_crc final check returned err=0, off=0, len=60, crc=0xc17e6ed1\nlfs_bd_crc second check returned err=0, crc=0x00000000\nEXIT lfs_dir_commitcrc success: commit->block=1, begin=0, end=64\nENTER lfs_dir_commitcrc: lfs=0x7fffec305728, cfg=0x7fffec305630, block_size=512, prog_size=16, commit(off=4, block=1672, begin=0, ptag=0xffffffff, crc=0xdebb20e3)\nComputed end=32\nLoop start: commit->off=4, calculated noff=32\nlfs_bd_read returned err=0, eperturb=0xff\nlfs_bd_crc for fcrc returned err=0, fcrc.size=16, fcrc.crc=0xc04c39e5\nCalling lfs_dir_commitattr to write fcrc: block=1672, noff=32, fcrc.size=16, fcrc.crc=0xc04c39e5\nlfs_dir_commitattr returned err=0\nPrepared CCRC: ntag=0x500ffc0c, ptag=0x5ffffc08, commit->crc=0x21f22bc0, ccrc.crc=0x21f22bc0\nlfs_bd_prog returned err=0 for block=1672 off=16 size=8\nSet off1=20, crc1=0x21f22bc0\nAfter update: commit->off=32, commit->ptag=0x500ffc0c, commit->crc=0xffffffff\nlfs_bd_sync returned err=0\nlfs_bd_crc final check returned err=0, off=0, len=20, crc=0x21f22bc0\nlfs_bd_crc second check returned err=0, crc=0x00000000\nEXIT lfs_dir_commitcrc success: commit->block=1672, begin=0, end=32\nENTER lfs_dir_commitcrc: lfs=0x7fffec305728, cfg=0x7fffec305630, block_size=512, prog_size=16, commit(off=105, block=1, begin=64, ptag=0x600ffc08, crc=0x5568a36b)\nComputed end=128\nLoop start: commit->off=105, calculated noff=128\nlfs_bd_read returned err=0, eperturb=0xff\nlfs_bd_crc for fcrc returned err=0, fcrc.size=16, fcrc.crc=0xc04c39e5\nCalling lfs_dir_commitattr to write fcrc: block=1, noff=128, fcrc.size=16, fcrc.crc=0xc04c39e5\nlfs_dir_commitattr returned err=0\nPrepared CCRC: ntag=0x500ffc07, ptag=0x5ffffc08, commit->crc=0x3ee96576, ccrc.crc=0x3ee96576\nlfs_bd_prog returned err=0 for block=1 off=117 size=8\nSet off1=121, crc1=0x3ee96576\nAfter update: commit->off=128, commit->ptag=0x500ffc07, commit->crc=0xffffffff\nlfs_bd_sync returned err=0\nlfs_bd_crc final check returned err=0, off=64, len=57, crc=0x3ee96576\nlfs_bd_crc second check returned err=0, crc=0x00000000\nEXIT lfs_dir_commitcrc success: commit->block=1, begin=64, end=128\nENTER lfs_dir_commitcrc: lfs=0x7fffec305728, cfg=0x7fffec305630, block_size=512, prog_size=16, commit(off=49, block=1672, begin=32, ptag=0x20100000, crc=0xee81f6c7)\nComputed end=80\nLoop start: commit->off=49, calculated noff=80\nlfs_bd_read returned err=0, eperturb=0xff\nlfs_bd_crc for fcrc returned err=0, fcrc.size=16, fcrc.crc=0xc04c39e5\nCa\n</execution_log>\n<additional code>Here are the definitions of symbols that are close to the target function lfs_dir_commitcrc:\ntypedef struct lfs {\n    lfs_cache_t rcache;\n    lfs_cache_t pcache;\n\n    lfs_block_t root[2];\n    struct lfs_mlist {\n        struct lfs_mlist *next;\n        uint16_t id;\n        uint8_t type;\n        lfs_mdir_t m;\n    } *mlist;\n    uint32_t seed;\n\n    lfs_gstate_t gstate;\n    lfs_gstate_t gdisk;\n    lfs_gstate_t gdelta;\n\n    struct lfs_lookahead {\n        lfs_block_t start;\n        lfs_block_t size;\n        lfs_block_t next;\n        lfs_block_t ckpoint;\n        uint8_t *buffer;\n    } lookahead;\n\n    const struct lfs_config *cfg;\n    lfs_size_t block_count;\n    lfs_size_t name_max;\n    lfs_size_t file_max;\n    lfs_size_t attr_max;\n    lfs_size_t inline_max;\n\n#ifdef LFS_MIGRATE\n    struct lfs1 *lfs1;\n#endif\n} lfs_t\n...\nstruct lfs_commit {\n    lfs_block_t block;\n    lfs_off_t off;\n    lfs_tag_t ptag;\n    uint32_t crc;\n\n    lfs_off_t begin;\n    lfs_off_t end;\n}\n...\nstruct lfs_fcrc {\n    lfs_size_t size;\n    uint32_t crc;\n}\n...\ntypedef uint32_t lfs_tag_t\n...\ntypedef uint32_t lfs_off_t\n...\ntypedef struct lfs_cache {\n    lfs_block_t block;\n    lfs_off_t off;\n    lfs_size_t size;\n    uint8_t *buffer;\n} lfs_cache_t\n...\nstatic int lfs_bd_read(lfs_t *lfs,\n        const lfs_cache_t *pcache, lfs_cache_t *rcache, lfs_size_t hint,\n        lfs_block_t block, lfs_off_t off,\n        void *buffer, lfs_size_t size) {\n    uint8_t *data = buffer;\n    if (off+size > lfs->cfg->block_size\n            || (lfs->block_count && block >= lfs->block_count)) {\n        return LFS_ERR_CORRUPT;\n    }\n\n    while (size > 0) {\n        lfs_size_t diff = size;\n\n        if (pcache && block == pcache->block &&\n                off < pcache->off + pcache->size) {\n            if (off >= pcache->off) {\n                // is already in pcache?\n                diff = lfs_min(diff, pcache->size - (off-pcache->off));\n                memcpy(data, &pcache->buffer[off-pcache->off], diff);\n\n                data += diff;\n                off += diff;\n                size -= diff;\n                continue;\n            }\n\n            // pcache takes priority\n            diff = lfs_min(diff, pcache->off-off);\n        }\n\n        if (block == rcache->block &&\n                off < rcache->off + rcache->size) {\n            if (off >= rcache->off) {\n                // is already in rcache?\n                diff = lfs_min(diff, rcache->size - (off-rcache->off));\n                memcpy(data, &rcache->buffer[off-rcache->off], diff);\n\n                data += diff;\n                off += diff;\n                size -= diff;\n                continue;\n            }\n\n            // rcache takes priority\n            diff = lfs_min(diff, rcache->off-off);\n        }\n\n        if (size >= hint && off % lfs->cfg->read_size == 0 &&\n                size >= lfs->cfg->read_size) {\n            // bypass cache?\n            diff = lfs_aligndown(diff, lfs->cfg->read_size);\n            int err = lfs->cfg->read(lfs->cfg, block, off, data, diff);\n            if (err) {\n                return err;\n            }\n\n            data += diff;\n            off += diff;\n            size -= diff;\n            continue;\n        }\n\n        // load to cache, first condition can no longer fail\n        LFS_ASSERT(!lfs->block_count || block < lfs->block_count);\n        rcache->block = block;\n        rcache->off = lfs_aligndown(off, lfs->cfg->read_size);\n        rcache->size = lfs_min(\n                lfs_min(\n                    lfs_alignup(off+hint, lfs->cfg->read_size),\n                    lfs->cfg->block_size)\n                - rcache->off,\n                lfs->cfg->cache_size);\n        int err = lfs->cfg->read(lfs->cfg, rcache->block,\n                rcache->off, rcache->buffer, rcache->size);\n        LFS_ASSERT(err <= 0);\n        if (err) {\n            return err;\n        }\n    }\n\n    return 0;\n}\n...\nstatic int lfs_bd_crc(lfs_t *lfs,\n        const lfs_cache_t *pcache, lfs_cache_t *rcache, lfs_size_t hint,\n        lfs_block_t block, lfs_off_t off, lfs_size_t size, uint32_t *crc) {\n    lfs_size_t diff = 0;\n\n    for (lfs_off_t i = 0; i < size; i += diff) {\n        uint8_t dat[8];\n        diff = lfs_min(size-i, sizeof(dat));\n        int err = lfs_bd_read(lfs,\n                pcache, rcache, hint-i,\n                block, off+i, &dat, diff);\n        if (err) {\n            return err;\n        }\n\n        *crc = lfs_crc(*crc, &dat, diff);\n    }\n\n    return 0;\n}\n...\nstatic int lfs_bd_prog(lfs_t *lfs,\n        lfs_cache_t *pcache, lfs_cache_t *rcache, bool validate,\n        lfs_block_t block, lfs_off_t off,\n        const void *buffer, lfs_size_t size) {\n    const uint8_t *data = buffer;\n    LFS_ASSERT(block == LFS_BLOCK_INLINE || block < lfs->block_count);\n    LFS_ASSERT(off + size <= lfs->cfg->block_size);\n\n    while (size > 0) {\n        if (block == pcache->block &&\n                off >= pcache->off &&\n                off < pcache->off + lfs->cfg->cache_size) {\n            // already fits in pcache?\n            lfs_size_t diff = lfs_min(size,\n                    lfs->cfg->cache_size - (off-pcache->off));\n            memcpy(&pcache->buffer[off-pcache->off], data, diff);\n\n            data += diff;\n            off += diff;\n            size -= diff;\n\n            pcache->size = lfs_max(pcache->size, off - pcache->off);\n            if (pcache->size == lfs->cfg->cache_size) {\n                // eagerly flush out pcache if we fill up\n                int err = lfs_bd_flush(lfs, pcache, rcache, validate);\n                if (err) {\n                    return err;\n                }\n            }\n\n            continue;\n        }\n\n        // pcache must have been flushed, either by programming and\n        // entire block or manually flushing the pcache\n        LFS_ASSERT(pcache->block == LFS_BLOCK_NULL);\n\n        // prepare pcache, first condition can no longer fail\n        pcache->block = block;\n        pcache->off = lfs_aligndown(off, lfs->cfg->prog_size);\n        pcache->size = 0;\n    }\n\n    return 0;\n}\n...\nstatic int lfs_bd_sync(lfs_t *lfs,\n        lfs_cache_t *pcache, lfs_cache_t *rcache, bool validate) {\n    lfs_cache_drop(lfs, rcache);\n\n    int err = lfs_bd_flush(lfs, pcache, rcache, validate);\n    if (err) {\n        return err;\n    }\n\n    err = lfs->cfg->sync(lfs->cfg);\n    LFS_ASSERT(err <= 0);\n    return err;\n}\n...\nstatic int lfs_dir_commitattr(lfs_t *lfs, struct lfs_commit *commit,\n        lfs_tag_t tag, const void *buffer) {\n    // check if we fit\n    lfs_size_t dsize = lfs_tag_dsize(tag);\n    if (commit->off + dsize > commit->end) {\n        return LFS_ERR_NOSPC;\n    }\n\n    // write out tag\n    lfs_tag_t ntag = lfs_tobe32((tag & 0x7fffffff) ^ commit->ptag);\n    int err = lfs_dir_commitprog(lfs, commit, &ntag, sizeof(ntag));\n    if (err) {\n        return err;\n    }\n\n    if (!(tag & 0x80000000)) {\n        // from memory\n        err = lfs_dir_commitprog(lfs, commit, buffer, dsize-sizeof(tag));\n        if (err) {\n            return err;\n        }\n    } else {\n        // from disk\n        const struct lfs_diskoff *disk = buffer;\n        for (lfs_off_t i = 0; i < dsize-sizeof(tag); i++) {\n            // rely on caching to make this efficient\n            uint8_t dat;\n            err = lfs_bd_read(lfs,\n                    NULL, &lfs->rcache, dsize-sizeof(tag)-i,\n                    disk->block, disk->off+i, &dat, 1);\n            if (err) {\n                return err;\n            }\n\n            err = lfs_dir_commitprog(lfs, commit, &dat, 1);\n            if (err) {\n                return err;\n            }\n        }\n    }\n\n    commit->ptag = tag & 0x7fffffff;\n    return 0;\n}\n...\nstatic void lfs_fcrc_tole32(struct lfs_fcrc *fcrc) {\n    fcrc->size = lfs_tole32(fcrc->size);\n    fcrc->crc = lfs_tole32(fcrc->crc);\n}\n...\nuint32_t lfs_crc(uint32_t crc, const void *buffer, size_t size) {\n    static const uint32_t rtable[16] = {\n        0x00000000, 0x1db71064, 0x3b6e20c8, 0x26d930ac,\n        0x76dc4190, 0x6b6b51f4, 0x4db26158, 0x5005713c,\n        0xedb88320, 0xf00f9344, 0xd6d6a3e8, 0xcb61b38c,\n        0x9b64c2b0, 0x86d3d2d4, 0xa00ae278, 0xbdbdf21c,\n    };\n\n    const uint8_t *data = buffer;\n\n    for (size_t i = 0; i < size; i++) {\n        crc = (crc >> 4) ^ rtable[(crc ^ (data[i] >> 0)) & 0xf];\n        crc = (crc >> 4) ^ rtable[(crc ^ (data[i] >> 4)) & 0xf];\n    }\n\n    return crc;\n}\n</additional code>\n\n<instruction>\nJudge whether the report is correct or not.\n</instruction>\n",
  "is_report_correct": true,
  "explanation": "Agent A is correct. The function lfs_bd_read only reads members of the lfs_t object (reads lfs->cfg, lfs->block_count, etc.) and never modifies any lfs_t members; all side effects are on the rcache/pcache arguments or via calls to read callbacks. Therefore the incoming pointer could and should be declared as const lfs_t *lfs to conform with MISRA C 2023 Rule 8.13 (a pointer should point to a const-qualified type whenever possible). Changing the parameter to const lfs_t * is safe w.r.t. its callers (passing a non-const lfs_t * to a function expecting const is allowed). Note: other bd functions that do modify the lfs_t state (e.g. lfs_bd_prog, lfs_bd_sync) correctly keep a non-const parameter; the reported issue specifically applies to lfs_bd_read."
}