{
  "user_message": "An agent A claimed that the following lfs_bd_cmp code violates the MISRA C 2023 rule 17.8.\n<misra_rule>\nMISRA C 2023 Rule 17.8 is A function parameter should not be modified.\nNote that the object referred to by a pointer parameter may be modified, but the pointer itself shall not be modified.\n</misra_rule>\n<target_code>\nHere is the original code of lfs_bd_cmp.\n```c\nstatic int lfs_bd_cmp(lfs_t *lfs,\n        const lfs_cache_t *pcache, lfs_cache_t *rcache, lfs_size_t hint,\n        lfs_block_t block, lfs_off_t off,\n        const void *buffer, lfs_size_t size) {\n    const uint8_t *data = buffer;\n    lfs_size_t diff = 0;\n\n    for (lfs_off_t i = 0; i < size; i += diff) {\n        uint8_t dat[8];\n\n        diff = lfs_min(size-i, sizeof(dat));\n        int err = lfs_bd_read(lfs,\n                pcache, rcache, hint-i,\n                block, off+i, &dat, diff);\n        if (err) {\n            return err;\n        }\n\n        int res = memcmp(dat, data + i, diff);\n        if (res) {\n            return res < 0 ? LFS_CMP_LT : LFS_CMP_GT;\n        }\n    }\n\n    return LFS_CMP_EQ;\n}\n```\n</target_code>\n<response format>\nProvide your answer with these fields.\n- explanation: your evaluation of the scenario provided by the agent A.\n- is_report_correct: whether the report is correct or not (true/false). True means there is a violation.\n</response format>\n<scenario>\nThe agent A provided the following violation scenario:\nWithin lfs_bd_read the function parameters 'off' and 'size' are modified (off += diff; size -= diff;) in the loop. This violates MISRA C 2023 Rule 17.8, which forbids modifying function parameters. (Note: advancing the local pointer 'data' is allowed since 'buffer' itself is not modified.)\n</scenario>\n\n<execution_log>\nThe agent A also provided the following output log:\nENTER lfs_bd_cmp: lfs=0x7ffcb8f958d8 pcache=(nil) rcache=0x7ffcb8f958d8 hint=8 block=1 off=8 buffer=0x557f3e54ebd9 size=8\nITER lfs_bd_cmp: i=0 diff=8 hint_minus_i=8 block=1 off_plus_i=8 size=8\nCMP lfs_bd_cmp: i=0 diff=8 res=0\nRETURN lfs_bd_cmp: all equal returning=0\nENTER lfs_bd_cmp: lfs=0x7ffcb8f958d8 pcache=(nil) rcache=0x7ffcb8f958d8 hint=8 block=1 off=8 buffer=0x557f3e54ebd9 size=8\nITER lfs_bd_cmp: i=0 diff=8 hint_minus_i=8 block=1 off_plus_i=8 size=8\nCMP lfs_bd_cmp: i=0 diff=8 res=0\nRETURN lfs_bd_cmp: all equal returning=0\nENTER lfs_bd_cmp: lfs=0x7ffcb8f958d8 pcache=(nil) rcache=0x7ffcb8f958d8 hint=9 block=1 off=72 buffer=0x7ffcb8f95d78 size=9\nITER lfs_bd_cmp: i=0 diff=8 hint_minus_i=9 block=1 off_plus_i=72 size=9\nCMP lfs_bd_cmp: i=0 diff=8 res=0\nITER lfs_bd_cmp: i=8 diff=1 hint_minus_i=1 block=1 off_plus_i=80 size=9\nCMP lfs_bd_cmp: i=8 diff=1 res=0\nRETURN lfs_bd_cmp: all equal returning=0\nENTER lfs_bd_cmp: lfs=0x7ffcb8f958d8 pcache=(nil) rcache=0x7ffcb8f958d8 hint=9 block=1 off=72 buffer=0x7ffcb8f95d78 size=9\nITER lfs_bd_cmp: i=0 diff=8 hint_minus_i=9 block=1 off_plus_i=72 size=9\nCMP lfs_bd_cmp: i=0 diff=8 res=0\nITER lfs_bd_cmp: i=8 diff=1 hint_minus_i=1 block=1 off_plus_i=80 size=9\nCMP lfs_bd_cmp: i=8 diff=1 res=0\nRETURN lfs_bd_cmp: all equal returning=0\nENTER lfs_bd_cmp: lfs=0x7ffcb8f958d8 pcache=(nil) rcache=0x7ffcb8f958d8 hint=4 block=1672 off=40 buffer=0x7ffcb8f95d82 size=4\nITER lfs_bd_cmp: i=0 diff=4 hint_minus_i=4 block=1672 off_plus_i=40 size=4\nCMP lfs_bd_cmp: i=0 diff=4 res=-3\nRETURN lfs_bd_cmp: comparison non-zero, res=-3 returning=1\nENTER lfs_bd_cmp: lfs=0x7ffcb8f958d8 pcache=(nil) rcache=0x7ffcb8f958d8 hint=9 block=1 off=72 buffer=0x7ffcb8f95d78 size=9\nITER lfs_bd_cmp: i=0 diff=8 hint_minus_i=9 block=1 off_plus_i=72 size=9\nCMP lfs_bd_cmp: i=0 diff=8 res=0\nITER lfs_bd_cmp: i=8 diff=1 hint_minus_i=1 block=1 off_plus_i=80 size=9\nCMP lfs_bd_cmp: i=8 diff=1 res=0\nRETURN lfs_bd_cmp: all equal returning=0\nENTER lfs_bd_cmp: lfs=0x7ffcb8f958d8 pcache=(nil) rcache=0x7ffcb8f958d8 hint=5 block=1672 off=40 buffer=0x7ffcb8f95d82 size=5\nITER lfs_bd_cmp: i=0 diff=5 hint_minus_i=5 block=1672 off_plus_i=40 size=5\nCMP lfs_bd_cmp: i=0 diff=5 res=-14\nRETURN lfs_bd_cmp: comparison non-zero, res=-14 returning=1\nENTER lfs_bd_cmp: lfs=0x7ffcb8f958d8 pcache=(nil) rcache=0x7ffcb8f958d8 hint=4 block=1672 off=88 buffer=0x7ffcb8f95d82 size=4\nITER lfs_bd_cmp: i=0 diff=4 hint_minus_i=4 block=1672 off_plus_i=88 size=4\nCMP lfs_bd_cmp: i=0 diff=4 res=-11\nRETURN lfs_bd_cmp: comparison non-zero, res=-11 returning=1\nENTER lfs_bd_cmp: lfs=0x7ffcb8f958d8 pcache=(nil) rcache=0x7ffcb8f958d8 hint=64 block=1283 off=0 buffer=0x557f3fb1e010 size=64\nITER lfs_bd_cmp: i=0 diff=8 hint_minus_i=64 block=1283 off_plus_i=0 size=64\nCMP lfs_bd_cmp: i=0 diff=8 res=0\nITER lfs_bd_cmp: i=8 diff=8 hint_minus_i=56 block=1283 off_plus_i=8 size=64\nCMP lfs_bd_cmp: i=8 diff=8 res=0\nITER lfs_bd_cmp: i=16 diff=8 hint_minus_i=48 block=1283 off_plus_i=16 size=64\nCMP lfs_bd_cmp: i=16 diff=8 res=0\nITER lfs_bd_cmp: i=24 diff=8 hint_minus_i=40 block=1283 off_plus_i=24 size=64\nCMP lfs_bd_cmp: i=24 diff=8 res=0\nITER lfs_bd_cmp: i=32 diff=8 hint_minus_i=32 block=1283 off_plus_i=32 size=64\nCMP lfs_bd_cmp: i=32 diff=8 res=0\nITER lfs_bd_cmp: i=40 diff=8 hint_minus_i=24 block=1283 off_plus_i=40 size=64\nCMP lfs_bd_cmp: i=40 diff=8 res=0\nITER lfs_bd_cmp: i=48 diff=8 hint_minus_i=16 block=1283 off_plus_i=48 size=64\nCMP lfs_bd_cmp: i=48 diff=8 res=0\nITER lfs_bd_cmp: i=56 diff=8 hint_minus_i=8 block=1283 off_plus_i=56 size=64\nCMP lfs_bd_cmp: i=56 diff=8 res=0\nRETURN lfs_bd_cmp: all equal returning=0\nENTER lfs_bd_cmp: lfs=0x7ffcb8f958d8 pcache=(nil) rcache=0x7ffcb8f958d8 hint=64 block=1283 off=64 buffer=0x557f3fb1e010 size=64\nITER lfs_bd_cmp: i=0 diff=8 hint_minus_i=64 block=1283 off_plus_i=64 size=64\nCMP lfs_bd_cmp: i=0 diff=8 res=0\nITER lfs_bd_cmp: i=8 diff=8 hint_minus_i=56 block=1283 off_plus_i=72 size=64\nCMP lfs_bd_cmp: i=8 diff=8 res=0\nITER lfs_bd_cmp: i=16 diff=8 hint_minus_i=48 block=1283 off_plus_i=80 size=64\nCMP lfs_bd_cmp: i=16 diff=8 res=0\nITER lfs_bd_cmp: i=24 diff=8 hint_min\n</execution_log>\n<additional code>Here are the definitions of symbols that are close to the target function lfs_bd_cmp:\nstatic int lfs_bd_read(lfs_t *lfs,\n        const lfs_cache_t *pcache, lfs_cache_t *rcache, lfs_size_t hint,\n        lfs_block_t block, lfs_off_t off,\n        void *buffer, lfs_size_t size) {\n    uint8_t *data = buffer;\n    if (off+size > lfs->cfg->block_size\n            || (lfs->block_count && block >= lfs->block_count)) {\n        return LFS_ERR_CORRUPT;\n    }\n\n    while (size > 0) {\n        lfs_size_t diff = size;\n\n        if (pcache && block == pcache->block &&\n                off < pcache->off + pcache->size) {\n            if (off >= pcache->off) {\n                // is already in pcache?\n                diff = lfs_min(diff, pcache->size - (off-pcache->off));\n                memcpy(data, &pcache->buffer[off-pcache->off], diff);\n\n                data += diff;\n                off += diff;\n                size -= diff;\n                continue;\n            }\n\n            // pcache takes priority\n            diff = lfs_min(diff, pcache->off-off);\n        }\n\n        if (block == rcache->block &&\n                off < rcache->off + rcache->size) {\n            if (off >= rcache->off) {\n                // is already in rcache?\n                diff = lfs_min(diff, rcache->size - (off-rcache->off));\n                memcpy(data, &rcache->buffer[off-rcache->off], diff);\n\n                data += diff;\n                off += diff;\n                size -= diff;\n                continue;\n            }\n\n            // rcache takes priority\n            diff = lfs_min(diff, rcache->off-off);\n        }\n\n        if (size >= hint && off % lfs->cfg->read_size == 0 &&\n                size >= lfs->cfg->read_size) {\n            // bypass cache?\n            diff = lfs_aligndown(diff, lfs->cfg->read_size);\n            int err = lfs->cfg->read(lfs->cfg, block, off, data, diff);\n            if (err) {\n                return err;\n            }\n\n            data += diff;\n            off += diff;\n            size -= diff;\n            continue;\n        }\n\n        // load to cache, first condition can no longer fail\n        LFS_ASSERT(!lfs->block_count || block < lfs->block_count);\n        rcache->block = block;\n        rcache->off = lfs_aligndown(off, lfs->cfg->read_size);\n        rcache->size = lfs_min(\n                lfs_min(\n                    lfs_alignup(off+hint, lfs->cfg->read_size),\n                    lfs->cfg->block_size)\n                - rcache->off,\n                lfs->cfg->cache_size);\n        int err = lfs->cfg->read(lfs->cfg, rcache->block,\n                rcache->off, rcache->buffer, rcache->size);\n        LFS_ASSERT(err <= 0);\n        if (err) {\n            return err;\n        }\n    }\n\n    return 0;\n}\n</additional code>\n\n<instruction>\nJudge whether the report is correct or not.\n</instruction>\n",
  "is_report_correct": true,
  "explanation": "The report is correct. MISRA C 2023 Rule 17.8 states that function parameters shall not be modified (the objects pointed to by pointer parameters may be modified, but not the pointer parameter itself). In the supplied lfs_bd_read implementation the value parameters off and size are repeatedly modified (off += diff; size -= diff;) inside the loop. Those are scalar parameters passed by value, and modifying them inside the function violates Rule 17.8. Note that advancing the local pointer data (data += diff) is fine because data is a local copy of the pointer parameter buffer; the pointer parameter itself is not modified. To comply with MISRA, make local working copies (e.g. curr_off and remaining_size) and modify those instead of the parameter variables."
}