{
  "user_message": "An agent A claimed that the following lfs_file_opencfg_ code violates the MISRA C 2023 rule 17.8.\n<misra_rule>\nMISRA C 2023 Rule 17.8 is A function parameter should not be modified.\nNote that the object referred to by a pointer parameter may be modified, but the pointer itself shall not be modified.\n</misra_rule>\n<target_code>\nHere is the original code of lfs_file_opencfg_.\n```c\nstatic int lfs_file_opencfg_(lfs_t *lfs, lfs_file_t *file,\n        const char *path, int flags,\n        const struct lfs_file_config *cfg) {\n#ifndef LFS_READONLY\n    // deorphan if we haven't yet, needed at most once after poweron\n    if ((flags & LFS_O_WRONLY) == LFS_O_WRONLY) {\n        int err = lfs_fs_forceconsistency(lfs);\n        if (err) {\n            return err;\n        }\n    }\n#else\n    LFS_ASSERT((flags & LFS_O_RDONLY) == LFS_O_RDONLY);\n#endif\n\n    // setup simple file details\n    int err;\n    file->cfg = cfg;\n    file->flags = flags;\n    file->pos = 0;\n    file->off = 0;\n    file->cache.buffer = NULL;\n\n    // allocate entry for file if it doesn't exist\n    lfs_stag_t tag = lfs_dir_find(lfs, &file->m, &path, &file->id);\n    if (tag < 0 && !(tag == LFS_ERR_NOENT && lfs_path_islast(path))) {\n        err = tag;\n        goto cleanup;\n    }\n\n    // get id, add to list of mdirs to catch update changes\n    file->type = LFS_TYPE_REG;\n    lfs_mlist_append(lfs, (struct lfs_mlist *)file);\n\n#ifdef LFS_READONLY\n    if (tag == LFS_ERR_NOENT) {\n        err = LFS_ERR_NOENT;\n        goto cleanup;\n#else\n    if (tag == LFS_ERR_NOENT) {\n        if (!(flags & LFS_O_CREAT)) {\n            err = LFS_ERR_NOENT;\n            goto cleanup;\n        }\n\n        // don't allow trailing slashes\n        if (lfs_path_isdir(path)) {\n            err = LFS_ERR_NOTDIR;\n            goto cleanup;\n        }\n\n        // check that name fits\n        lfs_size_t nlen = lfs_path_namelen(path);\n        if (nlen > lfs->name_max) {\n            err = LFS_ERR_NAMETOOLONG;\n            goto cleanup;\n        }\n\n        // get next slot and create entry to remember name\n        err = lfs_dir_commit(lfs, &file->m, LFS_MKATTRS(\n                {LFS_MKTAG(LFS_TYPE_CREATE, file->id, 0), NULL},\n                {LFS_MKTAG(LFS_TYPE_REG, file->id, nlen), path},\n                {LFS_MKTAG(LFS_TYPE_INLINESTRUCT, file->id, 0), NULL}));\n\n        // it may happen that the file name doesn't fit in the metadata blocks, e.g., a 256 byte file name will\n        // not fit in a 128 byte block.\n        err = (err == LFS_ERR_NOSPC) ? LFS_ERR_NAMETOOLONG : err;\n        if (err) {\n            goto cleanup;\n        }\n\n        tag = LFS_MKTAG(LFS_TYPE_INLINESTRUCT, 0, 0);\n    } else if (flags & LFS_O_EXCL) {\n        err = LFS_ERR_EXIST;\n        goto cleanup;\n#endif\n    } else if (lfs_tag_type3(tag) != LFS_TYPE_REG) {\n        err = LFS_ERR_ISDIR;\n        goto cleanup;\n#ifndef LFS_READONLY\n    } else if (flags & LFS_O_TRUNC) {\n        // truncate if requested\n        tag = LFS_MKTAG(LFS_TYPE_INLINESTRUCT, file->id, 0);\n        file->flags |= LFS_F_DIRTY;\n#endif\n    } else {\n        // try to load what's on disk, if it's inlined we'll fix it later\n        tag = lfs_dir_get(lfs, &file->m, LFS_MKTAG(0x700, 0x3ff, 0),\n                LFS_MKTAG(LFS_TYPE_STRUCT, file->id, 8), &file->ctz);\n        if (tag < 0) {\n            err = tag;\n            goto cleanup;\n        }\n        lfs_ctz_fromle32(&file->ctz);\n    }\n\n    // fetch attrs\n    for (unsigned i = 0; i < file->cfg->attr_count; i++) {\n        // if opened for read / read-write operations\n        if ((file->flags & LFS_O_RDONLY) == LFS_O_RDONLY) {\n            lfs_stag_t res = lfs_dir_get(lfs, &file->m,\n                    LFS_MKTAG(0x7ff, 0x3ff, 0),\n                    LFS_MKTAG(LFS_TYPE_USERATTR + file->cfg->attrs[i].type,\n                        file->id, file->cfg->attrs[i].size),\n                        file->cfg->attrs[i].buffer);\n            if (res < 0 && res != LFS_ERR_NOENT) {\n                err = res;\n                goto cleanup;\n            }\n        }\n\n#ifndef LFS_READONLY\n        // if opened for write / read-write operations\n        if ((file->flags & LFS_O_WRONLY) == LFS_O_WRONLY) {\n            if (file->cfg->attrs[i].size > lfs->attr_max) {\n                err = LFS_ERR_NOSPC;\n                goto cleanup;\n            }\n\n            file->flags |= LFS_F_DIRTY;\n        }\n#endif\n    }\n\n    // allocate buffer if needed\n    if (file->cfg->buffer) {\n        file->cache.buffer = file->cfg->buffer;\n    } else {\n        file->cache.buffer = lfs_malloc(lfs->cfg->cache_size);\n        if (!file->cache.buffer) {\n            err = LFS_ERR_NOMEM;\n            goto cleanup;\n        }\n    }\n\n    // zero to avoid information leak\n    lfs_cache_zero(lfs, &file->cache);\n\n    if (lfs_tag_type3(tag) == LFS_TYPE_INLINESTRUCT) {\n        // load inline files\n        file->ctz.head = LFS_BLOCK_INLINE;\n        file->ctz.size = lfs_tag_size(tag);\n        file->flags |= LFS_F_INLINE;\n        file->cache.block = file->ctz.head;\n        file->cache.off = 0;\n        file->cache.size = lfs->cfg->cache_size;\n\n        // don't always read (may be new/trunc file)\n        if (file->ctz.size > 0) {\n            lfs_stag_t res = lfs_dir_get(lfs, &file->m,\n                    LFS_MKTAG(0x700, 0x3ff, 0),\n                    LFS_MKTAG(LFS_TYPE_STRUCT, file->id,\n                        lfs_min(file->cache.size, 0x3fe)),\n                    file->cache.buffer);\n            if (res < 0) {\n                err = res;\n                goto cleanup;\n            }\n        }\n    }\n\n    return 0;\n\ncleanup:\n    // clean up lingering resources\n#ifndef LFS_READONLY\n    file->flags |= LFS_F_ERRED;\n#endif\n    lfs_file_close_(lfs, file);\n    return err;\n}\n```\n</target_code>\n<response format>\nProvide your answer with these fields.\n- explanation: your evaluation of the scenario provided by the agent A.\n- is_report_correct: whether the report is correct or not (true/false). True means there is a violation.\n</response format>\n<scenario>\nThe agent A provided the following violation scenario:\nYes. The function parameter 'path' of lfs_file_opencfg_ (declared as const char *path) is passed by address to lfs_dir_find(&path). Inside lfs_dir_find the pointer is updated (e.g. '*path = name;'), which changes the caller's parameter variable. This modifies the function parameter itself (the pointer value), violating MISRA C 2023 Rule 17.8, which forbids modifying a function parameter (the pointer itself) even though the pointed-to object may be altered.\n</scenario>\n\n<execution_log>\nThe agent A also provided the following output log:\nlfs_file_opencfg_: ENTRY flags=0x902 file=0x7ffcbaa3e330 path_addr=0x7ffcbaa3e268 path=breakfast/bacon cfg=0x558ce5b06d60\nbefore_dir_find: path_var_addr=0x7ffcbaa3e268, pointer_value=0x7ffcbaa3ea38, string=breakfast/bacon\nafter_dir_find: path_var_addr=0x7ffcbaa3e268, pointer_value=0x7ffcbaa3ea42, string=bacon\nlfs_dir_find returned tag=-2 for file=0x7ffcbaa3e330 id=0\nlfs_file_opencfg_: SUCCESS id=0 flags=0x100902 path=bacon\nlfs_file_opencfg_: ENTRY flags=0x902 file=0x7ffcbaa3e398 path_addr=0x7ffcbaa3e268 path=breakfast/eggs cfg=0x558ce5b06d60\nbefore_dir_find: path_var_addr=0x7ffcbaa3e268, pointer_value=0x7ffcbaa3ea38, string=breakfast/eggs\nafter_dir_find: path_var_addr=0x7ffcbaa3e268, pointer_value=0x7ffcbaa3ea42, string=eggs\nlfs_dir_find returned tag=-2 for file=0x7ffcbaa3e398 id=1\nlfs_file_opencfg_: SUCCESS id=1 flags=0x100902 path=eggs\nlfs_file_opencfg_: ENTRY flags=0x902 file=0x7ffcbaa3e400 path_addr=0x7ffcbaa3e268 path=breakfast/pancakes cfg=0x558ce5b06d60\nbefore_dir_find: path_var_addr=0x7ffcbaa3e268, pointer_value=0x7ffcbaa3ea38, string=breakfast/pancakes\nafter_dir_find: path_var_addr=0x7ffcbaa3e268, pointer_value=0x7ffcbaa3ea42, string=pancakes\nlfs_dir_find returned tag=-2 for file=0x7ffcbaa3e400 id=2\nlfs_file_opencfg_: SUCCESS id=2 flags=0x100902 path=pancakes\nlfs_file_opencfg_: ENTRY flags=0x1 file=0x7ffcbaa3e530 path_addr=0x7ffcbaa3e268 path=breakfast/bacon cfg=0x558ce5b06d60\nbefore_dir_find: path_var_addr=0x7ffcbaa3e268, pointer_value=0x7ffcbaa3e638, string=breakfast/bacon\nafter_dir_find: path_var_addr=0x7ffcbaa3e268, pointer_value=0x7ffcbaa3e642, string=bacon\nlfs_dir_find returned tag=1048581 for file=0x7ffcbaa3e530 id=0\nlfs_file_opencfg_: SUCCESS id=0 flags=0x1 path=bacon\nlfs_file_opencfg_: ENTRY flags=0x1 file=0x7ffcbaa3e530 path_addr=0x7ffcbaa3e268 path=breakfast/eggs cfg=0x558ce5b06d60\nbefore_dir_find: path_var_addr=0x7ffcbaa3e268, pointer_value=0x7ffcbaa3e638, string=breakfast/eggs\nafter_dir_find: path_var_addr=0x7ffcbaa3e268, pointer_value=0x7ffcbaa3e642, string=eggs\nlfs_dir_find returned tag=1049604 for file=0x7ffcbaa3e530 id=1\nlfs_file_opencfg_: SUCCESS id=1 flags=0x1 path=eggs\nlfs_file_opencfg_: ENTRY flags=0x1 file=0x7ffcbaa3e530 path_addr=0x7ffcbaa3e268 path=breakfast/pancakes cfg=0x558ce5b06d60\nbefore_dir_find: path_var_addr=0x7ffcbaa3e268, pointer_value=0x7ffcbaa3e638, string=breakfast/pancakes\nafter_dir_find: path_var_addr=0x7ffcbaa3e268, pointer_value=0x7ffcbaa3e642, string=pancakes\nlfs_dir_find returned tag=1050632 for file=0x7ffcbaa3e530 id=2\nlfs_file_opencfg_: SUCCESS id=2 flags=0x1 path=pancakes\nlfs_file_opencfg_: ENTRY flags=0x902 file=0x7ffcbaa3e330 path_addr=0x7ffcbaa3e268 path=breakfast/bacon cfg=0x558ce5b06d60\nbefore_dir_find: path_var_addr=0x7ffcbaa3e268, pointer_value=0x7ffcbaa3ea38, string=breakfast/bacon\nafter_dir_find: path_var_addr=0x7ffcbaa3e268, pointer_value=0x7ffcbaa3ea42, string=bacon\nlfs_dir_find returned tag=-2 for file=0x7ffcbaa3e330 id=0\nlfs_file_opencfg_: SUCCESS id=0 flags=0x100902 path=bacon\nlfs_file_opencfg_: ENTRY flags=0x902 file=0x7ffcbaa3e398 path_addr=0x7ffcbaa3e268 path=breakfast/eggs cfg=0x558ce5b06d60\nbefore_dir_find: path_var_addr=0x7ffcbaa3e268, pointer_value=0x7ffcbaa3ea38, string=breakfast/eggs\nafter_dir_find: path_var_addr=0x7ffcbaa3e268, pointer_value=0x7ffcbaa3ea42, string=eggs\nlfs_dir_find returned tag=-2 for file=0x7ffcbaa3e398 id=1\nlfs_file_opencfg_: SUCCESS id=1 flags=0x100902 path=eggs\nlfs_file_opencfg_: ENTRY flags=0x902 file=0x7ffcbaa3e400 path_addr=0x7ffcbaa3e268 path=breakfast/pancakes cfg=0x558ce5b06d60\nbefore_dir_find: path_var_addr=0x7ffcbaa3e268, pointer_value=0x7ffcbaa3ea38, string=breakfast/pancakes\nafter_dir_find: path_var_addr=0x7ffcbaa3e268, pointer_value=0x7ffcbaa3ea42, string=pancakes\nlfs_dir_find returned tag=-2 for file=0x7ffcbaa3e400 id=2\nlfs_file_opencfg_: SUCCESS id=2 flags=0x100902 path=pancakes\nlfs_file_opencfg_: ENTRY flags=0x1 file=0x7ffcbaa3e530 path_addr=0x7ffcbaa3e268 path=breakfast/bacon cfg=0x558ce5b06d60\nbefore_dir_find: path_var_addr=0x7ffcbaa3e268, pointer_value=0x7ffcbaa3e638, string=breakfast/bacon\nafter_dir_find:\n</execution_log>\n<additional code>Here are the definitions of symbols that are close to the target function lfs_file_opencfg_:\nstatic lfs_stag_t lfs_dir_find(lfs_t *lfs, lfs_mdir_t *dir,\n        const char **path, uint16_t *id) {\n    // we reduce path to a single name if we can find it\n    const char *name = *path;\n\n    // default to root dir\n    lfs_stag_t tag = LFS_MKTAG(LFS_TYPE_DIR, 0x3ff, 0);\n    dir->tail[0] = lfs->root[0];\n    dir->tail[1] = lfs->root[1];\n\n    // empty paths are not allowed\n    if (*name == '\\0') {\n        return LFS_ERR_INVAL;\n    }\n\n    while (true) {\nnextname:\n        // skip slashes if we're a directory\n        if (lfs_tag_type3(tag) == LFS_TYPE_DIR) {\n            name += strspn(name, \"/\");\n        }\n        lfs_size_t namelen = strcspn(name, \"/\");\n\n        // skip '.'\n        if (namelen == 1 && memcmp(name, \".\", 1) == 0) {\n            name += namelen;\n            goto nextname;\n        }\n\n        // error on unmatched '..', trying to go above root?\n        if (namelen == 2 && memcmp(name, \"..\", 2) == 0) {\n            return LFS_ERR_INVAL;\n        }\n\n        // skip if matched by '..' in name\n        const char *suffix = name + namelen;\n        lfs_size_t sufflen;\n        int depth = 1;\n        while (true) {\n            suffix += strspn(suffix, \"/\");\n            sufflen = strcspn(suffix, \"/\");\n            if (sufflen == 0) {\n                break;\n            }\n\n            if (sufflen == 1 && memcmp(suffix, \".\", 1) == 0) {\n                // noop\n            } else if (sufflen == 2 && memcmp(suffix, \"..\", 2) == 0) {\n                depth -= 1;\n                if (depth == 0) {\n                    name = suffix + sufflen;\n                    goto nextname;\n                }\n            } else {\n                depth += 1;\n            }\n\n            suffix += sufflen;\n        }\n\n        // found path\n        if (*name == '\\0') {\n            return tag;\n        }\n\n        // update what we've found so far\n        *path = name;\n\n        // only continue if we're a directory\n        if (lfs_tag_type3(tag) != LFS_TYPE_DIR) {\n            return LFS_ERR_NOTDIR;\n        }\n\n        // grab the entry data\n        if (lfs_tag_id(tag) != 0x3ff) {\n            lfs_stag_t res = lfs_dir_get(lfs, dir, LFS_MKTAG(0x700, 0x3ff, 0),\n                    LFS_MKTAG(LFS_TYPE_STRUCT, lfs_tag_id(tag), 8), dir->tail);\n            if (res < 0) {\n                return res;\n            }\n            lfs_pair_fromle32(dir->tail);\n        }\n\n        // find entry matching name\n        while (true) {\n            tag = lfs_dir_fetchmatch(lfs, dir, dir->tail,\n                    LFS_MKTAG(0x780, 0, 0),\n                    LFS_MKTAG(LFS_TYPE_NAME, 0, namelen),\n                    id,\n                    lfs_dir_find_match, &(struct lfs_dir_find_match){\n                        lfs, name, namelen});\n            if (tag < 0) {\n                return tag;\n            }\n\n            if (tag) {\n                break;\n            }\n\n            if (!dir->split) {\n                return LFS_ERR_NOENT;\n            }\n        }\n\n        // to next name\n        name += namelen;\n    }\n}\n...\nstatic inline bool lfs_path_islast(const char *path) {\n    lfs_size_t namelen = lfs_path_namelen(path);\n    return path[namelen + strspn(path + namelen, \"/\")] == '\\0';\n}\n...\nstatic inline bool lfs_path_isdir(const char *path) {\n    return path[lfs_path_namelen(path)] != '\\0';\n}\n...\nstatic inline lfs_size_t lfs_path_namelen(const char *path) {\n    return strcspn(path, \"/\");\n}\n</additional code>\n\n<instruction>\nJudge whether the report is correct or not.\n</instruction>\n",
  "is_report_correct": true,
  "explanation": "Correct. MISRA C 2023 Rule 17.8 forbids modifying a function parameter itself (the value of a pointer parameter shall not be changed; the object it points to may be). lfs_file_opencfg_ declares a parameter const char *path and then passes its address to lfs_dir_find: lfs_dir_find(lfs, &file->m, &path, &file->id); lfs_dir_find takes const char **path and assigns to it via *path = name; (see the \"update what we've found so far\" comment). That assignment changes the caller's local parameter variable path (as shown in the provided execution log), i.e. the pointer value is modified. This is a direct violation of Rule 17.8. A simple fix is to avoid passing &path to the callee (use a local temporary const char *tmp = path and pass &tmp), or change the API so the callee returns the reduced path without modifying the caller's parameter."
}