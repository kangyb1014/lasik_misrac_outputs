{
  "user_message": "<misra_rule>\nMISRA C 2023 Rule 8.13 is: A pointer should point to a const-qualified type whenever possible.\n\n</misra_rule>\n\nAnother agent reported that the target code violated the Rule 8.13.\nHere is the comment from the agent.\n<violation scenario>\nYes. The call creates attributes with a pointer to the file name (path, declared as const char *). If the struct lfs_mattr (created by LFS_MKATTRS/LFS_MKTAG) stores that buffer as a non-const pointer (e.g. void *buffer or char *), then a const char * is being passed/assigned to a non-const pointer. This discards the const qualifier and means the pointer type is not const-qualified even though the data is not modified \u2014 violating MISRA C 2023 Rule 8.13. (If lfs_mattr actually uses a const-qualified pointer for the buffer field, then there is no violation.)\n</violation scenario>\n\nYour job is to insert logging code to capture the control flow and state information of the program.\nInsert logging code so that other agents can reproduce and get evidence for the violation scenario.\n<response format>\n- test_code: a modified lfs_file_opencfg_ code that contains useful probe functions that print useful logs to a file \"/tmp/logs/533.txt\". The logs should contain the control path and state information of the violation scenario. If test code is not required to validate the scenario, you can leave this blank.\nHere are the constraints for the test code:\n- The test code MUST preserve the original logic of lfs_file_opencfg_ as much as possible.\nYou CAN just insert probe functions to the original code.\n- DO NOT introduce new violations to demonstrate your scenario.\n- The test code MUST be compilable and executable.\n- The test code MUST include line breaks.\n- You MUST NOT define the main function.\n- You MUST NOT define macros.\n</response format>\n<target_code>\nHere is the code of lfs_file_opencfg_:\n```c\nstatic int lfs_file_opencfg_(lfs_t *lfs, lfs_file_t *file,\n        const char *path, int flags,\n        const struct lfs_file_config *cfg) {\n#ifndef LFS_READONLY\n    // deorphan if we haven't yet, needed at most once after poweron\n    if ((flags & LFS_O_WRONLY) == LFS_O_WRONLY) {\n        int err = lfs_fs_forceconsistency(lfs);\n        if (err) {\n            return err;\n        }\n    }\n#else\n    LFS_ASSERT((flags & LFS_O_RDONLY) == LFS_O_RDONLY);\n#endif\n\n    // setup simple file details\n    int err;\n    file->cfg = cfg;\n    file->flags = flags;\n    file->pos = 0;\n    file->off = 0;\n    file->cache.buffer = NULL;\n\n    // allocate entry for file if it doesn't exist\n    lfs_stag_t tag = lfs_dir_find(lfs, &file->m, &path, &file->id);\n    if (tag < 0 && !(tag == LFS_ERR_NOENT && lfs_path_islast(path))) {\n        err = tag;\n        goto cleanup;\n    }\n\n    // get id, add to list of mdirs to catch update changes\n    file->type = LFS_TYPE_REG;\n    lfs_mlist_append(lfs, (struct lfs_mlist *)file);\n\n#ifdef LFS_READONLY\n    if (tag == LFS_ERR_NOENT) {\n        err = LFS_ERR_NOENT;\n        goto cleanup;\n#else\n    if (tag == LFS_ERR_NOENT) {\n        if (!(flags & LFS_O_CREAT)) {\n            err = LFS_ERR_NOENT;\n            goto cleanup;\n        }\n\n        // don't allow trailing slashes\n        if (lfs_path_isdir(path)) {\n            err = LFS_ERR_NOTDIR;\n            goto cleanup;\n        }\n\n        // check that name fits\n        lfs_size_t nlen = lfs_path_namelen(path);\n        if (nlen > lfs->name_max) {\n            err = LFS_ERR_NAMETOOLONG;\n            goto cleanup;\n        }\n\n        // get next slot and create entry to remember name\n        err = lfs_dir_commit(lfs, &file->m, LFS_MKATTRS(\n                {LFS_MKTAG(LFS_TYPE_CREATE, file->id, 0), NULL},\n                {LFS_MKTAG(LFS_TYPE_REG, file->id, nlen), path},\n                {LFS_MKTAG(LFS_TYPE_INLINESTRUCT, file->id, 0), NULL}));\n\n        // it may happen that the file name doesn't fit in the metadata blocks, e.g., a 256 byte file name will\n        // not fit in a 128 byte block.\n        err = (err == LFS_ERR_NOSPC) ? LFS_ERR_NAMETOOLONG : err;\n        if (err) {\n            goto cleanup;\n        }\n\n        tag = LFS_MKTAG(LFS_TYPE_INLINESTRUCT, 0, 0);\n    } else if (flags & LFS_O_EXCL) {\n        err = LFS_ERR_EXIST;\n        goto cleanup;\n#endif\n    } else if (lfs_tag_type3(tag) != LFS_TYPE_REG) {\n        err = LFS_ERR_ISDIR;\n        goto cleanup;\n#ifndef LFS_READONLY\n    } else if (flags & LFS_O_TRUNC) {\n        // truncate if requested\n        tag = LFS_MKTAG(LFS_TYPE_INLINESTRUCT, file->id, 0);\n        file->flags |= LFS_F_DIRTY;\n#endif\n    } else {\n        // try to load what's on disk, if it's inlined we'll fix it later\n        tag = lfs_dir_get(lfs, &file->m, LFS_MKTAG(0x700, 0x3ff, 0),\n                LFS_MKTAG(LFS_TYPE_STRUCT, file->id, 8), &file->ctz);\n        if (tag < 0) {\n            err = tag;\n            goto cleanup;\n        }\n        lfs_ctz_fromle32(&file->ctz);\n    }\n\n    // fetch attrs\n    for (unsigned i = 0; i < file->cfg->attr_count; i++) {\n        // if opened for read / read-write operations\n        if ((file->flags & LFS_O_RDONLY) == LFS_O_RDONLY) {\n            lfs_stag_t res = lfs_dir_get(lfs, &file->m,\n                    LFS_MKTAG(0x7ff, 0x3ff, 0),\n                    LFS_MKTAG(LFS_TYPE_USERATTR + file->cfg->attrs[i].type,\n                        file->id, file->cfg->attrs[i].size),\n                        file->cfg->attrs[i].buffer);\n            if (res < 0 && res != LFS_ERR_NOENT) {\n                err = res;\n                goto cleanup;\n            }\n        }\n\n#ifndef LFS_READONLY\n        // if opened for write / read-write operations\n        if ((file->flags & LFS_O_WRONLY) == LFS_O_WRONLY) {\n            if (file->cfg->attrs[i].size > lfs->attr_max) {\n                err = LFS_ERR_NOSPC;\n                goto cleanup;\n            }\n\n            file->flags |= LFS_F_DIRTY;\n        }\n#endif\n    }\n\n    // allocate buffer if needed\n    if (file->cfg->buffer) {\n        file->cache.buffer = file->cfg->buffer;\n    } else {\n        file->cache.buffer = lfs_malloc(lfs->cfg->cache_size);\n        if (!file->cache.buffer) {\n            err = LFS_ERR_NOMEM;\n            goto cleanup;\n        }\n    }\n\n    // zero to avoid information leak\n    lfs_cache_zero(lfs, &file->cache);\n\n    if (lfs_tag_type3(tag) == LFS_TYPE_INLINESTRUCT) {\n        // load inline files\n        file->ctz.head = LFS_BLOCK_INLINE;\n        file->ctz.size = lfs_tag_size(tag);\n        file->flags |= LFS_F_INLINE;\n        file->cache.block = file->ctz.head;\n        file->cache.off = 0;\n        file->cache.size = lfs->cfg->cache_size;\n\n        // don't always read (may be new/trunc file)\n        if (file->ctz.size > 0) {\n            lfs_stag_t res = lfs_dir_get(lfs, &file->m,\n                    LFS_MKTAG(0x700, 0x3ff, 0),\n                    LFS_MKTAG(LFS_TYPE_STRUCT, file->id,\n                        lfs_min(file->cache.size, 0x3fe)),\n                    file->cache.buffer);\n            if (res < 0) {\n                err = res;\n                goto cleanup;\n            }\n        }\n    }\n\n    return 0;\n\ncleanup:\n    // clean up lingering resources\n#ifndef LFS_READONLY\n    file->flags |= LFS_F_ERRED;\n#endif\n    lfs_file_close_(lfs, file);\n    return err;\n}\n```\n</target_code>\nPlease provide the modified lfs_file_opencfg_ code.\n",
  "test_code": "#include <stdio.h>\n#include <stdarg.h>\n#include <stdint.h>\n\n/* Simple logging helper to append probe information to /tmp/logs/533.txt */\nstatic void lfs_file_opencfg_log(const char *fmt, ...) {\n    FILE *f = fopen(\"/tmp/logs/533.txt\", \"a\");\n    if (!f) {\n        return;\n    }\n    va_list ap;\n    va_start(ap, fmt);\n    vfprintf(f, fmt, ap);\n    fprintf(f, \"\\n\");\n    va_end(ap);\n    fclose(f);\n}\n\nstatic int lfs_file_opencfg_(lfs_t *lfs, lfs_file_t *file,\n        const char *path, int flags,\n        const struct lfs_file_config *cfg) {\n    lfs_file_opencfg_log(\"ENTER lfs_file_opencfg_: lfs=%p file=%p path=%s flags=0x%X cfg=%p\",\n            (void *)lfs, (void *)file, (path ? path : \"(null)\"), flags, (void *)cfg);\n#ifndef LFS_READONLY\n    // deorphan if we haven't yet, needed at most once after poweron\n    if ((flags & LFS_O_WRONLY) == LFS_O_WRONLY) {\n        int err = lfs_fs_forceconsistency(lfs);\n        lfs_file_opencfg_log(\"lfs_fs_forceconsistency returned %d\", err);\n        if (err) {\n            return err;\n        }\n    }\n#else\n    LFS_ASSERT((flags & LFS_O_RDONLY) == LFS_O_RDONLY);\n#endif\n\n    // setup simple file details\n    int err;\n    file->cfg = cfg;\n    file->flags = flags;\n    file->pos = 0;\n    file->off = 0;\n    file->cache.buffer = NULL;\n\n    lfs_file_opencfg_log(\"after setup: file=%p cfg=%p flags=0x%X pos=%u off=%u cache.buffer=%p\",\n            (void *)file, (void *)file->cfg, file->flags, (unsigned)file->pos, (unsigned)file->off,\n            (void *)file->cache.buffer);\n\n    if (cfg) {\n        lfs_file_opencfg_log(\"cfg: attr_count=%u buffer=%p\",\n                (unsigned)cfg->attr_count, (void *)cfg->buffer);\n    }\n\n    // allocate entry for file if it doesn't exist\n    lfs_stag_t tag = lfs_dir_find(lfs, &file->m, &path, &file->id);\n    lfs_file_opencfg_log(\"lfs_dir_find returned tag=0x%X file->id=%u path_after_find=%s\",\n            (unsigned)tag, (unsigned)file->id, (path ? path : \"(null)\"));\n\n    if (tag < 0 && !(tag == LFS_ERR_NOENT && lfs_path_islast(path))) {\n        err = tag;\n        lfs_file_opencfg_log(\"error: unexpected tag from lfs_dir_find: %d\", err);\n        goto cleanup;\n    }\n\n    // get id, add to list of mdirs to catch update changes\n    file->type = LFS_TYPE_REG;\n    lfs_mlist_append(lfs, (struct lfs_mlist *)file);\n\n    lfs_file_opencfg_log(\"after mlist append: file->type=%d\", (int)file->type);\n\n#ifdef LFS_READONLY\n    if (tag == LFS_ERR_NOENT) {\n        err = LFS_ERR_NOENT;\n        lfs_file_opencfg_log(\"readonly and noent: returning LFS_ERR_NOENT\");\n        goto cleanup;\n#else\n    if (tag == LFS_ERR_NOENT) {\n        if (!(flags & LFS_O_CREAT)) {\n            err = LFS_ERR_NOENT;\n            lfs_file_opencfg_log(\"noent and not creat: returning LFS_ERR_NOENT\");\n            goto cleanup;\n        }\n\n        // don't allow trailing slashes\n        if (lfs_path_isdir(path)) {\n            err = LFS_ERR_NOTDIR;\n            lfs_file_opencfg_log(\"path is dir: returning LFS_ERR_NOTDIR path=%s\", (path ? path : \"(null)\"));\n            goto cleanup;\n        }\n\n        // check that name fits\n        lfs_size_t nlen = lfs_path_namelen(path);\n        lfs_file_opencfg_log(\"name length=%u max=%u\", (unsigned)nlen, (unsigned)lfs->name_max);\n        if (nlen > lfs->name_max) {\n            err = LFS_ERR_NAMETOOLONG;\n            lfs_file_opencfg_log(\"name too long: returning LFS_ERR_NAMETOOLONG\");\n            goto cleanup;\n        }\n\n        // get next slot and create entry to remember name\n        lfs_file_opencfg_log(\"calling lfs_dir_commit to create new file: path=%s nlen=%u\",\n                (path ? path : \"(null)\"), (unsigned)nlen);\n        err = lfs_dir_commit(lfs, &file->m, LFS_MKATTRS(\n                {LFS_MKTAG(LFS_TYPE_CREATE, file->id, 0), NULL},\n                {LFS_MKTAG(LFS_TYPE_REG, file->id, nlen), path},\n                {LFS_MKTAG(LFS_TYPE_INLINESTRUCT, file->id, 0), NULL}));\n        lfs_file_opencfg_log(\"lfs_dir_commit returned %d\", err);\n\n        // it may happen that the file name doesn't fit in the metadata blocks, e.g., a 256 byte file name will\n        // not fit in a 128 byte block.\n        err = (err == LFS_ERR_NOSPC) ? LFS_ERR_NAMETOOLONG : err;\n        if (err) {\n            lfs_file_opencfg_log(\"error after commit: %d\", err);\n            goto cleanup;\n        }\n\n        tag = LFS_MKTAG(LFS_TYPE_INLINESTRUCT, 0, 0);\n        lfs_file_opencfg_log(\"created new file, set tag to INLINESTRUCT: 0x%X\", (unsigned)tag);\n    } else if (flags & LFS_O_EXCL) {\n        err = LFS_ERR_EXIST;\n        lfs_file_opencfg_log(\"O_EXCL and exists: returning LFS_ERR_EXIST\");\n        goto cleanup;\n#endif\n    } else if (lfs_tag_type3(tag) != LFS_TYPE_REG) {\n        err = LFS_ERR_ISDIR;\n        lfs_file_opencfg_log(\"tag type not REG: returning LFS_ERR_ISDIR tag=0x%X\", (unsigned)tag);\n        goto cleanup;\n#ifndef LFS_READONLY\n    } else if (flags & LFS_O_TRUNC) {\n        // truncate if requested\n        tag = LFS_MKTAG(LFS_TYPE_INLINESTRUCT, file->id, 0);\n        file->flags |= LFS_F_DIRTY;\n        lfs_file_opencfg_log(\"O_TRUNC requested: tag set to INLINESTRUCT, file->flags=0x%X\", (unsigned)file->flags);\n#endif\n    } else {\n        // try to load what's on disk, if it's inlined we'll fix it later\n        lfs_file_opencfg_log(\"loading struct from disk: file->id=%u\", (unsigned)file->id);\n        tag = lfs_dir_get(lfs, &file->m, LFS_MKTAG(0x700, 0x3ff, 0),\n                LFS_MKTAG(LFS_TYPE_STRUCT, file->id, 8), &file->ctz);\n        lfs_file_opencfg_log(\"lfs_dir_get returned tag=0x%X\", (unsigned)tag);\n        if (tag < 0) {\n            err = tag;\n            lfs_file_opencfg_log(\"error loading struct: %d\", err);\n            goto cleanup;\n        }\n        lfs_ctz_fromle32(&file->ctz);\n        lfs_file_opencfg_log(\"loaded ctz: head=%u size=%u\", (unsigned)file->ctz.head, (unsigned)file->ctz.size);\n    }\n\n    // fetch attrs\n    for (unsigned i = 0; i < file->cfg->attr_count; i++) {\n        lfs_file_opencfg_log(\"attr[%u]: type=%u size=%u buffer=%p\",\n                i, (unsigned)file->cfg->attrs[i].type, (unsigned)file->cfg->attrs[i].size,\n                (void *)file->cfg->attrs[i].buffer);\n        // if opened for read / read-write operations\n        if ((file->flags & LFS_O_RDONLY) == LFS_O_RDONLY) {\n            lfs_file_opencfg_log(\"attempting to lfs_dir_get for attr[%u] (read path)\", i);\n            lfs_stag_t res = lfs_dir_get(lfs, &file->m,\n                    LFS_MKTAG(0x7ff, 0x3ff, 0),\n                    LFS_MKTAG(LFS_TYPE_USERATTR + file->cfg->attrs[i].type,\n                        file->id, file->cfg->attrs[i].size),\n                        file->cfg->attrs[i].buffer);\n            lfs_file_opencfg_log(\"lfs_dir_get for attr[%u] returned %d\", i, (int)res);\n            if (res < 0 && res != LFS_ERR_NOENT) {\n                err = res;\n                lfs_file_opencfg_log(\"error fetching attr[%u]: %d\", i, err);\n                goto cleanup;\n            }\n        }\n\n#ifndef LFS_READONLY\n        // if opened for write / read-write operations\n        if ((file->flags & LFS_O_WRONLY) == LFS_O_WRONLY) {\n            lfs_file_opencfg_log(\"attr[%u] write-check size=%u attr_max=%u\", i,\n                    (unsigned)file->cfg->attrs[i].size, (unsigned)lfs->attr_max);\n            if (file->cfg->attrs[i].size > lfs->attr_max) {\n                err = LFS_ERR_NOSPC;\n                lfs_file_opencfg_log(\"attr[%u] too large: returning LFS_ERR_NOSPC\", i);\n                goto cleanup;\n            }\n\n            file->flags |= LFS_F_DIRTY;\n            lfs_file_opencfg_log(\"attr[%u] marked file dirty, file->flags=0x%X\", i, (unsigned)file->flags);\n        }\n#endif\n    }\n\n    // allocate buffer if needed\n    if (file->cfg->buffer) {\n        file->cache.buffer = file->cfg->buffer;\n        lfs_file_opencfg_log(\"using provided buffer: %p\", (void *)file->cache.buffer);\n    } else {\n        file->cache.buffer = lfs_malloc(lfs->cfg->cache_size);\n        lfs_file_opencfg_log(\"allocated cache buffer: %p (size=%u)\", (void *)file->cache.buffer,\n                (unsigned)lfs->cfg->cache_size);\n        if (!file->cache.buffer) {\n            err = LFS_ERR_NOMEM;\n            lfs_file_opencfg_log(\"allocation failed: returning LFS_ERR_NOMEM\");\n            goto cleanup;\n        }\n    }\n\n    // zero to avoid information leak\n    lfs_cache_zero(lfs, &file->cache);\n    lfs_file_opencfg_log(\"cache zeroed: cache.buffer=%p cache.size=%u\", (void *)file->cache.buffer,\n            (unsigned)file->cache.size);\n\n    if (lfs_tag_type3(tag) == LFS_TYPE_INLINESTRUCT) {\n        // load inline files\n        file->ctz.head = LFS_BLOCK_INLINE;\n        file->ctz.size = lfs_tag_size(tag);\n        file->flags |= LFS_F_INLINE;\n        file->cache.block = file->ctz.head;\n        file->cache.off = 0;\n        file->cache.size = lfs->cfg->cache_size;\n\n        lfs_file_opencfg_log(\"INLINESTRUCT: head=%u size=%u cache.size=%u\",\n                (unsigned)file->ctz.head, (unsigned)file->ctz.size, (unsigned)file->cache.size);\n\n        // don't always read (may be new/trunc file)\n        if (file->ctz.size > 0) {\n            lfs_file_opencfg_log(\"attempting to read inline file contents into cache buffer %p\",\n                    (void *)file->cache.buffer);\n            lfs_stag_t res = lfs_dir_get(lfs, &file->m,\n                    LFS_MKTAG(0x700, 0x3ff, 0),\n                    LFS_MKTAG(LFS_TYPE_STRUCT, file->id,\n                        lfs_min(file->cache.size, 0x3fe)),\n                    file->cache.buffer);\n            lfs_file_opencfg_log(\"lfs_dir_get for inline data returned %d\", (int)res);\n            if (res < 0) {\n                err = res;\n                lfs_file_opencfg_log(\"error reading inline data: %d\", err);\n                goto cleanup;\n            }\n        }\n    }\n\n    lfs_file_opencfg_log(\"EXIT lfs_file_opencfg_ success: file=%p\", (void *)file);\n    return 0;\n\ncleanup:\n    // clean up lingering resources\n#ifndef LFS_READONLY\n    file->flags |= LFS_F_ERRED;\n#endif\n    lfs_file_opencfg_log(\"cleanup: error=%d file=%p flags=0x%X\", err, (void *)file, (unsigned)file->flags);\n    lfs_file_close_(lfs, file);\n    return err;\n}\n"
}