{
  "user_message": "An agent A claimed that the following lfs_file_opencfg_ code violates the MISRA C 2023 rule 8.13.\n<misra_rule>\nMISRA C 2023 Rule 8.13 is A pointer should point to a const-qualified type whenever possible.\n\n</misra_rule>\n<target_code>\nHere is the original code of lfs_file_opencfg_.\n```c\nstatic int lfs_file_opencfg_(lfs_t *lfs, lfs_file_t *file,\n        const char *path, int flags,\n        const struct lfs_file_config *cfg) {\n#ifndef LFS_READONLY\n    // deorphan if we haven't yet, needed at most once after poweron\n    if ((flags & LFS_O_WRONLY) == LFS_O_WRONLY) {\n        int err = lfs_fs_forceconsistency(lfs);\n        if (err) {\n            return err;\n        }\n    }\n#else\n    LFS_ASSERT((flags & LFS_O_RDONLY) == LFS_O_RDONLY);\n#endif\n\n    // setup simple file details\n    int err;\n    file->cfg = cfg;\n    file->flags = flags;\n    file->pos = 0;\n    file->off = 0;\n    file->cache.buffer = NULL;\n\n    // allocate entry for file if it doesn't exist\n    lfs_stag_t tag = lfs_dir_find(lfs, &file->m, &path, &file->id);\n    if (tag < 0 && !(tag == LFS_ERR_NOENT && lfs_path_islast(path))) {\n        err = tag;\n        goto cleanup;\n    }\n\n    // get id, add to list of mdirs to catch update changes\n    file->type = LFS_TYPE_REG;\n    lfs_mlist_append(lfs, (struct lfs_mlist *)file);\n\n#ifdef LFS_READONLY\n    if (tag == LFS_ERR_NOENT) {\n        err = LFS_ERR_NOENT;\n        goto cleanup;\n#else\n    if (tag == LFS_ERR_NOENT) {\n        if (!(flags & LFS_O_CREAT)) {\n            err = LFS_ERR_NOENT;\n            goto cleanup;\n        }\n\n        // don't allow trailing slashes\n        if (lfs_path_isdir(path)) {\n            err = LFS_ERR_NOTDIR;\n            goto cleanup;\n        }\n\n        // check that name fits\n        lfs_size_t nlen = lfs_path_namelen(path);\n        if (nlen > lfs->name_max) {\n            err = LFS_ERR_NAMETOOLONG;\n            goto cleanup;\n        }\n\n        // get next slot and create entry to remember name\n        err = lfs_dir_commit(lfs, &file->m, LFS_MKATTRS(\n                {LFS_MKTAG(LFS_TYPE_CREATE, file->id, 0), NULL},\n                {LFS_MKTAG(LFS_TYPE_REG, file->id, nlen), path},\n                {LFS_MKTAG(LFS_TYPE_INLINESTRUCT, file->id, 0), NULL}));\n\n        // it may happen that the file name doesn't fit in the metadata blocks, e.g., a 256 byte file name will\n        // not fit in a 128 byte block.\n        err = (err == LFS_ERR_NOSPC) ? LFS_ERR_NAMETOOLONG : err;\n        if (err) {\n            goto cleanup;\n        }\n\n        tag = LFS_MKTAG(LFS_TYPE_INLINESTRUCT, 0, 0);\n    } else if (flags & LFS_O_EXCL) {\n        err = LFS_ERR_EXIST;\n        goto cleanup;\n#endif\n    } else if (lfs_tag_type3(tag) != LFS_TYPE_REG) {\n        err = LFS_ERR_ISDIR;\n        goto cleanup;\n#ifndef LFS_READONLY\n    } else if (flags & LFS_O_TRUNC) {\n        // truncate if requested\n        tag = LFS_MKTAG(LFS_TYPE_INLINESTRUCT, file->id, 0);\n        file->flags |= LFS_F_DIRTY;\n#endif\n    } else {\n        // try to load what's on disk, if it's inlined we'll fix it later\n        tag = lfs_dir_get(lfs, &file->m, LFS_MKTAG(0x700, 0x3ff, 0),\n                LFS_MKTAG(LFS_TYPE_STRUCT, file->id, 8), &file->ctz);\n        if (tag < 0) {\n            err = tag;\n            goto cleanup;\n        }\n        lfs_ctz_fromle32(&file->ctz);\n    }\n\n    // fetch attrs\n    for (unsigned i = 0; i < file->cfg->attr_count; i++) {\n        // if opened for read / read-write operations\n        if ((file->flags & LFS_O_RDONLY) == LFS_O_RDONLY) {\n            lfs_stag_t res = lfs_dir_get(lfs, &file->m,\n                    LFS_MKTAG(0x7ff, 0x3ff, 0),\n                    LFS_MKTAG(LFS_TYPE_USERATTR + file->cfg->attrs[i].type,\n                        file->id, file->cfg->attrs[i].size),\n                        file->cfg->attrs[i].buffer);\n            if (res < 0 && res != LFS_ERR_NOENT) {\n                err = res;\n                goto cleanup;\n            }\n        }\n\n#ifndef LFS_READONLY\n        // if opened for write / read-write operations\n        if ((file->flags & LFS_O_WRONLY) == LFS_O_WRONLY) {\n            if (file->cfg->attrs[i].size > lfs->attr_max) {\n                err = LFS_ERR_NOSPC;\n                goto cleanup;\n            }\n\n            file->flags |= LFS_F_DIRTY;\n        }\n#endif\n    }\n\n    // allocate buffer if needed\n    if (file->cfg->buffer) {\n        file->cache.buffer = file->cfg->buffer;\n    } else {\n        file->cache.buffer = lfs_malloc(lfs->cfg->cache_size);\n        if (!file->cache.buffer) {\n            err = LFS_ERR_NOMEM;\n            goto cleanup;\n        }\n    }\n\n    // zero to avoid information leak\n    lfs_cache_zero(lfs, &file->cache);\n\n    if (lfs_tag_type3(tag) == LFS_TYPE_INLINESTRUCT) {\n        // load inline files\n        file->ctz.head = LFS_BLOCK_INLINE;\n        file->ctz.size = lfs_tag_size(tag);\n        file->flags |= LFS_F_INLINE;\n        file->cache.block = file->ctz.head;\n        file->cache.off = 0;\n        file->cache.size = lfs->cfg->cache_size;\n\n        // don't always read (may be new/trunc file)\n        if (file->ctz.size > 0) {\n            lfs_stag_t res = lfs_dir_get(lfs, &file->m,\n                    LFS_MKTAG(0x700, 0x3ff, 0),\n                    LFS_MKTAG(LFS_TYPE_STRUCT, file->id,\n                        lfs_min(file->cache.size, 0x3fe)),\n                    file->cache.buffer);\n            if (res < 0) {\n                err = res;\n                goto cleanup;\n            }\n        }\n    }\n\n    return 0;\n\ncleanup:\n    // clean up lingering resources\n#ifndef LFS_READONLY\n    file->flags |= LFS_F_ERRED;\n#endif\n    lfs_file_close_(lfs, file);\n    return err;\n}\n```\n</target_code>\n<response format>\nProvide your answer with these fields.\n- explanation: your evaluation of the scenario provided by the agent A.\n- is_report_correct: whether the report is correct or not (true/false). True means there is a violation.\n</response format>\n<scenario>\nThe agent A provided the following violation scenario:\nYes. The call creates attributes with a pointer to the file name (path, declared as const char *). If the struct lfs_mattr (created by LFS_MKATTRS/LFS_MKTAG) stores that buffer as a non-const pointer (e.g. void *buffer or char *), then a const char * is being passed/assigned to a non-const pointer. This discards the const qualifier and means the pointer type is not const-qualified even though the data is not modified \u2014 violating MISRA C 2023 Rule 8.13. (If lfs_mattr actually uses a const-qualified pointer for the buffer field, then there is no violation.)\n</scenario>\n\n<execution_log>\nThe agent A also provided the following output log:\nENTER lfs_file_opencfg_: lfs=0x7ffd1672ad88 file=0x7ffd1672ab20 path=breakfast/bacon flags=0x902 cfg=0x5583ef557f10\nlfs_fs_forceconsistency returned 0\nafter setup: file=0x7ffd1672ab20 cfg=0x5583ef557f10 flags=0x902 pos=0 off=0 cache.buffer=(nil)\ncfg: attr_count=0 buffer=(nil)\nlfs_dir_find returned tag=0xFFFFFFFE file->id=0 path_after_find=bacon\nafter mlist append: file->type=1\nname length=5 max=255\ncalling lfs_dir_commit to create new file: path=bacon nlen=5\nlfs_dir_commit returned 0\ncreated new file, set tag to INLINESTRUCT: 0x20100000\nallocated cache buffer: 0x55842334f010 (size=64)\ncache zeroed: cache.buffer=0x55842334f010 cache.size=4344\nINLINESTRUCT: head=4294967294 size=0 cache.size=64\nEXIT lfs_file_opencfg_ success: file=0x7ffd1672ab20\nENTER lfs_file_opencfg_: lfs=0x7ffd1672ad88 file=0x7ffd1672ab88 path=breakfast/eggs flags=0x902 cfg=0x5583ef557f10\nlfs_fs_forceconsistency returned 0\nafter setup: file=0x7ffd1672ab88 cfg=0x5583ef557f10 flags=0x902 pos=0 off=0 cache.buffer=(nil)\ncfg: attr_count=0 buffer=(nil)\nlfs_dir_find returned tag=0xFFFFFFFE file->id=1 path_after_find=eggs\nafter mlist append: file->type=1\nname length=4 max=255\ncalling lfs_dir_commit to create new file: path=eggs nlen=4\nlfs_dir_commit returned 0\ncreated new file, set tag to INLINESTRUCT: 0x20100000\nallocated cache buffer: 0x55842334f060 (size=64)\ncache zeroed: cache.buffer=0x55842334f060 cache.size=3577624276\nINLINESTRUCT: head=4294967294 size=0 cache.size=64\nEXIT lfs_file_opencfg_ success: file=0x7ffd1672ab88\nENTER lfs_file_opencfg_: lfs=0x7ffd1672ad88 file=0x7ffd1672abf0 path=breakfast/pancakes flags=0x902 cfg=0x5583ef557f10\nlfs_fs_forceconsistency returned 0\nafter setup: file=0x7ffd1672abf0 cfg=0x5583ef557f10 flags=0x902 pos=0 off=0 cache.buffer=(nil)\ncfg: attr_count=0 buffer=(nil)\nlfs_dir_find returned tag=0xFFFFFFFE file->id=2 path_after_find=pancakes\nafter mlist append: file->type=1\nname length=8 max=255\ncalling lfs_dir_commit to create new file: path=pancakes nlen=8\nlfs_dir_commit returned 0\ncreated new file, set tag to INLINESTRUCT: 0x20100000\nallocated cache buffer: 0x55842334f0b0 (size=64)\ncache zeroed: cache.buffer=0x55842334f0b0 cache.size=0\nINLINESTRUCT: head=4294967294 size=0 cache.size=64\nEXIT lfs_file_opencfg_ success: file=0x7ffd1672abf0\nENTER lfs_file_opencfg_: lfs=0x7ffd1672ad88 file=0x7ffd1672ad20 path=breakfast/bacon flags=0x1 cfg=0x5583ef557f10\nafter setup: file=0x7ffd1672ad20 cfg=0x5583ef557f10 flags=0x1 pos=0 off=0 cache.buffer=(nil)\ncfg: attr_count=0 buffer=(nil)\nlfs_dir_find returned tag=0x100005 file->id=0 path_after_find=bacon\nafter mlist append: file->type=1\nloading struct from disk: file->id=0\nlfs_dir_get returned tag=0x20200008\nloaded ctz: head=1965 size=343060\nallocated cache buffer: 0x55842334f0b0 (size=64)\ncache zeroed: cache.buffer=0x55842334f0b0 cache.size=163808\nEXIT lfs_file_opencfg_ success: file=0x7ffd1672ad20\nENTER lfs_file_opencfg_: lfs=0x7ffd1672ad88 file=0x7ffd1672ad20 path=breakfast/eggs flags=0x1 cfg=0x5583ef557f10\nafter setup: file=0x7ffd1672ad20 cfg=0x5583ef557f10 flags=0x1 pos=0 off=0 cache.buffer=(nil)\ncfg: attr_count=0 buffer=(nil)\nlfs_dir_find returned tag=0x100404 file->id=1 path_after_find=eggs\nafter mlist append: file->type=1\nloading struct from disk: file->id=1\nlfs_dir_get returned tag=0x20200408\nloaded ctz: head=600 size=343056\nallocated cache buffer: 0x55842334f0b0 (size=64)\ncache zeroed: cache.buffer=0x55842334f0b0 cache.size=64\nEXIT lfs_file_opencfg_ success: file=0x7ffd1672ad20\nENTER lfs_file_opencfg_: lfs=0x7ffd1672ad88 file=0x7ffd1672ad20 path=breakfast/pancakes flags=0x1 cfg=0x5583ef557f10\nafter setup: file=0x7ffd1672ad20 cfg=0x5583ef557f10 flags=0x1 pos=0 off=0 cache.buffer=(nil)\ncfg: attr_count=0 buffer=(nil)\nlfs_dir_find returned tag=0x100808 file->id=2 path_after_find=pancakes\nafter mlist append: file->type=1\nloading struct from disk: file->id=2\nlfs_dir_get returned tag=0x20200808\nloaded ctz: head=1281 size=343056\nallocated cache buffer: 0x55842334f0b0 (size=64)\ncache zeroed: cache.buffer=0x55842334f0b0 cache.size=64\nEXIT lfs_file_opencfg_ success: file=0x7ffd1672ad20\nENTER lfs_fi\n</execution_log>\n<additional code>Here are the definitions of symbols that are close to the target function lfs_file_opencfg_:\nstatic lfs_stag_t lfs_dir_find(lfs_t *lfs, lfs_mdir_t *dir,\n        const char **path, uint16_t *id) {\n    // we reduce path to a single name if we can find it\n    const char *name = *path;\n\n    // default to root dir\n    lfs_stag_t tag = LFS_MKTAG(LFS_TYPE_DIR, 0x3ff, 0);\n    dir->tail[0] = lfs->root[0];\n    dir->tail[1] = lfs->root[1];\n\n    // empty paths are not allowed\n    if (*name == '\\0') {\n        return LFS_ERR_INVAL;\n    }\n\n    while (true) {\nnextname:\n        // skip slashes if we're a directory\n        if (lfs_tag_type3(tag) == LFS_TYPE_DIR) {\n            name += strspn(name, \"/\");\n        }\n        lfs_size_t namelen = strcspn(name, \"/\");\n\n        // skip '.'\n        if (namelen == 1 && memcmp(name, \".\", 1) == 0) {\n            name += namelen;\n            goto nextname;\n        }\n\n        // error on unmatched '..', trying to go above root?\n        if (namelen == 2 && memcmp(name, \"..\", 2) == 0) {\n            return LFS_ERR_INVAL;\n        }\n\n        // skip if matched by '..' in name\n        const char *suffix = name + namelen;\n        lfs_size_t sufflen;\n        int depth = 1;\n        while (true) {\n            suffix += strspn(suffix, \"/\");\n            sufflen = strcspn(suffix, \"/\");\n            if (sufflen == 0) {\n                break;\n            }\n\n            if (sufflen == 1 && memcmp(suffix, \".\", 1) == 0) {\n                // noop\n            } else if (sufflen == 2 && memcmp(suffix, \"..\", 2) == 0) {\n                depth -= 1;\n                if (depth == 0) {\n                    name = suffix + sufflen;\n                    goto nextname;\n                }\n            } else {\n                depth += 1;\n            }\n\n            suffix += sufflen;\n        }\n\n        // found path\n        if (*name == '\\0') {\n            return tag;\n        }\n\n        // update what we've found so far\n        *path = name;\n\n        // only continue if we're a directory\n        if (lfs_tag_type3(tag) != LFS_TYPE_DIR) {\n            return LFS_ERR_NOTDIR;\n        }\n\n        // grab the entry data\n        if (lfs_tag_id(tag) != 0x3ff) {\n            lfs_stag_t res = lfs_dir_get(lfs, dir, LFS_MKTAG(0x700, 0x3ff, 0),\n                    LFS_MKTAG(LFS_TYPE_STRUCT, lfs_tag_id(tag), 8), dir->tail);\n            if (res < 0) {\n                return res;\n            }\n            lfs_pair_fromle32(dir->tail);\n        }\n\n        // find entry matching name\n        while (true) {\n            tag = lfs_dir_fetchmatch(lfs, dir, dir->tail,\n                    LFS_MKTAG(0x780, 0, 0),\n                    LFS_MKTAG(LFS_TYPE_NAME, 0, namelen),\n                    id,\n                    lfs_dir_find_match, &(struct lfs_dir_find_match){\n                        lfs, name, namelen});\n            if (tag < 0) {\n                return tag;\n            }\n\n            if (tag) {\n                break;\n            }\n\n            if (!dir->split) {\n                return LFS_ERR_NOENT;\n            }\n        }\n\n        // to next name\n        name += namelen;\n    }\n}\n...\nstatic int lfs_dir_commit(lfs_t *lfs, lfs_mdir_t *dir,\n        const struct lfs_mattr *attrs, int attrcount) {\n    int orphans = lfs_dir_orphaningcommit(lfs, dir, attrs, attrcount);\n    if (orphans < 0) {\n        return orphans;\n    }\n\n    if (orphans) {\n        // make sure we've removed all orphans, this is a noop if there\n        // are none, but if we had nested blocks failures we may have\n        // created some\n        int err = lfs_fs_deorphan(lfs, false);\n        if (err) {\n            return err;\n        }\n    }\n\n    return 0;\n}\n...\nstatic lfs_stag_t lfs_dir_get(lfs_t *lfs, const lfs_mdir_t *dir,\n        lfs_tag_t gmask, lfs_tag_t gtag, void *buffer) {\n    return lfs_dir_getslice(lfs, dir,\n            gmask, gtag,\n            0, buffer, lfs_tag_size(gtag));\n}\n...\nstatic inline bool lfs_path_islast(const char *path) {\n    lfs_size_t namelen = lfs_path_namelen(path);\n    return path[namelen + strspn(path + namelen, \"/\")] == '\\0';\n}\n...\nstatic inline bool lfs_path_isdir(const char *path) {\n    return path[lfs_path_namelen(path)] != '\\0';\n}\n</additional code>\n\n<instruction>\nJudge whether the report is correct or not.\n</instruction>\n",
  "is_report_correct": false,
  "explanation": "The report is not supported by the provided code. The call to lfs_dir_commit is passing a const char * (path) inside an attrs initializer, but lfs_dir_commit takes a const struct lfs_mattr *attrs. That strongly indicates the attr structure is intended to hold read-only data (and in the real littlefs implementation the attr buffer field is a const-qualified pointer, e.g. const void *). Passing a const char * to a const void * (or other const-qualified pointer) does not discard qualifiers and does not violate Rule 8.13. \n\nBy contrast, the scenario described by agent A (where struct lfs_mattr.buffer is a non-const pointer type such as void *) would indeed discard the const qualifier and could violate Rule 8.13. However there is no evidence of that in the snippets you provided (and the API using const struct lfs_mattr *attrs suggests the buffer is const-qualified). Therefore the reported violation is not correct for the given code.\n"
}