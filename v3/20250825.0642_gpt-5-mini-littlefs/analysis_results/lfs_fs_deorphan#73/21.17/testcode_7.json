{
  "user_message": "<misra_rule>\nMISRA C 2023 Rule 21.17 is: Use of the string handling functions from <string.h> shall not result in accesses beyond the bounds of the objects referenced by their pointer parameters.\nThis rule strictly applies to the Standard Library functions in <string.h> such as memcpy, memmove, memset, memcmp, strcpy, strncpy, strcat, strncat, strlen, and strspn.\n</misra_rule>\n\nAnother agent reported that the target code violated the Rule 21.17.\nHere is the comment from the agent.\n<violation scenario>\nlfs_dir_get forwards buffer and a length computed from gtag (lfs_tag_size(gtag)) to lfs_dir_getslice without validating that the provided buffer is at least that size. If a caller passes a gtag indicating size N while buffer points to a smaller object of size M < N, a subsequent lfs_dir_getslice implementation that uses memcpy/memmove/memset (from <string.h>) with that length will access beyond the bounds of buffer, violating Rule 21.17.\n</violation scenario>\n\nYour job is to insert logging code to capture the control flow and state information of the program.\nInsert logging code so that other agents can reproduce and get evidence for the violation scenario.\n<response format>\n- test_code: a modified lfs_fs_deorphan code that contains useful probe functions that print useful logs to a file \"/tmp/logs/739.txt\". The logs should contain the control path and state information of the violation scenario. If test code is not required to validate the scenario, you can leave this blank.\nHere are the constraints for the test code:\n- The test code MUST preserve the original logic of lfs_fs_deorphan as much as possible.\nYou CAN just insert probe functions to the original code.\n- DO NOT introduce new violations to demonstrate your scenario.\n- The test code MUST be compilable and executable.\n- The test code MUST include line breaks.\n- You MUST NOT define the main function.\n- You MUST NOT define macros.\n</response format>\n<target_code>\nHere is the code of lfs_fs_deorphan:\n```c\nstatic int lfs_fs_deorphan(lfs_t *lfs, bool powerloss) {\n    if (!lfs_gstate_hasorphans(&lfs->gstate)) {\n        return 0;\n    }\n\n    // Check for orphans in two separate passes:\n    // - 1 for half-orphans (relocations)\n    // - 2 for full-orphans (removes/renames)\n    //\n    // Two separate passes are needed as half-orphans can contain outdated\n    // references to full-orphans, effectively hiding them from the deorphan\n    // search.\n    //\n    int pass = 0;\n    while (pass < 2) {\n        // Fix any orphans\n        lfs_mdir_t pdir = {.split = true, .tail = {0, 1}};\n        lfs_mdir_t dir;\n        bool moreorphans = false;\n\n        // iterate over all directory directory entries\n        while (!lfs_pair_isnull(pdir.tail)) {\n            int err = lfs_dir_fetch(lfs, &dir, pdir.tail);\n            if (err) {\n                return err;\n            }\n\n            // check head blocks for orphans\n            if (!pdir.split) {\n                // check if we have a parent\n                lfs_mdir_t parent;\n                lfs_stag_t tag = lfs_fs_parent(lfs, pdir.tail, &parent);\n                if (tag < 0 && tag != LFS_ERR_NOENT) {\n                    return tag;\n                }\n\n                if (pass == 0 && tag != LFS_ERR_NOENT) {\n                    lfs_block_t pair[2];\n                    lfs_stag_t state = lfs_dir_get(lfs, &parent,\n                            LFS_MKTAG(0x7ff, 0x3ff, 0), tag, pair);\n                    if (state < 0) {\n                        return state;\n                    }\n                    lfs_pair_fromle32(pair);\n\n                    if (!lfs_pair_issync(pair, pdir.tail)) {\n                        // we have desynced\n                        LFS_DEBUG(\"Fixing half-orphan \"\n                                \"{0x%\"PRIx32\", 0x%\"PRIx32\"} \"\n                                \"-> {0x%\"PRIx32\", 0x%\"PRIx32\"}\",\n                                pdir.tail[0], pdir.tail[1], pair[0], pair[1]);\n\n                        // fix pending move in this pair? this looks like an\n                        // optimization but is in fact _required_ since\n                        // relocating may outdate the move.\n                        uint16_t moveid = 0x3ff;\n                        if (lfs_gstate_hasmovehere(&lfs->gstate, pdir.pair)) {\n                            moveid = lfs_tag_id(lfs->gstate.tag);\n                            LFS_DEBUG(\"Fixing move while fixing orphans \"\n                                    \"{0x%\"PRIx32\", 0x%\"PRIx32\"} 0x%\"PRIx16\"\\n\",\n                                    pdir.pair[0], pdir.pair[1], moveid);\n                            lfs_fs_prepmove(lfs, 0x3ff, NULL);\n                        }\n\n                        lfs_pair_tole32(pair);\n                        state = lfs_dir_orphaningcommit(lfs, &pdir, LFS_MKATTRS(\n                                {LFS_MKTAG_IF(moveid != 0x3ff,\n                                    LFS_TYPE_DELETE, moveid, 0), NULL},\n                                {LFS_MKTAG(LFS_TYPE_SOFTTAIL, 0x3ff, 8),\n                                    pair}));\n                        lfs_pair_fromle32(pair);\n                        if (state < 0) {\n                            return state;\n                        }\n\n                        // did our commit create more orphans?\n                        if (state == LFS_OK_ORPHANED) {\n                            moreorphans = true;\n                        }\n\n                        // refetch tail\n                        continue;\n                    }\n                }\n\n                // note we only check for full orphans if we may have had a\n                // power-loss, otherwise orphans are created intentionally\n                // during operations such as lfs_mkdir\n                if (pass == 1 && tag == LFS_ERR_NOENT && powerloss) {\n                    // we are an orphan\n                    LFS_DEBUG(\"Fixing orphan {0x%\"PRIx32\", 0x%\"PRIx32\"}\",\n                            pdir.tail[0], pdir.tail[1]);\n\n                    // steal state\n                    err = lfs_dir_getgstate(lfs, &dir, &lfs->gdelta);\n                    if (err) {\n                        return err;\n                    }\n\n                    // steal tail\n                    lfs_pair_tole32(dir.tail);\n                    int state = lfs_dir_orphaningcommit(lfs, &pdir, LFS_MKATTRS(\n                            {LFS_MKTAG(LFS_TYPE_TAIL + dir.split, 0x3ff, 8),\n                                dir.tail}));\n                    lfs_pair_fromle32(dir.tail);\n                    if (state < 0) {\n                        return state;\n                    }\n\n                    // did our commit create more orphans?\n                    if (state == LFS_OK_ORPHANED) {\n                        moreorphans = true;\n                    }\n\n                    // refetch tail\n                    continue;\n                }\n            }\n\n            pdir = dir;\n        }\n\n        pass = moreorphans ? 0 : pass+1;\n    }\n\n    // mark orphans as fixed\n    return lfs_fs_preporphans(lfs, -lfs_gstate_getorphans(&lfs->gstate));\n}\n```\n</target_code>\nPlease provide the modified lfs_fs_deorphan code.\n",
  "test_code": "#include <stdio.h>\n#include <stdarg.h>\n#include <inttypes.h>\n\n/* Probe logging helper. Appends logs to /tmp/logs/739.txt. */\nstatic void lfs_probe_log(const char *fmt, ...) {\n    FILE *f = fopen(\"/tmp/logs/739.txt\", \"a\");\n    if (!f) {\n        return;\n    }\n\n    va_list ap;\n    va_start(ap, fmt);\n    vfprintf(f, fmt, ap);\n    fprintf(f, \"\\n\");\n    va_end(ap);\n\n    fclose(f);\n}\n\n/* Small helpers to print common structures used in lfs_fs_deorphan. These\n   deliberately take generic pointers/integers to avoid introducing\n   dependencies on other declarations. */\nstatic void lfs_probe_print_pair(const char *label, const uint32_t pair[2]) {\n    lfs_probe_log(\"%s: {0x%08\" PRIx32 \", 0x%08\" PRIx32 \"}\", label, pair[0], pair[1]);\n}\n\nstatic void lfs_probe_print_mdir(const char *label, const lfs_mdir_t *mdir) {\n    if (!mdir) {\n        lfs_probe_log(\"%s: <null>\", label);\n        return;\n    }\n    lfs_probe_log(\"%s.split=%d\", label, (int)mdir->split);\n    lfs_probe_log(\"%s.tail: {0x%08\" PRIx32 \", 0x%08\" PRIx32 \"}\", label, mdir->tail[0], mdir->tail[1]);\n    lfs_probe_log(\"%s.pair: {0x%08\" PRIx32 \", 0x%08\" PRIx32 \"}\", label, mdir->pair[0], mdir->pair[1]);\n}\n\n/* Modified function with probes inserted. Logic preserved, only logging added. */\nstatic int lfs_fs_deorphan(lfs_t *lfs, bool powerloss) {\n    lfs_probe_log(\"ENTER lfs_fs_deorphan: lfs=%p, powerloss=%d\", (void*)lfs, (int)powerloss);\n\n    if (!lfs_gstate_hasorphans(&lfs->gstate)) {\n        lfs_probe_log(\"No orphans present. Exiting.\");\n        return 0;\n    }\n\n    lfs_probe_log(\"Orphans detected. Beginning two-pass deorphaning.\");\n\n    // Check for orphans in two separate passes:\n    // - 1 for half-orphans (relocations)\n    // - 2 for full-orphans (removes/renames)\n    //\n    // Two separate passes are needed as half-orphans can contain outdated\n    // references to full-orphans, effectively hiding them from the deorphan\n    // search.\n    //\n    int pass = 0;\n    while (pass < 2) {\n        // Fix any orphans\n        lfs_mdir_t pdir = {.split = true, .tail = {0, 1}};\n        lfs_mdir_t dir;\n        bool moreorphans = false;\n\n        lfs_probe_log(\"Starting pass %d\", pass);\n\n        // iterate over all directory directory entries\n        while (!lfs_pair_isnull(pdir.tail)) {\n            lfs_probe_log(\"About to fetch dir for pdir.tail {0x%08\" PRIx32 \", 0x%08\" PRIx32 \"}\", pdir.tail[0], pdir.tail[1]);\n            int err = lfs_dir_fetch(lfs, &dir, pdir.tail);\n            lfs_probe_log(\"lfs_dir_fetch returned %d for tail {0x%08\" PRIx32 \", 0x%08\" PRIx32 \"}\", err, pdir.tail[0], pdir.tail[1]);\n            if (err) {\n                lfs_probe_log(\"lfs_dir_fetch error, returning %d\", err);\n                return err;\n            }\n\n            lfs_probe_print_mdir(\"pdir (before checks)\", &pdir);\n            lfs_probe_print_mdir(\"dir (fetched)\", &dir);\n\n            // check head blocks for orphans\n            if (!pdir.split) {\n                // check if we have a parent\n                lfs_mdir_t parent;\n                lfs_probe_log(\"Calling lfs_fs_parent for pdir.tail {0x%08\" PRIx32 \", 0x%08\" PRIx32 \"}\", pdir.tail[0], pdir.tail[1]);\n                lfs_stag_t tag = lfs_fs_parent(lfs, pdir.tail, &parent);\n                lfs_probe_log(\"lfs_fs_parent returned tag=%d\", (int)tag);\n                if (tag < 0 && tag != LFS_ERR_NOENT) {\n                    lfs_probe_log(\"lfs_fs_parent returned fatal error %d\", (int)tag);\n                    return tag;\n                }\n\n                lfs_probe_print_mdir(\"parent (from lfs_fs_parent)\", &parent);\n\n                if (pass == 0 && tag != LFS_ERR_NOENT) {\n                    lfs_block_t pair[2];\n\n                    /* Probe: log parameters just before calling lfs_dir_get.\n                       This is important for reproducing the scenario where the\n                       caller supplies a buffer (pair) that may be smaller than\n                       the length derived from 'tag' inside lfs_dir_get. */\n                    lfs_probe_log(\"Preparing to call lfs_dir_get: parent=%p, out_pair=%p, parent_tag=%d\", (void*)&parent, (void*)pair, (int)tag);\n\n                    lfs_stag_t state = lfs_dir_get(lfs, &parent,\n                            LFS_MKTAG(0x7ff, 0x3ff, 0), tag, pair);\n                    lfs_probe_log(\"lfs_dir_get returned state=%d\", (int)state);\n                    if (state < 0) {\n                        lfs_probe_log(\"lfs_dir_get error, returning %d\", (int)state);\n                        return state;\n                    }\n                    lfs_pair_fromle32(pair);\n\n                    lfs_probe_print_pair(\"pair (from lfs_dir_get)\", pair);\n\n                    if (!lfs_pair_issync(pair, pdir.tail)) {\n                        // we have desynced\n                        LFS_DEBUG(\"Fixing half-orphan \"\n                                \"{0x%\" PRIx32 \", 0x%\" PRIx32 \"} \"\n                                \"-> {0x%\" PRIx32 \", 0x%\" PRIx32 \"}\",\n                                pdir.tail[0], pdir.tail[1], pair[0], pair[1]);\n\n                        lfs_probe_log(\"Half-orphan detected: pdir.tail differs from pair returned by parent\");\n\n                        // fix pending move in this pair? this looks like an\n                        // optimization but is in fact _required_ since\n                        // relocating may outdate the move.\n                        uint16_t moveid = 0x3ff;\n                        if (lfs_gstate_hasmovehere(&lfs->gstate, pdir.pair)) {\n                            moveid = lfs_tag_id(lfs->gstate.tag);\n                            LFS_DEBUG(\"Fixing move while fixing orphans \"\n                                    \"{0x%\" PRIx32 \", 0x%\" PRIx32 \"} 0x%\" PRIx16 \"\\n\",\n                                    pdir.pair[0], pdir.pair[1], moveid);\n                            lfs_probe_log(\"Detected pending move at pdir.pair, moveid=0x%03\" PRIx16, moveid);\n                            lfs_fs_prepmove(lfs, 0x3ff, NULL);\n                        }\n\n                        lfs_pair_tole32(pair);\n                        state = lfs_dir_orphaningcommit(lfs, &pdir, LFS_MKATTRS(\n                                {LFS_MKTAG_IF(moveid != 0x3ff,\n                                    LFS_TYPE_DELETE, moveid, 0), NULL},\n                                {LFS_MKTAG(LFS_TYPE_SOFTTAIL, 0x3ff, 8),\n                                    pair}));\n                        lfs_pair_fromle32(pair);\n                        lfs_probe_log(\"lfs_dir_orphaningcommit returned state=%d\", (int)state);\n                        if (state < 0) {\n                            lfs_probe_log(\"lfs_dir_orphaningcommit error, returning %d\", (int)state);\n                            return state;\n                        }\n\n                        // did our commit create more orphans?\n                        if (state == LFS_OK_ORPHANED) {\n                            moreorphans = true;\n                            lfs_probe_log(\"Orphaning commit reported LFS_OK_ORPHANED\");\n                        }\n\n                        // refetch tail\n                        lfs_probe_log(\"Refetching tail after orphaning commit (continue loop)\");\n                        continue;\n                    }\n                }\n\n                // note we only check for full orphans if we may have had a\n                // power-loss, otherwise orphans are created intentionally\n                // during operations such as lfs_mkdir\n                if (pass == 1 && tag == LFS_ERR_NOENT && powerloss) {\n                    // we are an orphan\n                    LFS_DEBUG(\"Fixing orphan {0x%\" PRIx32 \", 0x%\" PRIx32 \"}\",\n                            pdir.tail[0], pdir.tail[1]);\n\n                    lfs_probe_log(\"Full-orphan detected at pdir.tail {0x%08\" PRIx32 \", 0x%08\" PRIx32 \"}, stealing state\", pdir.tail[0], pdir.tail[1]);\n\n                    // steal state\n                    err = lfs_dir_getgstate(lfs, &dir, &lfs->gdelta);\n                    lfs_probe_log(\"lfs_dir_getgstate returned %d\", err);\n                    if (err) {\n                        lfs_probe_log(\"lfs_dir_getgstate error, returning %d\", err);\n                        return err;\n                    }\n\n                    // steal tail\n                    lfs_pair_tole32(dir.tail);\n                    int state = lfs_dir_orphaningcommit(lfs, &pdir, LFS_MKATTRS(\n                            {LFS_MKTAG(LFS_TYPE_TAIL + dir.split, 0x3ff, 8),\n                                dir.tail}));\n                    lfs_pair_fromle32(dir.tail);\n                    lfs_probe_log(\"lfs_dir_orphaningcommit (full orphan) returned state=%d\", state);\n                    if (state < 0) {\n                        lfs_probe_log(\"lfs_dir_orphaningcommit error (full orphan), returning %d\", state);\n                        return state;\n                    }\n\n                    // did our commit create more orphans?\n                    if (state == LFS_OK_ORPHANED) {\n                        moreorphans = true;\n                        lfs_probe_log(\"Full-orphaning commit reported LFS_OK_ORPHANED\");\n                    }\n\n                    // refetch tail\n                    lfs_probe_log(\"Refetching tail after full-orphaning commit (continue loop)\");\n                    continue;\n                }\n            }\n\n            /* advance: set pdir = dir; we log the transition so the trace\n               shows how the iteration progressed. */\n            lfs_probe_log(\"Advancing pdir = dir; next loop iteration\");\n            pdir = dir;\n        }\n\n        pass = moreorphans ? 0 : pass+1;\n        lfs_probe_log(\"End of pass: pass=%d, moreorphans=%d\", pass, (int)moreorphans);\n    }\n\n    // mark orphans as fixed\n    int ret = lfs_fs_preporphans(lfs, -lfs_gstate_getorphans(&lfs->gstate));\n    lfs_probe_log(\"Exiting lfs_fs_deorphan with return %d\", ret);\n    return ret;\n}\n"
}