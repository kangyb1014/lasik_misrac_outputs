{
  "user_message": "An agent A claimed that the following lfs_rename code violates the MISRA C 2023 rule 17.8.\n<misra_rule>\nMISRA C 2023 Rule 17.8 is A function parameter should not be modified.\nNote that the object referred to by a pointer parameter may be modified, but the pointer itself shall not be modified.\n</misra_rule>\n<target_code>\nHere is the original code of lfs_rename.\n```c\nint lfs_rename(lfs_t *lfs, const char *oldpath, const char *newpath) {\n    int err = LFS_LOCK(lfs->cfg);\n    if (err) {\n        return err;\n    }\n    LFS_TRACE(\"lfs_rename(%p, \\\"%s\\\", \\\"%s\\\")\", (void*)lfs, oldpath, newpath);\n\n    err = lfs_rename_(lfs, oldpath, newpath);\n\n    LFS_TRACE(\"lfs_rename -> %d\", err);\n    LFS_UNLOCK(lfs->cfg);\n    return err;\n}\n```\n</target_code>\n<response format>\nProvide your answer with these fields.\n- explanation: your evaluation of the scenario provided by the agent A.\n- is_report_correct: whether the report is correct or not (true/false). True means there is a violation.\n</response format>\n<scenario>\nThe agent A provided the following violation scenario:\nViolation: the function lfs_rename_ takes parameter 'const char *oldpath' and then passes its address (&oldpath) to lfs_dir_find. That allows lfs_dir_find to modify the pointer variable oldpath (e.g. advance it to subsequent path components). Rule 17.8 forbids modifying a function parameter itself (the pointer), even though the object pointed to may be modified. Therefore this usage violates MISRA C 2023 Rule 17.8.\n</scenario>\n\n<execution_log>\nThe agent A also provided the following output log:\nlfs_rename:before_call: lfs=0x7ffee0924860, oldpath_ptr=0x7ffee0924a08, &oldpath=0x7ffee0924638, oldpath_str=\"test000\", newpath_ptr=0x7ffee0924a88, &newpath=0x7ffee0924630, newpath_str=\"tedd000\", err=0\nlfs_rename:after_call: lfs=0x7ffee0924860, oldpath_ptr=0x7ffee0924a08, &oldpath=0x7ffee0924648, oldpath_str=\"test000\", newpath_ptr=0x7ffee0924a88, &newpath=0x7ffee0924640, newpath_str=\"tedd000\", err=0\nlfs_rename:before_call: lfs=0x7ffee0924860, oldpath_ptr=0x7ffee0924a08, &oldpath=0x7ffee0924638, oldpath_str=\"test001\", newpath_ptr=0x7ffee0924a88, &newpath=0x7ffee0924630, newpath_str=\"tedd001\", err=0\nlfs_rename:after_call: lfs=0x7ffee0924860, oldpath_ptr=0x7ffee0924a08, &oldpath=0x7ffee0924648, oldpath_str=\"test001\", newpath_ptr=0x7ffee0924a88, &newpath=0x7ffee0924640, newpath_str=\"tedd001\", err=0\nlfs_rename:before_call: lfs=0x7ffee0924860, oldpath_ptr=0x7ffee0924a08, &oldpath=0x7ffee0924638, oldpath_str=\"test002\", newpath_ptr=0x7ffee0924a88, &newpath=0x7ffee0924630, newpath_str=\"tedd002\", err=0\nlfs_rename:after_call: lfs=0x7ffee0924860, oldpath_ptr=0x7ffee0924a08, &oldpath=0x7ffee0924648, oldpath_str=\"test002\", newpath_ptr=0x7ffee0924a88, &newpath=0x7ffee0924640, newpath_str=\"tedd002\", err=0\nlfs_rename:before_call: lfs=0x7ffee0924860, oldpath_ptr=0x7ffee0924a08, &oldpath=0x7ffee0924638, oldpath_str=\"test000\", newpath_ptr=0x7ffee0924a88, &newpath=0x7ffee0924630, newpath_str=\"tedd000\", err=0\nlfs_rename:after_call: lfs=0x7ffee0924860, oldpath_ptr=0x7ffee0924a08, &oldpath=0x7ffee0924648, oldpath_str=\"test000\", newpath_ptr=0x7ffee0924a88, &newpath=0x7ffee0924640, newpath_str=\"tedd000\", err=0\nlfs_rename:before_call: lfs=0x7ffee0924860, oldpath_ptr=0x7ffee0924a08, &oldpath=0x7ffee0924638, oldpath_str=\"test001\", newpath_ptr=0x7ffee0924a88, &newpath=0x7ffee0924630, newpath_str=\"tedd001\", err=0\nlfs_rename:after_call: lfs=0x7ffee0924860, oldpath_ptr=0x7ffee0924a08, &oldpath=0x7ffee0924648, oldpath_str=\"test001\", newpath_ptr=0x7ffee0924a88, &newpath=0x7ffee0924640, newpath_str=\"tedd001\", err=0\nlfs_rename:before_call: lfs=0x7ffee0924860, oldpath_ptr=0x7ffee0924a08, &oldpath=0x7ffee0924638, oldpath_str=\"test002\", newpath_ptr=0x7ffee0924a88, &newpath=0x7ffee0924630, newpath_str=\"tedd002\", err=0\nlfs_rename:after_call: lfs=0x7ffee0924860, oldpath_ptr=0x7ffee0924a08, &oldpath=0x7ffee0924648, oldpath_str=\"test002\", newpath_ptr=0x7ffee0924a88, &newpath=0x7ffee0924640, newpath_str=\"tedd002\", err=0\nlfs_rename:before_call: lfs=0x7ffee0924860, oldpath_ptr=0x7ffee0924a08, &oldpath=0x7ffee0924638, oldpath_str=\"test000\", newpath_ptr=0x7ffee0924a88, &newpath=0x7ffee0924630, newpath_str=\"tedd000\", err=0\nlfs_rename:after_call: lfs=0x7ffee0924860, oldpath_ptr=0x7ffee0924a08, &oldpath=0x7ffee0924648, oldpath_str=\"test000\", newpath_ptr=0x7ffee0924a88, &newpath=0x7ffee0924640, newpath_str=\"tedd000\", err=0\nlfs_rename:before_call: lfs=0x7ffee0924860, oldpath_ptr=0x7ffee0924a08, &oldpath=0x7ffee0924638, oldpath_str=\"test001\", newpath_ptr=0x7ffee0924a88, &newpath=0x7ffee0924630, newpath_str=\"tedd001\", err=0\nlfs_rename:after_call: lfs=0x7ffee0924860, oldpath_ptr=0x7ffee0924a08, &oldpath=0x7ffee0924648, oldpath_str=\"test001\", newpath_ptr=0x7ffee0924a88, &newpath=0x7ffee0924640, newpath_str=\"tedd001\", err=0\nlfs_rename:before_call: lfs=0x7ffee0924860, oldpath_ptr=0x7ffee0924a08, &oldpath=0x7ffee0924638, oldpath_str=\"test002\", newpath_ptr=0x7ffee0924a88, &newpath=0x7ffee0924630, newpath_str=\"tedd002\", err=0\nlfs_rename:after_call: lfs=0x7ffee0924860, oldpath_ptr=0x7ffee0924a08, &oldpath=0x7ffee0924648, oldpath_str=\"test002\", newpath_ptr=0x7ffee0924a88, &newpath=0x7ffee0924640, newpath_str=\"tedd002\", err=0\nlfs_rename:before_call: lfs=0x7ffee0924860, oldpath_ptr=0x7ffee0924a08, &oldpath=0x7ffee0924638, oldpath_str=\"test000\", newpath_ptr=0x7ffee0924a88, &newpath=0x7ffee0924630, newpath_str=\"tedd000\", err=0\nlfs_rename:after_call: lfs=0x7ffee0924860, oldpath_ptr=0x7ffee0924a08, &oldpath=0x7ffee0924648, oldpath_str=\"test000\", newpath_ptr=0x7ffee0924a88, &newpath=0x7ffee0924640, newpath_str=\"tedd000\", err=0\nlfs_rename:before_call: lfs=0x7ffee0924860, oldpath_ptr=0x7ffee092\n</execution_log>\n<additional code>Here are the definitions of symbols that are close to the target function lfs_rename:\n#define LFS_LOCK(cfg) ((void)cfg,0)\n...\n#define LFS_UNLOCK(cfg) ((void)cfg)\n...\n#define LFS_TRACE(__VA_ARGS__) \n...\nstatic int lfs_rename_(lfs_t *lfs, const char *oldpath, const char *newpath) {\n    // deorphan if we haven't yet, needed at most once after poweron\n    int err = lfs_fs_forceconsistency(lfs);\n    if (err) {\n        return err;\n    }\n\n    // find old entry\n    lfs_mdir_t oldcwd;\n    lfs_stag_t oldtag = lfs_dir_find(lfs, &oldcwd, &oldpath, NULL);\n    if (oldtag < 0 || lfs_tag_id(oldtag) == 0x3ff) {\n        return (oldtag < 0) ? (int)oldtag : LFS_ERR_INVAL;\n    }\n\n    // find new entry\n    lfs_mdir_t newcwd;\n    uint16_t newid;\n    lfs_stag_t prevtag = lfs_dir_find(lfs, &newcwd, &newpath, &newid);\n    if ((prevtag < 0 || lfs_tag_id(prevtag) == 0x3ff) &&\n            !(prevtag == LFS_ERR_NOENT && lfs_path_islast(newpath))) {\n        return (prevtag < 0) ? (int)prevtag : LFS_ERR_INVAL;\n    }\n\n    // if we're in the same pair there's a few special cases...\n    bool samepair = (lfs_pair_cmp(oldcwd.pair, newcwd.pair) == 0);\n    uint16_t newoldid = lfs_tag_id(oldtag);\n\n    struct lfs_mlist prevdir;\n    prevdir.next = lfs->mlist;\n    if (prevtag == LFS_ERR_NOENT) {\n        // if we're a file, don't allow trailing slashes\n        if (lfs_path_isdir(newpath)\n                && lfs_tag_type3(oldtag) != LFS_TYPE_DIR) {\n            return LFS_ERR_NOTDIR;\n        }\n\n        // check that name fits\n        lfs_size_t nlen = lfs_path_namelen(newpath);\n        if (nlen > lfs->name_max) {\n            return LFS_ERR_NAMETOOLONG;\n        }\n\n        // there is a small chance we are being renamed in the same\n        // directory/ to an id less than our old id, the global update\n        // to handle this is a bit messy\n        if (samepair && newid <= newoldid) {\n            newoldid += 1;\n        }\n    } else if (lfs_tag_type3(prevtag) != lfs_tag_type3(oldtag)) {\n        return (lfs_tag_type3(prevtag) == LFS_TYPE_DIR)\n                ? LFS_ERR_ISDIR\n                : LFS_ERR_NOTDIR;\n    } else if (samepair && newid == newoldid) {\n        // we're renaming to ourselves??\n        return 0;\n    } else if (lfs_tag_type3(prevtag) == LFS_TYPE_DIR) {\n        // must be empty before removal\n        lfs_block_t prevpair[2];\n        lfs_stag_t res = lfs_dir_get(lfs, &newcwd, LFS_MKTAG(0x700, 0x3ff, 0),\n                LFS_MKTAG(LFS_TYPE_STRUCT, newid, 8), prevpair);\n        if (res < 0) {\n            return (int)res;\n        }\n        lfs_pair_fromle32(prevpair);\n\n        // must be empty before removal\n        err = lfs_dir_fetch(lfs, &prevdir.m, prevpair);\n        if (err) {\n            return err;\n        }\n\n        if (prevdir.m.count > 0 || prevdir.m.split) {\n            return LFS_ERR_NOTEMPTY;\n        }\n\n        // mark fs as orphaned\n        err = lfs_fs_preporphans(lfs, +1);\n        if (err) {\n            return err;\n        }\n\n        // I know it's crazy but yes, dir can be changed by our parent's\n        // commit (if predecessor is child)\n        prevdir.type = 0;\n        prevdir.id = 0;\n        lfs->mlist = &prevdir;\n    }\n\n    if (!samepair) {\n        lfs_fs_prepmove(lfs, newoldid, oldcwd.pair);\n    }\n\n    // move over all attributes\n    err = lfs_dir_commit(lfs, &newcwd, LFS_MKATTRS(\n            {LFS_MKTAG_IF(prevtag != LFS_ERR_NOENT,\n                LFS_TYPE_DELETE, newid, 0), NULL},\n            {LFS_MKTAG(LFS_TYPE_CREATE, newid, 0), NULL},\n            {LFS_MKTAG(lfs_tag_type3(oldtag),\n                newid, lfs_path_namelen(newpath)), newpath},\n            {LFS_MKTAG(LFS_FROM_MOVE, newid, lfs_tag_id(oldtag)), &oldcwd},\n            {LFS_MKTAG_IF(samepair,\n                LFS_TYPE_DELETE, newoldid, 0), NULL}));\n    if (err) {\n        lfs->mlist = prevdir.next;\n        return err;\n    }\n\n    // let commit clean up after move (if we're different! otherwise move\n    // logic already fixed it for us)\n    if (!samepair && lfs_gstate_hasmove(&lfs->gstate)) {\n        // prep gstate and delete move id\n        lfs_fs_prepmove(lfs, 0x3ff, NULL);\n        err = lfs_dir_commit(lfs, &oldcwd, LFS_MKATTRS(\n                {LFS_MKTAG(LFS_TYPE_DELETE, lfs_tag_id(oldtag), 0), NULL}));\n        if (err) {\n            lfs->mlist = prevdir.next;\n            return err;\n        }\n    }\n\n    lfs->mlist = prevdir.next;\n    if (lfs_gstate_hasorphans(&lfs->gstate)) {\n        LFS_ASSERT(prevtag != LFS_ERR_NOENT\n                && lfs_tag_type3(prevtag) == LFS_TYPE_DIR);\n\n        // fix orphan\n        err = lfs_fs_preporphans(lfs, -1);\n        if (err) {\n            return err;\n        }\n\n        err = lfs_fs_pred(lfs, prevdir.m.pair, &newcwd);\n        if (err) {\n            return err;\n        }\n\n        err = lfs_dir_drop(lfs, &newcwd, &prevdir.m);\n        if (err) {\n            return err;\n        }\n    }\n\n    return 0;\n}\n</additional code>\n\n<instruction>\nJudge whether the report is correct or not.\n</instruction>\n",
  "is_report_correct": true,
  "explanation": "The report is correct. MISRA C:2023 Rule 17.8 forbids modifying a function parameter itself; while the object pointed to by a pointer parameter may be changed, the pointer variable shall not be modified. In lfs_rename_ the parameters are declared as const char *oldpath and const char *newpath and their addresses (&oldpath, &newpath) are passed to lfs_dir_find. If lfs_dir_find updates those pointers (which is the documented/typical behavior in littlefs to advance the path pointer), that writes into the parameter variables oldpath/newpath \u2014 i.e. it modifies the function parameters themselves \u2014 and therefore violates Rule 17.8. The top-level lfs_rename shown does not modify its parameters, but the static lfs_rename_ implementation does. A simple corrective fix is to copy the parameters into local pointer variables (e.g. const char *p_old = oldpath; const char *p_new = newpath;) and pass &p_old / &p_new to lfs_dir_find so the function parameters are not modified."
}