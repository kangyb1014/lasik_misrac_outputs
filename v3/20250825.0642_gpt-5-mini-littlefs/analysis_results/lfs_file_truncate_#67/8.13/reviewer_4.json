{
  "user_message": "An agent A claimed that the following lfs_file_truncate_ code violates the MISRA C 2023 rule 8.13.\n<misra_rule>\nMISRA C 2023 Rule 8.13 is A pointer should point to a const-qualified type whenever possible.\n\n</misra_rule>\n<target_code>\nHere is the original code of lfs_file_truncate_.\n```c\nstatic int lfs_file_truncate_(lfs_t *lfs, lfs_file_t *file, lfs_off_t size) {\n    LFS_ASSERT((file->flags & LFS_O_WRONLY) == LFS_O_WRONLY);\n\n    if (size > LFS_FILE_MAX) {\n        return LFS_ERR_INVAL;\n    }\n\n    lfs_off_t pos = file->pos;\n    lfs_off_t oldsize = lfs_file_size_(lfs, file);\n    if (size < oldsize) {\n        // revert to inline file?\n        if (size <= lfs->inline_max) {\n            // flush+seek to head\n            lfs_soff_t res = lfs_file_seek_(lfs, file, 0, LFS_SEEK_SET);\n            if (res < 0) {\n                return (int)res;\n            }\n\n            // read our data into rcache temporarily\n            lfs_cache_drop(lfs, &lfs->rcache);\n            res = lfs_file_flushedread(lfs, file,\n                    lfs->rcache.buffer, size);\n            if (res < 0) {\n                return (int)res;\n            }\n\n            file->ctz.head = LFS_BLOCK_INLINE;\n            file->ctz.size = size;\n            file->flags |= LFS_F_DIRTY | LFS_F_READING | LFS_F_INLINE;\n            file->cache.block = file->ctz.head;\n            file->cache.off = 0;\n            file->cache.size = lfs->cfg->cache_size;\n            memcpy(file->cache.buffer, lfs->rcache.buffer, size);\n\n        } else {\n            // need to flush since directly changing metadata\n            int err = lfs_file_flush(lfs, file);\n            if (err) {\n                return err;\n            }\n\n            // lookup new head in ctz skip list\n            err = lfs_ctz_find(lfs, NULL, &file->cache,\n                    file->ctz.head, file->ctz.size,\n                    size-1, &file->block, &(lfs_off_t){0});\n            if (err) {\n                return err;\n            }\n\n            // need to set pos/block/off consistently so seeking back to\n            // the old position does not get confused\n            file->pos = size;\n            file->ctz.head = file->block;\n            file->ctz.size = size;\n            file->flags |= LFS_F_DIRTY | LFS_F_READING;\n        }\n    } else if (size > oldsize) {\n        // flush+seek if not already at end\n        lfs_soff_t res = lfs_file_seek_(lfs, file, 0, LFS_SEEK_END);\n        if (res < 0) {\n            return (int)res;\n        }\n\n        // fill with zeros\n        while (file->pos < size) {\n            res = lfs_file_write_(lfs, file, &(uint8_t){0}, 1);\n            if (res < 0) {\n                return (int)res;\n            }\n        }\n    }\n\n    // restore pos\n    lfs_soff_t res = lfs_file_seek_(lfs, file, pos, LFS_SEEK_SET);\n    if (res < 0) {\n      return (int)res;\n    }\n\n    return 0;\n}\n```\n</target_code>\n<response format>\nProvide your answer with these fields.\n- explanation: your evaluation of the scenario provided by the agent A.\n- is_report_correct: whether the report is correct or not (true/false). True means there is a violation.\n</response format>\n<scenario>\nThe agent A provided the following violation scenario:\nThe call passes the address of a compound literal &(lfs_off_t){size-1} to lfs_ctz_index whose second parameter is (in the codebase) a non-const lfs_off_t*. The function only reads the value (all callers use it as an input), so the parameter should be declared as const lfs_off_t * to indicate read-only access. Because the pointer parameter is not const-qualified when it could be, this violates MISRA C 2023 Rule 8.13.\n</scenario>\n\n<execution_log>\nThe agent A also provided the following output log:\nENTER lfs_file_truncate_: lfs=0x7fff2219c008 file=0x7fff2219bfa0 size=502016 file->pos=502032 file->flags=0x102\nlfs_file_truncate_: computed oldsize=502032\nlfs_file_truncate_: branch size < oldsize (size=502016 oldsize=502032)\nlfs_file_truncate_: non-inline truncate path (size=502016 inline_max=64)\nlfs_file_truncate_: before lfs_ctz_find: ctz.head=0x15 ctz.size=502032 size-1=502015 compound_zero_addr=0x7fff2219bf30 compound_zero_val=0\nlfs_file_truncate_: lfs_ctz_find returned err=0, new block=0x14\nlfs_file_truncate_: after non-inline adjust: pos=502016 ctz.head=0x14 ctz.size=502016 flags=0x50102\nEXIT lfs_file_truncate_: success (restored pos=502032)\nENTER lfs_file_truncate_: lfs=0x7fff2219c008 file=0x7fff2219bfa0 size=502016 file->pos=502032 file->flags=0x102\nlfs_file_truncate_: computed oldsize=502032\nlfs_file_truncate_: branch size < oldsize (size=502016 oldsize=502032)\nlfs_file_truncate_: non-inline truncate path (size=502016 inline_max=64)\nlfs_file_truncate_: before lfs_ctz_find: ctz.head=0x3e2 ctz.size=502032 size-1=502015 compound_zero_addr=0x7fff2219bf30 compound_zero_val=0\nlfs_file_truncate_: lfs_ctz_find returned err=0, new block=0x3e1\nlfs_file_truncate_: after non-inline adjust: pos=502016 ctz.head=0x3e1 ctz.size=502016 flags=0x50102\nEXIT lfs_file_truncate_: success (restored pos=502032)\nENTER lfs_file_truncate_: lfs=0x7fff2219c008 file=0x7fff2219bfa0 size=503024 file->pos=503040 file->flags=0x102\nlfs_file_truncate_: computed oldsize=503040\nlfs_file_truncate_: branch size < oldsize (size=503024 oldsize=503040)\nlfs_file_truncate_: non-inline truncate path (size=503024 inline_max=64)\nlfs_file_truncate_: before lfs_ctz_find: ctz.head=0x369 ctz.size=503040 size-1=503023 compound_zero_addr=0x7fff2219bf30 compound_zero_val=0\nlfs_file_truncate_: lfs_ctz_find returned err=0, new block=0x368\nlfs_file_truncate_: after non-inline adjust: pos=503024 ctz.head=0x368 ctz.size=503024 flags=0x50102\nEXIT lfs_file_truncate_: success (restored pos=503040)\n\n</execution_log>\n<additional code>Here are the definitions of symbols that are close to the target function lfs_file_truncate_:\ntypedef struct lfs {\n    lfs_cache_t rcache;\n    lfs_cache_t pcache;\n\n    lfs_block_t root[2];\n    struct lfs_mlist {\n        struct lfs_mlist *next;\n        uint16_t id;\n        uint8_t type;\n        lfs_mdir_t m;\n    } *mlist;\n    uint32_t seed;\n\n    lfs_gstate_t gstate;\n    lfs_gstate_t gdisk;\n    lfs_gstate_t gdelta;\n\n    struct lfs_lookahead {\n        lfs_block_t start;\n        lfs_block_t size;\n        lfs_block_t next;\n        lfs_block_t ckpoint;\n        uint8_t *buffer;\n    } lookahead;\n\n    const struct lfs_config *cfg;\n    lfs_size_t block_count;\n    lfs_size_t name_max;\n    lfs_size_t file_max;\n    lfs_size_t attr_max;\n    lfs_size_t inline_max;\n\n#ifdef LFS_MIGRATE\n    struct lfs1 *lfs1;\n#endif\n} lfs_t\n...\ntypedef struct lfs_file {\n    struct lfs_file *next;\n    uint16_t id;\n    uint8_t type;\n    lfs_mdir_t m;\n\n    struct lfs_ctz {\n        lfs_block_t head;\n        lfs_size_t size;\n    } ctz;\n\n    uint32_t flags;\n    lfs_off_t pos;\n    lfs_block_t block;\n    lfs_off_t off;\n    lfs_cache_t cache;\n\n    const struct lfs_file_config *cfg;\n} lfs_file_t\n...\ntypedef uint32_t lfs_off_t\n...\ntypedef int32_t  lfs_soff_t\n...\nstatic lfs_ssize_t lfs_file_flushedread(lfs_t *lfs, lfs_file_t *file,\n        void *buffer, lfs_size_t size) {\n    uint8_t *data = buffer;\n    lfs_size_t nsize = size;\n\n    if (file->pos >= file->ctz.size) {\n        // eof if past end\n        return 0;\n    }\n\n    size = lfs_min(size, file->ctz.size - file->pos);\n    nsize = size;\n\n    while (nsize > 0) {\n        // check if we need a new block\n        if (!(file->flags & LFS_F_READING) ||\n                file->off == lfs->cfg->block_size) {\n            if (!(file->flags & LFS_F_INLINE)) {\n                int err = lfs_ctz_find(lfs, NULL, &file->cache,\n                        file->ctz.head, file->ctz.size,\n                        file->pos, &file->block, &file->off);\n                if (err) {\n                    return err;\n                }\n            } else {\n                file->block = LFS_BLOCK_INLINE;\n                file->off = file->pos;\n            }\n\n            file->flags |= LFS_F_READING;\n        }\n\n        // read as much as we can in current block\n        lfs_size_t diff = lfs_min(nsize, lfs->cfg->block_size - file->off);\n        if (file->flags & LFS_F_INLINE) {\n            int err = lfs_dir_getread(lfs, &file->m,\n                    NULL, &file->cache, lfs->cfg->block_size,\n                    LFS_MKTAG(0xfff, 0x1ff, 0),\n                    LFS_MKTAG(LFS_TYPE_INLINESTRUCT, file->id, 0),\n                    file->off, data, diff);\n            if (err) {\n                return err;\n            }\n        } else {\n            int err = lfs_bd_read(lfs,\n                    NULL, &file->cache, lfs->cfg->block_size,\n                    file->block, file->off, data, diff);\n            if (err) {\n                return err;\n            }\n        }\n\n        file->pos += diff;\n        file->off += diff;\n        data += diff;\n        nsize -= diff;\n    }\n\n    return size;\n}\n...\nstatic lfs_ssize_t lfs_file_write_(lfs_t *lfs, lfs_file_t *file,\n        const void *buffer, lfs_size_t size) {\n    LFS_ASSERT((file->flags & LFS_O_WRONLY) == LFS_O_WRONLY);\n\n    if (file->flags & LFS_F_READING) {\n        // drop any reads\n        int err = lfs_file_flush(lfs, file);\n        if (err) {\n            return err;\n        }\n    }\n\n    if ((file->flags & LFS_O_APPEND) && file->pos < file->ctz.size) {\n        file->pos = file->ctz.size;\n    }\n\n    if (file->pos + size > lfs->file_max) {\n        // Larger than file limit?\n        return LFS_ERR_FBIG;\n    }\n\n    if (!(file->flags & LFS_F_WRITING) && file->pos > file->ctz.size) {\n        // fill with zeros\n        lfs_off_t pos = file->pos;\n        file->pos = file->ctz.size;\n\n        while (file->pos < pos) {\n            lfs_ssize_t res = lfs_file_flushedwrite(lfs, file, &(uint8_t){0}, 1);\n            if (res < 0) {\n                return res;\n            }\n        }\n    }\n\n    lfs_ssize_t nsize = lfs_file_flushedwrite(lfs, file, buffer, size);\n    if (nsize < 0) {\n        return nsize;\n    }\n\n    file->flags &= ~LFS_F_ERRED;\n    return nsize;\n}\n...\nstatic int lfs_ctz_find(lfs_t *lfs,\n        const lfs_cache_t *pcache, lfs_cache_t *rcache,\n        lfs_block_t head, lfs_size_t size,\n        lfs_size_t pos, lfs_block_t *block, lfs_off_t *off) {\n    if (size == 0) {\n        *block = LFS_BLOCK_NULL;\n        *off = 0;\n        return 0;\n    }\n\n    lfs_off_t current = lfs_ctz_index(lfs, &(lfs_off_t){size-1});\n    lfs_off_t target = lfs_ctz_index(lfs, &pos);\n\n    while (current > target) {\n        lfs_size_t skip = lfs_min(\n                lfs_npw2(current-target+1) - 1,\n                lfs_ctz(current));\n\n        int err = lfs_bd_read(lfs,\n                pcache, rcache, sizeof(head),\n                head, 4*skip, &head, sizeof(head));\n        head = lfs_fromle32(head);\n        if (err) {\n            return err;\n        }\n\n        current -= 1 << skip;\n    }\n\n    *block = head;\n    *off = pos;\n    return 0;\n}\n...\nstatic inline void lfs_cache_drop(lfs_t *lfs, lfs_cache_t *rcache) {\n    // do not zero, cheaper if cache is readonly or only going to be\n    // written with identical data (during relocates)\n    (void)lfs;\n    rcache->block = LFS_BLOCK_NULL;\n}\n...\nstatic int lfs_file_flush(lfs_t *lfs, lfs_file_t *file) {\n    if (file->flags & LFS_F_READING) {\n        if (!(file->flags & LFS_F_INLINE)) {\n            lfs_cache_drop(lfs, &file->cache);\n        }\n        file->flags &= ~LFS_F_READING;\n    }\n\n#ifndef LFS_READONLY\n    if (file->flags & LFS_F_WRITING) {\n        lfs_off_t pos = file->pos;\n\n        if (!(file->flags & LFS_F_INLINE)) {\n            // copy over anything after current branch\n            lfs_file_t orig = {\n                .ctz.head = file->ctz.head,\n                .ctz.size = file->ctz.size,\n                .flags = LFS_O_RDONLY,\n                .pos = file->pos,\n                .cache = lfs->rcache,\n            };\n            lfs_cache_drop(lfs, &lfs->rcache);\n\n            while (file->pos < file->ctz.size) {\n                // copy over a byte at a time, leave it up to caching\n                // to make this efficient\n                uint8_t data;\n                lfs_ssize_t res = lfs_file_flushedread(lfs, &orig, &data, 1);\n                if (res < 0) {\n                    return res;\n                }\n\n                res = lfs_file_flushedwrite(lfs, file, &data, 1);\n                if (res < 0) {\n                    return res;\n                }\n\n                // keep our reference to the rcache in sync\n                if (lfs->rcache.block != LFS_BLOCK_NULL) {\n                    lfs_cache_drop(lfs, &orig.cache);\n                    lfs_cache_drop(lfs, &lfs->rcache);\n                }\n            }\n\n            // write out what we have\n            while (true) {\n                int err = lfs_bd_flush(lfs, &file->cache, &lfs->rcache, true);\n                if (err) {\n                    if (err == LFS_ERR_CORRUPT) {\n                        goto relocate;\n                    }\n                    return err;\n                }\n\n                break;\n\nrelocate:\n                LFS_DEBUG(\"Bad block at 0x%\"PRIx32, file->block);\n                err = lfs_file_relocate(lfs, file);\n                if (err) {\n                    return err;\n                }\n            }\n        } else {\n            file->pos = lfs_max(file->pos, file->ctz.size);\n        }\n\n        // actual file updates\n        file->ctz.head = file->block;\n        file->ctz.size = file->pos;\n        file->flags &= ~LFS_F_WRITING;\n        file->flags |= LFS_F_DIRTY;\n\n        file->pos = pos;\n    }\n#endif\n\n    return 0;\n}\n...\nstatic lfs_soff_t lfs_file_seek_(lfs_t *lfs, lfs_file_t *file,\n        lfs_soff_t off, int whence) {\n    // find new pos\n    //\n    // fortunately for us, littlefs is limited to 31-bit file sizes, so we\n    // don't have to worry too much about integer overflow\n    lfs_off_t npos = file->pos;\n    if (whence == LFS_SEEK_SET) {\n        npos = off;\n    } else if (whence == LFS_SEEK_CUR) {\n        npos = file->pos + (lfs_off_t)off;\n    } else if (whence == LFS_SEEK_END) {\n        npos = (lfs_off_t)lfs_file_size_(lfs, file) + (lfs_off_t)off;\n    }\n\n    if (npos > lfs->file_max) {\n        // file position out of range\n        return LFS_ERR_INVAL;\n    }\n\n    if (file->pos == npos) {\n        // noop - position has not changed\n        return npos;\n    }\n\n    // if we're only reading and our new offset is still in the file's cache\n    // we can avoid flushing and needing to reread the data\n    if ((file->flags & LFS_F_READING)\n            && file->off != lfs->cfg->block_size) {\n        int oindex = lfs_ctz_index(lfs, &(lfs_off_t){file->pos});\n        lfs_off_t noff = npos;\n        int nindex = lfs_ctz_index(lfs, &noff);\n        if (oindex == nindex\n                && noff >= file->cache.off\n                && noff < file->cache.off + file->cache.size) {\n            file->pos = npos;\n            file->off = noff;\n            return npos;\n        }\n    }\n\n    // write out everything beforehand, may be noop if rdonly\n    int err = lfs_file_flush(lfs, file);\n    if (err) {\n        return err;\n    }\n\n    // update pos\n    file->pos = npos;\n    return npos;\n}\n</additional code>\n\n<instruction>\nJudge whether the report is correct or not.\n</instruction>\n",
  "is_report_correct": false,
  "explanation": "The report is not correct. The called function (lfs_ctz_find) and likely lfs_ctz_index are using the pointed-to lfs_off_t as an output/modified value, so the parameter cannot be const. In lfs_ctz_find we see writes to the off parameter (*off = 0; later *off = pos;), and the call sites (e.g. in lfs_file_seek_) pass a modifiable local (&noff) and then use the possibly-updated off value afterwards. This indicates the functions modify the pointed object, so declaring the parameter as const would be incorrect. Also, the compound literal (lfs_off_t){...} has block scope automatic storage and is a modifiable object, so taking its address and passing it to a function that may write is valid. Therefore there is no MISRA Rule 8.13 violation here."
}