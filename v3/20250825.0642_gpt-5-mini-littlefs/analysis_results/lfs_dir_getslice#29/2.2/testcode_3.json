{
  "user_message": "<misra_rule>\nMISRA C 2023 Rule 2.2 is: A project shall not contain dead code.\nAny operation that is executed but whose removal would not affect program behaviour constitutes dead code. Notes:\n1. The behaviour of an embedded sytem is often determined not just by the nature of its actions, but also by the time at which they occur.\n2. unreachable code is not dead code, as it cannot be executed.\n3.Initialization is not the same as an assignment operation and is therfore not a candidate for dead code.\n</misra_rule>\n\nAnother agent reported that the target code violated the Rule 2.2.\nHere is the comment from the agent.\n<violation scenario>\nWithin the given fragment, the outer if requires lfs_tag_type1(tag) == LFS_TYPE_SPLICE (i.e. tag has type SPLICE). The nested if compares tag for equality with a value built by LFS_MKTAG(LFS_TYPE_CREATE, ...), which has type CREATE. Since a tag cannot simultaneously have two different type fields, the equality can never be true. Therefore the body of the nested if (the return LFS_ERR_NOENT;) is dead code: it is reachable (the condition is evaluated) but the branch can never be taken, so removing it would not change program behaviour. This violates MISRA C 2023 Rule 2.2.\n</violation scenario>\n\nYour job is to insert logging code to capture the control flow and state information of the program.\nInsert logging code so that other agents can reproduce and get evidence for the violation scenario.\n<response format>\n- test_code: a modified lfs_dir_getslice code that contains useful probe functions that print useful logs to a file \"/tmp/logs/292.txt\". The logs should contain the control path and state information of the violation scenario. If test code is not required to validate the scenario, you can leave this blank.\nHere are the constraints for the test code:\n- The test code MUST preserve the original logic of lfs_dir_getslice as much as possible.\nYou CAN just insert probe functions to the original code.\n- DO NOT introduce new violations to demonstrate your scenario.\n- The test code MUST be compilable and executable.\n- The test code MUST include line breaks.\n- You MUST NOT define the main function.\n- You MUST NOT define macros.\n</response format>\n<target_code>\nHere is the code of lfs_dir_getslice:\n```c\nstatic lfs_stag_t lfs_dir_getslice(lfs_t *lfs, const lfs_mdir_t *dir,\n        lfs_tag_t gmask, lfs_tag_t gtag,\n        lfs_off_t goff, void *gbuffer, lfs_size_t gsize) {\n    lfs_off_t off = dir->off;\n    lfs_tag_t ntag = dir->etag;\n    lfs_stag_t gdiff = 0;\n\n    // synthetic moves\n    if (lfs_gstate_hasmovehere(&lfs->gdisk, dir->pair) &&\n            lfs_tag_id(gmask) != 0) {\n        if (lfs_tag_id(lfs->gdisk.tag) == lfs_tag_id(gtag)) {\n            return LFS_ERR_NOENT;\n        } else if (lfs_tag_id(lfs->gdisk.tag) < lfs_tag_id(gtag)) {\n            gdiff -= LFS_MKTAG(0, 1, 0);\n        }\n    }\n\n    // iterate over dir block backwards (for faster lookups)\n    while (off >= sizeof(lfs_tag_t) + lfs_tag_dsize(ntag)) {\n        off -= lfs_tag_dsize(ntag);\n        lfs_tag_t tag = ntag;\n        int err = lfs_bd_read(lfs,\n                NULL, &lfs->rcache, sizeof(ntag),\n                dir->pair[0], off, &ntag, sizeof(ntag));\n        if (err) {\n            return err;\n        }\n\n        ntag = (lfs_frombe32(ntag) ^ tag) & 0x7fffffff;\n\n        if (lfs_tag_id(gmask) != 0 &&\n                lfs_tag_type1(tag) == LFS_TYPE_SPLICE &&\n                lfs_tag_id(tag) <= lfs_tag_id(gtag - gdiff)) {\n            if (tag == (LFS_MKTAG(LFS_TYPE_CREATE, 0, 0) |\n                    (LFS_MKTAG(0, 0x3ff, 0) & (gtag - gdiff)))) {\n                // found where we were created\n                return LFS_ERR_NOENT;\n            }\n\n            // move around splices\n            gdiff += LFS_MKTAG(0, lfs_tag_splice(tag), 0);\n        }\n\n        if ((gmask & tag) == (gmask & (gtag - gdiff))) {\n            if (lfs_tag_isdelete(tag)) {\n                return LFS_ERR_NOENT;\n            }\n\n            lfs_size_t diff = lfs_min(lfs_tag_size(tag), gsize);\n            err = lfs_bd_read(lfs,\n                    NULL, &lfs->rcache, diff,\n                    dir->pair[0], off+sizeof(tag)+goff, gbuffer, diff);\n            if (err) {\n                return err;\n            }\n\n            memset((uint8_t*)gbuffer + diff, 0, gsize - diff);\n\n            return tag + gdiff;\n        }\n    }\n\n    return LFS_ERR_NOENT;\n}\n```\n</target_code>\nPlease provide the modified lfs_dir_getslice code.\n",
  "test_code": "#include <stdio.h>\n#include <stdarg.h>\n#include <stdint.h>\n#include <inttypes.h>\n#include <string.h>\n\n/* Probe logging helper. Appends human-readable control and state info\n   to /tmp/logs/292.txt. Does not alter program control flow. */\nstatic void lfs_probe_log(const char *fmt, ...) {\n    FILE *f = fopen(\"/tmp/logs/292.txt\", \"a\");\n    if (!f) {\n        return;\n    }\n    va_list ap;\n    va_start(ap, fmt);\n    vfprintf(f, fmt, ap);\n    va_end(ap);\n    fclose(f);\n}\n\nstatic lfs_stag_t lfs_dir_getslice(lfs_t *lfs, const lfs_mdir_t *dir,\n        lfs_tag_t gmask, lfs_tag_t gtag,\n        lfs_off_t goff, void *gbuffer, lfs_size_t gsize) {\n    lfs_off_t off = dir->off;\n    lfs_tag_t ntag = dir->etag;\n    lfs_stag_t gdiff = 0;\n\n    lfs_probe_log(\"ENTER lfs_dir_getslice: off=%lld ntag=0x%08llx gmask=0x%08llx gtag=0x%08llx goff=%lld gsize=%llu\\n\",\n            (long long)off, (unsigned long long)ntag,\n            (unsigned long long)gmask, (unsigned long long)gtag,\n            (long long)goff, (unsigned long long)gsize);\n\n    /* synthetic moves */\n    if (lfs_gstate_hasmovehere(&lfs->gdisk, dir->pair) &&\n            lfs_tag_id(gmask) != 0) {\n        lfs_probe_log(\"SYNTHETIC MOVES: hasmovehere=1 gmask_id=%llu gdisk.tag_id=%llu gtag_id=%llu\\n\",\n                (unsigned long long)lfs_tag_id(gmask),\n                (unsigned long long)lfs_tag_id(lfs->gdisk.tag),\n                (unsigned long long)lfs_tag_id(gtag));\n\n        if (lfs_tag_id(lfs->gdisk.tag) == lfs_tag_id(gtag)) {\n            lfs_probe_log(\"SYNTHETIC MOVES: gdisk.tag id == gtag id -> returning LFS_ERR_NOENT\\n\");\n            return LFS_ERR_NOENT;\n        } else if (lfs_tag_id(lfs->gdisk.tag) < lfs_tag_id(gtag)) {\n            gdiff -= LFS_MKTAG(0, 1, 0);\n            lfs_probe_log(\"SYNTHETIC MOVES: gdisk.tag id < gtag id -> gdiff updated to %llu\\n\",\n                    (unsigned long long)gdiff);\n        }\n    }\n\n    /* iterate over dir block backwards (for faster lookups) */\n    while (off >= sizeof(lfs_tag_t) + lfs_tag_dsize(ntag)) {\n        off -= lfs_tag_dsize(ntag);\n        lfs_tag_t tag = ntag;\n        lfs_probe_log(\"LOOP ITER: off=%lld tag=0x%08llx ntag(before read)=0x%08llx\\n\",\n                (long long)off, (unsigned long long)tag, (unsigned long long)ntag);\n\n        int err = lfs_bd_read(lfs,\n                NULL, &lfs->rcache, sizeof(ntag),\n                dir->pair[0], off, &ntag, sizeof(ntag));\n        if (err) {\n            lfs_probe_log(\"LOOP READ ERROR: err=%d -> returning err\\n\", err);\n            return err;\n        }\n\n        ntag = (lfs_frombe32(ntag) ^ tag) & 0x7fffffff;\n        lfs_probe_log(\"LOOP READ: ntag(after decode)=0x%08llx\\n\", (unsigned long long)ntag);\n\n        if (lfs_tag_id(gmask) != 0 &&\n                lfs_tag_type1(tag) == LFS_TYPE_SPLICE &&\n                lfs_tag_id(tag) <= lfs_tag_id(gtag - gdiff)) {\n\n            lfs_probe_log(\"SPLICE BRANCH: tag=0x%08llx type1=%llu (SPLICE=%llu) tag_id=%llu gtag_minus_gdiff=0x%08llx gtag_minus_gdiff_id=%llu\\n\",\n                    (unsigned long long)tag,\n                    (unsigned long long)lfs_tag_type1(tag),\n                    (unsigned long long)LFS_TYPE_SPLICE,\n                    (unsigned long long)lfs_tag_id(tag),\n                    (unsigned long long)(gtag - gdiff),\n                    (unsigned long long)lfs_tag_id(gtag - gdiff));\n\n            /* compute the value compared in the nested if so we can log it */\n            lfs_tag_t create_masked = (LFS_MKTAG(LFS_TYPE_CREATE, 0, 0) |\n                    (LFS_MKTAG(0, 0x3ff, 0) & (gtag - gdiff)));\n\n            int nested_eq = (tag == create_masked);\n            lfs_probe_log(\"NESTED IF CHECK: tag=0x%08llx create_masked=0x%08llx nested_eq=%d tag_type=%llu create_type=%llu\\n\",\n                    (unsigned long long)tag,\n                    (unsigned long long)create_masked,\n                    nested_eq,\n                    (unsigned long long)lfs_tag_type1(tag),\n                    (unsigned long long)LFS_TYPE_CREATE);\n\n            if (nested_eq) {\n                /* preserve original behavior */\n                lfs_probe_log(\"NESTED IF TAKEN: tag equals create_masked -> returning LFS_ERR_NOENT\\n\");\n                return LFS_ERR_NOENT;\n            }\n\n            /* move around splices */\n            gdiff += LFS_MKTAG(0, lfs_tag_splice(tag), 0);\n            lfs_probe_log(\"SPLICE MOVE: added splice=%llu -> gdiff now=%llu\\n\",\n                    (unsigned long long)lfs_tag_splice(tag),\n                    (unsigned long long)gdiff);\n        }\n\n        if ((gmask & tag) == (gmask & (gtag - gdiff))) {\n            lfs_probe_log(\"MATCH CHECK: (gmask & tag)=0x%08llx (gmask & (gtag-gdiff))=0x%08llx -> match\\n\",\n                    (unsigned long long)(gmask & tag),\n                    (unsigned long long)(gmask & (gtag - gdiff)));\n\n            if (lfs_tag_isdelete(tag)) {\n                lfs_probe_log(\"MATCHED TAG IS DELETE -> returning LFS_ERR_NOENT\\n\");\n                return LFS_ERR_NOENT;\n            }\n\n            lfs_size_t diff = lfs_min(lfs_tag_size(tag), gsize);\n            lfs_probe_log(\"READ PAYLOAD: diff=%llu goff=%lld off+sizeof(tag)+goff=%lld\\n\",\n                    (unsigned long long)diff, (long long)goff, (long long)(off + sizeof(tag) + goff));\n\n            err = lfs_bd_read(lfs,\n                    NULL, &lfs->rcache, diff,\n                    dir->pair[0], off+sizeof(tag)+goff, gbuffer, diff);\n            if (err) {\n                lfs_probe_log(\"READ PAYLOAD ERROR: err=%d -> returning err\\n\", err);\n                return err;\n            }\n\n            memset((uint8_t*)gbuffer + diff, 0, gsize - diff);\n\n            lfs_probe_log(\"RETURNING TAG+GDIFF: tag=0x%08llx gdiff=0x%08llx ret=0x%08llx\\n\",\n                    (unsigned long long)tag, (unsigned long long)gdiff,\n                    (unsigned long long)(tag + gdiff));\n\n            return tag + gdiff;\n        }\n    }\n\n    lfs_probe_log(\"END lfs_dir_getslice: reached end -> returning LFS_ERR_NOENT\\n\");\n    return LFS_ERR_NOENT;\n}\n"
}