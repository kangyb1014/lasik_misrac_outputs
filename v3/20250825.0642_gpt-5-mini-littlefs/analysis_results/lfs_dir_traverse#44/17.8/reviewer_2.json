{
  "user_message": "An agent A claimed that the following lfs_dir_traverse code violates the MISRA C 2023 rule 17.8.\n<misra_rule>\nMISRA C 2023 Rule 17.8 is A function parameter should not be modified.\nNote that the object referred to by a pointer parameter may be modified, but the pointer itself shall not be modified.\n</misra_rule>\n<target_code>\nHere is the original code of lfs_dir_traverse.\n```c\nstatic int lfs_dir_traverse(lfs_t *lfs,\n        const lfs_mdir_t *dir, lfs_off_t off, lfs_tag_t ptag,\n        const struct lfs_mattr *attrs, int attrcount,\n        lfs_tag_t tmask, lfs_tag_t ttag,\n        uint16_t begin, uint16_t end, int16_t diff,\n        int (*cb)(void *data, lfs_tag_t tag, const void *buffer), void *data) {\n    // This function in inherently recursive, but bounded. To allow tool-based\n    // analysis without unnecessary code-cost we use an explicit stack\n    struct lfs_dir_traverse stack[LFS_DIR_TRAVERSE_DEPTH-1];\n    unsigned sp = 0;\n    int res;\n\n    // iterate over directory and attrs\n    lfs_tag_t tag;\n    const void *buffer;\n    struct lfs_diskoff disk = {0};\n    while (true) {\n        {\n            if (off+lfs_tag_dsize(ptag) < dir->off) {\n                off += lfs_tag_dsize(ptag);\n                int err = lfs_bd_read(lfs,\n                        NULL, &lfs->rcache, sizeof(tag),\n                        dir->pair[0], off, &tag, sizeof(tag));\n                if (err) {\n                    return err;\n                }\n\n                tag = (lfs_frombe32(tag) ^ ptag) | 0x80000000;\n                disk.block = dir->pair[0];\n                disk.off = off+sizeof(lfs_tag_t);\n                buffer = &disk;\n                ptag = tag;\n            } else if (attrcount > 0) {\n                tag = attrs[0].tag;\n                buffer = attrs[0].buffer;\n                attrs += 1;\n                attrcount -= 1;\n            } else {\n                // finished traversal, pop from stack?\n                res = 0;\n                break;\n            }\n\n            // do we need to filter?\n            lfs_tag_t mask = LFS_MKTAG(0x7ff, 0, 0);\n            if ((mask & tmask & tag) != (mask & tmask & ttag)) {\n                continue;\n            }\n\n            if (lfs_tag_id(tmask) != 0) {\n                LFS_ASSERT(sp < LFS_DIR_TRAVERSE_DEPTH);\n                // recurse, scan for duplicates, and update tag based on\n                // creates/deletes\n                stack[sp] = (struct lfs_dir_traverse){\n                    .dir        = dir,\n                    .off        = off,\n                    .ptag       = ptag,\n                    .attrs      = attrs,\n                    .attrcount  = attrcount,\n                    .tmask      = tmask,\n                    .ttag       = ttag,\n                    .begin      = begin,\n                    .end        = end,\n                    .diff       = diff,\n                    .cb         = cb,\n                    .data       = data,\n                    .tag        = tag,\n                    .buffer     = buffer,\n                    .disk       = disk,\n                };\n                sp += 1;\n\n                tmask = 0;\n                ttag = 0;\n                begin = 0;\n                end = 0;\n                diff = 0;\n                cb = lfs_dir_traverse_filter;\n                data = &stack[sp-1].tag;\n                continue;\n            }\n        }\n\npopped:\n        // in filter range?\n        if (lfs_tag_id(tmask) != 0 &&\n                !(lfs_tag_id(tag) >= begin && lfs_tag_id(tag) < end)) {\n            continue;\n        }\n\n        // handle special cases for mcu-side operations\n        if (lfs_tag_type3(tag) == LFS_FROM_NOOP) {\n            // do nothing\n        } else if (lfs_tag_type3(tag) == LFS_FROM_MOVE) {\n            // Without this condition, lfs_dir_traverse can exhibit an\n            // extremely expensive O(n^3) of nested loops when renaming.\n            // This happens because lfs_dir_traverse tries to filter tags by\n            // the tags in the source directory, triggering a second\n            // lfs_dir_traverse with its own filter operation.\n            //\n            // traverse with commit\n            // '-> traverse with filter\n            //     '-> traverse with move\n            //         '-> traverse with filter\n            //\n            // However we don't actually care about filtering the second set of\n            // tags, since duplicate tags have no effect when filtering.\n            //\n            // This check skips this unnecessary recursive filtering explicitly,\n            // reducing this runtime from O(n^3) to O(n^2).\n            if (cb == lfs_dir_traverse_filter) {\n                continue;\n            }\n\n            // recurse into move\n            stack[sp] = (struct lfs_dir_traverse){\n                .dir        = dir,\n                .off        = off,\n                .ptag       = ptag,\n                .attrs      = attrs,\n                .attrcount  = attrcount,\n                .tmask      = tmask,\n                .ttag       = ttag,\n                .begin      = begin,\n                .end        = end,\n                .diff       = diff,\n                .cb         = cb,\n                .data       = data,\n                .tag        = LFS_MKTAG(LFS_FROM_NOOP, 0, 0),\n            };\n            sp += 1;\n\n            uint16_t fromid = lfs_tag_size(tag);\n            uint16_t toid = lfs_tag_id(tag);\n            dir = buffer;\n            off = 0;\n            ptag = 0xffffffff;\n            attrs = NULL;\n            attrcount = 0;\n            tmask = LFS_MKTAG(0x600, 0x3ff, 0);\n            ttag = LFS_MKTAG(LFS_TYPE_STRUCT, 0, 0);\n            begin = fromid;\n            end = fromid+1;\n            diff = toid-fromid+diff;\n        } else if (lfs_tag_type3(tag) == LFS_FROM_USERATTRS) {\n            for (unsigned i = 0; i < lfs_tag_size(tag); i++) {\n                const struct lfs_attr *a = buffer;\n                res = cb(data, LFS_MKTAG(LFS_TYPE_USERATTR + a[i].type,\n                        lfs_tag_id(tag) + diff, a[i].size), a[i].buffer);\n                if (res < 0) {\n                    return res;\n                }\n\n                if (res) {\n                    break;\n                }\n            }\n        } else {\n            res = cb(data, tag + LFS_MKTAG(0, diff, 0), buffer);\n            if (res < 0) {\n                return res;\n            }\n\n            if (res) {\n                break;\n            }\n        }\n    }\n\n    if (sp > 0) {\n        // pop from the stack and return, fortunately all pops share\n        // a destination\n        dir         = stack[sp-1].dir;\n        off         = stack[sp-1].off;\n        ptag        = stack[sp-1].ptag;\n        attrs       = stack[sp-1].attrs;\n        attrcount   = stack[sp-1].attrcount;\n        tmask       = stack[sp-1].tmask;\n        ttag        = stack[sp-1].ttag;\n        begin       = stack[sp-1].begin;\n        end         = stack[sp-1].end;\n        diff        = stack[sp-1].diff;\n        cb          = stack[sp-1].cb;\n        data        = stack[sp-1].data;\n        tag         = stack[sp-1].tag;\n        buffer      = stack[sp-1].buffer;\n        disk        = stack[sp-1].disk;\n        sp -= 1;\n        goto popped;\n    } else {\n        return res;\n    }\n}\n```\n</target_code>\n<response format>\nProvide your answer with these fields.\n- explanation: your evaluation of the scenario provided by the agent A.\n- is_report_correct: whether the report is correct or not (true/false). True means there is a violation.\n</response format>\n<scenario>\nThe agent A provided the following violation scenario:\nThe function modifies several of its parameter variables in-place. In the fragment shown the code assigns to tmask, ttag, begin, end, diff, cb and data (e.g. \"tmask = 0; cb = lfs_dir_traverse_filter; data = &stack[sp-1].tag;\"). Modifying the pointer parameter 'data' and the function-pointer parameter 'cb' (and other value parameters) alters the parameter variables themselves rather than just the objects they point to, which violates MISRA C 2023 Rule 17.8. (Note: elsewhere in the function attrs is also incremented with attrs += 1, another parameter modification.)\n</scenario>\n\n<execution_log>\nThe agent A also provided the following output log:\nENTER lfs_dir_traverse: lfs=0x7fffaf669008 dir=0x7fffaf668c38 off=0 ptag=0xffffffff attrs=0x7fffaf668d30 attrcount=3 tmask=0x400ffc00 ttag=0x00000000 begin=0 end=1 diff=0 cb=0x55b049d3c41d data=0x7fffaf668a50\nADVANCE ATTRS: old attrs=0x7fffaf668d30 attrcount=3 -> new attrs=0x7fffaf668d40 attrcount=2\nADVANCE ATTRS: old attrs=0x7fffaf668d40 attrcount=2 -> new attrs=0x7fffaf668d50 attrcount=1\nPUSH stack[0]: saved tmask=0x400ffc00 ttag=0x00000000 begin=0 end=1 diff=0 cb=0x55b049d3c41d data=0x7fffaf668a50 (will zero/replace these)\nSET FILTER CB/DATA: old cb=0x55b049d3c41d old data=0x7fffaf668a50 -> new cb=0x55b049d385e4 new data=0x7fffaf668928 (stack[0].tag)\nADVANCE ATTRS: old attrs=0x7fffaf668d50 attrcount=1 -> new attrs=0x7fffaf668d60 attrcount=0\nPOP: sp=1 restoring from stack[0]: dir=0x7fffaf668c38 off=0 ptag=0xffffffff attrs=0x7fffaf668d50 attrcount=1 tmask=0x400ffc00 ttag=0x00000000 begin=0 end=1 diff=0 cb=0x55b049d3c41d data=0x7fffaf668a50 tag=0x0ff00008\nADVANCE ATTRS: old attrs=0x7fffaf668d50 attrcount=1 -> new attrs=0x7fffaf668d60 attrcount=0\nPUSH stack[0]: saved tmask=0x400ffc00 ttag=0x00000000 begin=0 end=1 diff=0 cb=0x55b049d3c41d data=0x7fffaf668a50 (will zero/replace these)\nSET FILTER CB/DATA: old cb=0x55b049d3c41d old data=0x7fffaf668a50 -> new cb=0x55b049d385e4 new data=0x7fffaf668928 (stack[0].tag)\nPOP: sp=1 restoring from stack[0]: dir=0x7fffaf668c38 off=0 ptag=0xffffffff attrs=0x7fffaf668d60 attrcount=0 tmask=0x400ffc00 ttag=0x00000000 begin=0 end=1 diff=0 cb=0x55b049d3c41d data=0x7fffaf668a50 tag=0x20100018\nEXIT lfs_dir_traverse: res=0\nENTER lfs_dir_traverse: lfs=0x7fffaf669008 dir=0x7fffaf668c38 off=0 ptag=0xffffffff attrs=(nil) attrcount=0 tmask=0x400ffc00 ttag=0x00000000 begin=0 end=1 diff=0 cb=0x55b049d3c41d data=0x7fffaf668a50\nPUSH stack[0]: saved tmask=0x400ffc00 ttag=0x00000000 begin=0 end=1 diff=0 cb=0x55b049d3c41d data=0x7fffaf668a50 (will zero/replace these)\nSET FILTER CB/DATA: old cb=0x55b049d3c41d old data=0x7fffaf668a50 -> new cb=0x55b049d385e4 new data=0x7fffaf668928 (stack[0].tag)\nPOP: sp=1 restoring from stack[0]: dir=0x7fffaf668c38 off=4 ptag=0x8ff00008 attrs=(nil) attrcount=0 tmask=0x400ffc00 ttag=0x00000000 begin=0 end=1 diff=0 cb=0x55b049d3c41d data=0x7fffaf668a50 tag=0x8ff00008\nPUSH stack[0]: saved tmask=0x400ffc00 ttag=0x00000000 begin=0 end=1 diff=0 cb=0x55b049d3c41d data=0x7fffaf668a50 (will zero/replace these)\nSET FILTER CB/DATA: old cb=0x55b049d3c41d old data=0x7fffaf668a50 -> new cb=0x55b049d385e4 new data=0x7fffaf668928 (stack[0].tag)\nPOP: sp=1 restoring from stack[0]: dir=0x7fffaf668c38 off=16 ptag=0xa0100018 attrs=(nil) attrcount=0 tmask=0x400ffc00 ttag=0x00000000 begin=0 end=1 diff=0 cb=0x55b049d3c41d data=0x7fffaf668a50 tag=0xa0100018\nEXIT lfs_dir_traverse: res=0\nENTER lfs_dir_traverse: lfs=0x7fffaf669008 dir=0x7fffaf668bc8 off=0 ptag=0xffffffff attrs=0x7fffaf668c90 attrcount=1 tmask=0x400ffc00 ttag=0x00000000 begin=0 end=0 diff=0 cb=0x55b049d3c41d data=0x7fffaf6689e0\nADVANCE ATTRS: old attrs=0x7fffaf668c90 attrcount=1 -> new attrs=0x7fffaf668ca0 attrcount=0\nEXIT lfs_dir_traverse: res=0\nENTER lfs_dir_traverse: lfs=0x7fffaf669008 dir=0x7fffaf668bc8 off=64 ptag=0x500ffc04 attrs=0x7fffaf668d10 attrcount=4 tmask=0x00000000 ttag=0x00000000 begin=0 end=0 diff=0 cb=0x55b049d3c41d data=0x7fffaf668af0\nADVANCE ATTRS: old attrs=0x7fffaf668d10 attrcount=4 -> new attrs=0x7fffaf668d20 attrcount=3\nADVANCE ATTRS: old attrs=0x7fffaf668d20 attrcount=3 -> new attrs=0x7fffaf668d30 attrcount=2\nADVANCE ATTRS: old attrs=0x7fffaf668d30 attrcount=2 -> new attrs=0x7fffaf668d40 attrcount=1\nADVANCE ATTRS: old attrs=0x7fffaf668d40 attrcount=1 -> new attrs=0x7fffaf668d50 attrcount=0\nEXIT lfs_dir_traverse: res=0\nENTER lfs_dir_traverse: lfs=0x7fffaf669008 dir=0x7fffaf668c28 off=32 ptag=0x500ffc0c attrs=0x7fffaf668ce0 attrcount=3 tmask=0x00000000 ttag=0x00000000 begin=0 end=0 diff=0 cb=0x55b049d3c41d data=0x7fffaf668b50\nADVANCE ATTRS: old attrs=0x7fffaf668ce0 attrcount=3 -> new attrs=0x7fffaf668cf0 attrcount=2\nADVANCE ATTRS: old attrs=0x7fffaf668cf0 attrcount=2 -> new attrs=0x7fffaf668d00 attrcount=1\nADVANCE\n</execution_log>\n<additional code>Here are the definitions of symbols that are close to the target function lfs_dir_traverse:\nstatic int lfs_dir_traverse_filter(void *p,\n        lfs_tag_t tag, const void *buffer) {\n    lfs_tag_t *filtertag = p;\n    (void)buffer;\n\n    // which mask depends on unique bit in tag structure\n    uint32_t mask = (tag & LFS_MKTAG(0x100, 0, 0))\n            ? LFS_MKTAG(0x7ff, 0x3ff, 0)\n            : LFS_MKTAG(0x700, 0x3ff, 0);\n\n    // check for redundancy\n    if ((mask & tag) == (mask & *filtertag) ||\n            lfs_tag_isdelete(*filtertag) ||\n            (LFS_MKTAG(0x7ff, 0x3ff, 0) & tag) == (\n                LFS_MKTAG(LFS_TYPE_DELETE, 0, 0) |\n                    (LFS_MKTAG(0, 0x3ff, 0) & *filtertag))) {\n        *filtertag = LFS_MKTAG(LFS_FROM_NOOP, 0, 0);\n        return true;\n    }\n\n    // check if we need to adjust for created/deleted tags\n    if (lfs_tag_type1(tag) == LFS_TYPE_SPLICE &&\n            lfs_tag_id(tag) <= lfs_tag_id(*filtertag)) {\n        *filtertag += LFS_MKTAG(0, lfs_tag_splice(tag), 0);\n    }\n\n    return false;\n}\n...\ntypedef struct lfs {\n    lfs_cache_t rcache;\n    lfs_cache_t pcache;\n\n    lfs_block_t root[2];\n    struct lfs_mlist {\n        struct lfs_mlist *next;\n        uint16_t id;\n        uint8_t type;\n        lfs_mdir_t m;\n    } *mlist;\n    uint32_t seed;\n\n    lfs_gstate_t gstate;\n    lfs_gstate_t gdisk;\n    lfs_gstate_t gdelta;\n\n    struct lfs_lookahead {\n        lfs_block_t start;\n        lfs_block_t size;\n        lfs_block_t next;\n        lfs_block_t ckpoint;\n        uint8_t *buffer;\n    } lookahead;\n\n    const struct lfs_config *cfg;\n    lfs_size_t block_count;\n    lfs_size_t name_max;\n    lfs_size_t file_max;\n    lfs_size_t attr_max;\n    lfs_size_t inline_max;\n\n#ifdef LFS_MIGRATE\n    struct lfs1 *lfs1;\n#endif\n} lfs_t\n...\ntypedef struct lfs_mdir {\n    lfs_block_t pair[2];\n    uint32_t rev;\n    lfs_off_t off;\n    uint32_t etag;\n    uint16_t count;\n    bool erased;\n    bool split;\n    lfs_block_t tail[2];\n} lfs_mdir_t\n...\nstruct lfs_mattr {\n    lfs_tag_t tag;\n    const void *buffer;\n}\n...\nstruct lfs_attr {\n    // 8-bit type of attribute, provided by user and used to\n    // identify the attribute\n    uint8_t type;\n\n    // Pointer to buffer containing the attribute\n    void *buffer;\n\n    // Size of attribute in bytes, limited to LFS_ATTR_MAX\n    lfs_size_t size;\n}\n...\ntypedef uint32_t lfs_tag_t\n...\ntypedef uint32_t lfs_off_t\n...\nstruct lfs_diskoff {\n    lfs_block_t block;\n    lfs_off_t off;\n}\n...\n#define LFS_DIR_TRAVERSE_DEPTH 3\n...\n#define LFS_MKTAG(type, id, size) (((lfs_tag_t)(type)<<20)|((lfs_tag_t)(id)<<10)|(lfs_tag_t)(size))\n</additional code>\n\n<instruction>\nJudge whether the report is correct or not.\n</instruction>\n",
  "is_report_correct": true,
  "explanation": "Agent A is correct. MISRA C 2023 Rule 17.8 requires that function parameters not be modified; for pointer parameters only the object pointed-to may be modified but not the pointer itself. The implementation of lfs_dir_traverse assigns to many of its parameter variables directly (e.g. attrs += 1; attrs is a pointer parameter; tmask = 0; ttag = 0; begin = 0; end = 0; diff = 0; cb = lfs_dir_traverse_filter; data = &stack[sp-1].tag; dir = buffer; off = 0; ptag = 0xffffffff; etc.). These are modifications of the parameter variables (including pointer and function-pointer parameters), which violates Rule 17.8. The fact that the function saves/restores parameter values on an explicit stack does not avoid the rule: the parameters themselves are still being assigned. To be MISRA-compliant the function should use local copies of parameters for mutation and leave the incoming parameter variables unmodified."
}