{
  "user_message": "An agent A claimed that the following lfs_fs_parent code violates the MISRA C 2023 rule 8.13.\n<misra_rule>\nMISRA C 2023 Rule 8.13 is A pointer should point to a const-qualified type whenever possible.\n\n</misra_rule>\n<target_code>\nHere is the original code of lfs_fs_parent.\n```c\nstatic lfs_stag_t lfs_fs_parent(lfs_t *lfs, const lfs_block_t pair[2],\n        lfs_mdir_t *parent) {\n    // use fetchmatch with callback to find pairs\n    parent->tail[0] = 0;\n    parent->tail[1] = 1;\n    struct lfs_tortoise_t tortoise = {\n        .pair = {LFS_BLOCK_NULL, LFS_BLOCK_NULL},\n        .i = 1,\n        .period = 1,\n    };\n    int err = LFS_ERR_OK;\n    while (!lfs_pair_isnull(parent->tail)) {\n        err = lfs_tortoise_detectcycles(parent, &tortoise);\n        if (err < 0) {\n            return err;\n        }\n\n        lfs_stag_t tag = lfs_dir_fetchmatch(lfs, parent, parent->tail,\n                LFS_MKTAG(0x7ff, 0, 0x3ff),\n                LFS_MKTAG(LFS_TYPE_DIRSTRUCT, 0, 8),\n                NULL,\n                lfs_fs_parent_match, &(struct lfs_fs_parent_match){\n                    lfs, {pair[0], pair[1]}});\n        if (tag && tag != LFS_ERR_NOENT) {\n            return tag;\n        }\n    }\n\n    return LFS_ERR_NOENT;\n}\n```\n</target_code>\n<response format>\nProvide your answer with these fields.\n- explanation: your evaluation of the scenario provided by the agent A.\n- is_report_correct: whether the report is correct or not (true/false). True means there is a violation.\n</response format>\n<scenario>\nThe agent A provided the following violation scenario:\nThe callback parameter 'data' is declared as void * but is only read (cast to struct lfs_fs_parent_match *find and used read\u2011only). According to MISRA C 2023 Rule 8.13 this should be a pointer to a const\u2011qualified type (e.g. const void *data, cast to const struct lfs_fs_parent_match *). Therefore the function signature violates Rule 8.13 (unless the non\u2011const prototype is mandated by an external API, in which case this is an unavoidable deviation).\n</scenario>\n\n<execution_log>\nThe agent A also provided the following output log:\nENTER lfs_fs_parent: lfs=0x7ffcdac9de70, pair[0]=27, pair[1]=26, parent=0x7ffcdac9dc08\ninit tortoise: pair[0]=4294967295, pair[1]=4294967295, i=1, period=1\nloop top: parent->tail[0]=0, parent->tail[1]=1\nafter tortoise_detectcycles: err=0, tortoise.i=1, tortoise.period=2, tortoise.pair[0]=0, tortoise.pair[1]=1\ncalling lfs_dir_fetchmatch: parent=0x7ffcdac9dc08, parent->tail=0x7ffcdac9dc20, find_addr=0x7ffcdac9db28, find.lfs=0x7ffcdac9de70, find.pair[0]=27, find.pair[1]=26\nreturned from lfs_dir_fetchmatch: tag=0\nloop top: parent->tail[0]=12, parent->tail[1]=13\nafter tortoise_detectcycles: err=0, tortoise.i=2, tortoise.period=2, tortoise.pair[0]=0, tortoise.pair[1]=1\ncalling lfs_dir_fetchmatch: parent=0x7ffcdac9dc08, parent->tail=0x7ffcdac9dc20, find_addr=0x7ffcdac9db28, find.lfs=0x7ffcdac9de70, find.pair[0]=27, find.pair[1]=26\nreturned from lfs_dir_fetchmatch: tag=0\nloop top: parent->tail[0]=20, parent->tail[1]=21\nafter tortoise_detectcycles: err=0, tortoise.i=1, tortoise.period=4, tortoise.pair[0]=20, tortoise.pair[1]=21\ncalling lfs_dir_fetchmatch: parent=0x7ffcdac9dc08, parent->tail=0x7ffcdac9dc20, find_addr=0x7ffcdac9db28, find.lfs=0x7ffcdac9de70, find.pair[0]=27, find.pair[1]=26\nreturned from lfs_dir_fetchmatch: tag=0\nloop top: parent->tail[0]=23, parent->tail[1]=24\nafter tortoise_detectcycles: err=0, tortoise.i=2, tortoise.period=4, tortoise.pair[0]=20, tortoise.pair[1]=21\ncalling lfs_dir_fetchmatch: parent=0x7ffcdac9dc08, parent->tail=0x7ffcdac9dc20, find_addr=0x7ffcdac9db28, find.lfs=0x7ffcdac9de70, find.pair[0]=27, find.pair[1]=26\nreturned from lfs_dir_fetchmatch: tag=0\nloop top: parent->tail[0]=18, parent->tail[1]=19\nafter tortoise_detectcycles: err=0, tortoise.i=3, tortoise.period=4, tortoise.pair[0]=20, tortoise.pair[1]=21\ncalling lfs_dir_fetchmatch: parent=0x7ffcdac9dc08, parent->tail=0x7ffcdac9dc20, find_addr=0x7ffcdac9db28, find.lfs=0x7ffcdac9de70, find.pair[0]=27, find.pair[1]=26\nreturned from lfs_dir_fetchmatch: tag=0\nloop top: parent->tail[0]=15, parent->tail[1]=16\nafter tortoise_detectcycles: err=0, tortoise.i=4, tortoise.period=4, tortoise.pair[0]=20, tortoise.pair[1]=21\ncalling lfs_dir_fetchmatch: parent=0x7ffcdac9dc08, parent->tail=0x7ffcdac9dc20, find_addr=0x7ffcdac9db28, find.lfs=0x7ffcdac9de70, find.pair[0]=27, find.pair[1]=26\nreturned from lfs_dir_fetchmatch: tag=0\nloop top: parent->tail[0]=10, parent->tail[1]=11\nafter tortoise_detectcycles: err=0, tortoise.i=1, tortoise.period=8, tortoise.pair[0]=10, tortoise.pair[1]=11\ncalling lfs_dir_fetchmatch: parent=0x7ffcdac9dc08, parent->tail=0x7ffcdac9dc20, find_addr=0x7ffcdac9db28, find.lfs=0x7ffcdac9de70, find.pair[0]=27, find.pair[1]=26\nreturned from lfs_dir_fetchmatch: tag=0\nloop top: parent->tail[0]=7, parent->tail[1]=8\nafter tortoise_detectcycles: err=0, tortoise.i=2, tortoise.period=8, tortoise.pair[0]=10, tortoise.pair[1]=11\ncalling lfs_dir_fetchmatch: parent=0x7ffcdac9dc08, parent->tail=0x7ffcdac9dc20, find_addr=0x7ffcdac9db28, find.lfs=0x7ffcdac9de70, find.pair[0]=27, find.pair[1]=26\nreturned from lfs_dir_fetchmatch: tag=0\nloop top: parent->tail[0]=4, parent->tail[1]=5\nafter tortoise_detectcycles: err=0, tortoise.i=3, tortoise.period=8, tortoise.pair[0]=10, tortoise.pair[1]=11\ncalling lfs_dir_fetchmatch: parent=0x7ffcdac9dc08, parent->tail=0x7ffcdac9dc20, find_addr=0x7ffcdac9db28, find.lfs=0x7ffcdac9de70, find.pair[0]=27, find.pair[1]=26\nreturned from lfs_dir_fetchmatch: tag=0\nloop top: parent->tail[0]=2, parent->tail[1]=3\nafter tortoise_detectcycles: err=0, tortoise.i=4, tortoise.period=8, tortoise.pair[0]=10, tortoise.pair[1]=11\ncalling lfs_dir_fetchmatch: parent=0x7ffcdac9dc08, parent->tail=0x7ffcdac9dc20, find_addr=0x7ffcdac9db28, find.lfs=0x7ffcdac9de70, find.pair[0]=27, find.pair[1]=26\nreturned from lfs_dir_fetchmatch: tag=0\nEXIT lfs_fs_parent: returning LFS_ERR_NOENT\nENTER lfs_fs_parent: lfs=0x7ffcdac9de70, pair[0]=46, pair[1]=47, parent=0x7ffcdac9dc08\ninit tortoise: pair[0]=4294967295, pair[1]=4294967295, i=1, period=1\nloop top: parent->tail[0]=0, parent->tail[1]=1\nafter tortoise_detectcycles: err=0, tortoise.i=1, tortoise.period=2, tortoi\n</execution_log>\n<additional code>Here are the definitions of symbols that are close to the target function lfs_fs_parent:\ntypedef struct lfs {\n    lfs_cache_t rcache;\n    lfs_cache_t pcache;\n\n    lfs_block_t root[2];\n    struct lfs_mlist {\n        struct lfs_mlist *next;\n        uint16_t id;\n        uint8_t type;\n        lfs_mdir_t m;\n    } *mlist;\n    uint32_t seed;\n\n    lfs_gstate_t gstate;\n    lfs_gstate_t gdisk;\n    lfs_gstate_t gdelta;\n\n    struct lfs_lookahead {\n        lfs_block_t start;\n        lfs_block_t size;\n        lfs_block_t next;\n        lfs_block_t ckpoint;\n        uint8_t *buffer;\n    } lookahead;\n\n    const struct lfs_config *cfg;\n    lfs_size_t block_count;\n    lfs_size_t name_max;\n    lfs_size_t file_max;\n    lfs_size_t attr_max;\n    lfs_size_t inline_max;\n\n#ifdef LFS_MIGRATE\n    struct lfs1 *lfs1;\n#endif\n} lfs_t\n...\ntypedef struct lfs_mdir {\n    lfs_block_t pair[2];\n    uint32_t rev;\n    lfs_off_t off;\n    uint32_t etag;\n    uint16_t count;\n    bool erased;\n    bool split;\n    lfs_block_t tail[2];\n} lfs_mdir_t\n...\ntypedef uint32_t lfs_block_t\n...\nstruct lfs_tortoise_t {\n    lfs_block_t pair[2];\n    lfs_size_t i;\n    lfs_size_t period;\n}\n...\nstatic int lfs_fs_parent_match(void *data,\n        lfs_tag_t tag, const void *buffer) {\n    struct lfs_fs_parent_match *find = data;\n    lfs_t *lfs = find->lfs;\n    const struct lfs_diskoff *disk = buffer;\n    (void)tag;\n\n    lfs_block_t child[2];\n    int err = lfs_bd_read(lfs,\n            &lfs->pcache, &lfs->rcache, lfs->cfg->block_size,\n            disk->block, disk->off, &child, sizeof(child));\n    if (err) {\n        return err;\n    }\n\n    lfs_pair_fromle32(child);\n    return (lfs_pair_cmp(child, find->pair) == 0) ? LFS_CMP_EQ : LFS_CMP_LT;\n}\n</additional code>\n\n<instruction>\nJudge whether the report is correct or not.\n</instruction>\n",
  "is_report_correct": true,
  "explanation": "Agent A is correct in identifying a Rule 8.13 concern. The callback parameter data is declared as void * but is only read (cast to struct lfs_fs_parent_match *find and used read\u2011only), so the pointer could and should be to a const\u2011qualified type (e.g. const void *data and cast to const struct lfs_fs_parent_match *). That would satisfy MISRA C 2023 Rule 8.13 (a pointer should point to a const\u2011qualified type whenever possible).\n\nHowever, there is an important caveat: if the callback prototype is mandated by an external API (e.g. lfs_dir_fetchmatch requires a function of type int (*)(void *, lfs_tag_t, const void *)), then the non\u2011const parameter type is forced by that API and the deviation is unavoidable (and should be documented as such). If the prototype is under project control, change the parameter to const void *data (and the internal cast to const struct lfs_fs_parent_match *) to comply with Rule 8.13."
}