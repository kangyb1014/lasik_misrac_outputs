{
  "user_message": "An agent A claimed that the following lfs_fs_parent code violates the MISRA C 2023 rule 8.13.\n<misra_rule>\nMISRA C 2023 Rule 8.13 is A pointer should point to a const-qualified type whenever possible.\n\n</misra_rule>\n<target_code>\nHere is the original code of lfs_fs_parent.\n```c\nstatic lfs_stag_t lfs_fs_parent(lfs_t *lfs, const lfs_block_t pair[2],\n        lfs_mdir_t *parent) {\n    // use fetchmatch with callback to find pairs\n    parent->tail[0] = 0;\n    parent->tail[1] = 1;\n    struct lfs_tortoise_t tortoise = {\n        .pair = {LFS_BLOCK_NULL, LFS_BLOCK_NULL},\n        .i = 1,\n        .period = 1,\n    };\n    int err = LFS_ERR_OK;\n    while (!lfs_pair_isnull(parent->tail)) {\n        err = lfs_tortoise_detectcycles(parent, &tortoise);\n        if (err < 0) {\n            return err;\n        }\n\n        lfs_stag_t tag = lfs_dir_fetchmatch(lfs, parent, parent->tail,\n                LFS_MKTAG(0x7ff, 0, 0x3ff),\n                LFS_MKTAG(LFS_TYPE_DIRSTRUCT, 0, 8),\n                NULL,\n                lfs_fs_parent_match, &(struct lfs_fs_parent_match){\n                    lfs, {pair[0], pair[1]}});\n        if (tag && tag != LFS_ERR_NOENT) {\n            return tag;\n        }\n    }\n\n    return LFS_ERR_NOENT;\n}\n```\n</target_code>\n<response format>\nProvide your answer with these fields.\n- explanation: your evaluation of the scenario provided by the agent A.\n- is_report_correct: whether the report is correct or not (true/false). True means there is a violation.\n</response format>\n<scenario>\nThe agent A provided the following violation scenario:\nThe callback data argument is passed as the address of a non-const compound literal, but the callback lfs_fs_parent_match only reads from that data. Specifically, lfs_fs_parent_match has prototype (void *data, ...) and immediately treats data as const by only reading find->lfs and find->pair. Therefore the pointer could and should point to a const-qualified type. Passing &(struct lfs_fs_parent_match){ lfs, {pair[0], pair[1]} } as a non-const pointer violates MISRA C 2023 Rule 8.13. A compliant fix is to change the callback prototype to accept const void *data (and update callers) or otherwise ensure the pointed-to type is const-qualified.\n</scenario>\n\n<execution_log>\nThe agent A also provided the following output log:\nSTAGE: before_fetchmatch\n parent->tail = [0, 1]\n requested pair = [27, 26]\n lfs ptr = 0x7ffe05644d40\n data ptr = 0x7ffe056449f8\n  data->lfs = 0x7ffe05644d40\n  data->pair = [27, 26]\n tortoise.i = 1 period = 2\n tortoise.pair = [0, 1]\n tag = 0\n----\nSTAGE: after_fetchmatch\n parent->tail = [12, 13]\n requested pair = [27, 26]\n lfs ptr = 0x7ffe05644d40\n data ptr = 0x7ffe056449f8\n  data->lfs = 0x7ffe05644d40\n  data->pair = [27, 26]\n tortoise.i = 1 period = 2\n tortoise.pair = [0, 1]\n tag = 0\n----\nSTAGE: before_fetchmatch\n parent->tail = [12, 13]\n requested pair = [27, 26]\n lfs ptr = 0x7ffe05644d40\n data ptr = 0x7ffe056449f8\n  data->lfs = 0x7ffe05644d40\n  data->pair = [27, 26]\n tortoise.i = 2 period = 2\n tortoise.pair = [0, 1]\n tag = 0\n----\nSTAGE: after_fetchmatch\n parent->tail = [20, 21]\n requested pair = [27, 26]\n lfs ptr = 0x7ffe05644d40\n data ptr = 0x7ffe056449f8\n  data->lfs = 0x7ffe05644d40\n  data->pair = [27, 26]\n tortoise.i = 2 period = 2\n tortoise.pair = [0, 1]\n tag = 0\n----\nSTAGE: before_fetchmatch\n parent->tail = [20, 21]\n requested pair = [27, 26]\n lfs ptr = 0x7ffe05644d40\n data ptr = 0x7ffe056449f8\n  data->lfs = 0x7ffe05644d40\n  data->pair = [27, 26]\n tortoise.i = 1 period = 4\n tortoise.pair = [20, 21]\n tag = 0\n----\nSTAGE: after_fetchmatch\n parent->tail = [23, 24]\n requested pair = [27, 26]\n lfs ptr = 0x7ffe05644d40\n data ptr = 0x7ffe056449f8\n  data->lfs = 0x7ffe05644d40\n  data->pair = [27, 26]\n tortoise.i = 1 period = 4\n tortoise.pair = [20, 21]\n tag = 0\n----\nSTAGE: before_fetchmatch\n parent->tail = [23, 24]\n requested pair = [27, 26]\n lfs ptr = 0x7ffe05644d40\n data ptr = 0x7ffe056449f8\n  data->lfs = 0x7ffe05644d40\n  data->pair = [27, 26]\n tortoise.i = 2 period = 4\n tortoise.pair = [20, 21]\n tag = 0\n----\nSTAGE: after_fetchmatch\n parent->tail = [18, 19]\n requested pair = [27, 26]\n lfs ptr = 0x7ffe05644d40\n data ptr = 0x7ffe056449f8\n  data->lfs = 0x7ffe05644d40\n  data->pair = [27, 26]\n tortoise.i = 2 period = 4\n tortoise.pair = [20, 21]\n tag = 0\n----\nSTAGE: before_fetchmatch\n parent->tail = [18, 19]\n requested pair = [27, 26]\n lfs ptr = 0x7ffe05644d40\n data ptr = 0x7ffe056449f8\n  data->lfs = 0x7ffe05644d40\n  data->pair = [27, 26]\n tortoise.i = 3 period = 4\n tortoise.pair = [20, 21]\n tag = 0\n----\nSTAGE: after_fetchmatch\n parent->tail = [15, 16]\n requested pair = [27, 26]\n lfs ptr = 0x7ffe05644d40\n data ptr = 0x7ffe056449f8\n  data->lfs = 0x7ffe05644d40\n  data->pair = [27, 26]\n tortoise.i = 3 period = 4\n tortoise.pair = [20, 21]\n tag = 0\n----\nSTAGE: before_fetchmatch\n parent->tail = [15, 16]\n requested pair = [27, 26]\n lfs ptr = 0x7ffe05644d40\n data ptr = 0x7ffe056449f8\n  data->lfs = 0x7ffe05644d40\n  data->pair = [27, 26]\n tortoise.i = 4 period = 4\n tortoise.pair = [20, 21]\n tag = 0\n----\nSTAGE: after_fetchmatch\n parent->tail = [10, 11]\n requested pair = [27, 26]\n lfs ptr = 0x7ffe05644d40\n data ptr = 0x7ffe056449f8\n  data->lfs = 0x7ffe05644d40\n  data->pair = [27, 26]\n tortoise.i = 4 period = 4\n tortoise.pair = [20, 21]\n tag = 0\n----\nSTAGE: before_fetchmatch\n parent->tail = [10, 11]\n requested pair = [27, 26]\n lfs ptr = 0x7ffe05644d40\n data ptr = 0x7ffe056449f8\n  data->lfs = 0x7ffe05644d40\n  data->pair = [27, 26]\n tortoise.i = 1 period = 8\n tortoise.pair = [10, 11]\n tag = 0\n----\nSTAGE: after_fetchmatch\n parent->tail = [7, 8]\n requested pair = [27, 26]\n lfs ptr = 0x7ffe05644d40\n data ptr = 0x7ffe056449f8\n  data->lfs = 0x7ffe05644d40\n  data->pair = [27, 26]\n tortoise.i = 1 period = 8\n tortoise.pair = [10, 11]\n tag = 0\n----\nSTAGE: before_fetchmatch\n parent->tail = [7, 8]\n requested pair = [27, 26]\n lfs ptr = 0x7ffe05644d40\n data ptr = 0x7ffe056449f8\n  data->lfs = 0x7ffe05644d40\n  data->pair = [27, 26]\n tortoise.i = 2 period = 8\n tortoise.pair = [10, 11]\n tag = 0\n----\nSTAGE: after_fetchmatch\n parent->tail = [4, 5]\n requested pair = [27, 26]\n lfs ptr = 0x7ffe05644d40\n data ptr = 0x7ffe056449f8\n  data->lfs = 0x7ffe05644d40\n  data->pair = [27, 26]\n tortoise.i = 2 period = 8\n tortoise.pair = [10, 11]\n tag = 0\n----\nSTAGE: before_fetchmatch\n parent->tail = [4, 5]\n requested pair = [27, 26]\n lfs ptr = 0x7ffe05644d40\n data ptr = 0x7ffe0\n</execution_log>\n<additional code>Here are the definitions of symbols that are close to the target function lfs_fs_parent:\ntypedef struct lfs {\n    lfs_cache_t rcache;\n    lfs_cache_t pcache;\n\n    lfs_block_t root[2];\n    struct lfs_mlist {\n        struct lfs_mlist *next;\n        uint16_t id;\n        uint8_t type;\n        lfs_mdir_t m;\n    } *mlist;\n    uint32_t seed;\n\n    lfs_gstate_t gstate;\n    lfs_gstate_t gdisk;\n    lfs_gstate_t gdelta;\n\n    struct lfs_lookahead {\n        lfs_block_t start;\n        lfs_block_t size;\n        lfs_block_t next;\n        lfs_block_t ckpoint;\n        uint8_t *buffer;\n    } lookahead;\n\n    const struct lfs_config *cfg;\n    lfs_size_t block_count;\n    lfs_size_t name_max;\n    lfs_size_t file_max;\n    lfs_size_t attr_max;\n    lfs_size_t inline_max;\n\n#ifdef LFS_MIGRATE\n    struct lfs1 *lfs1;\n#endif\n} lfs_t\n...\ntypedef struct lfs_mdir {\n    lfs_block_t pair[2];\n    uint32_t rev;\n    lfs_off_t off;\n    uint32_t etag;\n    uint16_t count;\n    bool erased;\n    bool split;\n    lfs_block_t tail[2];\n} lfs_mdir_t\n...\ntypedef uint32_t lfs_block_t\n...\nstruct lfs_tortoise_t {\n    lfs_block_t pair[2];\n    lfs_size_t i;\n    lfs_size_t period;\n}\n...\nstatic int lfs_fs_parent_match(void *data,\n        lfs_tag_t tag, const void *buffer) {\n    struct lfs_fs_parent_match *find = data;\n    lfs_t *lfs = find->lfs;\n    const struct lfs_diskoff *disk = buffer;\n    (void)tag;\n\n    lfs_block_t child[2];\n    int err = lfs_bd_read(lfs,\n            &lfs->pcache, &lfs->rcache, lfs->cfg->block_size,\n            disk->block, disk->off, &child, sizeof(child));\n    if (err) {\n        return err;\n    }\n\n    lfs_pair_fromle32(child);\n    return (lfs_pair_cmp(child, find->pair) == 0) ? LFS_CMP_EQ : LFS_CMP_LT;\n}\n</additional code>\n\n<instruction>\nJudge whether the report is correct or not.\n</instruction>\n",
  "is_report_correct": true,
  "explanation": "The report is correct. The callback lfs_fs_parent_match is declared to accept void *data but only reads from the pointed-to object (it immediately treats it as read\u2011only). According to MISRA C 2023 Rule 8.13 a pointer should point to a const\u2011qualified type whenever possible, so the parameter should be declared const void *data (and the local pointer as const struct lfs_fs_parent_match *find). As written the code exposes a non\u2011const pointer to a compound literal even though the data is never modified.\n\nIf the lfs_dir_fetchmatch API requires the callback to have a non\u2011const data parameter (i.e. the prototype is fixed), then this is an unavoidable non\u2011compliance and should be documented as a deviation. Otherwise the correct fix is to make the callback prototype and all callers use const void *data (and update casts/usage accordingly)."
}