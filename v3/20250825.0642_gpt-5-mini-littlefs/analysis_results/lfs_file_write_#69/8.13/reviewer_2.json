{
  "user_message": "An agent A claimed that the following lfs_file_write_ code violates the MISRA C 2023 rule 8.13.\n<misra_rule>\nMISRA C 2023 Rule 8.13 is A pointer should point to a const-qualified type whenever possible.\n\n</misra_rule>\n<target_code>\nHere is the original code of lfs_file_write_.\n```c\nstatic lfs_ssize_t lfs_file_write_(lfs_t *lfs, lfs_file_t *file,\n        const void *buffer, lfs_size_t size) {\n    LFS_ASSERT((file->flags & LFS_O_WRONLY) == LFS_O_WRONLY);\n\n    if (file->flags & LFS_F_READING) {\n        // drop any reads\n        int err = lfs_file_flush(lfs, file);\n        if (err) {\n            return err;\n        }\n    }\n\n    if ((file->flags & LFS_O_APPEND) && file->pos < file->ctz.size) {\n        file->pos = file->ctz.size;\n    }\n\n    if (file->pos + size > lfs->file_max) {\n        // Larger than file limit?\n        return LFS_ERR_FBIG;\n    }\n\n    if (!(file->flags & LFS_F_WRITING) && file->pos > file->ctz.size) {\n        // fill with zeros\n        lfs_off_t pos = file->pos;\n        file->pos = file->ctz.size;\n\n        while (file->pos < pos) {\n            lfs_ssize_t res = lfs_file_flushedwrite(lfs, file, &(uint8_t){0}, 1);\n            if (res < 0) {\n                return res;\n            }\n        }\n    }\n\n    lfs_ssize_t nsize = lfs_file_flushedwrite(lfs, file, buffer, size);\n    if (nsize < 0) {\n        return nsize;\n    }\n\n    file->flags &= ~LFS_F_ERRED;\n    return nsize;\n}\n```\n</target_code>\n<response format>\nProvide your answer with these fields.\n- explanation: your evaluation of the scenario provided by the agent A.\n- is_report_correct: whether the report is correct or not (true/false). True means there is a violation.\n</response format>\n<scenario>\nThe agent A provided the following violation scenario:\nPassing the address of a non-const compound literal &(uint8_t){0} to a function that takes a pointer-to-const (const void *). The object being pointed at is not const-qualified even though it is not modified, so the pointer does not point to a const-qualified type as required by the rule. Use &(const uint8_t){0} or a named const uint8_t zero = 0; &zero instead.\n</scenario>\n\n<execution_log>\nThe agent A also provided the following output log:\nENTRY: lfs_file_write_: file=0x7ffd796b5940 flags=0x100902 pos=0 ctz.size=0 file_max=2147483647 size=5\nACTION: final write: buffer=0x558c95143058 size=5 pos=0\nRESULT: final lfs_file_flushedwrite returned 5\nEXIT: lfs_file_write_ success -> 5 (cleared F_ERRED)\nENTRY: lfs_file_write_: file=0x7ffd796b5940 flags=0x120902 pos=5 ctz.size=0 file_max=2147483647 size=5\nACTION: final write: buffer=0x558c95143058 size=5 pos=5\nRESULT: final lfs_file_flushedwrite returned 5\nEXIT: lfs_file_write_ success -> 5 (cleared F_ERRED)\nENTRY: lfs_file_write_: file=0x7ffd796b5940 flags=0x120902 pos=10 ctz.size=0 file_max=2147483647 size=5\nACTION: final write: buffer=0x558c95143058 size=5 pos=10\nRESULT: final lfs_file_flushedwrite returned 5\nEXIT: lfs_file_write_ success -> 5 (cleared F_ERRED)\nENTRY: lfs_file_write_: file=0x7ffd796b5940 flags=0x120902 pos=15 ctz.size=0 file_max=2147483647 size=5\nACTION: final write: buffer=0x558c95143058 size=5 pos=15\nRESULT: final lfs_file_flushedwrite returned 5\nEXIT: lfs_file_write_ success -> 5 (cleared F_ERRED)\nENTRY: lfs_file_write_: file=0x7ffd796b5940 flags=0x120902 pos=20 ctz.size=0 file_max=2147483647 size=5\nACTION: final write: buffer=0x558c95143058 size=5 pos=20\nRESULT: final lfs_file_flushedwrite returned 5\nEXIT: lfs_file_write_ success -> 5 (cleared F_ERRED)\nENTRY: lfs_file_write_: file=0x7ffd796b5940 flags=0x120902 pos=25 ctz.size=0 file_max=2147483647 size=5\nACTION: final write: buffer=0x558c95143058 size=5 pos=25\nRESULT: final lfs_file_flushedwrite returned 5\nEXIT: lfs_file_write_ success -> 5 (cleared F_ERRED)\nENTRY: lfs_file_write_: file=0x7ffd796b5940 flags=0x120902 pos=30 ctz.size=0 file_max=2147483647 size=5\nACTION: final write: buffer=0x558c95143058 size=5 pos=30\nRESULT: final lfs_file_flushedwrite returned 5\nEXIT: lfs_file_write_ success -> 5 (cleared F_ERRED)\nENTRY: lfs_file_write_: file=0x7ffd796b5940 flags=0x120902 pos=35 ctz.size=0 file_max=2147483647 size=5\nACTION: final write: buffer=0x558c95143058 size=5 pos=35\nRESULT: final lfs_file_flushedwrite returned 5\nEXIT: lfs_file_write_ success -> 5 (cleared F_ERRED)\nENTRY: lfs_file_write_: file=0x7ffd796b5940 flags=0x120902 pos=40 ctz.size=0 file_max=2147483647 size=5\nACTION: final write: buffer=0x558c95143058 size=5 pos=40\nRESULT: final lfs_file_flushedwrite returned 5\nEXIT: lfs_file_write_ success -> 5 (cleared F_ERRED)\nENTRY: lfs_file_write_: file=0x7ffd796b5940 flags=0x120902 pos=45 ctz.size=0 file_max=2147483647 size=5\nACTION: final write: buffer=0x558c95143058 size=5 pos=45\nRESULT: final lfs_file_flushedwrite returned 5\nEXIT: lfs_file_write_ success -> 5 (cleared F_ERRED)\nENTRY: lfs_file_write_: file=0x7ffd796b5940 flags=0x120902 pos=50 ctz.size=0 file_max=2147483647 size=5\nACTION: final write: buffer=0x558c95143058 size=5 pos=50\nRESULT: final lfs_file_flushedwrite returned 5\nEXIT: lfs_file_write_ success -> 5 (cleared F_ERRED)\nENTRY: lfs_file_write_: file=0x7ffd796b5940 flags=0x120902 pos=55 ctz.size=0 file_max=2147483647 size=5\nACTION: final write: buffer=0x558c95143058 size=5 pos=55\nRESULT: final lfs_file_flushedwrite returned 5\nEXIT: lfs_file_write_ success -> 5 (cleared F_ERRED)\nENTRY: lfs_file_write_: file=0x7ffd796b5940 flags=0x120902 pos=60 ctz.size=0 file_max=2147483647 size=5\nACTION: final write: buffer=0x558c95143058 size=5 pos=60\nRESULT: final lfs_file_flushedwrite returned 5\nEXIT: lfs_file_write_ success -> 5 (cleared F_ERRED)\nENTRY: lfs_file_write_: file=0x7ffd796b5940 flags=0x20902 pos=65 ctz.size=0 file_max=2147483647 size=5\nACTION: final write: buffer=0x558c95143058 size=5 pos=65\nRESULT: final lfs_file_flushedwrite returned 5\nEXIT: lfs_file_write_ success -> 5 (cleared F_ERRED)\nENTRY: lfs_file_write_: file=0x7ffd796b5940 flags=0x20902 pos=70 ctz.size=0 file_max=2147483647 size=5\nACTION: final write: buffer=0x558c95143058 size=5 pos=70\nRESULT: final lfs_file_flushedwrite returned 5\nEXIT: lfs_file_write_ success -> 5 (cleared F_ERRED)\nENTRY: lfs_file_write_: file=0x7ffd796b5940 flags=0x20902 pos=75 ctz.size=0 file_max=2147483647 size=5\nACTION: final write: buffer=0x558c95143058 size=5 pos=75\nRESULT: final lfs_file_flus\n</execution_log>\n<additional code>Here are the definitions of symbols that are close to the target function lfs_file_write_:\nstatic lfs_ssize_t lfs_file_flushedwrite(lfs_t *lfs, lfs_file_t *file,\n        const void *buffer, lfs_size_t size) {\n    const uint8_t *data = buffer;\n    lfs_size_t nsize = size;\n\n    if ((file->flags & LFS_F_INLINE) &&\n            lfs_max(file->pos+nsize, file->ctz.size) > lfs->inline_max) {\n        // inline file doesn't fit anymore\n        int err = lfs_file_outline(lfs, file);\n        if (err) {\n            file->flags |= LFS_F_ERRED;\n            return err;\n        }\n    }\n\n    while (nsize > 0) {\n        // check if we need a new block\n        if (!(file->flags & LFS_F_WRITING) ||\n                file->off == lfs->cfg->block_size) {\n            if (!(file->flags & LFS_F_INLINE)) {\n                if (!(file->flags & LFS_F_WRITING) && file->pos > 0) {\n                    // find out which block we're extending from\n                    int err = lfs_ctz_find(lfs, NULL, &file->cache,\n                            file->ctz.head, file->ctz.size,\n                            file->pos-1, &file->block, &(lfs_off_t){0});\n                    if (err) {\n                        file->flags |= LFS_F_ERRED;\n                        return err;\n                    }\n\n                    // mark cache as dirty since we may have read data into it\n                    lfs_cache_zero(lfs, &file->cache);\n                }\n\n                // extend file with new blocks\n                lfs_alloc_ckpoint(lfs);\n                int err = lfs_ctz_extend(lfs, &file->cache, &lfs->rcache,\n                        file->block, file->pos,\n                        &file->block, &file->off);\n                if (err) {\n                    file->flags |= LFS_F_ERRED;\n                    return err;\n                }\n            } else {\n                file->block = LFS_BLOCK_INLINE;\n                file->off = file->pos;\n            }\n\n            file->flags |= LFS_F_WRITING;\n        }\n\n        // program as much as we can in current block\n        lfs_size_t diff = lfs_min(nsize, lfs->cfg->block_size - file->off);\n        while (true) {\n            int err = lfs_bd_prog(lfs, &file->cache, &lfs->rcache, true,\n                    file->block, file->off, data, diff);\n            if (err) {\n                if (err == LFS_ERR_CORRUPT) {\n                    goto relocate;\n                }\n                file->flags |= LFS_F_ERRED;\n                return err;\n            }\n\n            break;\nrelocate:\n            err = lfs_file_relocate(lfs, file);\n            if (err) {\n                file->flags |= LFS_F_ERRED;\n                return err;\n            }\n        }\n\n        file->pos += diff;\n        file->off += diff;\n        data += diff;\n        nsize -= diff;\n\n        lfs_alloc_ckpoint(lfs);\n    }\n\n    return size;\n}\n...\nstatic int lfs_file_flush(lfs_t *lfs, lfs_file_t *file) {\n    if (file->flags & LFS_F_READING) {\n        if (!(file->flags & LFS_F_INLINE)) {\n            lfs_cache_drop(lfs, &file->cache);\n        }\n        file->flags &= ~LFS_F_READING;\n    }\n\n#ifndef LFS_READONLY\n    if (file->flags & LFS_F_WRITING) {\n        lfs_off_t pos = file->pos;\n\n        if (!(file->flags & LFS_F_INLINE)) {\n            // copy over anything after current branch\n            lfs_file_t orig = {\n                .ctz.head = file->ctz.head,\n                .ctz.size = file->ctz.size,\n                .flags = LFS_O_RDONLY,\n                .pos = file->pos,\n                .cache = lfs->rcache,\n            };\n            lfs_cache_drop(lfs, &lfs->rcache);\n\n            while (file->pos < file->ctz.size) {\n                // copy over a byte at a time, leave it up to caching\n                // to make this efficient\n                uint8_t data;\n                lfs_ssize_t res = lfs_file_flushedread(lfs, &orig, &data, 1);\n                if (res < 0) {\n                    return res;\n                }\n\n                res = lfs_file_flushedwrite(lfs, file, &data, 1);\n                if (res < 0) {\n                    return res;\n                }\n\n                // keep our reference to the rcache in sync\n                if (lfs->rcache.block != LFS_BLOCK_NULL) {\n                    lfs_cache_drop(lfs, &orig.cache);\n                    lfs_cache_drop(lfs, &lfs->rcache);\n                }\n            }\n\n            // write out what we have\n            while (true) {\n                int err = lfs_bd_flush(lfs, &file->cache, &lfs->rcache, true);\n                if (err) {\n                    if (err == LFS_ERR_CORRUPT) {\n                        goto relocate;\n                    }\n                    return err;\n                }\n\n                break;\n\nrelocate:\n                LFS_DEBUG(\"Bad block at 0x%\"PRIx32, file->block);\n                err = lfs_file_relocate(lfs, file);\n                if (err) {\n                    return err;\n                }\n            }\n        } else {\n            file->pos = lfs_max(file->pos, file->ctz.size);\n        }\n\n        // actual file updates\n        file->ctz.head = file->block;\n        file->ctz.size = file->pos;\n        file->flags &= ~LFS_F_WRITING;\n        file->flags |= LFS_F_DIRTY;\n\n        file->pos = pos;\n    }\n#endif\n\n    return 0;\n}\n...\nlfs_ssize_t lfs_file_write(lfs_t *lfs, lfs_file_t *file,\n        const void *buffer, lfs_size_t size) {\n    int err = LFS_LOCK(lfs->cfg);\n    if (err) {\n        return err;\n    }\n    LFS_TRACE(\"lfs_file_write(%p, %p, %p, %\"PRIu32\")\",\n            (void*)lfs, (void*)file, buffer, size);\n    LFS_ASSERT(lfs_mlist_isopen(lfs->mlist, (struct lfs_mlist*)file));\n\n    lfs_ssize_t res = lfs_file_write_(lfs, file, buffer, size);\n\n    LFS_TRACE(\"lfs_file_write -> %\"PRId32, res);\n    LFS_UNLOCK(lfs->cfg);\n    return res;\n}\n...\ntypedef struct lfs_file {\n    struct lfs_file *next;\n    uint16_t id;\n    uint8_t type;\n    lfs_mdir_t m;\n\n    struct lfs_ctz {\n        lfs_block_t head;\n        lfs_size_t size;\n    } ctz;\n\n    uint32_t flags;\n    lfs_off_t pos;\n    lfs_block_t block;\n    lfs_off_t off;\n    lfs_cache_t cache;\n\n    const struct lfs_file_config *cfg;\n} lfs_file_t\n...\ntypedef struct lfs {\n    lfs_cache_t rcache;\n    lfs_cache_t pcache;\n\n    lfs_block_t root[2];\n    struct lfs_mlist {\n        struct lfs_mlist *next;\n        uint16_t id;\n        uint8_t type;\n        lfs_mdir_t m;\n    } *mlist;\n    uint32_t seed;\n\n    lfs_gstate_t gstate;\n    lfs_gstate_t gdisk;\n    lfs_gstate_t gdelta;\n\n    struct lfs_lookahead {\n        lfs_block_t start;\n        lfs_block_t size;\n        lfs_block_t next;\n        lfs_block_t ckpoint;\n        uint8_t *buffer;\n    } lookahead;\n\n    const struct lfs_config *cfg;\n    lfs_size_t block_count;\n    lfs_size_t name_max;\n    lfs_size_t file_max;\n    lfs_size_t attr_max;\n    lfs_size_t inline_max;\n\n#ifdef LFS_MIGRATE\n    struct lfs1 *lfs1;\n#endif\n} lfs_t\n</additional code>\n\n<instruction>\nJudge whether the report is correct or not.\n</instruction>\n",
  "is_report_correct": false,
  "explanation": "The report is not correct. Rule 8.13 is about declaring pointers to point to const-qualified types when appropriate; the callee lfs_file_flushedwrite already declares its parameter as const void *buffer, so the pointer type is const-qualified. Passing the address of a non-const compound literal &(uint8_t){0} to a function taking const void * simply performs the usual qualification addition (it does not drop constness) and is allowed by the language. While using a const-qualified compound literal (e.g. (const uint8_t){0}) or a named const variable would be a stylistic improvement to make the pointed-at object const-qualified as well, it is not required to satisfy MISRA C 2023 Rule 8.13 in this context. Therefore the claim of a rule violation is unfounded."
}