{
  "user_message": "<misra_rule>\nMISRA C 2023 Rule 17.2 is: Functions shall not call themselves, either directly or indirectly.\n\n</misra_rule>\n<response format>\nProvide your answer with these fields.\n- is_rule_violated: whether the rule is violated or not (true/false),\n- scenario: a specific violation scenario.\n</response format>\n<target_code>\nHere is the code of lfs_dir_read_:\n```c\nstatic int lfs_dir_read_(lfs_t *lfs, lfs_dir_t *dir, struct lfs_info *info) {\n    memset(info, 0, sizeof(*info));\n\n    // special offset for '.' and '..'\n    if (dir->pos == 0) {\n        info->type = LFS_TYPE_DIR;\n        strcpy(info->name, \".\");\n        dir->pos += 1;\n        return true;\n    } else if (dir->pos == 1) {\n        info->type = LFS_TYPE_DIR;\n        strcpy(info->name, \"..\");\n        dir->pos += 1;\n        return true;\n    }\n\n    while (true) {\n        if (dir->id == dir->m.count) {\n            if (!dir->m.split) {\n                return false;\n            }\n\n            int err = lfs_dir_fetch(lfs, &dir->m, dir->m.tail);\n            if (err) {\n                return err;\n            }\n\n            dir->id = 0;\n        }\n\n        int err = lfs_dir_getinfo(lfs, &dir->m, dir->id, info);\n        if (err && err != LFS_ERR_NOENT) {\n            return err;\n        }\n\n        dir->id += 1;\n        if (err != LFS_ERR_NOENT) {\n            break;\n        }\n    }\n\n    dir->pos += 1;\n    return true;\n}\n```\n</target_code>\n<additional code>Here are the definitions of symbols that are close to the target function lfs_dir_read_:\nstatic int lfs_dir_fetch(lfs_t *lfs,\n        lfs_mdir_t *dir, const lfs_block_t pair[2]) {\n    // note, mask=-1, tag=-1 can never match a tag since this\n    // pattern has the invalid bit set\n    return (int)lfs_dir_fetchmatch(lfs, dir, pair,\n            (lfs_tag_t)-1, (lfs_tag_t)-1, NULL, NULL, NULL);\n}\n...\nstatic lfs_stag_t lfs_dir_fetchmatch(lfs_t *lfs,\n        lfs_mdir_t *dir, const lfs_block_t pair[2],\n        lfs_tag_t fmask, lfs_tag_t ftag, uint16_t *id,\n        int (*cb)(void *data, lfs_tag_t tag, const void *buffer), void *data) {\n    // we can find tag very efficiently during a fetch, since we're already\n    // scanning the entire directory\n    lfs_stag_t besttag = -1;\n\n    // if either block address is invalid we return LFS_ERR_CORRUPT here,\n    // otherwise later writes to the pair could fail\n    if (lfs->block_count \n            && (pair[0] >= lfs->block_count || pair[1] >= lfs->block_count)) {\n        return LFS_ERR_CORRUPT;\n    }\n\n    // find the block with the most recent revision\n    uint32_t revs[2] = {0, 0};\n    int r = 0;\n    for (int i = 0; i < 2; i++) {\n        int err = lfs_bd_read(lfs,\n                NULL, &lfs->rcache, sizeof(revs[i]),\n                pair[i], 0, &revs[i], sizeof(revs[i]));\n        revs[i] = lfs_fromle32(revs[i]);\n        if (err && err != LFS_ERR_CORRUPT) {\n            return err;\n        }\n\n        if (err != LFS_ERR_CORRUPT &&\n                lfs_scmp(revs[i], revs[(i+1)%2]) > 0) {\n            r = i;\n        }\n    }\n\n    dir->pair[0] = pair[(r+0)%2];\n    dir->pair[1] = pair[(r+1)%2];\n    dir->rev = revs[(r+0)%2];\n    dir->off = 0; // nonzero = found some commits\n\n    // now scan tags to fetch the actual dir and find possible match\n    for (int i = 0; i < 2; i++) {\n        lfs_off_t off = 0;\n        lfs_tag_t ptag = 0xffffffff;\n\n        uint16_t tempcount = 0;\n        lfs_block_t temptail[2] = {LFS_BLOCK_NULL, LFS_BLOCK_NULL};\n        bool tempsplit = false;\n        lfs_stag_t tempbesttag = besttag;\n\n        // assume not erased until proven otherwise\n        bool maybeerased = false;\n        bool hasfcrc = false;\n        struct lfs_fcrc fcrc;\n\n        dir->rev = lfs_tole32(dir->rev);\n        uint32_t crc = lfs_crc(0xffffffff, &dir->rev, sizeof(dir->rev));\n        dir->rev = lfs_fromle32(dir->rev);\n\n        while (true) {\n            // extract next tag\n            lfs_tag_t tag;\n            off += lfs_tag_dsize(ptag);\n            int err = lfs_bd_read(lfs,\n                    NULL, &lfs->rcache, lfs->cfg->block_size,\n                    dir->pair[0], off, &tag, sizeof(tag));\n            if (err) {\n                if (err == LFS_ERR_CORRUPT) {\n                    // can't continue?\n                    break;\n                }\n                return err;\n            }\n\n            crc = lfs_crc(crc, &tag, sizeof(tag));\n            tag = lfs_frombe32(tag) ^ ptag;\n\n            // next commit not yet programmed?\n            if (!lfs_tag_isvalid(tag)) {\n                // we only might be erased if the last tag was a crc\n                maybeerased = (lfs_tag_type2(ptag) == LFS_TYPE_CCRC);\n                break;\n            // out of range?\n            } else if (off + lfs_tag_dsize(tag) > lfs->cfg->block_size) {\n                break;\n            }\n\n            ptag = tag;\n\n            if (lfs_tag_type2(tag) == LFS_TYPE_CCRC) {\n                // check the crc attr\n                uint32_t dcrc;\n                err = lfs_bd_read(lfs,\n                        NULL, &lfs->rcache, lfs->cfg->block_size,\n                        dir->pair[0], off+sizeof(tag), &dcrc, sizeof(dcrc));\n                if (err) {\n                    if (err == LFS_ERR_CORRUPT) {\n                        break;\n                    }\n                    return err;\n                }\n                dcrc = lfs_fromle32(dcrc);\n\n                if (crc != dcrc) {\n                    break;\n                }\n\n                // reset the next bit if we need to\n                ptag ^= (lfs_tag_t)(lfs_tag_chunk(tag) & 1U) << 31;\n\n                // toss our crc into the filesystem seed for\n                // pseudorandom numbers, note we use another crc here\n                // as a collection function because it is sufficiently\n                // random and convenient\n                lfs->seed = lfs_crc(lfs->seed, &crc, sizeof(crc));\n\n                // update with what's found so far\n                besttag = tempbesttag;\n                dir->off = off + lfs_tag_dsize(tag);\n                dir->etag = ptag;\n                dir->count = tempcount;\n                dir->tail[0] = temptail[0];\n                dir->tail[1] = temptail[1];\n                dir->split = tempsplit;\n\n                // reset crc, hasfcrc\n                crc = 0xffffffff;\n                continue;\n            }\n\n            // crc the entry first, hopefully leaving it in the cache\n            err = lfs_bd_crc(lfs,\n                    NULL, &lfs->rcache, lfs->cfg->block_size,\n                    dir->pair[0], off+sizeof(tag),\n                    lfs_tag_dsize(tag)-sizeof(tag), &crc);\n            if (err) {\n                if (err == LFS_ERR_CORRUPT) {\n                    break;\n                }\n                return err;\n            }\n\n            // directory modification tags?\n            if (lfs_tag_type1(tag) == LFS_TYPE_NAME) {\n                // increase count of files if necessary\n                if (lfs_tag_id(tag) >= tempcount) {\n                    tempcount = lfs_tag_id(tag) + 1;\n                }\n            } else if (lfs_tag_type1(tag) == LFS_TYPE_SPLICE) {\n                tempcount += lfs_tag_splice(tag);\n\n                if (tag == (LFS_MKTAG(LFS_TYPE_DELETE, 0, 0) |\n                        (LFS_MKTAG(0, 0x3ff, 0) & tempbesttag))) {\n                    tempbesttag |= 0x80000000;\n                } else if (tempbesttag != -1 &&\n                        lfs_tag_id(tag) <= lfs_tag_id(tempbesttag)) {\n                    tempbesttag += LFS_MKTAG(0, lfs_tag_splice(tag), 0);\n                }\n            } else if (lfs_tag_type1(tag) == LFS_TYPE_TAIL) {\n                tempsplit = (lfs_tag_chunk(tag) & 1);\n\n                err = lfs_bd_read(lfs,\n                        NULL, &lfs->rcache, lfs->cfg->block_size,\n                        dir->pair[0], off+sizeof(tag), &temptail, 8);\n                if (err) {\n                    if (err == LFS_ERR_CORRUPT) {\n                        break;\n                    }\n                    return err;\n                }\n                lfs_pair_fromle32(temptail);\n            } else if (lfs_tag_type3(tag) == LFS_TYPE_FCRC) {\n                err = lfs_bd_read(lfs,\n                        NULL, &lfs->rcache, lfs->cfg->block_size,\n                        dir->pair[0], off+sizeof(tag),\n                        &fcrc, sizeof(fcrc));\n                if (err) {\n                    if (err == LFS_ERR_CORRUPT) {\n                        break;\n                    }\n                }\n\n                lfs_fcrc_fromle32(&fcrc);\n                hasfcrc = true;\n            }\n\n            // found a match for our fetcher?\n            if ((fmask & tag) == (fmask & ftag)) {\n                int res = cb(data, tag, &(struct lfs_diskoff){\n                        dir->pair[0], off+sizeof(tag)});\n                if (res < 0) {\n                    if (res == LFS_ERR_CORRUPT) {\n                        break;\n                    }\n                    return res;\n                }\n\n                if (res == LFS_CMP_EQ) {\n                    // found a match\n                    tempbesttag = tag;\n                } else if ((LFS_MKTAG(0x7ff, 0x3ff, 0) & tag) ==\n                        (LFS_MKTAG(0x7ff, 0x3ff, 0) & tempbesttag)) {\n                    // found an identical tag, but contents didn't match\n                    // this must mean that our besttag has been overwritten\n                    tempbesttag = -1;\n                } else if (res == LFS_CMP_GT &&\n                        lfs_tag_id(tag) <= lfs_tag_id(tempbesttag)) {\n                    // found a greater match, keep track to keep things sorted\n                    tempbesttag = tag | 0x80000000;\n                }\n            }\n        }\n\n        // found no valid commits?\n        if (dir->off == 0) {\n            // try the other block?\n            lfs_pair_swap(dir->pair);\n            dir->rev = revs[(r+1)%2];\n            continue;\n        }\n\n        // did we end on a valid commit? we may have an erased block\n        dir->erased = false;\n        if (maybeerased && dir->off % lfs->cfg->prog_size == 0) {\n        #ifdef LFS_MULTIVERSION\n            // note versions < lfs2.1 did not have fcrc tags, if\n            // we're < lfs2.1 treat missing fcrc as erased data\n            //\n            // we don't strictly need to do this, but otherwise writing\n            // to lfs2.0 disks becomes very inefficient\n            if (lfs_fs_disk_version(lfs) < 0x00020001) {\n                dir->erased = true;\n\n            } else\n        #endif\n            if (hasfcrc) {\n                // check for an fcrc matching the next prog's erased state, if\n                // this failed most likely a previous prog was interrupted, we\n                // need a new erase\n                uint32_t fcrc_ = 0xffffffff;\n                int err = lfs_bd_crc(lfs,\n                        NULL, &lfs->rcache, lfs->cfg->block_size,\n                        dir->pair[0], dir->off, fcrc.size, &fcrc_);\n                if (err && err != LFS_ERR_CORRUPT) {\n                    return err;\n                }\n\n                // found beginning of erased part?\n                dir->erased = (fcrc_ == fcrc.crc);\n            }\n        }\n\n        // synthetic move\n        if (lfs_gstate_hasmovehere(&lfs->gdisk, dir->pair)) {\n            if (lfs_tag_id(lfs->gdisk.tag) == lfs_tag_id(besttag)) {\n                besttag |= 0x80000000;\n            } else if (besttag != -1 &&\n                    lfs_tag_id(lfs->gdisk.tag) < lfs_tag_id(besttag)) {\n                besttag -= LFS_MKTAG(0, 1, 0);\n            }\n        }\n\n        // found tag? or found best id?\n        if (id) {\n            *id = lfs_min(lfs_tag_id(besttag), dir->count);\n        }\n\n        if (lfs_tag_isvalid(besttag)) {\n            return besttag;\n        } else if (lfs_tag_id(besttag) < dir->count) {\n            return LFS_ERR_NOENT;\n        } else {\n            return 0;\n        }\n    }\n\n    LFS_ERROR(\"Corrupted dir pair at {0x%\"PRIx32\", 0x%\"PRIx32\"}\",\n            dir->pair[0], dir->pair[1]);\n    return LFS_ERR_CORRUPT;\n}\n...\nstatic int lfs_dir_getinfo(lfs_t *lfs, lfs_mdir_t *dir,\n        uint16_t id, struct lfs_info *info) {\n    if (id == 0x3ff) {\n        // special case for root\n        strcpy(info->name, \"/\");\n        info->type = LFS_TYPE_DIR;\n        return 0;\n    }\n\n    lfs_stag_t tag = lfs_dir_get(lfs, dir, LFS_MKTAG(0x780, 0x3ff, 0),\n            LFS_MKTAG(LFS_TYPE_NAME, id, lfs->name_max+1), info->name);\n    if (tag < 0) {\n        return (int)tag;\n    }\n\n    info->type = lfs_tag_type3(tag);\n\n    struct lfs_ctz ctz;\n    tag = lfs_dir_get(lfs, dir, LFS_MKTAG(0x700, 0x3ff, 0),\n            LFS_MKTAG(LFS_TYPE_STRUCT, id, sizeof(ctz)), &ctz);\n    if (tag < 0) {\n        return (int)tag;\n    }\n    lfs_ctz_fromle32(&ctz);\n\n    if (lfs_tag_type3(tag) == LFS_TYPE_CTZSTRUCT) {\n        info->size = ctz.size;\n    } else if (lfs_tag_type3(tag) == LFS_TYPE_INLINESTRUCT) {\n        info->size = lfs_tag_size(tag);\n    }\n\n    return 0;\n}\n...\nstatic lfs_stag_t lfs_dir_get(lfs_t *lfs, const lfs_mdir_t *dir,\n        lfs_tag_t gmask, lfs_tag_t gtag, void *buffer) {\n    return lfs_dir_getslice(lfs, dir,\n            gmask, gtag,\n            0, buffer, lfs_tag_size(gtag));\n}\n...\nstatic inline uint16_t lfs_tag_type3(lfs_tag_t tag) {\n    return (tag & 0x7ff00000) >> 20;\n}\n...\nstatic void lfs_ctz_fromle32(struct lfs_ctz *ctz) {\n    ctz->head = lfs_fromle32(ctz->head);\n    ctz->size = lfs_fromle32(ctz->size);\n}\n...\nstatic inline lfs_size_t lfs_tag_size(lfs_tag_t tag) {\n    return tag & 0x000003ff;\n}\n...\nint lfs_dir_read(lfs_t *lfs, lfs_dir_t *dir, struct lfs_info *info) {\n    int err = LFS_LOCK(lfs->cfg);\n    if (err) {\n        return err;\n    }\n    LFS_TRACE(\"lfs_dir_read(%p, %p, %p)\",\n            (void*)lfs, (void*)dir, (void*)info);\n\n    err = lfs_dir_read_(lfs, dir, info);\n\n    LFS_TRACE(\"lfs_dir_read -> %d\", err);\n    LFS_UNLOCK(lfs->cfg);\n    return err;\n}\n</additional code>\n<target_code>\nHere is the code fragment that you need to analyze:\n```c\nint res = cb(data, tag, &(struct lfs_diskoff){\n                        dir->pair[0], off+sizeof(tag)});\n```\nFocus on the above code fragment and judge whether it violates the rule 17.2 or not.\n</target_code>\n",
  "is_rule_violated": false,
  "scenario": "The code fragment calls a callback function pointer (cb) from lfs_dir_fetchmatch and passes a compound-literal lfs_diskoff. This is not a call to the containing function itself, and there is no evidence in the provided code that cb points to a function that calls lfs_dir_fetchmatch (or otherwise invokes itself indirectly). Therefore no direct or indirect self-call occurs here."
}