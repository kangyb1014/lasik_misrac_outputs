{
  "user_message": "<misra_rule>\nMISRA C 2023 Rule 2.2 is: A project shall not contain dead code.\nAny operation that is executed but whose removal would not affect program behaviour constitutes dead code. Notes:\n1. The behaviour of an embedded sytem is often determined not just by the nature of its actions, but also by the time at which they occur.\n2. unreachable code is not dead code, as it cannot be executed.\n3.Initialization is not the same as an assignment operation and is therfore not a candidate for dead code.\n</misra_rule>\n\nAnother agent reported that the target code violated the Rule 2.2.\nHere is the comment from the agent.\n<violation scenario>\nThe LFS_LOCK macro expands to the comma expression ((void)cfg, 0). In lfs_removeattr the call LFS_LOCK(lfs->cfg) therefore evaluates (void)lfs->cfg (which has no effect for a normal non-volatile member access) and returns 0. Removing the (void)cfg sub-expression (leaving just 0) would not change program behaviour for the given usage, so that evaluation is dead code. (Note: if cfg evaluation had observable side-effects \u2014 e.g. involved volatile accesses or function calls \u2014 it would not be dead; but in the provided code lfs->cfg is an ordinary member access.)\n</violation scenario>\n\nYour job is to insert logging code to capture the control flow and state information of the program.\nInsert logging code so that other agents can reproduce and get evidence for the violation scenario.\n<response format>\n- test_code: a modified lfs_removeattr code that contains useful probe functions that print useful logs to a file \"/tmp/logs/1012.txt\". The logs should contain the control path and state information of the violation scenario. If test code is not required to validate the scenario, you can leave this blank.\nHere are the constraints for the test code:\n- The test code MUST preserve the original logic of lfs_removeattr as much as possible.\nYou CAN just insert probe functions to the original code.\n- DO NOT introduce new violations to demonstrate your scenario.\n- The test code MUST be compilable and executable.\n- The test code MUST include line breaks.\n- You MUST NOT define the main function.\n- You MUST NOT define macros.\n</response format>\n<target_code>\nHere is the code of lfs_removeattr:\n```c\nint lfs_removeattr(lfs_t *lfs, const char *path, uint8_t type) {\n    int err = LFS_LOCK(lfs->cfg);\n    if (err) {\n        return err;\n    }\n    LFS_TRACE(\"lfs_removeattr(%p, \\\"%s\\\", %\"PRIu8\")\", (void*)lfs, path, type);\n\n    err = lfs_removeattr_(lfs, path, type);\n\n    LFS_TRACE(\"lfs_removeattr -> %d\", err);\n    LFS_UNLOCK(lfs->cfg);\n    return err;\n}\n```\n</target_code>\nPlease provide the modified lfs_removeattr code.\n",
  "test_code": "#include <stdio.h>\n#include <stdint.h>\n#include <inttypes.h>\n#include <stddef.h>\n#include <stdarg.h>\n\n/* Probe helper: append log lines to /tmp/logs/1012.txt */\nstatic void __probe_log(const char *fmt, ...) {\n    FILE *f = fopen(\"/tmp/logs/1012.txt\", \"a\");\n    if (!f) {\n        return;\n    }\n    va_list ap;\n    va_start(ap, fmt);\n    vfprintf(f, fmt, ap);\n    va_end(ap);\n    fprintf(f, \"\\n\");\n    fclose(f);\n}\n\n/* Probe helper: dump the raw bytes of the lfs->cfg member along with context.\n   This reads the object representation of the member so that other agents can\n   compare before/after evaluation of LFS_LOCK and establish whether the\n   evaluation had observable effects. */\nstatic void __probe_dump_cfg_bytes(void *lfs_ptr, const char *label) {\n    if (!lfs_ptr) {\n        __probe_log(\"%s: lfs pointer is NULL\", label);\n        return;\n    }\n    /* We don't know the exact type of lfs->cfg here, so take its address\n       and print sizeof(lfs->cfg) by relying on the caller to pass the\n       correct pointer-to-struct and to perform offsetof. To avoid adding\n       type assumptions in this probe, the caller will do the sizeof read and\n       pass the pointer to the member. */\n    /* This function is intentionally simple: the caller will pass the\n       address of the cfg member and the size as if it were (unsigned char*).\n       For convenience, we treat lfs_ptr as pointer to a byte array. */\n    unsigned char *p = (unsigned char *)lfs_ptr;\n    /* We cannot determine size here; the caller will write a header line and\n       then dump a conservative number of bytes (up to 64) depending on the\n       size printed by the caller. */\n    /* NOTE: actual dumping size is controlled by the caller; here we just\n       provide an entry point used below. */\n    __probe_log(\"%s: dump bytes (raw display requested)\", label);\n}\n\n/* Modified lfs_removeattr with probes. Preserves original logic and calls. */\nint lfs_removeattr(lfs_t *lfs, const char *path, uint8_t type) {\n    /* Log entry with basic parameters */\n    __probe_log(\"ENTER lfs_removeattr: lfs=%p, path=\\\"%s\\\", type=%\" PRIu8\",\n                (void*)lfs, (path ? path : \"(null)\"), type);\n\n    /* If lfs is non-NULL, print information about the cfg member bytes and\n       its size so an external examiner can compare before/after. This does\n       one read of the cfg member for diagnostic purposes. This mirrors the\n       fact that LFS_LOCK will evaluate lfs->cfg in the original code; the\n       probe reads it to show whether that sub-expression had any observable\n       effect (bytes changed, etc.). */\n    if (lfs) {\n        size_t cfg_size = sizeof(lfs->cfg);\n        unsigned char *cfg_ptr = (unsigned char *)&lfs->cfg;\n        /* Header: address and size */\n        __probe_log(\"BEFORE LFS_LOCK: &lfs->cfg=%p, sizeof(lfs->cfg)=%zu\",\n                    (void*)cfg_ptr, cfg_size);\n        /* Dump the raw bytes of the cfg member */\n        {\n            FILE *f = fopen(\"/tmp/logs/1012.txt\", \"a\");\n            if (f) {\n                fprintf(f, \"BEFORE LFS_LOCK: cfg bytes:\");\n                for (size_t i = 0; i < cfg_size; i++) {\n                    fprintf(f, \" %02x\", (unsigned int)cfg_ptr[i]);\n                }\n                fprintf(f, \"\\n\");\n                fclose(f);\n            }\n        }\n    }\n\n    /* Call the lock as in original code. We capture its return value for\n       logging. Note: LFS_LOCK may evaluate lfs->cfg internally. */\n    int err = LFS_LOCK(lfs->cfg);\n\n    __probe_log(\"LFS_LOCK returned: %d\", err);\n\n    if (err) {\n        /* Log early return path, preserving original behaviour. */\n        __probe_log(\"lfs_removeattr returning early with err=%d\", err);\n        return err;\n    }\n\n    /* After the lock call, re-dump the cfg bytes to show whether the\n       evaluation of the cfg sub-expression had any observable effect on the\n       stored bytes (for non-volatile members this should be unchanged). */\n    if (lfs) {\n        size_t cfg_size = sizeof(lfs->cfg);\n        unsigned char *cfg_ptr = (unsigned char *)&lfs->cfg;\n        __probe_log(\"AFTER LFS_LOCK: &lfs->cfg=%p, sizeof(lfs->cfg)=%zu\",\n                    (void*)cfg_ptr, cfg_size);\n        {\n            FILE *f = fopen(\"/tmp/logs/1012.txt\", \"a\");\n            if (f) {\n                fprintf(f, \"AFTER LFS_LOCK: cfg bytes:\");\n                for (size_t i = 0; i < cfg_size; i++) {\n                    fprintf(f, \" %02x\", (unsigned int)cfg_ptr[i]);\n                }\n                fprintf(f, \"\\n\");\n                fclose(f);\n            }\n        }\n    }\n\n    /* Preserve original trace call */\n    LFS_TRACE(\"lfs_removeattr(%p, \\\"%s\\\", %\" PRIu8\")\", (void*)lfs, path, type);\n\n    /* Call underlying implementation and log its result. */\n    err = lfs_removeattr_(lfs, path, type);\n\n    __probe_log(\"lfs_removeattr_ returned: %d\", err);\n\n    LFS_TRACE(\"lfs_removeattr -> %d\", err);\n\n    /* Unlock and log that we did so. Preserve original unlock order. */\n    LFS_UNLOCK(lfs->cfg);\n    __probe_log(\"LFS_UNLOCK called for lfs->cfg (address taken)\");\n\n    __probe_log(\"EXIT lfs_removeattr with err=%d\", err);\n    return err;\n}\n"
}