{
  "user_message": "An agent A claimed that the following lfs_file_size_ code violates the MISRA C 2023 rule 8.13.\n<misra_rule>\nMISRA C 2023 Rule 8.13 is A pointer should point to a const-qualified type whenever possible.\n\n</misra_rule>\n<target_code>\nHere is the original code of lfs_file_size_.\n```c\nstatic lfs_soff_t lfs_file_size_(lfs_t *lfs, lfs_file_t *file) {\n    (void)lfs;\n\n#ifndef LFS_READONLY\n    if (file->flags & LFS_F_WRITING) {\n        return lfs_max(file->pos, file->ctz.size);\n    }\n#endif\n\n    return file->ctz.size;\n}\n```\n</target_code>\n<response format>\nProvide your answer with these fields.\n- explanation: your evaluation of the scenario provided by the agent A.\n- is_report_correct: whether the report is correct or not (true/false). True means there is a violation.\n</response format>\n<scenario>\nThe agent A provided the following violation scenario:\nThe parameter 'file' is declared as 'lfs_file_t *file' but the function only reads from the pointed-to object (file->flags, file->pos, file->ctz.size) and never modifies it. According to MISRA C 2023 Rule 8.13, it should be const-qualified when possible. The signature should be e.g. 'const lfs_file_t *file' (and possibly 'const lfs_t *lfs') to avoid this violation.\n</scenario>\n\n<execution_log>\nThe agent A also provided the following output log:\nlfs_file_size_ probe: enter\n  file pointer: 0x7ffe630832d0\n  file->flags: 0x00100001\n  file->pos: 0\n  file->ctz.size: 10\n----\nlfs_file_size_ probe: branch: default -> return file->ctz.size\n  file pointer: 0x7ffe630832d0\n  file->flags: 0x00100001\n  file->pos: 0\n  file->ctz.size: 10\n----\nlfs_file_size_ probe: enter\n  file pointer: 0x7ffe630832d0\n  file->flags: 0x00100001\n  file->pos: 0\n  file->ctz.size: 10\n----\nlfs_file_size_ probe: branch: default -> return file->ctz.size\n  file pointer: 0x7ffe630832d0\n  file->flags: 0x00100001\n  file->pos: 0\n  file->ctz.size: 10\n----\nlfs_file_size_ probe: enter\n  file pointer: 0x7ffe630832d0\n  file->flags: 0x00100001\n  file->pos: 0\n  file->ctz.size: 10\n----\nlfs_file_size_ probe: branch: default -> return file->ctz.size\n  file pointer: 0x7ffe630832d0\n  file->flags: 0x00100001\n  file->pos: 0\n  file->ctz.size: 10\n----\nlfs_file_size_ probe: enter\n  file pointer: 0x7ffe630832d0\n  file->flags: 0x00100001\n  file->pos: 0\n  file->ctz.size: 10\n----\nlfs_file_size_ probe: branch: default -> return file->ctz.size\n  file pointer: 0x7ffe630832d0\n  file->flags: 0x00100001\n  file->pos: 0\n  file->ctz.size: 10\n----\nlfs_file_size_ probe: enter\n  file pointer: 0x7ffe630832d0\n  file->flags: 0x00100001\n  file->pos: 0\n  file->ctz.size: 10\n----\nlfs_file_size_ probe: branch: default -> return file->ctz.size\n  file pointer: 0x7ffe630832d0\n  file->flags: 0x00100001\n  file->pos: 0\n  file->ctz.size: 10\n----\nlfs_file_size_ probe: enter\n  file pointer: 0x7ffe630832d0\n  file->flags: 0x00100001\n  file->pos: 0\n  file->ctz.size: 10\n----\nlfs_file_size_ probe: branch: default -> return file->ctz.size\n  file pointer: 0x7ffe630832d0\n  file->flags: 0x00100001\n  file->pos: 0\n  file->ctz.size: 10\n----\nlfs_file_size_ probe: enter\n  file pointer: 0x7ffe630832d0\n  file->flags: 0x00100001\n  file->pos: 0\n  file->ctz.size: 10\n----\nlfs_file_size_ probe: branch: default -> return file->ctz.size\n  file pointer: 0x7ffe630832d0\n  file->flags: 0x00100001\n  file->pos: 0\n  file->ctz.size: 10\n----\nlfs_file_size_ probe: enter\n  file pointer: 0x7ffe630832d0\n  file->flags: 0x00100001\n  file->pos: 0\n  file->ctz.size: 10\n----\nlfs_file_size_ probe: branch: default -> return file->ctz.size\n  file pointer: 0x7ffe630832d0\n  file->flags: 0x00100001\n  file->pos: 0\n  file->ctz.size: 10\n----\nlfs_file_size_ probe: enter\n  file pointer: 0x7ffe630832d0\n  file->flags: 0x00100001\n  file->pos: 0\n  file->ctz.size: 10\n----\nlfs_file_size_ probe: branch: default -> return file->ctz.size\n  file pointer: 0x7ffe630832d0\n  file->flags: 0x00100001\n  file->pos: 0\n  file->ctz.size: 10\n----\nlfs_file_size_ probe: enter\n  file pointer: 0x7ffe630832d0\n  file->flags: 0x00100001\n  file->pos: 0\n  file->ctz.size: 10\n----\nlfs_file_size_ probe: branch: default -> return file->ctz.size\n  file pointer: 0x7ffe630832d0\n  file->flags: 0x00100001\n  file->pos: 0\n  file->ctz.size: 10\n----\nlfs_file_size_ probe: enter\n  file pointer: 0x7ffe630832d0\n  file->flags: 0x00100001\n  file->pos: 0\n  file->ctz.size: 10\n----\nlfs_file_size_ probe: branch: default -> return file->ctz.size\n  file pointer: 0x7ffe630832d0\n  file->flags: 0x00100001\n  file->pos: 0\n  file->ctz.size: 10\n----\nlfs_file_size_ probe: enter\n  file pointer: 0x7ffe630832d0\n  file->flags: 0x00100001\n  file->pos: 0\n  file->ctz.size: 10\n----\nlfs_file_size_ probe: branch: default -> return file->ctz.size\n  file pointer: 0x7ffe630832d0\n  file->flags: 0x00100001\n  file->pos: 0\n  file->ctz.size: 10\n----\nlfs_file_size_ probe: enter\n  file pointer: 0x7ffe630832d0\n  file->flags: 0x00100001\n  file->pos: 0\n  file->ctz.size: 10\n----\nlfs_file_size_ probe: branch: default -> return file->ctz.size\n  file pointer: 0x7ffe630832d0\n  file->flags: 0x00100001\n  file->pos: 0\n  file->ctz.size: 10\n----\nlfs_file_size_ probe: enter\n  file pointer: 0x7ffe630832d0\n  file->flags: 0x00100001\n  file->pos: 0\n  file->ctz.size: 10\n----\nlfs_file_size_ probe: branch: default -> return file->ctz.size\n  file pointer: 0x7ffe630832d0\n  file->flags: 0x00100001\n  file->pos: 0\n  file->ctz.size: 10\n----\nlfs_file_size_ probe: enter\n  file pointer: 0x7ffe630832d0\n  file->flags: 0x00\n</execution_log>\n<additional code>Here are the definitions of symbols that are close to the target function lfs_file_size_:\ntypedef int32_t  lfs_soff_t\n...\ntypedef struct lfs {\n    lfs_cache_t rcache;\n    lfs_cache_t pcache;\n\n    lfs_block_t root[2];\n    struct lfs_mlist {\n        struct lfs_mlist *next;\n        uint16_t id;\n        uint8_t type;\n        lfs_mdir_t m;\n    } *mlist;\n    uint32_t seed;\n\n    lfs_gstate_t gstate;\n    lfs_gstate_t gdisk;\n    lfs_gstate_t gdelta;\n\n    struct lfs_lookahead {\n        lfs_block_t start;\n        lfs_block_t size;\n        lfs_block_t next;\n        lfs_block_t ckpoint;\n        uint8_t *buffer;\n    } lookahead;\n\n    const struct lfs_config *cfg;\n    lfs_size_t block_count;\n    lfs_size_t name_max;\n    lfs_size_t file_max;\n    lfs_size_t attr_max;\n    lfs_size_t inline_max;\n\n#ifdef LFS_MIGRATE\n    struct lfs1 *lfs1;\n#endif\n} lfs_t\n...\ntypedef struct lfs_file {\n    struct lfs_file *next;\n    uint16_t id;\n    uint8_t type;\n    lfs_mdir_t m;\n\n    struct lfs_ctz {\n        lfs_block_t head;\n        lfs_size_t size;\n    } ctz;\n\n    uint32_t flags;\n    lfs_off_t pos;\n    lfs_block_t block;\n    lfs_off_t off;\n    lfs_cache_t cache;\n\n    const struct lfs_file_config *cfg;\n} lfs_file_t\n</additional code>\n\n<instruction>\nJudge whether the report is correct or not.\n</instruction>\n",
  "is_report_correct": true,
  "explanation": "The report is correct. In lfs_file_size_ neither of the pointer parameters is used to modify the pointees: file is only read (file->flags, file->pos, file->ctz.size) and lfs is unused (cast to void). Under MISRA C 2023 Rule 8.13 a pointer parameter should be const-qualified whenever possible, so the signature could be const lfs_file_t *file (and const lfs_t *lfs). The only reason this would not be a violation is an external constraint (for example needing to match a non-const function-pointer type or API) \u2014 no such constraint is evident here, and the function is static, so changing to const is feasible."
}