{
  "user_message": "<misra_rule>\nMISRA C 2023 Rule 2.2 is: A project shall not contain dead code.\nAny operation that is executed but whose removal would not affect program behaviour constitutes dead code. Notes:\n1. The behaviour of an embedded sytem is often determined not just by the nature of its actions, but also by the time at which they occur.\n2. unreachable code is not dead code, as it cannot be executed.\n3.Initialization is not the same as an assignment operation and is therfore not a candidate for dead code.\n</misra_rule>\n\nAnother agent reported that the target code violated the Rule 2.2.\nHere is the comment from the agent.\n<violation scenario>\nWhen cwd.m.split is true the LFS_MKTAG_IF(...) in the last attribute evaluates to a NOOP tag so lfs_dir_commit will ignore that attribute. Nevertheless the initializer still evaluates/stores the paired value (dir.pair) into the temporary attrs array (and the call sequence around it is executed). Those evaluations/initializations have no effect on program behaviour in that case, so they are dead operations.\n</violation scenario>\n\nYour job is to insert logging code to capture the control flow and state information of the program.\nInsert logging code so that other agents can reproduce and get evidence for the violation scenario.\n<response format>\n- test_code: a modified lfs_mkdir_ code that contains useful probe functions that print useful logs to a file \"/tmp/logs/952.txt\". The logs should contain the control path and state information of the violation scenario. If test code is not required to validate the scenario, you can leave this blank.\nHere are the constraints for the test code:\n- The test code MUST preserve the original logic of lfs_mkdir_ as much as possible.\nYou CAN just insert probe functions to the original code.\n- DO NOT introduce new violations to demonstrate your scenario.\n- The test code MUST be compilable and executable.\n- The test code MUST include line breaks.\n- You MUST NOT define the main function.\n- You MUST NOT define macros.\n</response format>\n<target_code>\nHere is the code of lfs_mkdir_:\n```c\nstatic int lfs_mkdir_(lfs_t *lfs, const char *path) {\n    // deorphan if we haven't yet, needed at most once after poweron\n    int err = lfs_fs_forceconsistency(lfs);\n    if (err) {\n        return err;\n    }\n\n    struct lfs_mlist cwd;\n    cwd.next = lfs->mlist;\n    uint16_t id;\n    err = lfs_dir_find(lfs, &cwd.m, &path, &id);\n    if (!(err == LFS_ERR_NOENT && lfs_path_islast(path))) {\n        return (err < 0) ? err : LFS_ERR_EXIST;\n    }\n\n    // check that name fits\n    lfs_size_t nlen = lfs_path_namelen(path);\n    if (nlen > lfs->name_max) {\n        return LFS_ERR_NAMETOOLONG;\n    }\n\n    // build up new directory\n    lfs_alloc_ckpoint(lfs);\n    lfs_mdir_t dir;\n    err = lfs_dir_alloc(lfs, &dir);\n    if (err) {\n        return err;\n    }\n\n    // find end of list\n    lfs_mdir_t pred = cwd.m;\n    while (pred.split) {\n        err = lfs_dir_fetch(lfs, &pred, pred.tail);\n        if (err) {\n            return err;\n        }\n    }\n\n    // setup dir\n    lfs_pair_tole32(pred.tail);\n    err = lfs_dir_commit(lfs, &dir, LFS_MKATTRS(\n            {LFS_MKTAG(LFS_TYPE_SOFTTAIL, 0x3ff, 8), pred.tail}));\n    lfs_pair_fromle32(pred.tail);\n    if (err) {\n        return err;\n    }\n\n    // current block not end of list?\n    if (cwd.m.split) {\n        // update tails, this creates a desync\n        err = lfs_fs_preporphans(lfs, +1);\n        if (err) {\n            return err;\n        }\n\n        // it's possible our predecessor has to be relocated, and if\n        // our parent is our predecessor's predecessor, this could have\n        // caused our parent to go out of date, fortunately we can hook\n        // ourselves into littlefs to catch this\n        cwd.type = 0;\n        cwd.id = 0;\n        lfs->mlist = &cwd;\n\n        lfs_pair_tole32(dir.pair);\n        err = lfs_dir_commit(lfs, &pred, LFS_MKATTRS(\n                {LFS_MKTAG(LFS_TYPE_SOFTTAIL, 0x3ff, 8), dir.pair}));\n        lfs_pair_fromle32(dir.pair);\n        if (err) {\n            lfs->mlist = cwd.next;\n            return err;\n        }\n\n        lfs->mlist = cwd.next;\n        err = lfs_fs_preporphans(lfs, -1);\n        if (err) {\n            return err;\n        }\n    }\n\n    // now insert into our parent block\n    lfs_pair_tole32(dir.pair);\n    err = lfs_dir_commit(lfs, &cwd.m, LFS_MKATTRS(\n            {LFS_MKTAG(LFS_TYPE_CREATE, id, 0), NULL},\n            {LFS_MKTAG(LFS_TYPE_DIR, id, nlen), path},\n            {LFS_MKTAG(LFS_TYPE_DIRSTRUCT, id, 8), dir.pair},\n            {LFS_MKTAG_IF(!cwd.m.split,\n                LFS_TYPE_SOFTTAIL, 0x3ff, 8), dir.pair}));\n    lfs_pair_fromle32(dir.pair);\n    if (err) {\n        return err;\n    }\n\n    return 0;\n}\n```\n</target_code>\nPlease provide the modified lfs_mkdir_ code.\n",
  "test_code": "#include <stdio.h>\n#include <stdint.h>\n#include <stddef.h>\n\n/* Probe helper: write a compact log line to /tmp/logs/952.txt. */\nstatic void lfs_mkdir_log(const char *stage, int cwd_split, unsigned id,\n        size_t nlen, const void *pair_ptr, size_t pair_size,\n        const void *tail_ptr, size_t tail_size, const char *path) {\n    FILE *f = fopen(\"/tmp/logs/952.txt\", \"a\");\n    if (!f) { return; }\n    fprintf(f, \"[lfs_mkdir] %s: cwd_split=%d id=%u nlen=%zu path=%s\\n\",\n            stage, cwd_split, id, nlen, path ? path : \"(null)\");\n    if (pair_ptr && pair_size) {\n        const unsigned char *b = (const unsigned char*)pair_ptr;\n        fprintf(f, \"  dir.pair=\");\n        for (size_t i = 0; i < pair_size; i++) { fprintf(f, \"%02x\", b[i]); }\n        fprintf(f, \"\\n\");\n    }\n    if (tail_ptr && tail_size) {\n        const unsigned char *t = (const unsigned char*)tail_ptr;\n        fprintf(f, \"  pred.tail=\");\n        for (size_t i = 0; i < tail_size; i++) { fprintf(f, \"%02x\", t[i]); }\n        fprintf(f, \"\\n\");\n    }\n    fclose(f);\n}\n\nstatic int lfs_mkdir_(lfs_t *lfs, const char *path) {\n    // deorphan if we haven't yet, needed at most once after poweron\n    int err = lfs_fs_forceconsistency(lfs);\n    if (err) {\n        return err;\n    }\n\n    struct lfs_mlist cwd;\n    cwd.next = lfs->mlist;\n    uint16_t id;\n    err = lfs_dir_find(lfs, &cwd.m, &path, &id);\n    if (!(err == LFS_ERR_NOENT && lfs_path_islast(path))) {\n        return (err < 0) ? err : LFS_ERR_EXIST;\n    }\n\n    // check that name fits\n    lfs_size_t nlen = lfs_path_namelen(path);\n    if (nlen > lfs->name_max) {\n        return LFS_ERR_NAMETOOLONG;\n    }\n\n    // build up new directory\n    lfs_alloc_ckpoint(lfs);\n    lfs_mdir_t dir;\n    err = lfs_dir_alloc(lfs, &dir);\n    if (err) {\n        return err;\n    }\n\n    // find end of list\n    lfs_mdir_t pred = cwd.m;\n    while (pred.split) {\n        err = lfs_dir_fetch(lfs, &pred, pred.tail);\n        if (err) {\n            return err;\n        }\n    }\n\n    // Log state before first tail attachment\n    lfs_mkdir_log(\"before_attach_tail\", (int)cwd.m.split, id, nlen,\n            &dir.pair, sizeof(dir.pair), &pred.tail, sizeof(pred.tail), path);\n\n    // setup dir\n    lfs_pair_tole32(pred.tail);\n    /* log bytes after le32 conversion */\n    lfs_mkdir_log(\"after_pred_pair_tole32\", (int)cwd.m.split, id, nlen,\n            &dir.pair, sizeof(dir.pair), &pred.tail, sizeof(pred.tail), path);\n\n    err = lfs_dir_commit(lfs, &dir, LFS_MKATTRS(\n            {LFS_MKTAG(LFS_TYPE_SOFTTAIL, 0x3ff, 8), pred.tail}));\n    lfs_pair_fromle32(pred.tail);\n    if (err) {\n        return err;\n    }\n\n    // current block not end of list?\n    if (cwd.m.split) {\n        // update tails, this creates a desync\n        err = lfs_fs_preporphans(lfs, +1);\n        if (err) {\n            return err;\n        }\n\n        // it's possible our predecessor has to be relocated, and if\n        // our parent is our predecessor's predecessor, this could have\n        // caused our parent to go out of date, fortunately we can hook\n        // ourselves into littlefs to catch this\n        cwd.type = 0;\n        cwd.id = 0;\n        lfs->mlist = &cwd;\n\n        lfs_pair_tole32(dir.pair);\n        /* log dir.pair before committing to pred */\n        lfs_mkdir_log(\"before_commit_pred_with_dirpair\", (int)cwd.m.split, id, nlen,\n                &dir.pair, sizeof(dir.pair), &pred.tail, sizeof(pred.tail), path);\n\n        err = lfs_dir_commit(lfs, &pred, LFS_MKATTRS(\n                {LFS_MKTAG(LFS_TYPE_SOFTTAIL, 0x3ff, 8), dir.pair}));\n        lfs_pair_fromle32(dir.pair);\n        if (err) {\n            lfs->mlist = cwd.next;\n            return err;\n        }\n\n        lfs->mlist = cwd.next;\n        err = lfs_fs_preporphans(lfs, -1);\n        if (err) {\n            return err;\n        }\n\n        /* log state after pred updated when cwd.m.split was true */\n        lfs_mkdir_log(\"after_pred_update_in_split_path\", (int)cwd.m.split, id, nlen,\n                &dir.pair, sizeof(dir.pair), &pred.tail, sizeof(pred.tail), path);\n    }\n\n    // now insert into our parent block\n    /* Log state immediately before final commit. This is the critical\n       point for the reported violation: when cwd.m.split is true, the\n       conditional attribute LFS_MKTAG_IF(!cwd.m.split, ...) becomes a NOOP\n       and will be ignored by lfs_dir_commit, but the initializer (dir.pair)\n       is still evaluated/stored. We log cwd.m.split and the bytes of dir.pair\n       so callers can observe the unnecessary write. */\n    lfs_mkdir_log(\"before_final_commit\", (int)cwd.m.split, id, nlen,\n            &dir.pair, sizeof(dir.pair), &pred.tail, sizeof(pred.tail), path);\n\n    lfs_pair_tole32(dir.pair);\n    /* log dir.pair after endian conversion and just before commit */\n    lfs_mkdir_log(\"after_dir_pair_tole32_before_commit\", (int)cwd.m.split, id, nlen,\n            &dir.pair, sizeof(dir.pair), &pred.tail, sizeof(pred.tail), path);\n\n    err = lfs_dir_commit(lfs, &cwd.m, LFS_MKATTRS(\n            {LFS_MKTAG(LFS_TYPE_CREATE, id, 0), NULL},\n            {LFS_MKTAG(LFS_TYPE_DIR, id, nlen), path},\n            {LFS_MKTAG(LFS_TYPE_DIRSTRUCT, id, 8), dir.pair},\n            {LFS_MKTAG_IF(!cwd.m.split,\n                LFS_TYPE_SOFTTAIL, 0x3ff, 8), dir.pair}));\n    lfs_pair_fromle32(dir.pair);\n\n    /* Log result and final dir.pair bytes after commit */\n    lfs_mkdir_log(\"after_final_commit\", (int)cwd.m.split, id, nlen,\n            &dir.pair, sizeof(dir.pair), &pred.tail, sizeof(pred.tail), path);\n\n    if (err) {\n        return err;\n    }\n\n    return 0;\n}\n"
}