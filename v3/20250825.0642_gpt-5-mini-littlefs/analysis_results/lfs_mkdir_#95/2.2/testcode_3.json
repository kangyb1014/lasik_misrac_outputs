{
  "user_message": "<misra_rule>\nMISRA C 2023 Rule 2.2 is: A project shall not contain dead code.\nAny operation that is executed but whose removal would not affect program behaviour constitutes dead code. Notes:\n1. The behaviour of an embedded sytem is often determined not just by the nature of its actions, but also by the time at which they occur.\n2. unreachable code is not dead code, as it cannot be executed.\n3.Initialization is not the same as an assignment operation and is therfore not a candidate for dead code.\n</misra_rule>\n\nAnother agent reported that the target code violated the Rule 2.2.\nHere is the comment from the agent.\n<violation scenario>\nThe statement is an assertion macro (LFS_ASSERT) that only evaluates a condition and has no side-effects. If LFS_ASSERT is defined as a no-op in production (common when disabling debug asserts) then this line performs no observable action and its removal would not affect program behaviour, so it is dead code. It is also effectively dead if program invariants guarantee the condition is always true at runtime (the check only documents an invariant).\n</violation scenario>\n\nYour job is to insert logging code to capture the control flow and state information of the program.\nInsert logging code so that other agents can reproduce and get evidence for the violation scenario.\n<response format>\n- test_code: a modified lfs_mkdir_ code that contains useful probe functions that print useful logs to a file \"/tmp/logs/952.txt\". The logs should contain the control path and state information of the violation scenario. If test code is not required to validate the scenario, you can leave this blank.\nHere are the constraints for the test code:\n- The test code MUST preserve the original logic of lfs_mkdir_ as much as possible.\nYou CAN just insert probe functions to the original code.\n- DO NOT introduce new violations to demonstrate your scenario.\n- The test code MUST be compilable and executable.\n- The test code MUST include line breaks.\n- You MUST NOT define the main function.\n- You MUST NOT define macros.\n</response format>\n<target_code>\nHere is the code of lfs_mkdir_:\n```c\nstatic int lfs_mkdir_(lfs_t *lfs, const char *path) {\n    // deorphan if we haven't yet, needed at most once after poweron\n    int err = lfs_fs_forceconsistency(lfs);\n    if (err) {\n        return err;\n    }\n\n    struct lfs_mlist cwd;\n    cwd.next = lfs->mlist;\n    uint16_t id;\n    err = lfs_dir_find(lfs, &cwd.m, &path, &id);\n    if (!(err == LFS_ERR_NOENT && lfs_path_islast(path))) {\n        return (err < 0) ? err : LFS_ERR_EXIST;\n    }\n\n    // check that name fits\n    lfs_size_t nlen = lfs_path_namelen(path);\n    if (nlen > lfs->name_max) {\n        return LFS_ERR_NAMETOOLONG;\n    }\n\n    // build up new directory\n    lfs_alloc_ckpoint(lfs);\n    lfs_mdir_t dir;\n    err = lfs_dir_alloc(lfs, &dir);\n    if (err) {\n        return err;\n    }\n\n    // find end of list\n    lfs_mdir_t pred = cwd.m;\n    while (pred.split) {\n        err = lfs_dir_fetch(lfs, &pred, pred.tail);\n        if (err) {\n            return err;\n        }\n    }\n\n    // setup dir\n    lfs_pair_tole32(pred.tail);\n    err = lfs_dir_commit(lfs, &dir, LFS_MKATTRS(\n            {LFS_MKTAG(LFS_TYPE_SOFTTAIL, 0x3ff, 8), pred.tail}));\n    lfs_pair_fromle32(pred.tail);\n    if (err) {\n        return err;\n    }\n\n    // current block not end of list?\n    if (cwd.m.split) {\n        // update tails, this creates a desync\n        err = lfs_fs_preporphans(lfs, +1);\n        if (err) {\n            return err;\n        }\n\n        // it's possible our predecessor has to be relocated, and if\n        // our parent is our predecessor's predecessor, this could have\n        // caused our parent to go out of date, fortunately we can hook\n        // ourselves into littlefs to catch this\n        cwd.type = 0;\n        cwd.id = 0;\n        lfs->mlist = &cwd;\n\n        lfs_pair_tole32(dir.pair);\n        err = lfs_dir_commit(lfs, &pred, LFS_MKATTRS(\n                {LFS_MKTAG(LFS_TYPE_SOFTTAIL, 0x3ff, 8), dir.pair}));\n        lfs_pair_fromle32(dir.pair);\n        if (err) {\n            lfs->mlist = cwd.next;\n            return err;\n        }\n\n        lfs->mlist = cwd.next;\n        err = lfs_fs_preporphans(lfs, -1);\n        if (err) {\n            return err;\n        }\n    }\n\n    // now insert into our parent block\n    lfs_pair_tole32(dir.pair);\n    err = lfs_dir_commit(lfs, &cwd.m, LFS_MKATTRS(\n            {LFS_MKTAG(LFS_TYPE_CREATE, id, 0), NULL},\n            {LFS_MKTAG(LFS_TYPE_DIR, id, nlen), path},\n            {LFS_MKTAG(LFS_TYPE_DIRSTRUCT, id, 8), dir.pair},\n            {LFS_MKTAG_IF(!cwd.m.split,\n                LFS_TYPE_SOFTTAIL, 0x3ff, 8), dir.pair}));\n    lfs_pair_fromle32(dir.pair);\n    if (err) {\n        return err;\n    }\n\n    return 0;\n}\n```\n</target_code>\nPlease provide the modified lfs_mkdir_ code.\n",
  "test_code": "#include <stdio.h>\n#include <stdarg.h>\n\n/* Probe logging helper - writes to /tmp/logs/952.txt. Keeps function static to avoid symbol\n   collisions and minimize impact on program. */\nstatic void lfs_log_probe(const char *fmt, ...) {\n    FILE *f = fopen(\"/tmp/logs/952.txt\", \"a\");\n    if (!f) {\n        return;\n    }\n    va_list ap;\n    va_start(ap, fmt);\n    vfprintf(f, fmt, ap);\n    fprintf(f, \"\\n\");\n    va_end(ap);\n    fclose(f);\n}\n\nstatic int lfs_mkdir_(lfs_t *lfs, const char *path) {\n    lfs_log_probe(\"ENTER lfs_mkdir_: lfs=%p path='%s'\", (void *)lfs, path ? path : \"(null)\");\n\n    // deorphan if we haven't yet, needed at most once after poweron\n    int err = lfs_fs_forceconsistency(lfs);\n    lfs_log_probe(\"after lfs_fs_forceconsistency: err=%d\", err);\n    if (err) {\n        lfs_log_probe(\"EXIT lfs_mkdir_: returning err=%d (forceconsistency)\", err);\n        return err;\n    }\n\n    struct lfs_mlist cwd;\n    cwd.next = lfs->mlist;\n    uint16_t id;\n    err = lfs_dir_find(lfs, &cwd.m, &path, &id);\n    lfs_log_probe(\"after lfs_dir_find: err=%d id=%u path_now='%s' cwd.next=%p cwd.m=%p\", \n                  err, (unsigned)id, path ? path : \"(null)\", (void*)cwd.next, (void*)&cwd.m);\n\n    int is_last = lfs_path_islast(path);\n    lfs_log_probe(\"lfs_path_islast(path)=%d\", is_last);\n\n    if (!(err == LFS_ERR_NOENT && is_last)) {\n        int ret = (err < 0) ? err : LFS_ERR_EXIST;\n        lfs_log_probe(\"EXIT lfs_mkdir_: condition failed for creating dir, returning %d\", ret);\n        return ret;\n    }\n\n    // check that name fits\n    lfs_size_t nlen = lfs_path_namelen(path);\n    lfs_log_probe(\"name length nlen=%llu name_max=%llu\", (unsigned long long)nlen, (unsigned long long)lfs->name_max);\n    if (nlen > lfs->name_max) {\n        lfs_log_probe(\"EXIT lfs_mkdir_: name too long, returning LFS_ERR_NAMETOOLONG\");\n        return LFS_ERR_NAMETOOLONG;\n    }\n\n    // build up new directory\n    lfs_alloc_ckpoint(lfs);\n    lfs_mdir_t dir;\n    err = lfs_dir_alloc(lfs, &dir);\n    lfs_log_probe(\"after lfs_dir_alloc: err=%d dir_addr=%p\", err, (void*)&dir);\n    if (err) {\n        lfs_log_probe(\"EXIT lfs_mkdir_: returning err=%d (dir_alloc)\", err);\n        return err;\n    }\n\n    // find end of list\n    lfs_mdir_t pred = cwd.m;\n    lfs_log_probe(\"entering pred traversal: initial pred.split=%d pred_addr=%p\", (int)pred.split, (void*)&pred);\n    while (pred.split) {\n        err = lfs_dir_fetch(lfs, &pred, pred.tail);\n        lfs_log_probe(\"lfs_dir_fetch returned err=%d for pred.addr=%p\", err, (void*)&pred);\n        if (err) {\n            lfs_log_probe(\"EXIT lfs_mkdir_: returning err=%d (dir_fetch)\", err);\n            return err;\n        }\n    }\n    lfs_log_probe(\"exited pred traversal: pred.split=%d pred_addr=%p\", (int)pred.split, (void*)&pred);\n\n    // setup dir\n    lfs_pair_tole32(pred.tail);\n    lfs_log_probe(\"about to commit new dir tail: pred.tail (to-le) at pred_addr=%p\", (void*)&pred);\n    err = lfs_dir_commit(lfs, &dir, LFS_MKATTRS(\n            {LFS_MKTAG(LFS_TYPE_SOFTTAIL, 0x3ff, 8), pred.tail}));\n    lfs_pair_fromle32(pred.tail);\n    lfs_log_probe(\"after lfs_dir_commit (softtail->pred): err=%d\", err);\n    if (err) {\n        lfs_log_probe(\"EXIT lfs_mkdir_: returning err=%d (commit softtail->pred)\", err);\n        return err;\n    }\n\n    // current block not end of list?\n    if (cwd.m.split) {\n        lfs_log_probe(\"cwd.m.split is true: performing orphan preparation and possible relocation\");\n        // update tails, this creates a desync\n        err = lfs_fs_preporphans(lfs, +1);\n        lfs_log_probe(\"after lfs_fs_preporphans(+1): err=%d\", err);\n        if (err) {\n            lfs_log_probe(\"EXIT lfs_mkdir_: returning err=%d (preporphans +1)\", err);\n            return err;\n        }\n\n        // it's possible our predecessor has to be relocated, and if\n        // our parent is our predecessor's predecessor, this could have\n        // caused our parent to go out of date, fortunately we can hook\n        // ourselves into littlefs to catch this\n        cwd.type = 0;\n        cwd.id = 0;\n        lfs->mlist = &cwd;\n        lfs_log_probe(\"hooked cwd into lfs->mlist=%p (cwd_addr=%p)\", (void*)lfs->mlist, (void*)&cwd);\n\n        lfs_pair_tole32(dir.pair);\n        lfs_log_probe(\"about to commit pred with dir.pair (to-le): dir_addr=%p pred_addr=%p\", (void*)&dir, (void*)&pred);\n        err = lfs_dir_commit(lfs, &pred, LFS_MKATTRS(\n                {LFS_MKTAG(LFS_TYPE_SOFTTAIL, 0x3ff, 8), dir.pair}));\n        lfs_pair_fromle32(dir.pair);\n        lfs_log_probe(\"after lfs_dir_commit (softtail->dir): err=%d\", err);\n        if (err) {\n            lfs->mlist = cwd.next;\n            lfs_log_probe(\"commit failed, restored lfs->mlist=%p, returning err=%d\", (void*)lfs->mlist, err);\n            return err;\n        }\n\n        lfs->mlist = cwd.next;\n        lfs_log_probe(\"restored lfs->mlist to cwd.next=%p\", (void*)lfs->mlist);\n        err = lfs_fs_preporphans(lfs, -1);\n        lfs_log_probe(\"after lfs_fs_preporphans(-1): err=%d\", err);\n        if (err) {\n            lfs_log_probe(\"EXIT lfs_mkdir_: returning err=%d (preporphans -1)\", err);\n            return err;\n        }\n    }\n\n    // now insert into our parent block\n    lfs_pair_tole32(dir.pair);\n    lfs_log_probe(\"about to commit create/dir/dirstruct (parent insert): cwd.m=%p dir=%p id=%u nlen=%llu\", \n                  (void*)&cwd.m, (void*)&dir, (unsigned)id, (unsigned long long)nlen);\n    err = lfs_dir_commit(lfs, &cwd.m, LFS_MKATTRS(\n            {LFS_MKTAG(LFS_TYPE_CREATE, id, 0), NULL},\n            {LFS_MKTAG(LFS_TYPE_DIR, id, nlen), path},\n            {LFS_MKTAG(LFS_TYPE_DIRSTRUCT, id, 8), dir.pair},\n            {LFS_MKTAG_IF(!cwd.m.split,\n                LFS_TYPE_SOFTTAIL, 0x3ff, 8), dir.pair}));\n    lfs_pair_fromle32(dir.pair);\n    lfs_log_probe(\"after lfs_dir_commit (parent insert): err=%d\", err);\n    if (err) {\n        lfs_log_probe(\"EXIT lfs_mkdir_: returning err=%d (commit parent)\", err);\n        return err;\n    }\n\n    lfs_log_probe(\"EXIT lfs_mkdir_: success (return 0)\");\n    return 0;\n}\n"
}