{
  "user_message": "<misra_rule>\nMISRA C 2023 Rule 14.3 is: Controlling expressions shall not be invariant.\nHere are exceptions to this rule:\n1. Invariants that are used to create infinite loops are permitted.\n2. A do-while loop with an essentially Boolean controlling expression that evaluates to false and satisfies the constraints and semantics for an integer constant expression is permitted.\n</misra_rule>\n\nAnother agent reported that the target code violated the Rule 14.3.\nHere is the comment from the agent.\n<violation scenario>\nThe fragment contains three occurrences of while (true). The outermost while (true) is an intentional infinite loop (allowed by the exception). However the two inner loops \u2014 the suffix-scanning loop that begins with \"while (true) { suffix += strspn(...); ... if (sufflen == 0) break; ... }\" and the entry-matching loop that begins with \"while (true) { tag = lfs_dir_fetchmatch(...); if (tag < 0) return tag; if (tag) break; if (!dir->split) return LFS_ERR_NOENT; }\" \u2014 use invariant controlling expressions but are not intended to be infinite loops (they rely on internal break/return conditions). These do not fall under the permitted infinite-loop exception, so they violate MISRA C 2023 Rule 14.3.\n</violation scenario>\n\nYour job is to insert logging code to capture the control flow and state information of the program.\nInsert logging code so that other agents can reproduce and get evidence for the violation scenario.\n<response format>\n- test_code: a modified lfs_mkdir_ code that contains useful probe functions that print useful logs to a file \"/tmp/logs/955.txt\". The logs should contain the control path and state information of the violation scenario. If test code is not required to validate the scenario, you can leave this blank.\nHere are the constraints for the test code:\n- The test code MUST preserve the original logic of lfs_mkdir_ as much as possible.\nYou CAN just insert probe functions to the original code.\n- DO NOT introduce new violations to demonstrate your scenario.\n- The test code MUST be compilable and executable.\n- The test code MUST include line breaks.\n- You MUST NOT define the main function.\n- You MUST NOT define macros.\n</response format>\n<target_code>\nHere is the code of lfs_mkdir_:\n```c\nstatic int lfs_mkdir_(lfs_t *lfs, const char *path) {\n    // deorphan if we haven't yet, needed at most once after poweron\n    int err = lfs_fs_forceconsistency(lfs);\n    if (err) {\n        return err;\n    }\n\n    struct lfs_mlist cwd;\n    cwd.next = lfs->mlist;\n    uint16_t id;\n    err = lfs_dir_find(lfs, &cwd.m, &path, &id);\n    if (!(err == LFS_ERR_NOENT && lfs_path_islast(path))) {\n        return (err < 0) ? err : LFS_ERR_EXIST;\n    }\n\n    // check that name fits\n    lfs_size_t nlen = lfs_path_namelen(path);\n    if (nlen > lfs->name_max) {\n        return LFS_ERR_NAMETOOLONG;\n    }\n\n    // build up new directory\n    lfs_alloc_ckpoint(lfs);\n    lfs_mdir_t dir;\n    err = lfs_dir_alloc(lfs, &dir);\n    if (err) {\n        return err;\n    }\n\n    // find end of list\n    lfs_mdir_t pred = cwd.m;\n    while (pred.split) {\n        err = lfs_dir_fetch(lfs, &pred, pred.tail);\n        if (err) {\n            return err;\n        }\n    }\n\n    // setup dir\n    lfs_pair_tole32(pred.tail);\n    err = lfs_dir_commit(lfs, &dir, LFS_MKATTRS(\n            {LFS_MKTAG(LFS_TYPE_SOFTTAIL, 0x3ff, 8), pred.tail}));\n    lfs_pair_fromle32(pred.tail);\n    if (err) {\n        return err;\n    }\n\n    // current block not end of list?\n    if (cwd.m.split) {\n        // update tails, this creates a desync\n        err = lfs_fs_preporphans(lfs, +1);\n        if (err) {\n            return err;\n        }\n\n        // it's possible our predecessor has to be relocated, and if\n        // our parent is our predecessor's predecessor, this could have\n        // caused our parent to go out of date, fortunately we can hook\n        // ourselves into littlefs to catch this\n        cwd.type = 0;\n        cwd.id = 0;\n        lfs->mlist = &cwd;\n\n        lfs_pair_tole32(dir.pair);\n        err = lfs_dir_commit(lfs, &pred, LFS_MKATTRS(\n                {LFS_MKTAG(LFS_TYPE_SOFTTAIL, 0x3ff, 8), dir.pair}));\n        lfs_pair_fromle32(dir.pair);\n        if (err) {\n            lfs->mlist = cwd.next;\n            return err;\n        }\n\n        lfs->mlist = cwd.next;\n        err = lfs_fs_preporphans(lfs, -1);\n        if (err) {\n            return err;\n        }\n    }\n\n    // now insert into our parent block\n    lfs_pair_tole32(dir.pair);\n    err = lfs_dir_commit(lfs, &cwd.m, LFS_MKATTRS(\n            {LFS_MKTAG(LFS_TYPE_CREATE, id, 0), NULL},\n            {LFS_MKTAG(LFS_TYPE_DIR, id, nlen), path},\n            {LFS_MKTAG(LFS_TYPE_DIRSTRUCT, id, 8), dir.pair},\n            {LFS_MKTAG_IF(!cwd.m.split,\n                LFS_TYPE_SOFTTAIL, 0x3ff, 8), dir.pair}));\n    lfs_pair_fromle32(dir.pair);\n    if (err) {\n        return err;\n    }\n\n    return 0;\n}\n```\n</target_code>\nPlease provide the modified lfs_mkdir_ code.\n",
  "test_code": "#include <stdio.h>\n#include <stdarg.h>\n#include <stdint.h>\n#include <stddef.h>\n\n/* Probe logging function: append logs to /tmp/logs/955.txt */\nstatic void lfs_log(const char *fmt, ...)\n{\n    FILE *f = fopen(\"/tmp/logs/955.txt\", \"a\");\n    if (!f) {\n        return;\n    }\n    va_list ap;\n    va_start(ap, fmt);\n    vfprintf(f, fmt, ap);\n    va_end(ap);\n    fprintf(f, \"\\n\");\n    fclose(f);\n}\n\n/* Modified lfs_mkdir_ with probes. Original logic preserved. */\nstatic int lfs_mkdir_(lfs_t *lfs, const char *path) {\n    lfs_log(\"lfs_mkdir_: ENTRY path=%p (%s)\", (void *)path, path ? path : \"(null)\");\n\n    // deorphan if we haven't yet, needed at most once after poweron\n    int err = lfs_fs_forceconsistency(lfs);\n    lfs_log(\"lfs_mkdir_: after lfs_fs_forceconsistency -> err=%d\", err);\n    if (err) {\n        lfs_log(\"lfs_mkdir_: RETURN err (forceconsistency)=%d\", err);\n        return err;\n    }\n\n    struct lfs_mlist cwd;\n    cwd.next = lfs->mlist;\n    uint16_t id;\n    err = lfs_dir_find(lfs, &cwd.m, &path, &id);\n    lfs_log(\"lfs_mkdir_: after lfs_dir_find -> err=%d, path=%p (%s), id=%u, cwd.m=%p\", err, (void *)path, path ? path : \"(null)\", (unsigned)id, (void *)&cwd.m);\n    if (!(err == LFS_ERR_NOENT && lfs_path_islast(path))) {\n        int ret = (err < 0) ? err : LFS_ERR_EXIST;\n        lfs_log(\"lfs_mkdir_: RETURN err (dir_find path exists) -> %d\", ret);\n        return ret;\n    }\n\n    // check that name fits\n    lfs_size_t nlen = lfs_path_namelen(path);\n    lfs_log(\"lfs_mkdir_: name length nlen=%zu\", (size_t)nlen);\n    if (nlen > lfs->name_max) {\n        lfs_log(\"lfs_mkdir_: RETURN err (nametoolong) nlen=%zu name_max=%u\", (size_t)nlen, (unsigned)lfs->name_max);\n        return LFS_ERR_NAMETOOLONG;\n    }\n\n    // build up new directory\n    lfs_alloc_ckpoint(lfs);\n    lfs_log(\"lfs_mkdir_: after lfs_alloc_ckpoint\");\n    lfs_mdir_t dir;\n    err = lfs_dir_alloc(lfs, &dir);\n    lfs_log(\"lfs_mkdir_: after lfs_dir_alloc -> err=%d, dir=%p\", err, (void *)&dir);\n    if (err) {\n        lfs_log(\"lfs_mkdir_: RETURN err (dir_alloc)=%d\", err);\n        return err;\n    }\n\n    // find end of list\n    lfs_mdir_t pred = cwd.m;\n    lfs_log(\"lfs_mkdir_: entering pred loop: initial pred.split=%d\", (int)pred.split);\n    while (pred.split) {\n        lfs_log(\"lfs_mkdir_: pred.split is true, fetching pred.tail=%llu\", (unsigned long long)pred.tail);\n        err = lfs_dir_fetch(lfs, &pred, pred.tail);\n        lfs_log(\"lfs_mkdir_: after lfs_dir_fetch -> err=%d, new pred.split=%d, pred.tail=%llu\", err, (int)pred.split, (unsigned long long)pred.tail);\n        if (err) {\n            lfs_log(\"lfs_mkdir_: RETURN err (dir_fetch in pred loop)=%d\", err);\n            return err;\n        }\n    }\n    lfs_log(\"lfs_mkdir_: exited pred loop: pred.split=%d, pred.tail=%llu\", (int)pred.split, (unsigned long long)pred.tail);\n\n    // setup dir\n    lfs_pair_tole32(pred.tail);\n    lfs_log(\"lfs_mkdir_: before lfs_dir_commit (softtail->pred.tail=%llu)\", (unsigned long long)pred.tail);\n    err = lfs_dir_commit(lfs, &dir, LFS_MKATTRS(\n            {LFS_MKTAG(LFS_TYPE_SOFTTAIL, 0x3ff, 8), pred.tail}));\n    lfs_pair_fromle32(pred.tail);\n    lfs_log(\"lfs_mkdir_: after lfs_dir_commit (softtail) -> err=%d\", err);\n    if (err) {\n        lfs_log(\"lfs_mkdir_: RETURN err (dir_commit softtail)=%d\", err);\n        return err;\n    }\n\n    // current block not end of list?\n    if (cwd.m.split) {\n        lfs_log(\"lfs_mkdir_: cwd.m.split is true, preparing orphans\");\n        // update tails, this creates a desync\n        err = lfs_fs_preporphans(lfs, +1);\n        lfs_log(\"lfs_mkdir_: after lfs_fs_preporphans(+1) -> err=%d\", err);\n        if (err) {\n            lfs_log(\"lfs_mkdir_: RETURN err (preporphans +1)=%d\", err);\n            return err;\n        }\n\n        // it's possible our predecessor has to be relocated, and if\n        // our parent is our predecessor's predecessor, this could have\n        // caused our parent to go out of date, fortunately we can hook\n        // ourselves into littlefs to catch this\n        cwd.type = 0;\n        cwd.id = 0;\n        lfs->mlist = &cwd;\n        lfs_log(\"lfs_mkdir_: hooked cwd into lfs->mlist to protect against relocation\");\n\n        lfs_pair_tole32(dir.pair);\n        lfs_log(\"lfs_mkdir_: before lfs_dir_commit (softtail->dir.pair=%llu)\", (unsigned long long)dir.pair);\n        err = lfs_dir_commit(lfs, &pred, LFS_MKATTRS(\n                {LFS_MKTAG(LFS_TYPE_SOFTTAIL, 0x3ff, 8), dir.pair}));\n        lfs_pair_fromle32(dir.pair);\n        lfs_log(\"lfs_mkdir_: after lfs_dir_commit (update pred softtail) -> err=%d\", err);\n        if (err) {\n            lfs->mlist = cwd.next;\n            lfs_log(\"lfs_mkdir_: RETURN err (dir_commit update pred)=%d ; restored lfs->mlist=%p\", err, (void *)lfs->mlist);\n            return err;\n        }\n\n        lfs->mlist = cwd.next;\n        lfs_log(\"lfs_mkdir_: restored lfs->mlist=%p\", (void *)lfs->mlist);\n        err = lfs_fs_preporphans(lfs, -1);\n        lfs_log(\"lfs_mkdir_: after lfs_fs_preporphans(-1) -> err=%d\", err);\n        if (err) {\n            lfs_log(\"lfs_mkdir_: RETURN err (preporphans -1)=%d\", err);\n            return err;\n        }\n    }\n\n    // now insert into our parent block\n    lfs_pair_tole32(dir.pair);\n    lfs_log(\"lfs_mkdir_: before final lfs_dir_commit into parent: dir.pair=%llu, id=%u, nlen=%zu\", (unsigned long long)dir.pair, (unsigned)id, (size_t)nlen);\n    err = lfs_dir_commit(lfs, &cwd.m, LFS_MKATTRS(\n            {LFS_MKTAG(LFS_TYPE_CREATE, id, 0), NULL},\n            {LFS_MKTAG(LFS_TYPE_DIR, id, nlen), path},\n            {LFS_MKTAG(LFS_TYPE_DIRSTRUCT, id, 8), dir.pair},\n            {LFS_MKTAG_IF(!cwd.m.split,\n                LFS_TYPE_SOFTTAIL, 0x3ff, 8), dir.pair}));\n    lfs_pair_fromle32(dir.pair);\n    lfs_log(\"lfs_mkdir_: after final lfs_dir_commit -> err=%d\", err);\n    if (err) {\n        lfs_log(\"lfs_mkdir_: RETURN err (final commit)=%d\", err);\n        return err;\n    }\n\n    lfs_log(\"lfs_mkdir_: RETURN success (0)\");\n    return 0;\n}\n"
}