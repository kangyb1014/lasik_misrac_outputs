{
  "user_message": "An agent A claimed that the following lfs_rename_ code violates the MISRA C 2023 rule 17.8.\n<misra_rule>\nMISRA C 2023 Rule 17.8 is A function parameter should not be modified.\nNote that the object referred to by a pointer parameter may be modified, but the pointer itself shall not be modified.\n</misra_rule>\n<target_code>\nHere is the original code of lfs_rename_.\n```c\nstatic int lfs_rename_(lfs_t *lfs, const char *oldpath, const char *newpath) {\n    // deorphan if we haven't yet, needed at most once after poweron\n    int err = lfs_fs_forceconsistency(lfs);\n    if (err) {\n        return err;\n    }\n\n    // find old entry\n    lfs_mdir_t oldcwd;\n    lfs_stag_t oldtag = lfs_dir_find(lfs, &oldcwd, &oldpath, NULL);\n    if (oldtag < 0 || lfs_tag_id(oldtag) == 0x3ff) {\n        return (oldtag < 0) ? (int)oldtag : LFS_ERR_INVAL;\n    }\n\n    // find new entry\n    lfs_mdir_t newcwd;\n    uint16_t newid;\n    lfs_stag_t prevtag = lfs_dir_find(lfs, &newcwd, &newpath, &newid);\n    if ((prevtag < 0 || lfs_tag_id(prevtag) == 0x3ff) &&\n            !(prevtag == LFS_ERR_NOENT && lfs_path_islast(newpath))) {\n        return (prevtag < 0) ? (int)prevtag : LFS_ERR_INVAL;\n    }\n\n    // if we're in the same pair there's a few special cases...\n    bool samepair = (lfs_pair_cmp(oldcwd.pair, newcwd.pair) == 0);\n    uint16_t newoldid = lfs_tag_id(oldtag);\n\n    struct lfs_mlist prevdir;\n    prevdir.next = lfs->mlist;\n    if (prevtag == LFS_ERR_NOENT) {\n        // if we're a file, don't allow trailing slashes\n        if (lfs_path_isdir(newpath)\n                && lfs_tag_type3(oldtag) != LFS_TYPE_DIR) {\n            return LFS_ERR_NOTDIR;\n        }\n\n        // check that name fits\n        lfs_size_t nlen = lfs_path_namelen(newpath);\n        if (nlen > lfs->name_max) {\n            return LFS_ERR_NAMETOOLONG;\n        }\n\n        // there is a small chance we are being renamed in the same\n        // directory/ to an id less than our old id, the global update\n        // to handle this is a bit messy\n        if (samepair && newid <= newoldid) {\n            newoldid += 1;\n        }\n    } else if (lfs_tag_type3(prevtag) != lfs_tag_type3(oldtag)) {\n        return (lfs_tag_type3(prevtag) == LFS_TYPE_DIR)\n                ? LFS_ERR_ISDIR\n                : LFS_ERR_NOTDIR;\n    } else if (samepair && newid == newoldid) {\n        // we're renaming to ourselves??\n        return 0;\n    } else if (lfs_tag_type3(prevtag) == LFS_TYPE_DIR) {\n        // must be empty before removal\n        lfs_block_t prevpair[2];\n        lfs_stag_t res = lfs_dir_get(lfs, &newcwd, LFS_MKTAG(0x700, 0x3ff, 0),\n                LFS_MKTAG(LFS_TYPE_STRUCT, newid, 8), prevpair);\n        if (res < 0) {\n            return (int)res;\n        }\n        lfs_pair_fromle32(prevpair);\n\n        // must be empty before removal\n        err = lfs_dir_fetch(lfs, &prevdir.m, prevpair);\n        if (err) {\n            return err;\n        }\n\n        if (prevdir.m.count > 0 || prevdir.m.split) {\n            return LFS_ERR_NOTEMPTY;\n        }\n\n        // mark fs as orphaned\n        err = lfs_fs_preporphans(lfs, +1);\n        if (err) {\n            return err;\n        }\n\n        // I know it's crazy but yes, dir can be changed by our parent's\n        // commit (if predecessor is child)\n        prevdir.type = 0;\n        prevdir.id = 0;\n        lfs->mlist = &prevdir;\n    }\n\n    if (!samepair) {\n        lfs_fs_prepmove(lfs, newoldid, oldcwd.pair);\n    }\n\n    // move over all attributes\n    err = lfs_dir_commit(lfs, &newcwd, LFS_MKATTRS(\n            {LFS_MKTAG_IF(prevtag != LFS_ERR_NOENT,\n                LFS_TYPE_DELETE, newid, 0), NULL},\n            {LFS_MKTAG(LFS_TYPE_CREATE, newid, 0), NULL},\n            {LFS_MKTAG(lfs_tag_type3(oldtag),\n                newid, lfs_path_namelen(newpath)), newpath},\n            {LFS_MKTAG(LFS_FROM_MOVE, newid, lfs_tag_id(oldtag)), &oldcwd},\n            {LFS_MKTAG_IF(samepair,\n                LFS_TYPE_DELETE, newoldid, 0), NULL}));\n    if (err) {\n        lfs->mlist = prevdir.next;\n        return err;\n    }\n\n    // let commit clean up after move (if we're different! otherwise move\n    // logic already fixed it for us)\n    if (!samepair && lfs_gstate_hasmove(&lfs->gstate)) {\n        // prep gstate and delete move id\n        lfs_fs_prepmove(lfs, 0x3ff, NULL);\n        err = lfs_dir_commit(lfs, &oldcwd, LFS_MKATTRS(\n                {LFS_MKTAG(LFS_TYPE_DELETE, lfs_tag_id(oldtag), 0), NULL}));\n        if (err) {\n            lfs->mlist = prevdir.next;\n            return err;\n        }\n    }\n\n    lfs->mlist = prevdir.next;\n    if (lfs_gstate_hasorphans(&lfs->gstate)) {\n        LFS_ASSERT(prevtag != LFS_ERR_NOENT\n                && lfs_tag_type3(prevtag) == LFS_TYPE_DIR);\n\n        // fix orphan\n        err = lfs_fs_preporphans(lfs, -1);\n        if (err) {\n            return err;\n        }\n\n        err = lfs_fs_pred(lfs, prevdir.m.pair, &newcwd);\n        if (err) {\n            return err;\n        }\n\n        err = lfs_dir_drop(lfs, &newcwd, &prevdir.m);\n        if (err) {\n            return err;\n        }\n    }\n\n    return 0;\n}\n```\n</target_code>\n<response format>\nProvide your answer with these fields.\n- explanation: your evaluation of the scenario provided by the agent A.\n- is_report_correct: whether the report is correct or not (true/false). True means there is a violation.\n</response format>\n<scenario>\nThe agent A provided the following violation scenario:\nlfs_rename_ passes &oldpath (a function parameter of type const char *) to lfs_dir_find, which assigns to *path (\"*path = name;\"). That write modifies the pointer variable oldpath in the caller (changes the pointer value), i.e. the pointer parameter itself is modified rather than only the object it points to, violating MISRA C 2023 Rule 17.8.\n</scenario>\n\n<execution_log>\nThe agent A also provided the following output log:\nENTRY: lfs_rename_ called: lfs=0x7ffdaf61b850, oldpath=0x7ffdaf61b9f8 (test000), &oldpath=0x7ffdaf61b6b0, newpath=0x7ffdaf61ba78 (tedd000), &newpath=0x7ffdaf61b6b8\nBEFORE: calling lfs_dir_find(&oldcwd, &oldpath, NULL). pre_oldpath=0x7ffdaf61b9f8 (test000), &oldpath=0x7ffdaf61b6b0\nAFTER: lfs_dir_find returned oldtag=2098183. oldpath before=0x7ffdaf61b9f8 (test000), oldpath after=0x7ffdaf61b9f8 (test000), &oldpath=0x7ffdaf61b6b0\nBEFORE: calling lfs_dir_find(&newcwd, &newpath, &newid). pre_newpath=0x7ffdaf61ba78 (tedd000), &newpath=0x7ffdaf61b6b8\nAFTER: lfs_dir_find returned prevtag=-2, newid=1. newpath before=0x7ffdaf61ba78 (tedd000), newpath after=0x7ffdaf61ba78 (tedd000), &newpath=0x7ffdaf61b6b8\nHANDLING NOENT for newpath. samepair=1, newoldid=1\nADJUST newoldid: samepair && newid(1) <= newoldid(1). incrementing newoldid\nCOMMIT: about to call lfs_dir_commit for move (newid=1, newoldid=2)\nEXIT: lfs_rename_ success\nENTRY: lfs_rename_ called: lfs=0x7ffdaf61b850, oldpath=0x7ffdaf61b9f8 (test001), &oldpath=0x7ffdaf61b6b0, newpath=0x7ffdaf61ba78 (tedd001), &newpath=0x7ffdaf61b6b8\nBEFORE: calling lfs_dir_find(&oldcwd, &oldpath, NULL). pre_oldpath=0x7ffdaf61b9f8 (test001), &oldpath=0x7ffdaf61b6b0\nAFTER: lfs_dir_find returned oldtag=2099207. oldpath before=0x7ffdaf61b9f8 (test001), oldpath after=0x7ffdaf61b9f8 (test001), &oldpath=0x7ffdaf61b6b0\nBEFORE: calling lfs_dir_find(&newcwd, &newpath, &newid). pre_newpath=0x7ffdaf61ba78 (tedd001), &newpath=0x7ffdaf61b6b8\nAFTER: lfs_dir_find returned prevtag=-2, newid=2. newpath before=0x7ffdaf61ba78 (tedd001), newpath after=0x7ffdaf61ba78 (tedd001), &newpath=0x7ffdaf61b6b8\nHANDLING NOENT for newpath. samepair=1, newoldid=2\nADJUST newoldid: samepair && newid(2) <= newoldid(2). incrementing newoldid\nCOMMIT: about to call lfs_dir_commit for move (newid=2, newoldid=3)\nEXIT: lfs_rename_ success\nENTRY: lfs_rename_ called: lfs=0x7ffdaf61b850, oldpath=0x7ffdaf61b9f8 (test002), &oldpath=0x7ffdaf61b6b0, newpath=0x7ffdaf61ba78 (tedd002), &newpath=0x7ffdaf61b6b8\nBEFORE: calling lfs_dir_find(&oldcwd, &oldpath, NULL). pre_oldpath=0x7ffdaf61b9f8 (test002), &oldpath=0x7ffdaf61b6b0\nAFTER: lfs_dir_find returned oldtag=2100231. oldpath before=0x7ffdaf61b9f8 (test002), oldpath after=0x7ffdaf61b9f8 (test002), &oldpath=0x7ffdaf61b6b0\nBEFORE: calling lfs_dir_find(&newcwd, &newpath, &newid). pre_newpath=0x7ffdaf61ba78 (tedd002), &newpath=0x7ffdaf61b6b8\nAFTER: lfs_dir_find returned prevtag=-2, newid=3. newpath before=0x7ffdaf61ba78 (tedd002), newpath after=0x7ffdaf61ba78 (tedd002), &newpath=0x7ffdaf61b6b8\nHANDLING NOENT for newpath. samepair=1, newoldid=3\nADJUST newoldid: samepair && newid(3) <= newoldid(3). incrementing newoldid\nCOMMIT: about to call lfs_dir_commit for move (newid=3, newoldid=4)\nEXIT: lfs_rename_ success\nENTRY: lfs_rename_ called: lfs=0x7ffdaf61b850, oldpath=0x7ffdaf61b9f8 (test000), &oldpath=0x7ffdaf61b6b0, newpath=0x7ffdaf61ba78 (tedd000), &newpath=0x7ffdaf61b6b8\nBEFORE: calling lfs_dir_find(&oldcwd, &oldpath, NULL). pre_oldpath=0x7ffdaf61b9f8 (test000), &oldpath=0x7ffdaf61b6b0\nAFTER: lfs_dir_find returned oldtag=2098183. oldpath before=0x7ffdaf61b9f8 (test000), oldpath after=0x7ffdaf61b9f8 (test000), &oldpath=0x7ffdaf61b6b0\nBEFORE: calling lfs_dir_find(&newcwd, &newpath, &newid). pre_newpath=0x7ffdaf61ba78 (tedd000), &newpath=0x7ffdaf61b6b8\nAFTER: lfs_dir_find returned prevtag=-2, newid=1. newpath before=0x7ffdaf61ba78 (tedd000), newpath after=0x7ffdaf61ba78 (tedd000), &newpath=0x7ffdaf61b6b8\nHANDLING NOENT for newpath. samepair=1, newoldid=1\nADJUST newoldid: samepair && newid(1) <= newoldid(1). incrementing newoldid\nCOMMIT: about to call lfs_dir_commit for move (newid=1, newoldid=2)\nEXIT: lfs_rename_ success\nENTRY: lfs_rename_ called: lfs=0x7ffdaf61b850, oldpath=0x7ffdaf61b9f8 (test001), &oldpath=0x7ffdaf61b6b0, newpath=0x7ffdaf61ba78 (tedd001), &newpath=0x7ffdaf61b6b8\nBEFORE: calling lfs_dir_find(&oldcwd, &oldpath, NULL). pre_oldpath=0x7ffdaf61b9f8 (test001), &oldpath=0x7ffdaf61b6b0\nAFTER: lfs_dir_find returned oldtag=2099207. oldpath before=0x7ffdaf61b9f8 (test001), oldpath after=0x7ffdaf61b\n</execution_log>\n<additional code>Here are the definitions of symbols that are close to the target function lfs_rename_:\nstatic lfs_stag_t lfs_dir_find(lfs_t *lfs, lfs_mdir_t *dir,\n        const char **path, uint16_t *id) {\n    // we reduce path to a single name if we can find it\n    const char *name = *path;\n\n    // default to root dir\n    lfs_stag_t tag = LFS_MKTAG(LFS_TYPE_DIR, 0x3ff, 0);\n    dir->tail[0] = lfs->root[0];\n    dir->tail[1] = lfs->root[1];\n\n    // empty paths are not allowed\n    if (*name == '\\0') {\n        return LFS_ERR_INVAL;\n    }\n\n    while (true) {\nnextname:\n        // skip slashes if we're a directory\n        if (lfs_tag_type3(tag) == LFS_TYPE_DIR) {\n            name += strspn(name, \"/\");\n        }\n        lfs_size_t namelen = strcspn(name, \"/\");\n\n        // skip '.'\n        if (namelen == 1 && memcmp(name, \".\", 1) == 0) {\n            name += namelen;\n            goto nextname;\n        }\n\n        // error on unmatched '..', trying to go above root?\n        if (namelen == 2 && memcmp(name, \"..\", 2) == 0) {\n            return LFS_ERR_INVAL;\n        }\n\n        // skip if matched by '..' in name\n        const char *suffix = name + namelen;\n        lfs_size_t sufflen;\n        int depth = 1;\n        while (true) {\n            suffix += strspn(suffix, \"/\");\n            sufflen = strcspn(suffix, \"/\");\n            if (sufflen == 0) {\n                break;\n            }\n\n            if (sufflen == 1 && memcmp(suffix, \".\", 1) == 0) {\n                // noop\n            } else if (sufflen == 2 && memcmp(suffix, \"..\", 2) == 0) {\n                depth -= 1;\n                if (depth == 0) {\n                    name = suffix + sufflen;\n                    goto nextname;\n                }\n            } else {\n                depth += 1;\n            }\n\n            suffix += sufflen;\n        }\n\n        // found path\n        if (*name == '\\0') {\n            return tag;\n        }\n\n        // update what we've found so far\n        *path = name;\n\n        // only continue if we're a directory\n        if (lfs_tag_type3(tag) != LFS_TYPE_DIR) {\n            return LFS_ERR_NOTDIR;\n        }\n\n        // grab the entry data\n        if (lfs_tag_id(tag) != 0x3ff) {\n            lfs_stag_t res = lfs_dir_get(lfs, dir, LFS_MKTAG(0x700, 0x3ff, 0),\n                    LFS_MKTAG(LFS_TYPE_STRUCT, lfs_tag_id(tag), 8), dir->tail);\n            if (res < 0) {\n                return res;\n            }\n            lfs_pair_fromle32(dir->tail);\n        }\n\n        // find entry matching name\n        while (true) {\n            tag = lfs_dir_fetchmatch(lfs, dir, dir->tail,\n                    LFS_MKTAG(0x780, 0, 0),\n                    LFS_MKTAG(LFS_TYPE_NAME, 0, namelen),\n                    id,\n                    lfs_dir_find_match, &(struct lfs_dir_find_match){\n                        lfs, name, namelen});\n            if (tag < 0) {\n                return tag;\n            }\n\n            if (tag) {\n                break;\n            }\n\n            if (!dir->split) {\n                return LFS_ERR_NOENT;\n            }\n        }\n\n        // to next name\n        name += namelen;\n    }\n}\n...\nstatic inline bool lfs_path_islast(const char *path) {\n    lfs_size_t namelen = lfs_path_namelen(path);\n    return path[namelen + strspn(path + namelen, \"/\")] == '\\0';\n}\n...\nstatic inline lfs_size_t lfs_path_namelen(const char *path) {\n    return strcspn(path, \"/\");\n}\n</additional code>\n\n<instruction>\nJudge whether the report is correct or not.\n</instruction>\n",
  "is_report_correct": true,
  "explanation": "The report is correct. MISRA C 2023 Rule 17.8 forbids modifying a function parameter (the pointer itself may not be changed; only the object it points to may be modified). In lfs_rename_ the parameters oldpath and newpath are declared as const char * (i.e. pointer parameters). lfs_rename_ passes &oldpath and &newpath to lfs_dir_find, whose prototype is const char **path. Inside lfs_dir_find there is the statement \"*path = name;\" which writes into the caller-supplied pointer storage and thus can change the value of the parameter variables oldpath/newpath in lfs_rename_. That is a modification of the parameter itself, which violates Rule 17.8. (The runtime log showing identical before/after addresses does not refute the issue\u2014the called function clearly performs an assignment to *path, and therefore the code allows modification of the parameter.)"
}