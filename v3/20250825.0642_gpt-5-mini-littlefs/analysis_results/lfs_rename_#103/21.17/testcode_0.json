{
  "user_message": "<misra_rule>\nMISRA C 2023 Rule 21.17 is: Use of the string handling functions from <string.h> shall not result in accesses beyond the bounds of the objects referenced by their pointer parameters.\nThis rule strictly applies to the Standard Library functions in <string.h> such as memcpy, memmove, memset, memcmp, strcpy, strncpy, strcat, strncat, strlen, and strspn.\n</misra_rule>\n\nAnother agent reported that the target code violated the Rule 21.17.\nHere is the comment from the agent.\n<violation scenario>\nViolation: lfs_path_namelen calls strcspn(path, \"/\") but does not ensure that 'path' is a null-terminated C string within the bounds of the object. If a caller passes a buffer that is not terminated within its allocated bounds (or an invalid/non-string pointer), strcspn will keep scanning until it finds a '\\0' or a '/', potentially reading past the end of the object and causing an out\u2011of\u2011bounds access. This also affects callers such as lfs_path_isdir/lfs_path_islast that index path[namelen] or path[namelen + ...] using the result. Example: passing a non\u2011terminated char array or a pointer into a larger non\u2011string buffer can trigger the out\u2011of\u2011bounds read.\n</violation scenario>\n\nYour job is to insert logging code to capture the control flow and state information of the program.\nInsert logging code so that other agents can reproduce and get evidence for the violation scenario.\n<response format>\n- test_code: a modified lfs_rename_ code that contains useful probe functions that print useful logs to a file \"/tmp/logs/1039.txt\". The logs should contain the control path and state information of the violation scenario. If test code is not required to validate the scenario, you can leave this blank.\nHere are the constraints for the test code:\n- The test code MUST preserve the original logic of lfs_rename_ as much as possible.\nYou CAN just insert probe functions to the original code.\n- DO NOT introduce new violations to demonstrate your scenario.\n- The test code MUST be compilable and executable.\n- The test code MUST include line breaks.\n- You MUST NOT define the main function.\n- You MUST NOT define macros.\n</response format>\n<target_code>\nHere is the code of lfs_rename_:\n```c\nstatic int lfs_rename_(lfs_t *lfs, const char *oldpath, const char *newpath) {\n    // deorphan if we haven't yet, needed at most once after poweron\n    int err = lfs_fs_forceconsistency(lfs);\n    if (err) {\n        return err;\n    }\n\n    // find old entry\n    lfs_mdir_t oldcwd;\n    lfs_stag_t oldtag = lfs_dir_find(lfs, &oldcwd, &oldpath, NULL);\n    if (oldtag < 0 || lfs_tag_id(oldtag) == 0x3ff) {\n        return (oldtag < 0) ? (int)oldtag : LFS_ERR_INVAL;\n    }\n\n    // find new entry\n    lfs_mdir_t newcwd;\n    uint16_t newid;\n    lfs_stag_t prevtag = lfs_dir_find(lfs, &newcwd, &newpath, &newid);\n    if ((prevtag < 0 || lfs_tag_id(prevtag) == 0x3ff) &&\n            !(prevtag == LFS_ERR_NOENT && lfs_path_islast(newpath))) {\n        return (prevtag < 0) ? (int)prevtag : LFS_ERR_INVAL;\n    }\n\n    // if we're in the same pair there's a few special cases...\n    bool samepair = (lfs_pair_cmp(oldcwd.pair, newcwd.pair) == 0);\n    uint16_t newoldid = lfs_tag_id(oldtag);\n\n    struct lfs_mlist prevdir;\n    prevdir.next = lfs->mlist;\n    if (prevtag == LFS_ERR_NOENT) {\n        // if we're a file, don't allow trailing slashes\n        if (lfs_path_isdir(newpath)\n                && lfs_tag_type3(oldtag) != LFS_TYPE_DIR) {\n            return LFS_ERR_NOTDIR;\n        }\n\n        // check that name fits\n        lfs_size_t nlen = lfs_path_namelen(newpath);\n        if (nlen > lfs->name_max) {\n            return LFS_ERR_NAMETOOLONG;\n        }\n\n        // there is a small chance we are being renamed in the same\n        // directory/ to an id less than our old id, the global update\n        // to handle this is a bit messy\n        if (samepair && newid <= newoldid) {\n            newoldid += 1;\n        }\n    } else if (lfs_tag_type3(prevtag) != lfs_tag_type3(oldtag)) {\n        return (lfs_tag_type3(prevtag) == LFS_TYPE_DIR)\n                ? LFS_ERR_ISDIR\n                : LFS_ERR_NOTDIR;\n    } else if (samepair && newid == newoldid) {\n        // we're renaming to ourselves??\n        return 0;\n    } else if (lfs_tag_type3(prevtag) == LFS_TYPE_DIR) {\n        // must be empty before removal\n        lfs_block_t prevpair[2];\n        lfs_stag_t res = lfs_dir_get(lfs, &newcwd, LFS_MKTAG(0x700, 0x3ff, 0),\n                LFS_MKTAG(LFS_TYPE_STRUCT, newid, 8), prevpair);\n        if (res < 0) {\n            return (int)res;\n        }\n        lfs_pair_fromle32(prevpair);\n\n        // must be empty before removal\n        err = lfs_dir_fetch(lfs, &prevdir.m, prevpair);\n        if (err) {\n            return err;\n        }\n\n        if (prevdir.m.count > 0 || prevdir.m.split) {\n            return LFS_ERR_NOTEMPTY;\n        }\n\n        // mark fs as orphaned\n        err = lfs_fs_preporphans(lfs, +1);\n        if (err) {\n            return err;\n        }\n\n        // I know it's crazy but yes, dir can be changed by our parent's\n        // commit (if predecessor is child)\n        prevdir.type = 0;\n        prevdir.id = 0;\n        lfs->mlist = &prevdir;\n    }\n\n    if (!samepair) {\n        lfs_fs_prepmove(lfs, newoldid, oldcwd.pair);\n    }\n\n    // move over all attributes\n    err = lfs_dir_commit(lfs, &newcwd, LFS_MKATTRS(\n            {LFS_MKTAG_IF(prevtag != LFS_ERR_NOENT,\n                LFS_TYPE_DELETE, newid, 0), NULL},\n            {LFS_MKTAG(LFS_TYPE_CREATE, newid, 0), NULL},\n            {LFS_MKTAG(lfs_tag_type3(oldtag),\n                newid, lfs_path_namelen(newpath)), newpath},\n            {LFS_MKTAG(LFS_FROM_MOVE, newid, lfs_tag_id(oldtag)), &oldcwd},\n            {LFS_MKTAG_IF(samepair,\n                LFS_TYPE_DELETE, newoldid, 0), NULL}));\n    if (err) {\n        lfs->mlist = prevdir.next;\n        return err;\n    }\n\n    // let commit clean up after move (if we're different! otherwise move\n    // logic already fixed it for us)\n    if (!samepair && lfs_gstate_hasmove(&lfs->gstate)) {\n        // prep gstate and delete move id\n        lfs_fs_prepmove(lfs, 0x3ff, NULL);\n        err = lfs_dir_commit(lfs, &oldcwd, LFS_MKATTRS(\n                {LFS_MKTAG(LFS_TYPE_DELETE, lfs_tag_id(oldtag), 0), NULL}));\n        if (err) {\n            lfs->mlist = prevdir.next;\n            return err;\n        }\n    }\n\n    lfs->mlist = prevdir.next;\n    if (lfs_gstate_hasorphans(&lfs->gstate)) {\n        LFS_ASSERT(prevtag != LFS_ERR_NOENT\n                && lfs_tag_type3(prevtag) == LFS_TYPE_DIR);\n\n        // fix orphan\n        err = lfs_fs_preporphans(lfs, -1);\n        if (err) {\n            return err;\n        }\n\n        err = lfs_fs_pred(lfs, prevdir.m.pair, &newcwd);\n        if (err) {\n            return err;\n        }\n\n        err = lfs_dir_drop(lfs, &newcwd, &prevdir.m);\n        if (err) {\n            return err;\n        }\n    }\n\n    return 0;\n}\n```\n</target_code>\nPlease provide the modified lfs_rename_ code.\n",
  "test_code": "#include <stdio.h>\n#include <stdarg.h>\n#include <stdbool.h>\n#include <stdint.h>\n\nstatic void lfs_log_probe(const char *fmt, ...) {\n    FILE *f = fopen(\"/tmp/logs/1039.txt\", \"a\");\n    if (!f) {\n        return;\n    }\n    va_list ap;\n    va_start(ap, fmt);\n    vfprintf(f, fmt, ap);\n    va_end(ap);\n    fprintf(f, \"\\n\");\n    fclose(f);\n}\n\nstatic int lfs_rename_(lfs_t *lfs, const char *oldpath, const char *newpath) {\n    lfs_log_probe(\"lfs_rename_: entry oldpath=%p newpath=%p\", (const void*)oldpath, (const void*)newpath);\n\n    // deorphan if we haven't yet, needed at most once after poweron\n    int err = lfs_fs_forceconsistency(lfs);\n    lfs_log_probe(\"lfs_rename_: after fs_forceconsistency err=%d\", err);\n    if (err) {\n        lfs_log_probe(\"lfs_rename_: return (forceconsistency) %d\", err);\n        return err;\n    }\n\n    // find old entry\n    lfs_mdir_t oldcwd;\n    lfs_stag_t oldtag = lfs_dir_find(lfs, &oldcwd, &oldpath, NULL);\n    lfs_log_probe(\"lfs_rename_: after dir_find(old) oldtag=%ld oldtag_id=%u oldcwd.pair[0]=%u oldcwd.pair[1]=%u\", (long)oldtag, (unsigned)lfs_tag_id(oldtag), (unsigned)oldcwd.pair[0], (unsigned)oldcwd.pair[1]);\n    if (oldtag < 0 || lfs_tag_id(oldtag) == 0x3ff) {\n        int ret = (oldtag < 0) ? (int)oldtag : LFS_ERR_INVAL;\n        lfs_log_probe(\"lfs_rename_: return (old not found/invalid) %d\", ret);\n        return ret;\n    }\n\n    // find new entry\n    lfs_mdir_t newcwd;\n    uint16_t newid;\n    lfs_stag_t prevtag = lfs_dir_find(lfs, &newcwd, &newpath, &newid);\n    lfs_log_probe(\"lfs_rename_: after dir_find(new) prevtag=%ld prevtag_id=%u newcwd.pair[0]=%u newcwd.pair[1]=%u newid=%u\", (long)prevtag, (unsigned)lfs_tag_id(prevtag), (unsigned)newcwd.pair[0], (unsigned)newcwd.pair[1], (unsigned)newid);\n    if ((prevtag < 0 || lfs_tag_id(prevtag) == 0x3ff) &&\n            !(prevtag == LFS_ERR_NOENT && lfs_path_islast(newpath))) {\n        int ret = (prevtag < 0) ? (int)prevtag : LFS_ERR_INVAL;\n        lfs_log_probe(\"lfs_rename_: return (new entry invalid) %d\", ret);\n        return ret;\n    }\n\n    // if we're in the same pair there's a few special cases...\n    bool samepair = (lfs_pair_cmp(oldcwd.pair, newcwd.pair) == 0);\n    uint16_t newoldid = lfs_tag_id(oldtag);\n    lfs_log_probe(\"lfs_rename_: samepair=%d newoldid=%u\", (int)samepair, (unsigned)newoldid);\n\n    struct lfs_mlist prevdir;\n    prevdir.next = lfs->mlist;\n    if (prevtag == LFS_ERR_NOENT) {\n        // if we're a file, don't allow trailing slashes\n        bool newpath_isdir = lfs_path_isdir(newpath);\n        lfs_log_probe(\"lfs_rename_: prevtag==NOENT newpath_isdir=%d lfs_tag_type3(oldtag)=%u\", (int)newpath_isdir, (unsigned)lfs_tag_type3(oldtag));\n        if (newpath_isdir\n                && lfs_tag_type3(oldtag) != LFS_TYPE_DIR) {\n            lfs_log_probe(\"lfs_rename_: return LFS_ERR_NOTDIR (trailing slash on file)\");\n            return LFS_ERR_NOTDIR;\n        }\n\n        // check that name fits\n        lfs_size_t nlen = lfs_path_namelen(newpath);\n        lfs_log_probe(\"lfs_rename_: nlen=%llu name_max=%llu\", (unsigned long long)nlen, (unsigned long long)lfs->name_max);\n        if (nlen > lfs->name_max) {\n            lfs_log_probe(\"lfs_rename_: return LFS_ERR_NAMETOOLONG\");\n            return LFS_ERR_NAMETOOLONG;\n        }\n\n        // there is a small chance we are being renamed in the same\n        // directory/ to an id less than our old id, the global update\n        // to handle this is a bit messy\n        if (samepair && newid <= newoldid) {\n            lfs_log_probe(\"lfs_rename_: adjusting newoldid from %u to %u (samepair and newid<=newoldid)\", (unsigned)newoldid, (unsigned)(newoldid + 1));\n            newoldid += 1;\n        }\n    } else if (lfs_tag_type3(prevtag) != lfs_tag_type3(oldtag)) {\n        lfs_log_probe(\"lfs_rename_: type mismatch prevtag_type=%u oldtag_type=%u\", (unsigned)lfs_tag_type3(prevtag), (unsigned)lfs_tag_type3(oldtag));\n        return (lfs_tag_type3(prevtag) == LFS_TYPE_DIR)\n                ? LFS_ERR_ISDIR\n                : LFS_ERR_NOTDIR;\n    } else if (samepair && newid == newoldid) {\n        // we're renaming to ourselves??\n        lfs_log_probe(\"lfs_rename_: renaming to self (no-op)\");\n        return 0;\n    } else if (lfs_tag_type3(prevtag) == LFS_TYPE_DIR) {\n        // must be empty before removal\n        lfs_block_t prevpair[2];\n        lfs_stag_t res = lfs_dir_get(lfs, &newcwd, LFS_MKTAG(0x700, 0x3ff, 0),\n                LFS_MKTAG(LFS_TYPE_STRUCT, newid, 8), prevpair);\n        lfs_log_probe(\"lfs_rename_: dir_get res=%ld prevpair[0]=%u prevpair[1]=%u\", (long)res, (unsigned)prevpair[0], (unsigned)prevpair[1]);\n        if (res < 0) {\n            lfs_log_probe(\"lfs_rename_: return (dir_get) %ld\", (long)res);\n            return (int)res;\n        }\n        lfs_pair_fromle32(prevpair);\n\n        // must be empty before removal\n        err = lfs_dir_fetch(lfs, &prevdir.m, prevpair);\n        lfs_log_probe(\"lfs_rename_: dir_fetch err=%d prevdir.m.count=%u prevdir.m.split=%d\", err, (unsigned)prevdir.m.count, (int)prevdir.m.split);\n        if (err) {\n            lfs_log_probe(\"lfs_rename_: return (dir_fetch) %d\", err);\n            return err;\n        }\n\n        if (prevdir.m.count > 0 || prevdir.m.split) {\n            lfs_log_probe(\"lfs_rename_: return LFS_ERR_NOTEMPTY (dir not empty)\");\n            return LFS_ERR_NOTEMPTY;\n        }\n\n        // mark fs as orphaned\n        err = lfs_fs_preporphans(lfs, +1);\n        lfs_log_probe(\"lfs_rename_: fs_preporphans +1 err=%d\", err);\n        if (err) {\n            lfs_log_probe(\"lfs_rename_: return (preporphans +1) %d\", err);\n            return err;\n        }\n\n        // I know it's crazy but yes, dir can be changed by our parent's\n        // commit (if predecessor is child)\n        prevdir.type = 0;\n        prevdir.id = 0;\n        lfs->mlist = &prevdir;\n    }\n\n    if (!samepair) {\n        lfs_log_probe(\"lfs_rename_: preparing move since not samepair: newoldid=%u oldcwd.pair[0]=%u oldcwd.pair[1]=%u\", (unsigned)newoldid, (unsigned)oldcwd.pair[0], (unsigned)oldcwd.pair[1]);\n        lfs_fs_prepmove(lfs, newoldid, oldcwd.pair);\n    }\n\n    // move over all attributes\n    lfs_log_probe(\"lfs_rename_: about to dir_commit move attrs newid=%u newoldid=%u\", (unsigned)newid, (unsigned)newoldid);\n    err = lfs_dir_commit(lfs, &newcwd, LFS_MKATTRS(\n            {LFS_MKTAG_IF(prevtag != LFS_ERR_NOENT,\n                LFS_TYPE_DELETE, newid, 0), NULL},\n            {LFS_MKTAG(LFS_TYPE_CREATE, newid, 0), NULL},\n            {LFS_MKTAG(lfs_tag_type3(oldtag),\n                newid, lfs_path_namelen(newpath)), newpath},\n            {LFS_MKTAG(LFS_FROM_MOVE, newid, lfs_tag_id(oldtag)), &oldcwd},\n            {LFS_MKTAG_IF(samepair,\n                LFS_TYPE_DELETE, newoldid, 0), NULL}));\n    lfs_log_probe(\"lfs_rename_: dir_commit err=%d\", err);\n    if (err) {\n        lfs->mlist = prevdir.next;\n        lfs_log_probe(\"lfs_rename_: return (dir_commit) %d\", err);\n        return err;\n    }\n\n    // let commit clean up after move (if we're different! otherwise move\n    // logic already fixed it for us)\n    if (!samepair && lfs_gstate_hasmove(&lfs->gstate)) {\n        // prep gstate and delete move id\n        lfs_log_probe(\"lfs_rename_: hasmove true, prepping move cleanup\");\n        lfs_fs_prepmove(lfs, 0x3ff, NULL);\n        err = lfs_dir_commit(lfs, &oldcwd, LFS_MKATTRS(\n                {LFS_MKTAG(LFS_TYPE_DELETE, lfs_tag_id(oldtag), 0), NULL}));\n        lfs_log_probe(\"lfs_rename_: cleanup dir_commit err=%d\", err);\n        if (err) {\n            lfs->mlist = prevdir.next;\n            lfs_log_probe(\"lfs_rename_: return (cleanup dir_commit) %d\", err);\n            return err;\n        }\n    }\n\n    lfs->mlist = prevdir.next;\n    if (lfs_gstate_hasorphans(&lfs->gstate)) {\n        LFS_ASSERT(prevtag != LFS_ERR_NOENT\n                && lfs_tag_type3(prevtag) == LFS_TYPE_DIR);\n\n        // fix orphan\n        err = lfs_fs_preporphans(lfs, -1);\n        lfs_log_probe(\"lfs_rename_: fs_preporphans -1 err=%d\", err);\n        if (err) {\n            lfs_log_probe(\"lfs_rename_: return (preporphans -1) %d\", err);\n            return err;\n        }\n\n        err = lfs_fs_pred(lfs, prevdir.m.pair, &newcwd);\n        lfs_log_probe(\"lfs_rename_: fs_pred err=%d\", err);\n        if (err) {\n            lfs_log_probe(\"lfs_rename_: return (fs_pred) %d\", err);\n            return err;\n        }\n\n        err = lfs_dir_drop(lfs, &newcwd, &prevdir.m);\n        lfs_log_probe(\"lfs_rename_: dir_drop err=%d\", err);\n        if (err) {\n            lfs_log_probe(\"lfs_rename_: return (dir_drop) %d\", err);\n            return err;\n        }\n    }\n\n    lfs_log_probe(\"lfs_rename_: success return 0\");\n    return 0;\n}\n"
}