{
  "user_message": "<misra_rule>\nMISRA C 2023 Rule 2.2 is: A project shall not contain dead code.\nAny operation that is executed but whose removal would not affect program behaviour constitutes dead code. Notes:\n1. The behaviour of an embedded sytem is often determined not just by the nature of its actions, but also by the time at which they occur.\n2. unreachable code is not dead code, as it cannot be executed.\n3.Initialization is not the same as an assignment operation and is therfore not a candidate for dead code.\n</misra_rule>\n\nAnother agent reported that the target code violated the Rule 2.2.\nHere is the comment from the agent.\n<violation scenario>\nThis fragment can be dead code when the LFS_ASSERT macro has no observable effect (e.g. defined as ((void)0) or compiled out in release builds) and the boolean expression has no side-effects. In that case the reads/evaluation of lfs->cfg->metadata_max and lfs->cfg->read_size and the logical test are operations whose removal would not affect program behaviour, so Rule 2.2 would be violated. (If, however, LFS_ASSERT is implemented to perform a runtime check with side-effects such as logging/abort, then the assertion is not dead code and Rule 2.2 is not violated.)\n</violation scenario>\n\nYour job is to insert logging code to capture the control flow and state information of the program.\nInsert logging code so that other agents can reproduce and get evidence for the violation scenario.\n<response format>\n- test_code: a modified lfs_init code that contains useful probe functions that print useful logs to a file \"/tmp/logs/932.txt\". The logs should contain the control path and state information of the violation scenario. If test code is not required to validate the scenario, you can leave this blank.\nHere are the constraints for the test code:\n- The test code MUST preserve the original logic of lfs_init as much as possible.\nYou CAN just insert probe functions to the original code.\n- DO NOT introduce new violations to demonstrate your scenario.\n- The test code MUST be compilable and executable.\n- The test code MUST include line breaks.\n- You MUST NOT define the main function.\n- You MUST NOT define macros.\n</response format>\n<target_code>\nHere is the code of lfs_init:\n```c\nstatic int lfs_init(lfs_t *lfs, const struct lfs_config *cfg) {\n    lfs->cfg = cfg;\n    lfs->block_count = cfg->block_count;  // May be 0\n    int err = 0;\n\n#ifdef LFS_MULTIVERSION\n    // this driver only supports minor version < current minor version\n    LFS_ASSERT(!lfs->cfg->disk_version || (\n            (0xffff & (lfs->cfg->disk_version >> 16))\n                    == LFS_DISK_VERSION_MAJOR\n                && (0xffff & (lfs->cfg->disk_version >> 0))\n                    <= LFS_DISK_VERSION_MINOR));\n#endif\n\n    // check that bool is a truthy-preserving type\n    //\n    // note the most common reason for this failure is a before-c99 compiler,\n    // which littlefs currently does not support\n    LFS_ASSERT((bool)0x80000000);\n\n    // check that the required io functions are provided\n    LFS_ASSERT(lfs->cfg->read != NULL);\n#ifndef LFS_READONLY\n    LFS_ASSERT(lfs->cfg->prog != NULL);\n    LFS_ASSERT(lfs->cfg->erase != NULL);\n    LFS_ASSERT(lfs->cfg->sync != NULL);\n#endif\n\n    // validate that the lfs-cfg sizes were initiated properly before\n    // performing any arithmetic logics with them\n    LFS_ASSERT(lfs->cfg->read_size != 0);\n    LFS_ASSERT(lfs->cfg->prog_size != 0);\n    LFS_ASSERT(lfs->cfg->cache_size != 0);\n\n    // check that block size is a multiple of cache size is a multiple\n    // of prog and read sizes\n    LFS_ASSERT(lfs->cfg->cache_size % lfs->cfg->read_size == 0);\n    LFS_ASSERT(lfs->cfg->cache_size % lfs->cfg->prog_size == 0);\n    LFS_ASSERT(lfs->cfg->block_size % lfs->cfg->cache_size == 0);\n\n    // check that the block size is large enough to fit all ctz pointers\n    LFS_ASSERT(lfs->cfg->block_size >= 128);\n    // this is the exact calculation for all ctz pointers, if this fails\n    // and the simpler assert above does not, math must be broken\n    LFS_ASSERT(4*lfs_npw2(0xffffffff / (lfs->cfg->block_size-2*4))\n            <= lfs->cfg->block_size);\n\n    // block_cycles = 0 is no longer supported.\n    //\n    // block_cycles is the number of erase cycles before littlefs evicts\n    // metadata logs as a part of wear leveling. Suggested values are in the\n    // range of 100-1000, or set block_cycles to -1 to disable block-level\n    // wear-leveling.\n    LFS_ASSERT(lfs->cfg->block_cycles != 0);\n\n    // check that compact_thresh makes sense\n    //\n    // metadata can't be compacted below block_size/2, and metadata can't\n    // exceed a block_size\n    LFS_ASSERT(lfs->cfg->compact_thresh == 0\n            || lfs->cfg->compact_thresh >= lfs->cfg->block_size/2);\n    LFS_ASSERT(lfs->cfg->compact_thresh == (lfs_size_t)-1\n            || lfs->cfg->compact_thresh <= lfs->cfg->block_size);\n\n    // check that metadata_max is a multiple of read_size and prog_size,\n    // and a factor of the block_size\n    LFS_ASSERT(!lfs->cfg->metadata_max\n            || lfs->cfg->metadata_max % lfs->cfg->read_size == 0);\n    LFS_ASSERT(!lfs->cfg->metadata_max\n            || lfs->cfg->metadata_max % lfs->cfg->prog_size == 0);\n    LFS_ASSERT(!lfs->cfg->metadata_max\n            || lfs->cfg->block_size % lfs->cfg->metadata_max == 0);\n\n    // setup read cache\n    if (lfs->cfg->read_buffer) {\n        lfs->rcache.buffer = lfs->cfg->read_buffer;\n    } else {\n        lfs->rcache.buffer = lfs_malloc(lfs->cfg->cache_size);\n        if (!lfs->rcache.buffer) {\n            err = LFS_ERR_NOMEM;\n            goto cleanup;\n        }\n    }\n\n    // setup program cache\n    if (lfs->cfg->prog_buffer) {\n        lfs->pcache.buffer = lfs->cfg->prog_buffer;\n    } else {\n        lfs->pcache.buffer = lfs_malloc(lfs->cfg->cache_size);\n        if (!lfs->pcache.buffer) {\n            err = LFS_ERR_NOMEM;\n            goto cleanup;\n        }\n    }\n\n    // zero to avoid information leaks\n    lfs_cache_zero(lfs, &lfs->rcache);\n    lfs_cache_zero(lfs, &lfs->pcache);\n\n    // setup lookahead buffer, note mount finishes initializing this after\n    // we establish a decent pseudo-random seed\n    LFS_ASSERT(lfs->cfg->lookahead_size > 0);\n    if (lfs->cfg->lookahead_buffer) {\n        lfs->lookahead.buffer = lfs->cfg->lookahead_buffer;\n    } else {\n        lfs->lookahead.buffer = lfs_malloc(lfs->cfg->lookahead_size);\n        if (!lfs->lookahead.buffer) {\n            err = LFS_ERR_NOMEM;\n            goto cleanup;\n        }\n    }\n\n    // check that the size limits are sane\n    LFS_ASSERT(lfs->cfg->name_max <= LFS_NAME_MAX);\n    lfs->name_max = lfs->cfg->name_max;\n    if (!lfs->name_max) {\n        lfs->name_max = LFS_NAME_MAX;\n    }\n\n    LFS_ASSERT(lfs->cfg->file_max <= LFS_FILE_MAX);\n    lfs->file_max = lfs->cfg->file_max;\n    if (!lfs->file_max) {\n        lfs->file_max = LFS_FILE_MAX;\n    }\n\n    LFS_ASSERT(lfs->cfg->attr_max <= LFS_ATTR_MAX);\n    lfs->attr_max = lfs->cfg->attr_max;\n    if (!lfs->attr_max) {\n        lfs->attr_max = LFS_ATTR_MAX;\n    }\n\n    LFS_ASSERT(lfs->cfg->metadata_max <= lfs->cfg->block_size);\n\n    LFS_ASSERT(lfs->cfg->inline_max == (lfs_size_t)-1\n            || lfs->cfg->inline_max <= lfs->cfg->cache_size);\n    LFS_ASSERT(lfs->cfg->inline_max == (lfs_size_t)-1\n            || lfs->cfg->inline_max <= lfs->attr_max);\n    LFS_ASSERT(lfs->cfg->inline_max == (lfs_size_t)-1\n            || lfs->cfg->inline_max <= ((lfs->cfg->metadata_max)\n                ? lfs->cfg->metadata_max\n                : lfs->cfg->block_size)/8);\n    lfs->inline_max = lfs->cfg->inline_max;\n    if (lfs->inline_max == (lfs_size_t)-1) {\n        lfs->inline_max = 0;\n    } else if (lfs->inline_max == 0) {\n        lfs->inline_max = lfs_min(\n                lfs->cfg->cache_size,\n                lfs_min(\n                    lfs->attr_max,\n                    ((lfs->cfg->metadata_max)\n                        ? lfs->cfg->metadata_max\n                        : lfs->cfg->block_size)/8));\n    }\n\n    // setup default state\n    lfs->root[0] = LFS_BLOCK_NULL;\n    lfs->root[1] = LFS_BLOCK_NULL;\n    lfs->mlist = NULL;\n    lfs->seed = 0;\n    lfs->gdisk = (lfs_gstate_t){0};\n    lfs->gstate = (lfs_gstate_t){0};\n    lfs->gdelta = (lfs_gstate_t){0};\n#ifdef LFS_MIGRATE\n    lfs->lfs1 = NULL;\n#endif\n\n    return 0;\n\ncleanup:\n    lfs_deinit(lfs);\n    return err;\n}\n```\n</target_code>\nPlease provide the modified lfs_init code.\n",
  "test_code": "#include <stdio.h>\n#include <stdarg.h>\n#include <stddef.h>\n\n/* Probe helper: Append human-readable state and control-flow info to /tmp/logs/932.txt\n * This helper is intentionally non-intrusive: it does not modify program state and\n * returns quickly if logging cannot be performed. It preserves the original logic\n * of lfs_init (no side-effect other than writing logs to disk). */\nstatic void lfs_log_state(const void *lfs_ptr, const char *stage) {\n    /* We avoid referencing types here so we don't need type definitions. The\n     * caller will pass pointers cast to (void*). We only print pointer values\n     * and a stage message. For richer state we rely on callers to print\n     * specific values where type information is available. */\n    FILE *f = fopen(\"/tmp/logs/932.txt\", \"a\");\n    if (!f) {\n        return;\n    }\n    fprintf(f, \"lfs_init probe: stage=%s, lfs=%p\\n\", stage, lfs_ptr);\n    fclose(f);\n}\n\n/* More detailed logger for known structure layout state. This requires the\n * real types to be visible where this function is called; therefore callers\n * pass the concrete lfs pointer and a descriptive stage string. */\nstatic void lfs_log_detailed(const void *lfs_void, const char *stage,\n        const struct lfs_config *cfg,\n        size_t read_size, size_t prog_size, size_t cache_size,\n        size_t block_size, size_t metadata_max, size_t lookahead_size,\n        const void *read_buffer, const void *prog_buffer, const void *lookahead_buffer) {\n    FILE *f = fopen(\"/tmp/logs/932.txt\", \"a\");\n    if (!f) return;\n\n    fprintf(f, \"lfs_init detail: stage=%s\\n\", stage);\n    fprintf(f, \" cfg=%p, read=%p, prog=%p, erase=%p, sync=%p\\n\",\n            (const void*)cfg,\n            (const void*)(cfg ? cfg->read : NULL),\n            (const void*)(cfg ? cfg->prog : NULL),\n            (const void*)(cfg ? cfg->erase : NULL),\n            (const void*)(cfg ? cfg->sync : NULL));\n    fprintf(f, \" read_size=%zu prog_size=%zu cache_size=%zu block_size=%zu metadata_max=%zu lookahead_size=%zu\\n\",\n            read_size, prog_size, cache_size, block_size, metadata_max, lookahead_size);\n    fprintf(f, \" read_buffer=%p prog_buffer=%p lookahead_buffer=%p\\n\",\n            read_buffer, prog_buffer, lookahead_buffer);\n    fprintf(f, \"---\\n\");\n    fclose(f);\n}\n\n/* Modified lfs_init with probes inserted. Original logic preserved. */\nstatic int lfs_init(lfs_t *lfs, const struct lfs_config *cfg) {\n    /* Log entry to function with pointer only (safe even if cfg is NULL) */\n    lfs_log_state((const void*)lfs, \"entry\");\n\n    lfs->cfg = cfg;\n    lfs->block_count = cfg->block_count;  // May be 0\n    int err = 0;\n\n#ifdef LFS_MULTIVERSION\n    // this driver only supports minor version < current minor version\n    LFS_ASSERT(!lfs->cfg->disk_version || (\n            (0xffff & (lfs->cfg->disk_version >> 16))\n                    == LFS_DISK_VERSION_MAJOR\n                && (0xffff & (lfs->cfg->disk_version >> 0))\n                    <= LFS_DISK_VERSION_MINOR));\n#endif\n\n    // check that bool is a truthy-preserving type\n    //\n    // note the most common reason for this failure is a before-c99 compiler,\n    // which littlefs currently does not support\n    LFS_ASSERT((bool)0x80000000);\n\n    // check that the required io functions are provided\n    LFS_ASSERT(lfs->cfg->read != NULL);\n#ifndef LFS_READONLY\n    LFS_ASSERT(lfs->cfg->prog != NULL);\n    LFS_ASSERT(lfs->cfg->erase != NULL);\n    LFS_ASSERT(lfs->cfg->sync != NULL);\n#endif\n\n    // validate that the lfs-cfg sizes were initiated properly before\n    // performing any arithmetic logics with them\n    LFS_ASSERT(lfs->cfg->read_size != 0);\n    LFS_ASSERT(lfs->cfg->prog_size != 0);\n    LFS_ASSERT(lfs->cfg->cache_size != 0);\n\n    // check that block size is a multiple of cache size is a multiple\n    // of prog and read sizes\n    LFS_ASSERT(lfs->cfg->cache_size % lfs->cfg->read_size == 0);\n    LFS_ASSERT(lfs->cfg->cache_size % lfs->cfg->prog_size == 0);\n    LFS_ASSERT(lfs->cfg->block_size % lfs->cfg->cache_size == 0);\n\n    // check that the block size is large enough to fit all ctz pointers\n    LFS_ASSERT(lfs->cfg->block_size >= 128);\n    // this is the exact calculation for all ctz pointers, if this fails\n    // and the simpler assert above does not, math must be broken\n    LFS_ASSERT(4*lfs_npw2(0xffffffff / (lfs->cfg->block_size-2*4))\n            <= lfs->cfg->block_size);\n\n    // block_cycles = 0 is no longer supported.\n    //\n    // block_cycles is the number of erase cycles before littlefs evicts\n    // metadata logs as a part of wear leveling. Suggested values are in the\n    // range of 100-1000, or set block_cycles to -1 to disable block-level\n    // wear-leveling.\n    LFS_ASSERT(lfs->cfg->block_cycles != 0);\n\n    // check that compact_thresh makes sense\n    //\n    // metadata can't be compacted below block_size/2, and metadata can't\n    // exceed a block_size\n    LFS_ASSERT(lfs->cfg->compact_thresh == 0\n            || lfs->cfg->compact_thresh >= lfs->cfg->block_size/2);\n    LFS_ASSERT(lfs->cfg->compact_thresh == (lfs_size_t)-1\n            || lfs->cfg->compact_thresh <= lfs->cfg->block_size);\n\n    /*\n     * IMPORTANT PROBE: metadata_max related assertions can be dead code when\n     * LFS_ASSERT is compiled out (e.g. ((void)0)). To provide reproducible\n     * evidence, log all values that participate in those assertions right\n     * before they are evaluated. This does not change program logic.\n     */\n    lfs_log_detailed((const void*)lfs, \"before_metadata_checks\",\n            lfs->cfg,\n            (size_t)lfs->cfg->read_size,\n            (size_t)lfs->cfg->prog_size,\n            (size_t)lfs->cfg->cache_size,\n            (size_t)lfs->cfg->block_size,\n            (size_t)lfs->cfg->metadata_max,\n            (size_t)lfs->cfg->lookahead_size,\n            (const void*)lfs->cfg->read_buffer,\n            (const void*)lfs->cfg->prog_buffer,\n            (const void*)lfs->cfg->lookahead_buffer);\n\n    // check that metadata_max is a multiple of read_size and prog_size,\n    // and a factor of the block_size\n    LFS_ASSERT(!lfs->cfg->metadata_max\n            || lfs->cfg->metadata_max % lfs->cfg->read_size == 0);\n    LFS_ASSERT(!lfs->cfg->metadata_max\n            || lfs->cfg->metadata_max % lfs->cfg->prog_size == 0);\n    LFS_ASSERT(!lfs->cfg->metadata_max\n            || lfs->cfg->block_size % lfs->cfg->metadata_max == 0);\n\n    // setup read cache\n    if (lfs->cfg->read_buffer) {\n        lfs->rcache.buffer = lfs->cfg->read_buffer;\n        lfs_log_detailed((const void*)lfs, \"rcache_using_provided_buffer\",\n                lfs->cfg,\n                (size_t)lfs->cfg->read_size,\n                (size_t)lfs->cfg->prog_size,\n                (size_t)lfs->cfg->cache_size,\n                (size_t)lfs->cfg->block_size,\n                (size_t)lfs->cfg->metadata_max,\n                (size_t)lfs->cfg->lookahead_size,\n                (const void*)lfs->rcache.buffer,\n                (const void*)lfs->cfg->prog_buffer,\n                (const void*)lfs->cfg->lookahead_buffer);\n    } else {\n        lfs->rcache.buffer = lfs_malloc(lfs->cfg->cache_size);\n        if (!lfs->rcache.buffer) {\n            lfs_log_state((const void*)lfs, \"rcache_alloc_failed\");\n            err = LFS_ERR_NOMEM;\n            goto cleanup;\n        }\n        lfs_log_detailed((const void*)lfs, \"rcache_alloc_ok\",\n                lfs->cfg,\n                (size_t)lfs->cfg->read_size,\n                (size_t)lfs->cfg->prog_size,\n                (size_t)lfs->cfg->cache_size,\n                (size_t)lfs->cfg->block_size,\n                (size_t)lfs->cfg->metadata_max,\n                (size_t)lfs->cfg->lookahead_size,\n                (const void*)lfs->rcache.buffer,\n                (const void*)lfs->cfg->prog_buffer,\n                (const void*)lfs->cfg->lookahead_buffer);\n    }\n\n    // setup program cache\n    if (lfs->cfg->prog_buffer) {\n        lfs->pcache.buffer = lfs->cfg->prog_buffer;\n        lfs_log_detailed((const void*)lfs, \"pcache_using_provided_buffer\",\n                lfs->cfg,\n                (size_t)lfs->cfg->read_size,\n                (size_t)lfs->cfg->prog_size,\n                (size_t)lfs->cfg->cache_size,\n                (size_t)lfs->cfg->block_size,\n                (size_t)lfs->cfg->metadata_max,\n                (size_t)lfs->cfg->lookahead_size,\n                (const void*)lfs->cfg->read_buffer,\n                (const void*)lfs->pcache.buffer,\n                (const void*)lfs->cfg->lookahead_buffer);\n    } else {\n        lfs->pcache.buffer = lfs_malloc(lfs->cfg->cache_size);\n        if (!lfs->pcache.buffer) {\n            lfs_log_state((const void*)lfs, \"pcache_alloc_failed\");\n            err = LFS_ERR_NOMEM;\n            goto cleanup;\n        }\n        lfs_log_detailed((const void*)lfs, \"pcache_alloc_ok\",\n                lfs->cfg,\n                (size_t)lfs->cfg->read_size,\n                (size_t)lfs->cfg->prog_size,\n                (size_t)lfs->cfg->cache_size,\n                (size_t)lfs->cfg->block_size,\n                (size_t)lfs->cfg->metadata_max,\n                (size_t)lfs->cfg->lookahead_size,\n                (const void*)lfs->cfg->read_buffer,\n                (const void*)lfs->pcache.buffer,\n                (const void*)lfs->cfg->lookahead_buffer);\n    }\n\n    // zero to avoid information leaks\n    lfs_cache_zero(lfs, &lfs->rcache);\n    lfs_cache_zero(lfs, &lfs->pcache);\n\n    // setup lookahead buffer, note mount finishes initializing this after\n    // we establish a decent pseudo-random seed\n    LFS_ASSERT(lfs->cfg->lookahead_size > 0);\n    if (lfs->cfg->lookahead_buffer) {\n        lfs->lookahead.buffer = lfs->cfg->lookahead_buffer;\n        lfs_log_detailed((const void*)lfs, \"lookahead_using_provided_buffer\",\n                lfs->cfg,\n                (size_t)lfs->cfg->read_size,\n                (size_t)lfs->cfg->prog_size,\n                (size_t)lfs->cfg->cache_size,\n                (size_t)lfs->cfg->block_size,\n                (size_t)lfs->cfg->metadata_max,\n                (size_t)lfs->cfg->lookahead_size,\n                (const void*)lfs->cfg->read_buffer,\n                (const void*)lfs->cfg->prog_buffer,\n                (const void*)lfs->lookahead.buffer);\n    } else {\n        lfs->lookahead.buffer = lfs_malloc(lfs->cfg->lookahead_size);\n        if (!lfs->lookahead.buffer) {\n            lfs_log_state((const void*)lfs, \"lookahead_alloc_failed\");\n            err = LFS_ERR_NOMEM;\n            goto cleanup;\n        }\n        lfs_log_detailed((const void*)lfs, \"lookahead_alloc_ok\",\n                lfs->cfg,\n                (size_t)lfs->cfg->read_size,\n                (size_t)lfs->cfg->prog_size,\n                (size_t)lfs->cfg->cache_size,\n                (size_t)lfs->cfg->block_size,\n                (size_t)lfs->cfg->metadata_max,\n                (size_t)lfs->cfg->lookahead_size,\n                (const void*)lfs->cfg->read_buffer,\n                (const void*)lfs->cfg->prog_buffer,\n                (const void*)lfs->lookahead.buffer);\n    }\n\n    // check that the size limits are sane\n    LFS_ASSERT(lfs->cfg->name_max <= LFS_NAME_MAX);\n    lfs->name_max = lfs->cfg->name_max;\n    if (!lfs->name_max) {\n        lfs->name_max = LFS_NAME_MAX;\n    }\n\n    LFS_ASSERT(lfs->cfg->file_max <= LFS_FILE_MAX);\n    lfs->file_max = lfs->cfg->file_max;\n    if (!lfs->file_max) {\n        lfs->file_max = LFS_FILE_MAX;\n    }\n\n    LFS_ASSERT(lfs->cfg->attr_max <= LFS_ATTR_MAX);\n    lfs->attr_max = lfs->cfg->attr_max;\n    if (!lfs->attr_max) {\n        lfs->attr_max = LFS_ATTR_MAX;\n    }\n\n    LFS_ASSERT(lfs->cfg->metadata_max <= lfs->cfg->block_size);\n\n    LFS_ASSERT(lfs->cfg->inline_max == (lfs_size_t)-1\n            || lfs->cfg->inline_max <= lfs->cfg->cache_size);\n    LFS_ASSERT(lfs->cfg->inline_max == (lfs_size_t)-1\n            || lfs->cfg->inline_max <= lfs->attr_max);\n    LFS_ASSERT(lfs->cfg->inline_max == (lfs_size_t)-1\n            || lfs->cfg->inline_max <= ((lfs->cfg->metadata_max)\n                ? lfs->cfg->metadata_max\n                : lfs->cfg->block_size)/8);\n    lfs->inline_max = lfs->cfg->inline_max;\n    if (lfs->inline_max == (lfs_size_t)-1) {\n        lfs->inline_max = 0;\n    } else if (lfs->inline_max == 0) {\n        lfs->inline_max = lfs_min(\n                lfs->cfg->cache_size,\n                lfs_min(\n                    lfs->attr_max,\n                    ((lfs->cfg->metadata_max)\n                        ? lfs->cfg->metadata_max\n                        : lfs->cfg->block_size)/8));\n    }\n\n    // setup default state\n    lfs->root[0] = LFS_BLOCK_NULL;\n    lfs->root[1] = LFS_BLOCK_NULL;\n    lfs->mlist = NULL;\n    lfs->seed = 0;\n    lfs->gdisk = (lfs_gstate_t){0};\n    lfs->gstate = (lfs_gstate_t){0};\n    lfs->gdelta = (lfs_gstate_t){0};\n#ifdef LFS_MIGRATE\n    lfs->lfs1 = NULL;\n#endif\n\n    /* Final success log */\n    lfs_log_state((const void*)lfs, \"success_exit\");\n    return 0;\n\ncleanup:\n    lfs_log_state((const void*)lfs, \"cleanup_exit\");\n    lfs_deinit(lfs);\n    return err;\n}\n"
}