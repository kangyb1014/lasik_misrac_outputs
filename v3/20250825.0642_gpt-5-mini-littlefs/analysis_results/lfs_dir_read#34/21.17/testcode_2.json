{
  "user_message": "<misra_rule>\nMISRA C 2023 Rule 21.17 is: Use of the string handling functions from <string.h> shall not result in accesses beyond the bounds of the objects referenced by their pointer parameters.\nThis rule strictly applies to the Standard Library functions in <string.h> such as memcpy, memmove, memset, memcmp, strcpy, strncpy, strcat, strncat, strlen, and strspn.\n</misra_rule>\n\nAnother agent reported that the target code violated the Rule 21.17.\nHere is the comment from the agent.\n<violation scenario>\nThe call passes info->name (which has static size LFS_NAME_MAX+1) but requests a copy length of lfs->name_max+1. If lfs->name_max (from the on-disk superblock or runtime config) is greater than LFS_NAME_MAX, the called routine (lfs_dir_get) will copy up to lfs->name_max+1 bytes into info->name, causing out-of-bounds accesses (e.g. via memcpy/strcpy). Thus this use can violate Rule 21.17 unless the implementation guarantees lfs->name_max <= LFS_NAME_MAX before this call.\n</violation scenario>\n\nYour job is to insert logging code to capture the control flow and state information of the program.\nInsert logging code so that other agents can reproduce and get evidence for the violation scenario.\n<response format>\n- test_code: a modified lfs_dir_read code that contains useful probe functions that print useful logs to a file \"/tmp/logs/349.txt\". The logs should contain the control path and state information of the violation scenario. If test code is not required to validate the scenario, you can leave this blank.\nHere are the constraints for the test code:\n- The test code MUST preserve the original logic of lfs_dir_read as much as possible.\nYou CAN just insert probe functions to the original code.\n- DO NOT introduce new violations to demonstrate your scenario.\n- The test code MUST be compilable and executable.\n- The test code MUST include line breaks.\n- You MUST NOT define the main function.\n- You MUST NOT define macros.\n</response format>\n<target_code>\nHere is the code of lfs_dir_read:\n```c\nint lfs_dir_read(lfs_t *lfs, lfs_dir_t *dir, struct lfs_info *info) {\n    int err = LFS_LOCK(lfs->cfg);\n    if (err) {\n        return err;\n    }\n    LFS_TRACE(\"lfs_dir_read(%p, %p, %p)\",\n            (void*)lfs, (void*)dir, (void*)info);\n\n    err = lfs_dir_read_(lfs, dir, info);\n\n    LFS_TRACE(\"lfs_dir_read -> %d\", err);\n    LFS_UNLOCK(lfs->cfg);\n    return err;\n}\n```\n</target_code>\nPlease provide the modified lfs_dir_read code.\n",
  "test_code": "#include <stdio.h>\n#include <string.h>\n#include <stdint.h>\n\n/* Probe logging helper for lfs_dir_read. Writes a compact record of\n   relevant state to /tmp/logs/349.txt so other agents can reproduce\n   and gather evidence for potential out-of-bounds copying related to\n   lfs->name_max vs. the info->name buffer. */\nstatic void lfs_dir_read_probe(lfs_t *lfs, lfs_dir_t *dir, struct lfs_info *info, const char *stage) {\n    FILE *f = fopen(\"/tmp/logs/349.txt\", \"a\");\n    if (!f) {\n        return;\n    }\n\n    fprintf(f, \"---- lfs_dir_read probe (%s) ----\\n\", stage);\n    fprintf(f, \"lfs=%p, dir=%p, info=%p\\n\", (void*)lfs, (void*)dir, (void*)info);\n\n    if (lfs) {\n        /* lfs->name_max is an integer runtime value that controls how many\n           bytes may be copied into info->name by the callee. This is the\n           primary value of interest for the violation scenario. */\n        fprintf(f, \"lfs->name_max = %llu\\n\", (unsigned long long)lfs->name_max);\n        fprintf(f, \"lfs->cfg = %p\\n\", (void*)lfs->cfg);\n    }\n\n#ifdef LFS_NAME_MAX\n    /* If the compile-time configured LFS_NAME_MAX macro is available,\n       log it. This represents the compile-time buffer size for\n       info->name (typically LFS_NAME_MAX+1 including NUL). */\n    fprintf(f, \"LFS_NAME_MAX (macro) = %d\\n\", LFS_NAME_MAX);\n    fprintf(f, \"expected info->name buffer size (LFS_NAME_MAX+1) = %zu\\n\", (size_t)(LFS_NAME_MAX + 1));\n#endif\n\n    if (info) {\n        /* Try to log the actual size of the name member if the struct\n           is visible in this translation unit. sizeof won't access memory\n           and is safe even if the struct is incomplete at compile-time\n           (it will cause an error only if the member isn't known). */\n#ifdef __STDC__\n        /* Use a safe approach: attempt to print sizeof(info->name).\n           If this translation unit doesn't know the member, this line\n           will fail to compile \u2014 but in the typical build of the lfs\n           library the member is visible here, so it will succeed. */\n        fprintf(f, \"sizeof(info->name) = %zu\\n\", sizeof(info->name));\n\n        /* Log a short prefix of the current contents of info->name to\n           help determine whether a previous copy already overflowed or\n           what name would be copied. Only copy up to a safe cap (64).\n           We use memcpy to avoid depending on NUL termination. */\n        size_t name_bytes = sizeof(info->name);\n        size_t cap = name_bytes < 64 ? name_bytes : 64;\n        if (cap > 0) {\n            char buf[65];\n            memset(buf, 0, sizeof(buf));\n            /* Use memcpy with cap which is derived from sizeof(info->name)\n               to avoid reading out-of-bounds. */\n            memcpy(buf, info->name, cap);\n            /* Ensure buffer is NUL-terminated for safe printing. */\n            buf[64] = '\\0';\n            fprintf(f, \"info->name (prefix, up to %zu bytes) = '%s'\\n\", cap, buf);\n        }\n#endif\n    }\n\n    fprintf(f, \"---- end probe (%s) ----\\n\\n\", stage);\n    fclose(f);\n}\n\nint lfs_dir_read(lfs_t *lfs, lfs_dir_t *dir, struct lfs_info *info) {\n    int err = LFS_LOCK(lfs->cfg);\n    if (err) {\n        return err;\n    }\n    LFS_TRACE(\"lfs_dir_read(%p, %p, %p)\",\n            (void*)lfs, (void*)dir, (void*)info);\n\n    /* Probe BEFORE calling the underlying implementation to capture the\n       controlling parameters (notably lfs->name_max) and the state of\n       the info structure prior to any copy that may happen inside\n       lfs_dir_read_. This helps reproduce the violation scenario. */\n    lfs_dir_read_probe(lfs, dir, info, \"before lfs_dir_read_\");\n\n    err = lfs_dir_read_(lfs, dir, info);\n\n    /* Probe AFTER the call to capture the result and any changes to\n       info->name (or evidence of a truncated / overwritten value). */\n    lfs_dir_read_probe(lfs, dir, info, \"after lfs_dir_read_\");\n\n    LFS_TRACE(\"lfs_dir_read -> %d\", err);\n    LFS_UNLOCK(lfs->cfg);\n    return err;\n}"
}