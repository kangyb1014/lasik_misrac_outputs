{
  "user_message": "An agent A claimed that the following lfs_ctz_traverse code violates the MISRA C 2023 rule 17.8.\n<misra_rule>\nMISRA C 2023 Rule 17.8 is A function parameter should not be modified.\nNote that the object referred to by a pointer parameter may be modified, but the pointer itself shall not be modified.\n</misra_rule>\n<target_code>\nHere is the original code of lfs_ctz_traverse.\n```c\nstatic int lfs_ctz_traverse(lfs_t *lfs,\n        const lfs_cache_t *pcache, lfs_cache_t *rcache,\n        lfs_block_t head, lfs_size_t size,\n        int (*cb)(void*, lfs_block_t), void *data) {\n    if (size == 0) {\n        return 0;\n    }\n\n    lfs_off_t index = lfs_ctz_index(lfs, &(lfs_off_t){size-1});\n\n    while (true) {\n        int err = cb(data, head);\n        if (err) {\n            return err;\n        }\n\n        if (index == 0) {\n            return 0;\n        }\n\n        lfs_block_t heads[2];\n        int count = 2 - (index & 1);\n        err = lfs_bd_read(lfs,\n                pcache, rcache, count*sizeof(head),\n                head, 0, &heads, count*sizeof(head));\n        heads[0] = lfs_fromle32(heads[0]);\n        heads[1] = lfs_fromle32(heads[1]);\n        if (err) {\n            return err;\n        }\n\n        for (int i = 0; i < count-1; i++) {\n            err = cb(data, heads[i]);\n            if (err) {\n                return err;\n            }\n        }\n\n        head = heads[count-1];\n        index -= count;\n    }\n}\n```\n</target_code>\n<response format>\nProvide your answer with these fields.\n- explanation: your evaluation of the scenario provided by the agent A.\n- is_report_correct: whether the report is correct or not (true/false). True means there is a violation.\n</response format>\n<scenario>\nThe agent A provided the following violation scenario:\nThe assignment 'head = heads[count-1];' modifies the function parameter 'head' (a non-pointer parameter) inside lfs_ctz_traverse. MISRA C 2023 Rule 17.8 prohibits modifying function parameters. Replace with a local variable (e.g. lfs_block_t cur = head; update cur) or avoid assigning to the parameter to comply.\n</scenario>\n\n<execution_log>\nThe agent A also provided the following output log:\nlfs_ctz_traverse ENTER: head=1410 size=64548 index=127\ncb called: head=1410 cb_err=0\nabout to read heads: head=1410 index=127 count=1\nread heads: heads[0]=1409 heads[1]=32766 read_err=0\nabout to assign head = heads[count-1]: old_head=1410 new_head=1409\nafter assignment: head=1409 index_before=127\nindex updated: index=126\ncb called: head=1409 cb_err=0\nabout to read heads: head=1409 index=126 count=2\nread heads: heads[0]=1408 heads[1]=1407 read_err=0\ncb called for heads[0]=1408 cb_err=0\nabout to assign head = heads[count-1]: old_head=1409 new_head=1407\nafter assignment: head=1407 index_before=126\nindex updated: index=124\ncb called: head=1407 cb_err=0\nabout to read heads: head=1407 index=124 count=2\nread heads: heads[0]=1406 heads[1]=1405 read_err=0\ncb called for heads[0]=1406 cb_err=0\nabout to assign head = heads[count-1]: old_head=1407 new_head=1405\nafter assignment: head=1405 index_before=124\nindex updated: index=122\ncb called: head=1405 cb_err=0\nabout to read heads: head=1405 index=122 count=2\nread heads: heads[0]=1404 heads[1]=1403 read_err=0\ncb called for heads[0]=1404 cb_err=0\nabout to assign head = heads[count-1]: old_head=1405 new_head=1403\nafter assignment: head=1403 index_before=122\nindex updated: index=120\ncb called: head=1403 cb_err=0\nabout to read heads: head=1403 index=120 count=2\nread heads: heads[0]=1402 heads[1]=1401 read_err=0\ncb called for heads[0]=1402 cb_err=0\nabout to assign head = heads[count-1]: old_head=1403 new_head=1401\nafter assignment: head=1401 index_before=120\nindex updated: index=118\ncb called: head=1401 cb_err=0\nabout to read heads: head=1401 index=118 count=2\nread heads: heads[0]=1400 heads[1]=1399 read_err=0\ncb called for heads[0]=1400 cb_err=0\nabout to assign head = heads[count-1]: old_head=1401 new_head=1399\nafter assignment: head=1399 index_before=118\nindex updated: index=116\ncb called: head=1399 cb_err=0\nabout to read heads: head=1399 index=116 count=2\nread heads: heads[0]=1398 heads[1]=1397 read_err=0\ncb called for heads[0]=1398 cb_err=0\nabout to assign head = heads[count-1]: old_head=1399 new_head=1397\nafter assignment: head=1397 index_before=116\nindex updated: index=114\ncb called: head=1397 cb_err=0\nabout to read heads: head=1397 index=114 count=2\nread heads: heads[0]=1396 heads[1]=1395 read_err=0\ncb called for heads[0]=1396 cb_err=0\nabout to assign head = heads[count-1]: old_head=1397 new_head=1395\nafter assignment: head=1395 index_before=114\nindex updated: index=112\ncb called: head=1395 cb_err=0\nabout to read heads: head=1395 index=112 count=2\nread heads: heads[0]=1394 heads[1]=1393 read_err=0\ncb called for heads[0]=1394 cb_err=0\nabout to assign head = heads[count-1]: old_head=1395 new_head=1393\nafter assignment: head=1393 index_before=112\nindex updated: index=110\ncb called: head=1393 cb_err=0\nabout to read heads: head=1393 index=110 count=2\nread heads: heads[0]=1392 heads[1]=1391 read_err=0\ncb called for heads[0]=1392 cb_err=0\nabout to assign head = heads[count-1]: old_head=1393 new_head=1391\nafter assignment: head=1391 index_before=110\nindex updated: index=108\ncb called: head=1391 cb_err=0\nabout to read heads: head=1391 index=108 count=2\nread heads: heads[0]=1390 heads[1]=1389 read_err=0\ncb called for heads[0]=1390 cb_err=0\nabout to assign head = heads[count-1]: old_head=1391 new_head=1389\nafter assignment: head=1389 index_before=108\nindex updated: index=106\ncb called: head=1389 cb_err=0\nabout to read heads: head=1389 index=106 count=2\nread heads: heads[0]=1388 heads[1]=1387 read_err=0\ncb called for heads[0]=1388 cb_err=0\nabout to assign head = heads[count-1]: old_head=1389 new_head=1387\nafter assignment: head=1387 index_before=106\nindex updated: index=104\ncb called: head=1387 cb_err=0\nabout to read heads: head=1387 index=104 count=2\nread heads: heads[0]=1386 heads[1]=1385 read_err=0\ncb called for heads[0]=1386 cb_err=0\nabout to assign head = heads[count-1]: old_head=1387 new_head=1385\nafter assignment: head=1385 index_before=104\nindex updated: index=102\ncb called: head=1385 cb_err=0\nabout to read heads: head=1385 index=102 count=2\nread heads: heads[0]=1384 heads[1]=1383 read_e\n</execution_log>\n<additional code>Here are the definitions of symbols that are close to the target function lfs_ctz_traverse:\nstatic int lfs_ctz_index(lfs_t *lfs, lfs_off_t *off) {\n    lfs_off_t size = *off;\n    lfs_off_t b = lfs->cfg->block_size - 2*4;\n    lfs_off_t i = size / b;\n    if (i == 0) {\n        return 0;\n    }\n\n    i = (size - 4*(lfs_popc(i-1)+2)) / b;\n    *off = size - b*i - 4*lfs_popc(i);\n    return i;\n}\n...\nstatic int lfs_bd_read(lfs_t *lfs,\n        const lfs_cache_t *pcache, lfs_cache_t *rcache, lfs_size_t hint,\n        lfs_block_t block, lfs_off_t off,\n        void *buffer, lfs_size_t size) {\n    uint8_t *data = buffer;\n    if (off+size > lfs->cfg->block_size\n            || (lfs->block_count && block >= lfs->block_count)) {\n        return LFS_ERR_CORRUPT;\n    }\n\n    while (size > 0) {\n        lfs_size_t diff = size;\n\n        if (pcache && block == pcache->block &&\n                off < pcache->off + pcache->size) {\n            if (off >= pcache->off) {\n                // is already in pcache?\n                diff = lfs_min(diff, pcache->size - (off-pcache->off));\n                memcpy(data, &pcache->buffer[off-pcache->off], diff);\n\n                data += diff;\n                off += diff;\n                size -= diff;\n                continue;\n            }\n\n            // pcache takes priority\n            diff = lfs_min(diff, pcache->off-off);\n        }\n\n        if (block == rcache->block &&\n                off < rcache->off + rcache->size) {\n            if (off >= rcache->off) {\n                // is already in rcache?\n                diff = lfs_min(diff, rcache->size - (off-rcache->off));\n                memcpy(data, &rcache->buffer[off-rcache->off], diff);\n\n                data += diff;\n                off += diff;\n                size -= diff;\n                continue;\n            }\n\n            // rcache takes priority\n            diff = lfs_min(diff, rcache->off-off);\n        }\n\n        if (size >= hint && off % lfs->cfg->read_size == 0 &&\n                size >= lfs->cfg->read_size) {\n            // bypass cache?\n            diff = lfs_aligndown(diff, lfs->cfg->read_size);\n            int err = lfs->cfg->read(lfs->cfg, block, off, data, diff);\n            if (err) {\n                return err;\n            }\n\n            data += diff;\n            off += diff;\n            size -= diff;\n            continue;\n        }\n\n        // load to cache, first condition can no longer fail\n        LFS_ASSERT(!lfs->block_count || block < lfs->block_count);\n        rcache->block = block;\n        rcache->off = lfs_aligndown(off, lfs->cfg->read_size);\n        rcache->size = lfs_min(\n                lfs_min(\n                    lfs_alignup(off+hint, lfs->cfg->read_size),\n                    lfs->cfg->block_size)\n                - rcache->off,\n                lfs->cfg->cache_size);\n        int err = lfs->cfg->read(lfs->cfg, rcache->block,\n                rcache->off, rcache->buffer, rcache->size);\n        LFS_ASSERT(err <= 0);\n        if (err) {\n            return err;\n        }\n    }\n\n    return 0;\n}\n...\ntypedef uint32_t lfs_block_t\n...\ntypedef uint32_t lfs_off_t\n...\ntypedef uint32_t lfs_size_t\n...\ntypedef struct lfs_cache {\n    lfs_block_t block;\n    lfs_off_t off;\n    lfs_size_t size;\n    uint8_t *buffer;\n} lfs_cache_t\n...\ntypedef struct lfs {\n    lfs_cache_t rcache;\n    lfs_cache_t pcache;\n\n    lfs_block_t root[2];\n    struct lfs_mlist {\n        struct lfs_mlist *next;\n        uint16_t id;\n        uint8_t type;\n        lfs_mdir_t m;\n    } *mlist;\n    uint32_t seed;\n\n    lfs_gstate_t gstate;\n    lfs_gstate_t gdisk;\n    lfs_gstate_t gdelta;\n\n    struct lfs_lookahead {\n        lfs_block_t start;\n        lfs_block_t size;\n        lfs_block_t next;\n        lfs_block_t ckpoint;\n        uint8_t *buffer;\n    } lookahead;\n\n    const struct lfs_config *cfg;\n    lfs_size_t block_count;\n    lfs_size_t name_max;\n    lfs_size_t file_max;\n    lfs_size_t attr_max;\n    lfs_size_t inline_max;\n\n#ifdef LFS_MIGRATE\n    struct lfs1 *lfs1;\n#endif\n} lfs_t\n</additional code>\n\n<instruction>\nJudge whether the report is correct or not.\n</instruction>\n",
  "is_report_correct": true,
  "explanation": "The report is correct. MISRA C 2023 Rule 17.8 forbids modifying function parameter objects; the note only allows modifying the object pointed to by a pointer parameter, not reassigning the pointer or changing non\u2011pointer parameters. In lfs_ctz_traverse the statement 'head = heads[count-1];' assigns to the value parameter head (a non\u2011pointer lfs_block_t), so it violates Rule 17.8. The execution log confirms head is repeatedly updated. Fix by introducing a local variable (e.g. lfs_block_t cur = head;) and updating cur instead of the parameter. (As an aside, other functions in the code, e.g. lfs_bd_read, also modify parameters such as off, which would likewise contravene Rule 17.8.)"
}