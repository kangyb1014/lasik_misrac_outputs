{
  "user_message": "<misra_rule>\nMISRA C 2023 Rule 21.17 is: Use of the string handling functions from <string.h> shall not result in accesses beyond the bounds of the objects referenced by their pointer parameters.\nThis rule strictly applies to the Standard Library functions in <string.h> such as memcpy, memmove, memset, memcmp, strcpy, strncpy, strcat, strncat, strlen, and strspn.\n</misra_rule>\n<response format>\nProvide your answer with these fields.\n- is_rule_violated: whether the rule is violated or not (true/false),\n- scenario: a specific violation scenario.\n</response format>\n<target_code>\nHere is the code of lfs_dir_splittingcompact:\n```c\nstatic int lfs_dir_splittingcompact(lfs_t *lfs, lfs_mdir_t *dir,\n        const struct lfs_mattr *attrs, int attrcount,\n        lfs_mdir_t *source, uint16_t begin, uint16_t end) {\n    while (true) {\n        // find size of first split, we do this by halving the split until\n        // the metadata is guaranteed to fit\n        //\n        // Note that this isn't a true binary search, we never increase the\n        // split size. This may result in poorly distributed metadata but isn't\n        // worth the extra code size or performance hit to fix.\n        lfs_size_t split = begin;\n        while (end - split > 1) {\n            lfs_size_t size = 0;\n            int err = lfs_dir_traverse(lfs,\n                    source, 0, 0xffffffff, attrs, attrcount,\n                    LFS_MKTAG(0x400, 0x3ff, 0),\n                    LFS_MKTAG(LFS_TYPE_NAME, 0, 0),\n                    split, end, -split,\n                    lfs_dir_commit_size, &size);\n            if (err) {\n                return err;\n            }\n\n            // space is complicated, we need room for:\n            //\n            // - tail:         4+2*4 = 12 bytes\n            // - gstate:       4+3*4 = 16 bytes\n            // - move delete:  4     = 4 bytes\n            // - crc:          4+4   = 8 bytes\n            //                 total = 40 bytes\n            //\n            // And we cap at half a block to avoid degenerate cases with\n            // nearly-full metadata blocks.\n            //\n            lfs_size_t metadata_max = (lfs->cfg->metadata_max)\n                    ? lfs->cfg->metadata_max\n                    : lfs->cfg->block_size;\n            if (end - split < 0xff\n                    && size <= lfs_min(\n                        metadata_max - 40,\n                        lfs_alignup(\n                            metadata_max/2,\n                            lfs->cfg->prog_size))) {\n                break;\n            }\n\n            split = split + ((end - split) / 2);\n        }\n\n        if (split == begin) {\n            // no split needed\n            break;\n        }\n\n        // split into two metadata pairs and continue\n        int err = lfs_dir_split(lfs, dir, attrs, attrcount,\n                source, split, end);\n        if (err && err != LFS_ERR_NOSPC) {\n            return err;\n        }\n\n        if (err) {\n            // we can't allocate a new block, try to compact with degraded\n            // performance\n            LFS_WARN(\"Unable to split {0x%\"PRIx32\", 0x%\"PRIx32\"}\",\n                    dir->pair[0], dir->pair[1]);\n            break;\n        } else {\n            end = split;\n        }\n    }\n\n    if (lfs_dir_needsrelocation(lfs, dir)\n            && lfs_pair_cmp(dir->pair, (const lfs_block_t[2]){0, 1}) == 0) {\n        // oh no! we're writing too much to the superblock,\n        // should we expand?\n        lfs_ssize_t size = lfs_fs_size_(lfs);\n        if (size < 0) {\n            return size;\n        }\n\n        // littlefs cannot reclaim expanded superblocks, so expand cautiously\n        //\n        // if our filesystem is more than ~88% full, don't expand, this is\n        // somewhat arbitrary\n        if (lfs->block_count - size > lfs->block_count/8) {\n            LFS_DEBUG(\"Expanding superblock at rev %\"PRIu32, dir->rev);\n            int err = lfs_dir_split(lfs, dir, attrs, attrcount,\n                    source, begin, end);\n            if (err && err != LFS_ERR_NOSPC) {\n                return err;\n            }\n\n            if (err) {\n                // welp, we tried, if we ran out of space there's not much\n                // we can do, we'll error later if we've become frozen\n                LFS_WARN(\"Unable to expand superblock\");\n            } else {\n                // duplicate the superblock entry into the new superblock\n                end = 1;\n            }\n        }\n    }\n\n    return lfs_dir_compact(lfs, dir, attrs, attrcount, source, begin, end);\n}\n```\n</target_code>\n<additional code>Here are the definitions of symbols that are close to the target function lfs_dir_splittingcompact:\nstatic int lfs_dir_traverse(lfs_t *lfs,\n        const lfs_mdir_t *dir, lfs_off_t off, lfs_tag_t ptag,\n        const struct lfs_mattr *attrs, int attrcount,\n        lfs_tag_t tmask, lfs_tag_t ttag,\n        uint16_t begin, uint16_t end, int16_t diff,\n        int (*cb)(void *data, lfs_tag_t tag, const void *buffer), void *data) {\n    // This function in inherently recursive, but bounded. To allow tool-based\n    // analysis without unnecessary code-cost we use an explicit stack\n    struct lfs_dir_traverse stack[LFS_DIR_TRAVERSE_DEPTH-1];\n    unsigned sp = 0;\n    int res;\n\n    // iterate over directory and attrs\n    lfs_tag_t tag;\n    const void *buffer;\n    struct lfs_diskoff disk = {0};\n    while (true) {\n        {\n            if (off+lfs_tag_dsize(ptag) < dir->off) {\n                off += lfs_tag_dsize(ptag);\n                int err = lfs_bd_read(lfs,\n                        NULL, &lfs->rcache, sizeof(tag),\n                        dir->pair[0], off, &tag, sizeof(tag));\n                if (err) {\n                    return err;\n                }\n\n                tag = (lfs_frombe32(tag) ^ ptag) | 0x80000000;\n                disk.block = dir->pair[0];\n                disk.off = off+sizeof(lfs_tag_t);\n                buffer = &disk;\n                ptag = tag;\n            } else if (attrcount > 0) {\n                tag = attrs[0].tag;\n                buffer = attrs[0].buffer;\n                attrs += 1;\n                attrcount -= 1;\n            } else {\n                // finished traversal, pop from stack?\n                res = 0;\n                break;\n            }\n\n            // do we need to filter?\n            lfs_tag_t mask = LFS_MKTAG(0x7ff, 0, 0);\n            if ((mask & tmask & tag) != (mask & tmask & ttag)) {\n                continue;\n            }\n\n            if (lfs_tag_id(tmask) != 0) {\n                LFS_ASSERT(sp < LFS_DIR_TRAVERSE_DEPTH);\n                // recurse, scan for duplicates, and update tag based on\n                // creates/deletes\n                stack[sp] = (struct lfs_dir_traverse){\n                    .dir        = dir,\n                    .off        = off,\n                    .ptag       = ptag,\n                    .attrs      = attrs,\n                    .attrcount  = attrcount,\n                    .tmask      = tmask,\n                    .ttag       = ttag,\n                    .begin      = begin,\n                    .end        = end,\n                    .diff       = diff,\n                    .cb         = cb,\n                    .data       = data,\n                    .tag        = tag,\n                    .buffer     = buffer,\n                    .disk       = disk,\n                };\n                sp += 1;\n\n                tmask = 0;\n                ttag = 0;\n                begin = 0;\n                end = 0;\n                diff = 0;\n                cb = lfs_dir_traverse_filter;\n                data = &stack[sp-1].tag;\n                continue;\n            }\n        }\n\npopped:\n        // in filter range?\n        if (lfs_tag_id(tmask) != 0 &&\n                !(lfs_tag_id(tag) >= begin && lfs_tag_id(tag) < end)) {\n            continue;\n        }\n\n        // handle special cases for mcu-side operations\n        if (lfs_tag_type3(tag) == LFS_FROM_NOOP) {\n            // do nothing\n        } else if (lfs_tag_type3(tag) == LFS_FROM_MOVE) {\n            // Without this condition, lfs_dir_traverse can exhibit an\n            // extremely expensive O(n^3) of nested loops when renaming.\n            // This happens because lfs_dir_traverse tries to filter tags by\n            // the tags in the source directory, triggering a second\n            // lfs_dir_traverse with its own filter operation.\n            //\n            // traverse with commit\n            // '-> traverse with filter\n            //     '-> traverse with move\n            //         '-> traverse with filter\n            //\n            // However we don't actually care about filtering the second set of\n            // tags, since duplicate tags have no effect when filtering.\n            //\n            // This check skips this unnecessary recursive filtering explicitly,\n            // reducing this runtime from O(n^3) to O(n^2).\n            if (cb == lfs_dir_traverse_filter) {\n                continue;\n            }\n\n            // recurse into move\n            stack[sp] = (struct lfs_dir_traverse){\n                .dir        = dir,\n                .off        = off,\n                .ptag       = ptag,\n                .attrs      = attrs,\n                .attrcount  = attrcount,\n                .tmask      = tmask,\n                .ttag       = ttag,\n                .begin      = begin,\n                .end        = end,\n                .diff       = diff,\n                .cb         = cb,\n                .data       = data,\n                .tag        = LFS_MKTAG(LFS_FROM_NOOP, 0, 0),\n            };\n            sp += 1;\n\n            uint16_t fromid = lfs_tag_size(tag);\n            uint16_t toid = lfs_tag_id(tag);\n            dir = buffer;\n            off = 0;\n            ptag = 0xffffffff;\n            attrs = NULL;\n            attrcount = 0;\n            tmask = LFS_MKTAG(0x600, 0x3ff, 0);\n            ttag = LFS_MKTAG(LFS_TYPE_STRUCT, 0, 0);\n            begin = fromid;\n            end = fromid+1;\n            diff = toid-fromid+diff;\n        } else if (lfs_tag_type3(tag) == LFS_FROM_USERATTRS) {\n            for (unsigned i = 0; i < lfs_tag_size(tag); i++) {\n                const struct lfs_attr *a = buffer;\n                res = cb(data, LFS_MKTAG(LFS_TYPE_USERATTR + a[i].type,\n                        lfs_tag_id(tag) + diff, a[i].size), a[i].buffer);\n                if (res < 0) {\n                    return res;\n                }\n\n                if (res) {\n                    break;\n                }\n            }\n        } else {\n            res = cb(data, tag + LFS_MKTAG(0, diff, 0), buffer);\n            if (res < 0) {\n                return res;\n            }\n\n            if (res) {\n                break;\n            }\n        }\n    }\n\n    if (sp > 0) {\n        // pop from the stack and return, fortunately all pops share\n        // a destination\n        dir         = stack[sp-1].dir;\n        off         = stack[sp-1].off;\n        ptag        = stack[sp-1].ptag;\n        attrs       = stack[sp-1].attrs;\n        attrcount   = stack[sp-1].attrcount;\n        tmask       = stack[sp-1].tmask;\n        ttag        = stack[sp-1].ttag;\n        begin       = stack[sp-1].begin;\n        end         = stack[sp-1].end;\n        diff        = stack[sp-1].diff;\n        cb          = stack[sp-1].cb;\n        data        = stack[sp-1].data;\n        tag         = stack[sp-1].tag;\n        buffer      = stack[sp-1].buffer;\n        disk        = stack[sp-1].disk;\n        sp -= 1;\n        goto popped;\n    } else {\n        return res;\n    }\n}\n...\nstatic int lfs_dir_commit_size(void *p, lfs_tag_t tag, const void *buffer) {\n    lfs_size_t *size = p;\n    (void)buffer;\n\n    *size += lfs_tag_dsize(tag);\n    return 0;\n}\n...\nstatic int lfs_dir_split(lfs_t *lfs,\n        lfs_mdir_t *dir, const struct lfs_mattr *attrs, int attrcount,\n        lfs_mdir_t *source, uint16_t split, uint16_t end) {\n    // create tail metadata pair\n    lfs_mdir_t tail;\n    int err = lfs_dir_alloc(lfs, &tail);\n    if (err) {\n        return err;\n    }\n\n    tail.split = dir->split;\n    tail.tail[0] = dir->tail[0];\n    tail.tail[1] = dir->tail[1];\n\n    // note we don't care about LFS_OK_RELOCATED\n    int res = lfs_dir_compact(lfs, &tail, attrs, attrcount, source, split, end);\n    if (res < 0) {\n        return res;\n    }\n\n    dir->tail[0] = tail.pair[0];\n    dir->tail[1] = tail.pair[1];\n    dir->split = true;\n\n    // update root if needed\n    if (lfs_pair_cmp(dir->pair, lfs->root) == 0 && split == 0) {\n        lfs->root[0] = tail.pair[0];\n        lfs->root[1] = tail.pair[1];\n    }\n\n    return 0;\n}\n...\nstatic int lfs_dir_compact(lfs_t *lfs,\n        lfs_mdir_t *dir, const struct lfs_mattr *attrs, int attrcount,\n        lfs_mdir_t *source, uint16_t begin, uint16_t end) {\n    // save some state in case block is bad\n    bool relocated = false;\n    bool tired = lfs_dir_needsrelocation(lfs, dir);\n\n    // increment revision count\n    dir->rev += 1;\n\n    // do not proactively relocate blocks during migrations, this\n    // can cause a number of failure states such: clobbering the\n    // v1 superblock if we relocate root, and invalidating directory\n    // pointers if we relocate the head of a directory. On top of\n    // this, relocations increase the overall complexity of\n    // lfs_migration, which is already a delicate operation.\n#ifdef LFS_MIGRATE\n    if (lfs->lfs1) {\n        tired = false;\n    }\n#endif\n\n    if (tired && lfs_pair_cmp(dir->pair, (const lfs_block_t[2]){0, 1}) != 0) {\n        // we're writing too much, time to relocate\n        goto relocate;\n    }\n\n    // begin loop to commit compaction to blocks until a compact sticks\n    while (true) {\n        {\n            // setup commit state\n            struct lfs_commit commit = {\n                .block = dir->pair[1],\n                .off = 0,\n                .ptag = 0xffffffff,\n                .crc = 0xffffffff,\n\n                .begin = 0,\n                .end = (lfs->cfg->metadata_max ?\n                    lfs->cfg->metadata_max : lfs->cfg->block_size) - 8,\n            };\n\n            // erase block to write to\n            int err = lfs_bd_erase(lfs, dir->pair[1]);\n            if (err) {\n                if (err == LFS_ERR_CORRUPT) {\n                    goto relocate;\n                }\n                return err;\n            }\n\n            // write out header\n            dir->rev = lfs_tole32(dir->rev);\n            err = lfs_dir_commitprog(lfs, &commit,\n                    &dir->rev, sizeof(dir->rev));\n            dir->rev = lfs_fromle32(dir->rev);\n            if (err) {\n                if (err == LFS_ERR_CORRUPT) {\n                    goto relocate;\n                }\n                return err;\n            }\n\n            // traverse the directory, this time writing out all unique tags\n            err = lfs_dir_traverse(lfs,\n                    source, 0, 0xffffffff, attrs, attrcount,\n                    LFS_MKTAG(0x400, 0x3ff, 0),\n                    LFS_MKTAG(LFS_TYPE_NAME, 0, 0),\n                    begin, end, -begin,\n                    lfs_dir_commit_commit, &(struct lfs_dir_commit_commit){\n                        lfs, &commit});\n            if (err) {\n                if (err == LFS_ERR_CORRUPT) {\n                    goto relocate;\n                }\n                return err;\n            }\n\n            // commit tail, which may be new after last size check\n            if (!lfs_pair_isnull(dir->tail)) {\n                lfs_pair_tole32(dir->tail);\n                err = lfs_dir_commitattr(lfs, &commit,\n                        LFS_MKTAG(LFS_TYPE_TAIL + dir->split, 0x3ff, 8),\n                        dir->tail);\n                lfs_pair_fromle32(dir->tail);\n                if (err) {\n                    if (err == LFS_ERR_CORRUPT) {\n                        goto relocate;\n                    }\n                    return err;\n                }\n            }\n\n            // bring over gstate?\n            lfs_gstate_t delta = {0};\n            if (!relocated) {\n                lfs_gstate_xor(&delta, &lfs->gdisk);\n                lfs_gstate_xor(&delta, &lfs->gstate);\n            }\n            lfs_gstate_xor(&delta, &lfs->gdelta);\n            delta.tag &= ~LFS_MKTAG(0, 0, 0x3ff);\n\n            err = lfs_dir_getgstate(lfs, dir, &delta);\n            if (err) {\n                return err;\n            }\n\n            if (!lfs_gstate_iszero(&delta)) {\n                lfs_gstate_tole32(&delta);\n                err = lfs_dir_commitattr(lfs, &commit,\n                        LFS_MKTAG(LFS_TYPE_MOVESTATE, 0x3ff,\n                            sizeof(delta)), &delta);\n                if (err) {\n                    if (err == LFS_ERR_CORRUPT) {\n                        goto relocate;\n                    }\n                    return err;\n                }\n            }\n\n            // complete commit with crc\n            err = lfs_dir_commitcrc(lfs, &commit);\n            if (err) {\n                if (err == LFS_ERR_CORRUPT) {\n                    goto relocate;\n                }\n                return err;\n            }\n\n            // successful compaction, swap dir pair to indicate most recent\n            LFS_ASSERT(commit.off % lfs->cfg->prog_size == 0);\n            lfs_pair_swap(dir->pair);\n            dir->count = end - begin;\n            dir->off = commit.off;\n            dir->etag = commit.ptag;\n            // update gstate\n            lfs->gdelta = (lfs_gstate_t){0};\n            if (!relocated) {\n                lfs->gdisk = lfs->gstate;\n            }\n        }\n        break;\n\nrelocate:\n        // commit was corrupted, drop caches and prepare to relocate block\n        relocated = true;\n        lfs_cache_drop(lfs, &lfs->pcache);\n        if (!tired) {\n            LFS_DEBUG(\"Bad block at 0x%\"PRIx32, dir->pair[1]);\n        }\n\n        // can't relocate superblock, filesystem is now frozen\n        if (lfs_pair_cmp(dir->pair, (const lfs_block_t[2]){0, 1}) == 0) {\n            LFS_WARN(\"Superblock 0x%\"PRIx32\" has become unwritable\",\n                    dir->pair[1]);\n            return LFS_ERR_NOSPC;\n        }\n\n        // relocate half of pair\n        int err = lfs_alloc(lfs, &dir->pair[1]);\n        if (err && (err != LFS_ERR_NOSPC || !tired)) {\n            return err;\n        }\n\n        tired = false;\n        continue;\n    }\n\n    return relocated ? LFS_OK_RELOCATED : 0;\n}\n...\nstatic int lfs_bd_read(lfs_t *lfs,\n        const lfs_cache_t *pcache, lfs_cache_t *rcache, lfs_size_t hint,\n        lfs_block_t block, lfs_off_t off,\n        void *buffer, lfs_size_t size) {\n    uint8_t *data = buffer;\n    if (off+size > lfs->cfg->block_size\n            || (lfs->block_count && block >= lfs->block_count)) {\n        return LFS_ERR_CORRUPT;\n    }\n\n    while (size > 0) {\n        lfs_size_t diff = size;\n\n        if (pcache && block == pcache->block &&\n                off < pcache->off + pcache->size) {\n            if (off >= pcache->off) {\n                // is already in pcache?\n                diff = lfs_min(diff, pcache->size - (off-pcache->off));\n                memcpy(data, &pcache->buffer[off-pcache->off], diff);\n\n                data += diff;\n                off += diff;\n                size -= diff;\n                continue;\n            }\n\n            // pcache takes priority\n            diff = lfs_min(diff, pcache->off-off);\n        }\n\n        if (block == rcache->block &&\n                off < rcache->off + rcache->size) {\n            if (off >= rcache->off) {\n                // is already in rcache?\n                diff = lfs_min(diff, rcache->size - (off-rcache->off));\n                memcpy(data, &rcache->buffer[off-rcache->off], diff);\n\n                data += diff;\n                off += diff;\n                size -= diff;\n                continue;\n            }\n\n            // rcache takes priority\n            diff = lfs_min(diff, rcache->off-off);\n        }\n\n        if (size >= hint && off % lfs->cfg->read_size == 0 &&\n                size >= lfs->cfg->read_size) {\n            // bypass cache?\n            diff = lfs_aligndown(diff, lfs->cfg->read_size);\n            int err = lfs->cfg->read(lfs->cfg, block, off, data, diff);\n            if (err) {\n                return err;\n            }\n\n            data += diff;\n            off += diff;\n            size -= diff;\n            continue;\n        }\n\n        // load to cache, first condition can no longer fail\n        LFS_ASSERT(!lfs->block_count || block < lfs->block_count);\n        rcache->block = block;\n        rcache->off = lfs_aligndown(off, lfs->cfg->read_size);\n        rcache->size = lfs_min(\n                lfs_min(\n                    lfs_alignup(off+hint, lfs->cfg->read_size),\n                    lfs->cfg->block_size)\n                - rcache->off,\n                lfs->cfg->cache_size);\n        int err = lfs->cfg->read(lfs->cfg, rcache->block,\n                rcache->off, rcache->buffer, rcache->size);\n        LFS_ASSERT(err <= 0);\n        if (err) {\n            return err;\n        }\n    }\n\n    return 0;\n}\n...\nstatic int lfs_bd_prog(lfs_t *lfs,\n        lfs_cache_t *pcache, lfs_cache_t *rcache, bool validate,\n        lfs_block_t block, lfs_off_t off,\n        const void *buffer, lfs_size_t size) {\n    const uint8_t *data = buffer;\n    LFS_ASSERT(block == LFS_BLOCK_INLINE || block < lfs->block_count);\n    LFS_ASSERT(off + size <= lfs->cfg->block_size);\n\n    while (size > 0) {\n        if (block == pcache->block &&\n                off >= pcache->off &&\n                off < pcache->off + lfs->cfg->cache_size) {\n            // already fits in pcache?\n            lfs_size_t diff = lfs_min(size,\n                    lfs->cfg->cache_size - (off-pcache->off));\n            memcpy(&pcache->buffer[off-pcache->off], data, diff);\n\n            data += diff;\n            off += diff;\n            size -= diff;\n\n            pcache->size = lfs_max(pcache->size, off - pcache->off);\n            if (pcache->size == lfs->cfg->cache_size) {\n                // eagerly flush out pcache if we fill up\n                int err = lfs_bd_flush(lfs, pcache, rcache, validate);\n                if (err) {\n                    return err;\n                }\n            }\n\n            continue;\n        }\n\n        // pcache must have been flushed, either by programming and\n        // entire block or manually flushing the pcache\n        LFS_ASSERT(pcache->block == LFS_BLOCK_NULL);\n\n        // prepare pcache, first condition can no longer fail\n        pcache->block = block;\n        pcache->off = lfs_aligndown(off, lfs->cfg->prog_size);\n        pcache->size = 0;\n    }\n\n    return 0;\n}\n...\nstatic inline void lfs_cache_drop(lfs_t *lfs, lfs_cache_t *rcache) {\n    // do not zero, cheaper if cache is readonly or only going to be\n    // written with identical data (during relocates)\n    (void)lfs;\n    rcache->block = LFS_BLOCK_NULL;\n}\n...\nstatic int lfs_dir_commitattr(lfs_t *lfs, struct lfs_commit *commit,\n        lfs_tag_t tag, const void *buffer) {\n    // check if we fit\n    lfs_size_t dsize = lfs_tag_dsize(tag);\n    if (commit->off + dsize > commit->end) {\n        return LFS_ERR_NOSPC;\n    }\n\n    // write out tag\n    lfs_tag_t ntag = lfs_tobe32((tag & 0x7fffffff) ^ commit->ptag);\n    int err = lfs_dir_commitprog(lfs, commit, &ntag, sizeof(ntag));\n    if (err) {\n        return err;\n    }\n\n    if (!(tag & 0x80000000)) {\n        // from memory\n        err = lfs_dir_commitprog(lfs, commit, buffer, dsize-sizeof(tag));\n        if (err) {\n            return err;\n        }\n    } else {\n        // from disk\n        const struct lfs_diskoff *disk = buffer;\n        for (lfs_off_t i = 0; i < dsize-sizeof(tag); i++) {\n            // rely on caching to make this efficient\n            uint8_t dat;\n            err = lfs_bd_read(lfs,\n                    NULL, &lfs->rcache, dsize-sizeof(tag)-i,\n                    disk->block, disk->off+i, &dat, 1);\n            if (err) {\n                return err;\n            }\n\n            err = lfs_dir_commitprog(lfs, commit, &dat, 1);\n            if (err) {\n                return err;\n            }\n        }\n    }\n\n    commit->ptag = tag & 0x7fffffff;\n    return 0;\n}\n...\nstatic int lfs_dir_commitcrc(lfs_t *lfs, struct lfs_commit *commit) {\n    // align to program units\n    //\n    // this gets a bit complex as we have two types of crcs:\n    // - 5-word crc with fcrc to check following prog (middle of block)\n    // - 2-word crc with no following prog (end of block)\n    const lfs_off_t end = lfs_alignup(\n            lfs_min(commit->off + 5*sizeof(uint32_t), lfs->cfg->block_size),\n            lfs->cfg->prog_size);\n\n    lfs_off_t off1 = 0;\n    uint32_t crc1 = 0;\n\n    // create crc tags to fill up remainder of commit, note that\n    // padding is not crced, which lets fetches skip padding but\n    // makes committing a bit more complicated\n    while (commit->off < end) {\n        lfs_off_t noff = (\n                lfs_min(end - (commit->off+sizeof(lfs_tag_t)), 0x3fe)\n                + (commit->off+sizeof(lfs_tag_t)));\n        // too large for crc tag? need padding commits\n        if (noff < end) {\n            noff = lfs_min(noff, end - 5*sizeof(uint32_t));\n        }\n\n        // space for fcrc?\n        uint8_t eperturb = (uint8_t)-1;\n        if (noff >= end && noff <= lfs->cfg->block_size - lfs->cfg->prog_size) {\n            // first read the leading byte, this always contains a bit\n            // we can perturb to avoid writes that don't change the fcrc\n            int err = lfs_bd_read(lfs,\n                    NULL, &lfs->rcache, lfs->cfg->prog_size,\n                    commit->block, noff, &eperturb, 1);\n            if (err && err != LFS_ERR_CORRUPT) {\n                return err;\n            }\n\n        #ifdef LFS_MULTIVERSION\n            // unfortunately fcrcs break mdir fetching < lfs2.1, so only write\n            // these if we're a >= lfs2.1 filesystem\n            if (lfs_fs_disk_version(lfs) <= 0x00020000) {\n                // don't write fcrc\n            } else\n        #endif\n            {\n                // find the expected fcrc, don't bother avoiding a reread\n                // of the eperturb, it should still be in our cache\n                struct lfs_fcrc fcrc = {\n                    .size = lfs->cfg->prog_size,\n                    .crc = 0xffffffff\n                };\n                err = lfs_bd_crc(lfs,\n                        NULL, &lfs->rcache, lfs->cfg->prog_size,\n                        commit->block, noff, fcrc.size, &fcrc.crc);\n                if (err && err != LFS_ERR_CORRUPT) {\n                    return err;\n                }\n\n                lfs_fcrc_tole32(&fcrc);\n                err = lfs_dir_commitattr(lfs, commit,\n                        LFS_MKTAG(LFS_TYPE_FCRC, 0x3ff, sizeof(struct lfs_fcrc)),\n                        &fcrc);\n                if (err) {\n                    return err;\n                }\n            }\n        }\n\n        // build commit crc\n        struct {\n            lfs_tag_t tag;\n            uint32_t crc;\n        } ccrc;\n        lfs_tag_t ntag = LFS_MKTAG(\n                LFS_TYPE_CCRC + (((uint8_t)~eperturb) >> 7), 0x3ff,\n                noff - (commit->off+sizeof(lfs_tag_t)));\n        ccrc.tag = lfs_tobe32(ntag ^ commit->ptag);\n        commit->crc = lfs_crc(commit->crc, &ccrc.tag, sizeof(lfs_tag_t));\n        ccrc.crc = lfs_tole32(commit->crc);\n\n        int err = lfs_bd_prog(lfs,\n                &lfs->pcache, &lfs->rcache, false,\n                commit->block, commit->off, &ccrc, sizeof(ccrc));\n        if (err) {\n            return err;\n        }\n\n        // keep track of non-padding checksum to verify\n        if (off1 == 0) {\n            off1 = commit->off + sizeof(lfs_tag_t);\n            crc1 = commit->crc;\n        }\n\n        commit->off = noff;\n        // perturb valid bit?\n        commit->ptag = ntag ^ ((0x80UL & ~eperturb) << 24);\n        // reset crc for next commit\n        commit->crc = 0xffffffff;\n\n        // manually flush here since we don't prog the padding, this confuses\n        // the caching layer\n        if (noff >= end || noff >= lfs->pcache.off + lfs->cfg->cache_size) {\n            // flush buffers\n            int err = lfs_bd_sync(lfs, &lfs->pcache, &lfs->rcache, false);\n            if (err) {\n                return err;\n            }\n        }\n    }\n\n    // successful commit, check checksums to make sure\n    //\n    // note that we don't need to check padding commits, worst\n    // case if they are corrupted we would have had to compact anyways\n    lfs_off_t off = commit->begin;\n    uint32_t crc = 0xffffffff;\n    int err = lfs_bd_crc(lfs,\n            NULL, &lfs->rcache, off1+sizeof(uint32_t),\n            commit->block, off, off1-off, &crc);\n    if (err) {\n        return err;\n    }\n\n    // check non-padding commits against known crc\n    if (crc != crc1) {\n        return LFS_ERR_CORRUPT;\n    }\n\n    // make sure to check crc in case we happen to pick\n    // up an unrelated crc (frozen block?)\n    err = lfs_bd_crc(lfs,\n            NULL, &lfs->rcache, sizeof(uint32_t),\n            commit->block, off1, sizeof(uint32_t), &crc);\n    if (err) {\n        return err;\n    }\n\n    if (crc != 0) {\n        return LFS_ERR_CORRUPT;\n    }\n\n    return 0;\n}\n...\nstatic int lfs_dir_commitprog(lfs_t *lfs, struct lfs_commit *commit,\n        const void *buffer, lfs_size_t size) {\n    int err = lfs_bd_prog(lfs,\n            &lfs->pcache, &lfs->rcache, false,\n            commit->block, commit->off ,\n            (const uint8_t*)buffer, size);\n    if (err) {\n        return err;\n    }\n\n    commit->crc = lfs_crc(commit->crc, buffer, size);\n    commit->off += size;\n    return 0;\n}\n...\nstatic int lfs_dir_alloc(lfs_t *lfs, lfs_mdir_t *dir) {\n    // allocate pair of dir blocks (backwards, so we write block 1 first)\n    for (int i = 0; i < 2; i++) {\n        int err = lfs_alloc(lfs, &dir->pair[(i+1)%2]);\n        if (err) {\n            return err;\n        }\n    }\n\n    // zero for reproducibility in case initial block is unreadable\n    dir->rev = 0;\n\n    // rather than clobbering one of the blocks we just pretend\n    // the revision may be valid\n    int err = lfs_bd_read(lfs,\n            NULL, &lfs->rcache, sizeof(dir->rev),\n            dir->pair[0], 0, &dir->rev, sizeof(dir->rev));\n    dir->rev = lfs_fromle32(dir->rev);\n    if (err && err != LFS_ERR_CORRUPT) {\n        return err;\n    }\n\n    // to make sure we don't immediately evict, align the new revision count\n    // to our block_cycles modulus, see lfs_dir_compact for why our modulus\n    // is tweaked this way\n    if (lfs->cfg->block_cycles > 0) {\n        dir->rev = lfs_alignup(dir->rev, ((lfs->cfg->block_cycles+1)|1));\n    }\n\n    // set defaults\n    dir->off = sizeof(dir->rev);\n    dir->etag = 0xffffffff;\n    dir->count = 0;\n    dir->tail[0] = LFS_BLOCK_NULL;\n    dir->tail[1] = LFS_BLOCK_NULL;\n    dir->erased = false;\n    dir->split = false;\n\n    // don't write out yet, let caller take care of that\n    return 0;\n}\n...\nstatic int lfs_alloc(lfs_t *lfs, lfs_block_t *block) {\n    while (true) {\n        // scan our lookahead buffer for free blocks\n        while (lfs->lookahead.next < lfs->lookahead.size) {\n            if (!(lfs->lookahead.buffer[lfs->lookahead.next / 8]\n                    & (1U << (lfs->lookahead.next % 8)))) {\n                // found a free block\n                *block = (lfs->lookahead.start + lfs->lookahead.next)\n                        % lfs->block_count;\n\n                // eagerly find next free block to maximize how many blocks\n                // lfs_alloc_ckpoint makes available for scanning\n                while (true) {\n                    lfs->lookahead.next += 1;\n                    lfs->lookahead.ckpoint -= 1;\n\n                    if (lfs->lookahead.next >= lfs->lookahead.size\n                            || !(lfs->lookahead.buffer[lfs->lookahead.next / 8]\n                                & (1U << (lfs->lookahead.next % 8)))) {\n                        return 0;\n                    }\n                }\n            }\n\n            lfs->lookahead.next += 1;\n            lfs->lookahead.ckpoint -= 1;\n        }\n\n        // In order to keep our block allocator from spinning forever when our\n        // filesystem is full, we mark points where there are no in-flight\n        // allocations with a checkpoint before starting a set of allocations.\n        //\n        // If we've looked at all blocks since the last checkpoint, we report\n        // the filesystem as out of storage.\n        //\n        if (lfs->lookahead.ckpoint <= 0) {\n            LFS_ERROR(\"No more free space 0x%\"PRIx32,\n                    (lfs->lookahead.start + lfs->lookahead.next)\n                        % lfs->block_count);\n            return LFS_ERR_NOSPC;\n        }\n\n        // No blocks in our lookahead buffer, we need to scan the filesystem for\n        // unused blocks in the next lookahead window.\n        int err = lfs_alloc_scan(lfs);\n        if(err) {\n            return err;\n        }\n    }\n}\n...\nstatic inline int lfs_pair_cmp(\n        const lfs_block_t paira[2],\n        const lfs_block_t pairb[2]) {\n    return !(paira[0] == pairb[0] || paira[1] == pairb[1] ||\n             paira[0] == pairb[1] || paira[1] == pairb[0]);\n}\n...\nstatic inline void lfs_pair_tole32(lfs_block_t pair[2]) {\n    pair[0] = lfs_tole32(pair[0]);\n    pair[1] = lfs_tole32(pair[1]);\n}\n...\nstatic inline void lfs_pair_fromle32(lfs_block_t pair[2]) {\n    pair[0] = lfs_fromle32(pair[0]);\n    pair[1] = lfs_fromle32(pair[1]);\n}\n...\nstatic inline void lfs_pair_swap(lfs_block_t pair[2]) {\n    lfs_block_t t = pair[0];\n    pair[0] = pair[1];\n    pair[1] = t;\n}\n...\nstatic lfs_ssize_t lfs_fs_size_(lfs_t *lfs) {\n    lfs_size_t size = 0;\n    int err = lfs_fs_traverse_(lfs, lfs_fs_size_count, &size, false);\n    if (err) {\n        return err;\n    }\n\n    return size;\n}\n...\nint lfs_fs_traverse_(lfs_t *lfs,\n        int (*cb)(void *data, lfs_block_t block), void *data,\n        bool includeorphans) {\n    // iterate over metadata pairs\n    lfs_mdir_t dir = {.tail = {0, 1}};\n\n#ifdef LFS_MIGRATE\n    // also consider v1 blocks during migration\n    if (lfs->lfs1) {\n        int err = lfs1_traverse(lfs, cb, data);\n        if (err) {\n            return err;\n        }\n\n        dir.tail[0] = lfs->root[0];\n        dir.tail[1] = lfs->root[1];\n    }\n#endif\n\n    struct lfs_tortoise_t tortoise = {\n        .pair = {LFS_BLOCK_NULL, LFS_BLOCK_NULL},\n        .i = 1,\n        .period = 1,\n    };\n    int err = LFS_ERR_OK;\n    while (!lfs_pair_isnull(dir.tail)) {\n        err = lfs_tortoise_detectcycles(&dir, &tortoise);\n        if (err < 0) {\n            return LFS_ERR_CORRUPT;\n        }\n\n        for (int i = 0; i < 2; i++) {\n            int err = cb(data, dir.tail[i]);\n            if (err) {\n                return err;\n            }\n        }\n\n        // iterate through ids in directory\n        int err = lfs_dir_fetch(lfs, &dir, dir.tail);\n        if (err) {\n            return err;\n        }\n\n        for (uint16_t id = 0; id < dir.count; id++) {\n            struct lfs_ctz ctz;\n            lfs_stag_t tag = lfs_dir_get(lfs, &dir, LFS_MKTAG(0x700, 0x3ff, 0),\n                    LFS_MKTAG(LFS_TYPE_STRUCT, id, sizeof(ctz)), &ctz);\n            if (tag < 0) {\n                if (tag == LFS_ERR_NOENT) {\n                    continue;\n                }\n                return tag;\n            }\n            lfs_ctz_fromle32(&ctz);\n\n            if (lfs_tag_type3(tag) == LFS_TYPE_CTZSTRUCT) {\n                err = lfs_ctz_traverse(lfs, NULL, &lfs->rcache,\n                        ctz.head, ctz.size, cb, data);\n                if (err) {\n                    return err;\n                }\n            } else if (includeorphans &&\n                    lfs_tag_type3(tag) == LFS_TYPE_DIRSTRUCT) {\n                for (int i = 0; i < 2; i++) {\n                    err = cb(data, (&ctz.head)[i]);\n                    if (err) {\n                        return err;\n                    }\n                }\n            }\n        }\n    }\n\n#ifndef LFS_READONLY\n    // iterate over any open files\n    for (lfs_file_t *f = (lfs_file_t*)lfs->mlist; f; f = f->next) {\n        if (f->type != LFS_TYPE_REG) {\n            continue;\n        }\n\n        if ((f->flags & LFS_F_DIRTY) && !(f->flags & LFS_F_INLINE)) {\n            int err = lfs_ctz_traverse(lfs, &f->cache, &lfs->rcache,\n                    f->ctz.head, f->ctz.size, cb, data);\n            if (err) {\n                return err;\n            }\n        }\n\n        if ((f->flags & LFS_F_WRITING) && !(f->flags & LFS_F_INLINE)) {\n            int err = lfs_ctz_traverse(lfs, &f->cache, &lfs->rcache,\n                    f->block, f->pos, cb, data);\n            if (err) {\n                return err;\n            }\n        }\n    }\n#endif\n\n    return 0;\n}\n...\ntypedef struct lfs {\n    lfs_cache_t rcache;\n    lfs_cache_t pcache;\n\n    lfs_block_t root[2];\n    struct lfs_mlist {\n        struct lfs_mlist *next;\n        uint16_t id;\n        uint8_t type;\n        lfs_mdir_t m;\n    } *mlist;\n    uint32_t seed;\n\n    lfs_gstate_t gstate;\n    lfs_gstate_t gdisk;\n    lfs_gstate_t gdelta;\n\n    struct lfs_lookahead {\n        lfs_block_t start;\n        lfs_block_t size;\n        lfs_block_t next;\n        lfs_block_t ckpoint;\n        uint8_t *buffer;\n    } lookahead;\n\n    const struct lfs_config *cfg;\n    lfs_size_t block_count;\n    lfs_size_t name_max;\n    lfs_size_t file_max;\n    lfs_size_t attr_max;\n    lfs_size_t inline_max;\n\n#ifdef LFS_MIGRATE\n    struct lfs1 *lfs1;\n#endif\n} lfs_t\n...\ntypedef struct lfs_mdir {\n    lfs_block_t pair[2];\n    uint32_t rev;\n    lfs_off_t off;\n    uint32_t etag;\n    uint16_t count;\n    bool erased;\n    bool split;\n    lfs_block_t tail[2];\n} lfs_mdir_t\n...\nstruct lfs_mattr {\n    lfs_tag_t tag;\n    const void *buffer;\n}\n...\ntypedef uint32_t lfs_size_t\n...\ntypedef uint32_t lfs_block_t\n</additional code>\n<target_code>\nHere is the code fragment that you need to analyze:\n```c\n                diff = lfs_min(diff, rcache->size - (off-rcache->off));\n                memcpy(data, &rcache->buffer[off-rcache->off], diff);\n```\nFocus on the above code fragment and judge whether it violates the rule 21.17 or not.\n</target_code>\n",
  "is_rule_violated": false,
  "scenario": "The memcpy call is guarded by checks that ensure the source and destination ranges are within bounds: the enclosing if confirms block == rcache->block and off < rcache->off + rcache->size, and the inner if ensures off >= rcache->off so the computed index (off - rcache->off) is non\u2011negative. diff is reduced with diff = lfs_min(diff, rcache->size - (off-rcache->off)), so the copy length cannot exceed the remaining bytes in rcache->buffer. The destination buffer (data) is the caller buffer whose total length was validated earlier by if (off+size > lfs->cfg->block_size) and the loop maintains size accordingly. Therefore this use of memcpy cannot access beyond the bounds of the referenced objects, so Rule 21.17 is not violated."
}