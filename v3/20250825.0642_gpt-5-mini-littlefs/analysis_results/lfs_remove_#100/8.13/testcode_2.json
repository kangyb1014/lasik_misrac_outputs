{
  "user_message": "<misra_rule>\nMISRA C 2023 Rule 8.13 is: A pointer should point to a const-qualified type whenever possible.\n\n</misra_rule>\n\nAnother agent reported that the target code violated the Rule 8.13.\nHere is the comment from the agent.\n<violation scenario>\nThe call passes dir.m.pair (an array/member of type lfs_block_t[]) which decays to a pointer to a non-const lfs_block_t. If lfs_fs_pred only reads the pair (as its name and usage suggest) its second parameter should be declared to point to a const-qualified type (e.g. const lfs_block_t *pair or const lfs_block_t pair[2]). Since the pointer passed is to a non-const type, this violates MISRA C 2023 Rule 8.13 (unless lfs_fs_pred legitimately modifies the pair).\n</violation scenario>\n\nYour job is to insert logging code to capture the control flow and state information of the program.\nInsert logging code so that other agents can reproduce and get evidence for the violation scenario.\n<response format>\n- test_code: a modified lfs_remove_ code that contains useful probe functions that print useful logs to a file \"/tmp/logs/1003.txt\". The logs should contain the control path and state information of the violation scenario. If test code is not required to validate the scenario, you can leave this blank.\nHere are the constraints for the test code:\n- The test code MUST preserve the original logic of lfs_remove_ as much as possible.\nYou CAN just insert probe functions to the original code.\n- DO NOT introduce new violations to demonstrate your scenario.\n- The test code MUST be compilable and executable.\n- The test code MUST include line breaks.\n- You MUST NOT define the main function.\n- You MUST NOT define macros.\n</response format>\n<target_code>\nHere is the code of lfs_remove_:\n```c\nstatic int lfs_remove_(lfs_t *lfs, const char *path) {\n    // deorphan if we haven't yet, needed at most once after poweron\n    int err = lfs_fs_forceconsistency(lfs);\n    if (err) {\n        return err;\n    }\n\n    lfs_mdir_t cwd;\n    lfs_stag_t tag = lfs_dir_find(lfs, &cwd, &path, NULL);\n    if (tag < 0 || lfs_tag_id(tag) == 0x3ff) {\n        return (tag < 0) ? (int)tag : LFS_ERR_INVAL;\n    }\n\n    struct lfs_mlist dir;\n    dir.next = lfs->mlist;\n    if (lfs_tag_type3(tag) == LFS_TYPE_DIR) {\n        // must be empty before removal\n        lfs_block_t pair[2];\n        lfs_stag_t res = lfs_dir_get(lfs, &cwd, LFS_MKTAG(0x700, 0x3ff, 0),\n                LFS_MKTAG(LFS_TYPE_STRUCT, lfs_tag_id(tag), 8), pair);\n        if (res < 0) {\n            return (int)res;\n        }\n        lfs_pair_fromle32(pair);\n\n        err = lfs_dir_fetch(lfs, &dir.m, pair);\n        if (err) {\n            return err;\n        }\n\n        if (dir.m.count > 0 || dir.m.split) {\n            return LFS_ERR_NOTEMPTY;\n        }\n\n        // mark fs as orphaned\n        err = lfs_fs_preporphans(lfs, +1);\n        if (err) {\n            return err;\n        }\n\n        // I know it's crazy but yes, dir can be changed by our parent's\n        // commit (if predecessor is child)\n        dir.type = 0;\n        dir.id = 0;\n        lfs->mlist = &dir;\n    }\n\n    // delete the entry\n    err = lfs_dir_commit(lfs, &cwd, LFS_MKATTRS(\n            {LFS_MKTAG(LFS_TYPE_DELETE, lfs_tag_id(tag), 0), NULL}));\n    if (err) {\n        lfs->mlist = dir.next;\n        return err;\n    }\n\n    lfs->mlist = dir.next;\n    if (lfs_gstate_hasorphans(&lfs->gstate)) {\n        LFS_ASSERT(lfs_tag_type3(tag) == LFS_TYPE_DIR);\n\n        // fix orphan\n        err = lfs_fs_preporphans(lfs, -1);\n        if (err) {\n            return err;\n        }\n\n        err = lfs_fs_pred(lfs, dir.m.pair, &cwd);\n        if (err) {\n            return err;\n        }\n\n        err = lfs_dir_drop(lfs, &cwd, &dir.m);\n        if (err) {\n            return err;\n        }\n    }\n\n    return 0;\n}\n```\n</target_code>\nPlease provide the modified lfs_remove_ code.\n",
  "test_code": "#include <stdio.h>\n#include <stdarg.h>\n\n/*\n * Probe / logging helpers to capture control flow and state for the\n * lfs_remove_ function. Logs are appended to /tmp/logs/1003.txt.\n */\nstatic void lfs_log(const char *fmt, ...) {\n    FILE *f = fopen(\"/tmp/logs/1003.txt\", \"a\");\n    if (!f) {\n        return;\n    }\n    va_list ap;\n    va_start(ap, fmt);\n    vfprintf(f, fmt, ap);\n    va_end(ap);\n    fprintf(f, \"\\n\");\n    fclose(f);\n}\n\n/* Forward declarations of types used by the existing code. These are\n * already defined in the surrounding codebase. We only reference\n * members that are used in lfs_remove_. */\n/* types assumed to exist elsewhere:\ntypedef ... lfs_t;\ntypedef ... lfs_block_t;\ntypedef ... lfs_mdir_t;\ntypedef ... lfs_stag_t;\n*/\n\nstatic void lfs_log_pair(const lfs_block_t *pair, int n) {\n    if (!pair) {\n        lfs_log(\"pair: (null)\");\n        return;\n    }\n    /* Print each block value as an unsigned long long for portability */\n    for (int i = 0; i < n; i++) {\n        lfs_log(\"pair[%d]=%llu\", i, (unsigned long long)pair[i]);\n    }\n}\n\nstatic void lfs_log_mdir(const char *name, const lfs_mdir_t *m) {\n    if (!m) {\n        lfs_log(\"%s: (null)\", name);\n        return;\n    }\n    /* We log the members that are used in this function: count, split, pair */\n    /* Cast numeric fields to unsigned long long for consistent printing */\n    lfs_log(\"%s.count=%llu %s.split=%llu %s.pair=%p\",\n            name,\n            (unsigned long long)m->count,\n            name,\n            (unsigned long long)m->split,\n            name,\n            (const void *)m->pair);\n    /* If pair exists, dump the pair contents (array length assumed 2 where used) */\n    if (m->pair) {\n        lfs_log_pair(m->pair, 2);\n    }\n}\n\n/* Modified lfs_remove_ with probes inserted. Original logic preserved. */\nstatic int lfs_remove_(lfs_t *lfs, const char *path) {\n    lfs_log(\"ENTRY lfs_remove_: lfs=%p path=%s\", (void *)lfs, path ? path : \"(null)\");\n\n    // deorphan if we haven't yet, needed at most once after poweron\n    int err = lfs_fs_forceconsistency(lfs);\n    if (err) {\n        lfs_log(\"lfs_fs_forceconsistency returned err=%d\", err);\n        return err;\n    }\n\n    lfs_mdir_t cwd;\n    lfs_stag_t tag = lfs_dir_find(lfs, &cwd, &path, NULL);\n    lfs_log(\"lfs_dir_find returned tag=%ld\", (long)tag);\n    if (tag < 0 || lfs_tag_id(tag) == 0x3ff) {\n        lfs_log(\"invalid tag or not found: tag=%ld id=%u\", (long)tag, (unsigned)lfs_tag_id(tag));\n        return (tag < 0) ? (int)tag : LFS_ERR_INVAL;\n    }\n\n    struct lfs_mlist dir;\n    dir.next = lfs->mlist;\n    if (lfs_tag_type3(tag) == LFS_TYPE_DIR) {\n        lfs_log(\"entry is a directory: tag=%ld\", (long)tag);\n        // must be empty before removal\n        lfs_block_t pair[2];\n        lfs_stag_t res = lfs_dir_get(lfs, &cwd, LFS_MKTAG(0x700, 0x3ff, 0),\n                LFS_MKTAG(LFS_TYPE_STRUCT, lfs_tag_id(tag), 8), pair);\n        lfs_log(\"lfs_dir_get returned res=%ld\", (long)res);\n        if (res < 0) {\n            lfs_log(\"lfs_dir_get failed with res=%ld\", (long)res);\n            return (int)res;\n        }\n        lfs_pair_fromle32(pair);\n        lfs_log(\"pair after lfs_pair_fromle32:\");\n        lfs_log_pair(pair, 2);\n\n        err = lfs_dir_fetch(lfs, &dir.m, pair);\n        lfs_log(\"lfs_dir_fetch returned err=%d\", err);\n        if (err) {\n            lfs_log(\"lfs_dir_fetch failed err=%d\", err);\n            return err;\n        }\n\n        lfs_log_mdir(\"dir.m\", &dir.m);\n\n        if (dir.m.count > 0 || dir.m.split) {\n            lfs_log(\"directory not empty: count=%llu split=%llu\",\n                    (unsigned long long)dir.m.count,\n                    (unsigned long long)dir.m.split);\n            return LFS_ERR_NOTEMPTY;\n        }\n\n        // mark fs as orphaned\n        err = lfs_fs_preporphans(lfs, +1);\n        lfs_log(\"lfs_fs_preporphans(+1) returned err=%d\", err);\n        if (err) {\n            lfs_log(\"lfs_fs_preporphans(+1) failed err=%d\", err);\n            return err;\n        }\n\n        // I know it's crazy but yes, dir can be changed by our parent's\n        // commit (if predecessor is child)\n        dir.type = 0;\n        dir.id = 0;\n        lfs->mlist = &dir;\n    }\n\n    // delete the entry\n    err = lfs_dir_commit(lfs, &cwd, LFS_MKATTRS(\n            {LFS_MKTAG(LFS_TYPE_DELETE, lfs_tag_id(tag), 0), NULL}));\n    lfs_log(\"lfs_dir_commit delete returned err=%d\", err);\n    if (err) {\n        lfs->mlist = dir.next;\n        lfs_log(\"delete commit failed, restoring mlist and returning err=%d\", err);\n        return err;\n    }\n\n    lfs->mlist = dir.next;\n    lfs_log(\"after delete commit, lfs->mlist restored to %p\", (void *)lfs->mlist);\n    if (lfs_gstate_hasorphans(&lfs->gstate)) {\n        LFS_ASSERT(lfs_tag_type3(tag) == LFS_TYPE_DIR);\n\n        // fix orphan\n        err = lfs_fs_preporphans(lfs, -1);\n        lfs_log(\"lfs_fs_preporphans(-1) returned err=%d\", err);\n        if (err) {\n            lfs_log(\"lfs_fs_preporphans(-1) failed err=%d\", err);\n            return err;\n        }\n\n        /*\n         * Probe: log the exact contents of dir.m.pair and cwd before calling\n         * lfs_fs_pred. This captures the non-const pointer (decayed array)\n         * that is passed to lfs_fs_pred in the original code.\n         */\n        lfs_log(\"About to call lfs_fs_pred: lfs=%p cwd=%p\", (void *)lfs, (void *)&cwd);\n        lfs_log_mdir(\"dir.m\", &dir.m);\n        if (dir.m.pair) {\n            lfs_log(\"Dumping dir.m.pair before lfs_fs_pred:\");\n            lfs_log_pair(dir.m.pair, 2);\n        } else {\n            lfs_log(\"dir.m.pair is NULL before lfs_fs_pred\");\n        }\n\n        err = lfs_fs_pred(lfs, dir.m.pair, &cwd);\n        lfs_log(\"lfs_fs_pred returned err=%d\", err);\n        if (err) {\n            lfs_log(\"lfs_fs_pred failed err=%d\", err);\n            return err;\n        }\n\n        err = lfs_dir_drop(lfs, &cwd, &dir.m);\n        lfs_log(\"lfs_dir_drop returned err=%d\", err);\n        if (err) {\n            lfs_log(\"lfs_dir_drop failed err=%d\", err);\n            return err;\n        }\n    }\n\n    lfs_log(\"EXIT lfs_remove_ success\");\n    return 0;\n}\n"
}