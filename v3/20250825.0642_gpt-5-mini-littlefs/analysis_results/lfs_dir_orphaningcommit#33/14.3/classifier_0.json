{
  "user_message": "<misra_rule>\nMISRA C 2023 Rule 14.3 is: Controlling expressions shall not be invariant.\nHere are exceptions to this rule:\n1. Invariants that are used to create infinite loops are permitted.\n2. A do-while loop with an essentially Boolean controlling expression that evaluates to false and satisfies the constraints and semantics for an integer constant expression is permitted.\n</misra_rule>\n<response format>\nProvide your answer with these fields.\n- is_rule_violated: whether the rule is violated or not (true/false),\n- scenario: a specific violation scenario.\n</response format>\n<target_code>\nHere is the code of lfs_dir_orphaningcommit:\n```c\nstatic int lfs_dir_orphaningcommit(lfs_t *lfs, lfs_mdir_t *dir,\n        const struct lfs_mattr *attrs, int attrcount) {\n    // check for any inline files that aren't RAM backed and\n    // forcefully evict them, needed for filesystem consistency\n    for (lfs_file_t *f = (lfs_file_t*)lfs->mlist; f; f = f->next) {\n        if (dir != &f->m && lfs_pair_cmp(f->m.pair, dir->pair) == 0 &&\n                f->type == LFS_TYPE_REG && (f->flags & LFS_F_INLINE) &&\n                f->ctz.size > lfs->cfg->cache_size) {\n            int err = lfs_file_outline(lfs, f);\n            if (err) {\n                return err;\n            }\n\n            err = lfs_file_flush(lfs, f);\n            if (err) {\n                return err;\n            }\n        }\n    }\n\n    lfs_block_t lpair[2] = {dir->pair[0], dir->pair[1]};\n    lfs_mdir_t ldir = *dir;\n    lfs_mdir_t pdir;\n    int state = lfs_dir_relocatingcommit(lfs, &ldir, dir->pair,\n            attrs, attrcount, &pdir);\n    if (state < 0) {\n        return state;\n    }\n\n    // update if we're not in mlist, note we may have already been\n    // updated if we are in mlist\n    if (lfs_pair_cmp(dir->pair, lpair) == 0) {\n        *dir = ldir;\n    }\n\n    // commit was successful, but may require other changes in the\n    // filesystem, these would normally be tail recursive, but we have\n    // flattened them here avoid unbounded stack usage\n\n    // need to drop?\n    if (state == LFS_OK_DROPPED) {\n        // steal state\n        int err = lfs_dir_getgstate(lfs, dir, &lfs->gdelta);\n        if (err) {\n            return err;\n        }\n\n        // steal tail, note that this can't create a recursive drop\n        lpair[0] = pdir.pair[0];\n        lpair[1] = pdir.pair[1];\n        lfs_pair_tole32(dir->tail);\n        state = lfs_dir_relocatingcommit(lfs, &pdir, lpair, LFS_MKATTRS(\n                    {LFS_MKTAG(LFS_TYPE_TAIL + dir->split, 0x3ff, 8),\n                        dir->tail}),\n                NULL);\n        lfs_pair_fromle32(dir->tail);\n        if (state < 0) {\n            return state;\n        }\n\n        ldir = pdir;\n    }\n\n    // need to relocate?\n    bool orphans = false;\n    while (state == LFS_OK_RELOCATED) {\n        LFS_DEBUG(\"Relocating {0x%\"PRIx32\", 0x%\"PRIx32\"} \"\n                    \"-> {0x%\"PRIx32\", 0x%\"PRIx32\"}\",\n                lpair[0], lpair[1], ldir.pair[0], ldir.pair[1]);\n        state = 0;\n\n        // update internal root\n        if (lfs_pair_cmp(lpair, lfs->root) == 0) {\n            lfs->root[0] = ldir.pair[0];\n            lfs->root[1] = ldir.pair[1];\n        }\n\n        // update internally tracked dirs\n        for (struct lfs_mlist *d = lfs->mlist; d; d = d->next) {\n            if (lfs_pair_cmp(lpair, d->m.pair) == 0) {\n                d->m.pair[0] = ldir.pair[0];\n                d->m.pair[1] = ldir.pair[1];\n            }\n\n            if (d->type == LFS_TYPE_DIR &&\n                    lfs_pair_cmp(lpair, ((lfs_dir_t*)d)->head) == 0) {\n                ((lfs_dir_t*)d)->head[0] = ldir.pair[0];\n                ((lfs_dir_t*)d)->head[1] = ldir.pair[1];\n            }\n        }\n\n        // find parent\n        lfs_stag_t tag = lfs_fs_parent(lfs, lpair, &pdir);\n        if (tag < 0 && tag != LFS_ERR_NOENT) {\n            return tag;\n        }\n\n        bool hasparent = (tag != LFS_ERR_NOENT);\n        if (tag != LFS_ERR_NOENT) {\n            // note that if we have a parent, we must have a pred, so this will\n            // always create an orphan\n            int err = lfs_fs_preporphans(lfs, +1);\n            if (err) {\n                return err;\n            }\n\n            // fix pending move in this pair? this looks like an optimization but\n            // is in fact _required_ since relocating may outdate the move.\n            uint16_t moveid = 0x3ff;\n            if (lfs_gstate_hasmovehere(&lfs->gstate, pdir.pair)) {\n                moveid = lfs_tag_id(lfs->gstate.tag);\n                LFS_DEBUG(\"Fixing move while relocating \"\n                        \"{0x%\"PRIx32\", 0x%\"PRIx32\"} 0x%\"PRIx16\"\\n\",\n                        pdir.pair[0], pdir.pair[1], moveid);\n                lfs_fs_prepmove(lfs, 0x3ff, NULL);\n                if (moveid < lfs_tag_id(tag)) {\n                    tag -= LFS_MKTAG(0, 1, 0);\n                }\n            }\n\n            lfs_block_t ppair[2] = {pdir.pair[0], pdir.pair[1]};\n            lfs_pair_tole32(ldir.pair);\n            state = lfs_dir_relocatingcommit(lfs, &pdir, ppair, LFS_MKATTRS(\n                        {LFS_MKTAG_IF(moveid != 0x3ff,\n                            LFS_TYPE_DELETE, moveid, 0), NULL},\n                        {tag, ldir.pair}),\n                    NULL);\n            lfs_pair_fromle32(ldir.pair);\n            if (state < 0) {\n                return state;\n            }\n\n            if (state == LFS_OK_RELOCATED) {\n                lpair[0] = ppair[0];\n                lpair[1] = ppair[1];\n                ldir = pdir;\n                orphans = true;\n                continue;\n            }\n        }\n\n        // find pred\n        int err = lfs_fs_pred(lfs, lpair, &pdir);\n        if (err && err != LFS_ERR_NOENT) {\n            return err;\n        }\n        LFS_ASSERT(!(hasparent && err == LFS_ERR_NOENT));\n\n        // if we can't find dir, it must be new\n        if (err != LFS_ERR_NOENT) {\n            if (lfs_gstate_hasorphans(&lfs->gstate)) {\n                // next step, clean up orphans\n                err = lfs_fs_preporphans(lfs, -(int8_t)hasparent);\n                if (err) {\n                    return err;\n                }\n            }\n\n            // fix pending move in this pair? this looks like an optimization\n            // but is in fact _required_ since relocating may outdate the move.\n            uint16_t moveid = 0x3ff;\n            if (lfs_gstate_hasmovehere(&lfs->gstate, pdir.pair)) {\n                moveid = lfs_tag_id(lfs->gstate.tag);\n                LFS_DEBUG(\"Fixing move while relocating \"\n                        \"{0x%\"PRIx32\", 0x%\"PRIx32\"} 0x%\"PRIx16\"\\n\",\n                        pdir.pair[0], pdir.pair[1], moveid);\n                lfs_fs_prepmove(lfs, 0x3ff, NULL);\n            }\n\n            // replace bad pair, either we clean up desync, or no desync occured\n            lpair[0] = pdir.pair[0];\n            lpair[1] = pdir.pair[1];\n            lfs_pair_tole32(ldir.pair);\n            state = lfs_dir_relocatingcommit(lfs, &pdir, lpair, LFS_MKATTRS(\n                        {LFS_MKTAG_IF(moveid != 0x3ff,\n                            LFS_TYPE_DELETE, moveid, 0), NULL},\n                        {LFS_MKTAG(LFS_TYPE_TAIL + pdir.split, 0x3ff, 8),\n                            ldir.pair}),\n                    NULL);\n            lfs_pair_fromle32(ldir.pair);\n            if (state < 0) {\n                return state;\n            }\n\n            ldir = pdir;\n        }\n    }\n\n    return orphans ? LFS_OK_ORPHANED : 0;\n}\n```\n</target_code>\n<additional code>Here are the definitions of symbols that are close to the target function lfs_dir_orphaningcommit:\nstatic int lfs_file_relocate(lfs_t *lfs, lfs_file_t *file) {\n    while (true) {\n        // just relocate what exists into new block\n        lfs_block_t nblock;\n        int err = lfs_alloc(lfs, &nblock);\n        if (err) {\n            return err;\n        }\n\n        err = lfs_bd_erase(lfs, nblock);\n        if (err) {\n            if (err == LFS_ERR_CORRUPT) {\n                goto relocate;\n            }\n            return err;\n        }\n\n        // either read from dirty cache or disk\n        for (lfs_off_t i = 0; i < file->off; i++) {\n            uint8_t data;\n            if (file->flags & LFS_F_INLINE) {\n                err = lfs_dir_getread(lfs, &file->m,\n                        // note we evict inline files before they can be dirty\n                        NULL, &file->cache, file->off-i,\n                        LFS_MKTAG(0xfff, 0x1ff, 0),\n                        LFS_MKTAG(LFS_TYPE_INLINESTRUCT, file->id, 0),\n                        i, &data, 1);\n                if (err) {\n                    return err;\n                }\n            } else {\n                err = lfs_bd_read(lfs,\n                        &file->cache, &lfs->rcache, file->off-i,\n                        file->block, i, &data, 1);\n                if (err) {\n                    return err;\n                }\n            }\n\n            err = lfs_bd_prog(lfs,\n                    &lfs->pcache, &lfs->rcache, true,\n                    nblock, i, &data, 1);\n            if (err) {\n                if (err == LFS_ERR_CORRUPT) {\n                    goto relocate;\n                }\n                return err;\n            }\n        }\n\n        // copy over new state of file\n        memcpy(file->cache.buffer, lfs->pcache.buffer, lfs->cfg->cache_size);\n        file->cache.block = lfs->pcache.block;\n        file->cache.off = lfs->pcache.off;\n        file->cache.size = lfs->pcache.size;\n        lfs_cache_zero(lfs, &lfs->pcache);\n\n        file->block = nblock;\n        file->flags |= LFS_F_WRITING;\n        return 0;\n\nrelocate:\n        LFS_DEBUG(\"Bad block at 0x%\"PRIx32, nblock);\n\n        // just clear cache and try a new block\n        lfs_cache_drop(lfs, &lfs->pcache);\n    }\n}\n...\nstatic void lfs_alloc_ckpoint(lfs_t *lfs) {\n    lfs->lookahead.ckpoint = lfs->block_count;\n}\n...\nstatic inline void lfs_cache_drop(lfs_t *lfs, lfs_cache_t *rcache) {\n    // do not zero, cheaper if cache is readonly or only going to be\n    // written with identical data (during relocates)\n    (void)lfs;\n    rcache->block = LFS_BLOCK_NULL;\n}\n</additional code>\n<target_code>\nHere is the code fragment that you need to analyze:\n```c\nwhile (true) {\n```\nFocus on the above code fragment and judge whether it violates the rule 14.3 or not.\n</target_code>\n",
  "is_rule_violated": false,
  "scenario": "The controlling expression while (true) is invariant, but it is used to create an intentional infinite loop (exiting via returns/goto). This matches exception 1 (invariants that are used to create infinite loops are permitted), so no MISRA Rule 14.3 violation."
}