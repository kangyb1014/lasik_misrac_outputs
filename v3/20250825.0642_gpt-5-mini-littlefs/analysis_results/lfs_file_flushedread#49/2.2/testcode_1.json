{
  "user_message": "<misra_rule>\nMISRA C 2023 Rule 2.2 is: A project shall not contain dead code.\nAny operation that is executed but whose removal would not affect program behaviour constitutes dead code. Notes:\n1. The behaviour of an embedded sytem is often determined not just by the nature of its actions, but also by the time at which they occur.\n2. unreachable code is not dead code, as it cannot be executed.\n3.Initialization is not the same as an assignment operation and is therfore not a candidate for dead code.\n</misra_rule>\n\nAnother agent reported that the target code violated the Rule 2.2.\nHere is the comment from the agent.\n<violation scenario>\nThe assignment head = lfs_fromle32(head) is executed unconditionally immediately after lfs_bd_read, but if lfs_bd_read returns an error the function immediately returns err. In that error case the conversion has no effect on observable behaviour (and may even read an uninitialized value), so it is an operation that can be removed without changing program behaviour. The conversion should be performed only after confirming err == 0 (i.e. move the err check before the endian conversion).\n</violation scenario>\n\nYour job is to insert logging code to capture the control flow and state information of the program.\nInsert logging code so that other agents can reproduce and get evidence for the violation scenario.\n<response format>\n- test_code: a modified lfs_file_flushedread code that contains useful probe functions that print useful logs to a file \"/tmp/logs/492.txt\". The logs should contain the control path and state information of the violation scenario. If test code is not required to validate the scenario, you can leave this blank.\nHere are the constraints for the test code:\n- The test code MUST preserve the original logic of lfs_file_flushedread as much as possible.\nYou CAN just insert probe functions to the original code.\n- DO NOT introduce new violations to demonstrate your scenario.\n- The test code MUST be compilable and executable.\n- The test code MUST include line breaks.\n- You MUST NOT define the main function.\n- You MUST NOT define macros.\n</response format>\n<target_code>\nHere is the code of lfs_file_flushedread:\n```c\nstatic lfs_ssize_t lfs_file_flushedread(lfs_t *lfs, lfs_file_t *file,\n        void *buffer, lfs_size_t size) {\n    uint8_t *data = buffer;\n    lfs_size_t nsize = size;\n\n    if (file->pos >= file->ctz.size) {\n        // eof if past end\n        return 0;\n    }\n\n    size = lfs_min(size, file->ctz.size - file->pos);\n    nsize = size;\n\n    while (nsize > 0) {\n        // check if we need a new block\n        if (!(file->flags & LFS_F_READING) ||\n                file->off == lfs->cfg->block_size) {\n            if (!(file->flags & LFS_F_INLINE)) {\n                int err = lfs_ctz_find(lfs, NULL, &file->cache,\n                        file->ctz.head, file->ctz.size,\n                        file->pos, &file->block, &file->off);\n                if (err) {\n                    return err;\n                }\n            } else {\n                file->block = LFS_BLOCK_INLINE;\n                file->off = file->pos;\n            }\n\n            file->flags |= LFS_F_READING;\n        }\n\n        // read as much as we can in current block\n        lfs_size_t diff = lfs_min(nsize, lfs->cfg->block_size - file->off);\n        if (file->flags & LFS_F_INLINE) {\n            int err = lfs_dir_getread(lfs, &file->m,\n                    NULL, &file->cache, lfs->cfg->block_size,\n                    LFS_MKTAG(0xfff, 0x1ff, 0),\n                    LFS_MKTAG(LFS_TYPE_INLINESTRUCT, file->id, 0),\n                    file->off, data, diff);\n            if (err) {\n                return err;\n            }\n        } else {\n            int err = lfs_bd_read(lfs,\n                    NULL, &file->cache, lfs->cfg->block_size,\n                    file->block, file->off, data, diff);\n            if (err) {\n                return err;\n            }\n        }\n\n        file->pos += diff;\n        file->off += diff;\n        data += diff;\n        nsize -= diff;\n    }\n\n    return size;\n}\n```\n</target_code>\nPlease provide the modified lfs_file_flushedread code.\n",
  "test_code": "#include <stdio.h>\n#include <stdint.h>\n\nstatic lfs_ssize_t lfs_file_flushedread(lfs_t *lfs, lfs_file_t *file,\n        void *buffer, lfs_size_t size) {\n    uint8_t *data = buffer;\n    lfs_size_t nsize = size;\n\n    /* Probe: log entry into function with key state */\n    {\n        FILE *f = fopen(\"/tmp/logs/492.txt\", \"a\");\n        if (f) {\n            fprintf(f, \"ENTER lfs_file_flushedread: file=%p id=%llu pos=%llu ctz_head=%llu ctz_size=%llu req_size=%llu\\n\",\n                    (void*)file,\n                    (unsigned long long)file->id,\n                    (unsigned long long)file->pos,\n                    (unsigned long long)file->ctz.head,\n                    (unsigned long long)file->ctz.size,\n                    (unsigned long long)size);\n            fclose(f);\n        }\n    }\n\n    if (file->pos >= file->ctz.size) {\n        // eof if past end\n        {\n            FILE *f = fopen(\"/tmp/logs/492.txt\", \"a\");\n            if (f) {\n                fprintf(f, \"RETURN EOF: pos=%llu >= ctz.size=%llu\\n\",\n                        (unsigned long long)file->pos,\n                        (unsigned long long)file->ctz.size);\n                fclose(f);\n            }\n        }\n        return 0;\n    }\n\n    size = lfs_min(size, file->ctz.size - file->pos);\n    nsize = size;\n\n    while (nsize > 0) {\n        // check if we need a new block\n        if (!(file->flags & LFS_F_READING) ||\n                file->off == lfs->cfg->block_size) {\n            if (!(file->flags & LFS_F_INLINE)) {\n                /* Probe: about to call lfs_ctz_find - log parameters */\n                {\n                    FILE *f = fopen(\"/tmp/logs/492.txt\", \"a\");\n                    if (f) {\n                        fprintf(f, \"CTZ_FIND_CALL: file=%p head=%llu size=%llu pos=%llu\\n\",\n                                (void*)file,\n                                (unsigned long long)file->ctz.head,\n                                (unsigned long long)file->ctz.size,\n                                (unsigned long long)file->pos);\n                        fclose(f);\n                    }\n                }\n\n                int err = lfs_ctz_find(lfs, NULL, &file->cache,\n                        file->ctz.head, file->ctz.size,\n                        file->pos, &file->block, &file->off);\n                if (err) {\n                    /* Probe: log error from lfs_ctz_find and return */\n                    FILE *f = fopen(\"/tmp/logs/492.txt\", \"a\");\n                    if (f) {\n                        fprintf(f, \"CTZ_FIND_ERROR: err=%d file=%p id=%llu pos=%llu\\n\",\n                                err, (void*)file,\n                                (unsigned long long)file->id,\n                                (unsigned long long)file->pos);\n                        fclose(f);\n                    }\n                    return err;\n                }\n            } else {\n                file->block = LFS_BLOCK_INLINE;\n                file->off = file->pos;\n\n                /* Probe: inline selection logged */\n                FILE *f = fopen(\"/tmp/logs/492.txt\", \"a\");\n                if (f) {\n                    fprintf(f, \"INLINE_SELECT: file=%p id=%llu pos=%llu off=%llu\\n\",\n                            (void*)file,\n                            (unsigned long long)file->id,\n                            (unsigned long long)file->pos,\n                            (unsigned long long)file->off);\n                    fclose(f);\n                }\n            }\n\n            file->flags |= LFS_F_READING;\n        }\n\n        // read as much as we can in current block\n        lfs_size_t diff = lfs_min(nsize, lfs->cfg->block_size - file->off);\n        if (file->flags & LFS_F_INLINE) {\n            /* Probe: before inline read */\n            {\n                FILE *f = fopen(\"/tmp/logs/492.txt\", \"a\");\n                if (f) {\n                    fprintf(f, \"INLINE_READ_START: file=%p id=%llu block=%llu off=%llu diff=%llu head=%llu\\n\",\n                            (void*)file,\n                            (unsigned long long)file->id,\n                            (unsigned long long)file->block,\n                            (unsigned long long)file->off,\n                            (unsigned long long)diff,\n                            (unsigned long long)file->ctz.head);\n                    fclose(f);\n                }\n            }\n\n            int err = lfs_dir_getread(lfs, &file->m,\n                    NULL, &file->cache, lfs->cfg->block_size,\n                    LFS_MKTAG(0xfff, 0x1ff, 0),\n                    LFS_MKTAG(LFS_TYPE_INLINESTRUCT, file->id, 0),\n                    file->off, data, diff);\n            if (err) {\n                /* Probe: inline read error */\n                FILE *f = fopen(\"/tmp/logs/492.txt\", \"a\");\n                if (f) {\n                    fprintf(f, \"INLINE_READ_ERROR: err=%d file=%p id=%llu pos=%llu off=%llu head=%llu\\n\",\n                            err, (void*)file,\n                            (unsigned long long)file->id,\n                            (unsigned long long)file->pos,\n                            (unsigned long long)file->off,\n                            (unsigned long long)file->ctz.head);\n                    fclose(f);\n                }\n                return err;\n            }\n        } else {\n            /* Probe: before block-device read - capture pre-read state including ctz.head */\n            {\n                FILE *f = fopen(\"/tmp/logs/492.txt\", \"a\");\n                if (f) {\n                    fprintf(f, \"BD_READ_START: file=%p id=%llu block=%llu off=%llu diff=%llu pos=%llu ctz_head=%llu\\n\",\n                            (void*)file,\n                            (unsigned long long)file->id,\n                            (unsigned long long)file->block,\n                            (unsigned long long)file->off,\n                            (unsigned long long)diff,\n                            (unsigned long long)file->pos,\n                            (unsigned long long)file->ctz.head);\n                    fclose(f);\n                }\n            }\n\n            int err = lfs_bd_read(lfs,\n                    NULL, &file->cache, lfs->cfg->block_size,\n                    file->block, file->off, data, diff);\n            if (err) {\n                /* Probe: log BD read error and the pre-read ctz.head and other state\n                   This helps reproduce the scenario where an operation performed\n                   unconditionally would have no effect after an error return. */\n                FILE *f = fopen(\"/tmp/logs/492.txt\", \"a\");\n                if (f) {\n                    fprintf(f, \"BD_READ_ERROR: err=%d file=%p id=%llu block=%llu off=%llu pos=%llu pre_ctz_head=%llu\\n\",\n                            err, (void*)file,\n                            (unsigned long long)file->id,\n                            (unsigned long long)file->block,\n                            (unsigned long long)file->off,\n                            (unsigned long long)file->pos,\n                            (unsigned long long)file->ctz.head);\n                    fclose(f);\n                }\n                return err;\n            }\n\n            /* Probe: successful BD read */\n            {\n                FILE *f = fopen(\"/tmp/logs/492.txt\", \"a\");\n                if (f) {\n                    fprintf(f, \"BD_READ_OK: file=%p id=%llu block=%llu off=%llu diff=%llu pos=%llu post_ctz_head=%llu\\n\",\n                            (void*)file,\n                            (unsigned long long)file->id,\n                            (unsigned long long)file->block,\n                            (unsigned long long)file->off,\n                            (unsigned long long)diff,\n                            (unsigned long long)file->pos,\n                            (unsigned long long)file->ctz.head);\n                    fclose(f);\n                }\n            }\n        }\n\n        file->pos += diff;\n        file->off += diff;\n        data += diff;\n        nsize -= diff;\n\n        /* Probe: loop progress */\n        {\n            FILE *f = fopen(\"/tmp/logs/492.txt\", \"a\");\n            if (f) {\n                fprintf(f, \"LOOP_PROGRESS: file=%p id=%llu new_pos=%llu new_off=%llu remaining=%llu\\n\",\n                        (void*)file,\n                        (unsigned long long)file->id,\n                        (unsigned long long)file->pos,\n                        (unsigned long long)file->off,\n                        (unsigned long long)nsize);\n                fclose(f);\n            }\n        }\n    }\n\n    /* Probe: successful return */\n    {\n        FILE *f = fopen(\"/tmp/logs/492.txt\", \"a\");\n        if (f) {\n            fprintf(f, \"RETURN_OK: file=%p id=%llu returned_size=%llu\\n\",\n                    (void*)file,\n                    (unsigned long long)file->id,\n                    (unsigned long long)size);\n            fclose(f);\n        }\n    }\n\n    return size;\n}\n"
}