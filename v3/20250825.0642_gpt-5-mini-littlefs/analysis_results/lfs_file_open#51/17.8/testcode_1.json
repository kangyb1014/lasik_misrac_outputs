{
  "user_message": "<misra_rule>\nMISRA C 2023 Rule 17.8 is: A function parameter should not be modified.\nNote that the object referred to by a pointer parameter may be modified, but the pointer itself shall not be modified.\n</misra_rule>\n\nAnother agent reported that the target code violated the Rule 17.8.\nHere is the comment from the agent.\n<violation scenario>\nThe call passes the address of the parameter 'path' (const char *path) to lfs_dir_find: lfs_stag_t tag = lfs_dir_find(lfs, &file->m, &path, &file->id); lfs_dir_find is expected to update the pointer (const char **) to advance through the path, which modifies the function parameter 'path' itself. This violates MISRA C 2023 Rule 17.8 (a function parameter shall not be modified).\n</violation scenario>\n\nYour job is to insert logging code to capture the control flow and state information of the program.\nInsert logging code so that other agents can reproduce and get evidence for the violation scenario.\n<response format>\n- test_code: a modified lfs_file_open code that contains useful probe functions that print useful logs to a file \"/tmp/logs/517.txt\". The logs should contain the control path and state information of the violation scenario. If test code is not required to validate the scenario, you can leave this blank.\nHere are the constraints for the test code:\n- The test code MUST preserve the original logic of lfs_file_open as much as possible.\nYou CAN just insert probe functions to the original code.\n- DO NOT introduce new violations to demonstrate your scenario.\n- The test code MUST be compilable and executable.\n- The test code MUST include line breaks.\n- You MUST NOT define the main function.\n- You MUST NOT define macros.\n</response format>\n<target_code>\nHere is the code of lfs_file_open:\n```c\nint lfs_file_open(lfs_t *lfs, lfs_file_t *file, const char *path, int flags) {\n    int err = LFS_LOCK(lfs->cfg);\n    if (err) {\n        return err;\n    }\n    LFS_TRACE(\"lfs_file_open(%p, %p, \\\"%s\\\", %x)\",\n            (void*)lfs, (void*)file, path, (unsigned)flags);\n    LFS_ASSERT(!lfs_mlist_isopen(lfs->mlist, (struct lfs_mlist*)file));\n\n    err = lfs_file_open_(lfs, file, path, flags);\n\n    LFS_TRACE(\"lfs_file_open -> %d\", err);\n    LFS_UNLOCK(lfs->cfg);\n    return err;\n}\n```\n</target_code>\nPlease provide the modified lfs_file_open code.\n",
  "test_code": "#include <stdio.h>\n#include <stdarg.h>\n#include <string.h>\n\n/*\n * Probe logger for violation investigation. Appends human-readable\n * trace messages to /tmp/logs/517.txt. Kept minimal and non-intrusive.\n *\n * This file is intended to be inserted alongside the original code.\n */\nstatic void lfs_probe_log(const char *fmt, ...)\n{\n    FILE *f = fopen(\"/tmp/logs/517.txt\", \"a\");\n    if (f == NULL) {\n        return;\n    }\n\n    va_list ap;\n    va_start(ap, fmt);\n    vfprintf(f, fmt, ap);\n    va_end(ap);\n\n    fputc('\\n', f);\n    fclose(f);\n}\n\nint lfs_file_open(lfs_t *lfs, lfs_file_t *file, const char *path, int flags) {\n    int err = LFS_LOCK(lfs->cfg);\n    if (err) {\n        /* Log lock failure early so the control path is reproducible */\n        lfs_probe_log(\"lfs_file_open: LFS_LOCK failed -> %d (lfs=%p, file=%p)\",\n                      err, (void*)lfs, (void*)file);\n        return err;\n    }\n\n    /* Original tracing preserved */\n    LFS_TRACE(\"lfs_file_open(%p, %p, \\\"%s\\\", %x)\",\n            (void*)lfs, (void*)file, path, (unsigned)flags);\n\n    /* Additional probes: record the incoming parameter state and addresses.\n     * These help demonstrate whether the pointer itself is being modified\n     * later in the call chain (other functions can print matching addresses).\n     */\n    lfs_probe_log(\"ENTRY: lfs_file_open called (lfs=%p, file=%p, flags=0x%X)\",\n                  (void*)lfs, (void*)file, (unsigned)flags);\n\n    /* log the path pointer value and a truncated copy of the path string */\n    if (path != NULL) {\n        char buf[256];\n        /* strncpy used only to safely copy up to sizeof(buf)-1 chars */\n        strncpy(buf, path, sizeof(buf) - 1);\n        buf[sizeof(buf) - 1] = '\\0';\n        lfs_probe_log(\"ENTRY: path ptr=%p, path_str=\\\"%s\\\"\",\n                      (const void*)path, buf);\n    } else {\n        lfs_probe_log(\"ENTRY: path ptr=NULL\");\n    }\n\n    /* Log address of the parameter variable 'path' within this stack frame.\n     * If other functions also log the address they receive for their 'path'\n     * parameter, the matching addresses help identify where a pointer-to-\n     * pointer may have been used to mutate a parameter in violation of\n     * MISRA C Rule 17.8.\n     */\n    lfs_probe_log(\"ENTRY: address of parameter 'path' (this frame) = %p\", (void*)&path);\n\n    /* Log the address of file->m which the other agent mentioned is passed\n     * by address further down the call chain. This provides correlation\n     * between calls when reading the probe log.\n     */\n    lfs_probe_log(\"ENTRY: file pointer=%p, &file->m=%p\", (void*)file, (void*)&file->m);\n\n    LFS_ASSERT(!lfs_mlist_isopen(lfs->mlist, (struct lfs_mlist*)file));\n\n    /* Capture the pointer value before calling the internal helper so we\n     * can detect any unexpected modification to this parameter after the\n     * call returns (helpful for reproducing the reported violation).\n     */\n    const char *path_before = path;\n\n    err = lfs_file_open_(lfs, file, path, flags);\n\n    /* Capture after-call state and report differences */\n    lfs_probe_log(\"RETURN: lfs_file_open_ returned %d\", err);\n\n    if (path_before != path) {\n        /* If this ever prints, it indicates the pointer value of the\n         * parameter 'path' in this frame changed across the call to\n         * lfs_file_open_. That is suspicious and useful evidence.\n         */\n        lfs_probe_log(\"ALERT: path pointer changed during call: before=%p, after=%p\",\n                      (const void*)path_before, (const void*)path);\n\n        /* Also log current pointed string (if any) */\n        if (path != NULL) {\n            char buf2[256];\n            strncpy(buf2, path, sizeof(buf2) - 1);\n            buf2[sizeof(buf2) - 1] = '\\0';\n            lfs_probe_log(\"ALERT: new path_str=\\\"%s\\\" (after call)\", buf2);\n        } else {\n            lfs_probe_log(\"ALERT: new path_str=NULL (after call)\");\n        }\n    } else {\n        lfs_probe_log(\"OK: path pointer unchanged across lfs_file_open_ call: %p\", (const void*)path);\n    }\n\n    LFS_TRACE(\"lfs_file_open -> %d\", err);\n    LFS_UNLOCK(lfs->cfg);\n    return err;\n}\n"
}