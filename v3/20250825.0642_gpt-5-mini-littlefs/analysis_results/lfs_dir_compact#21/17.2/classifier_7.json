{
  "user_message": "<misra_rule>\nMISRA C 2023 Rule 17.2 is: Functions shall not call themselves, either directly or indirectly.\n\n</misra_rule>\n<response format>\nProvide your answer with these fields.\n- is_rule_violated: whether the rule is violated or not (true/false),\n- scenario: a specific violation scenario.\n</response format>\n<target_code>\nHere is the code of lfs_dir_compact:\n```c\nstatic int lfs_dir_compact(lfs_t *lfs,\n        lfs_mdir_t *dir, const struct lfs_mattr *attrs, int attrcount,\n        lfs_mdir_t *source, uint16_t begin, uint16_t end) {\n    // save some state in case block is bad\n    bool relocated = false;\n    bool tired = lfs_dir_needsrelocation(lfs, dir);\n\n    // increment revision count\n    dir->rev += 1;\n\n    // do not proactively relocate blocks during migrations, this\n    // can cause a number of failure states such: clobbering the\n    // v1 superblock if we relocate root, and invalidating directory\n    // pointers if we relocate the head of a directory. On top of\n    // this, relocations increase the overall complexity of\n    // lfs_migration, which is already a delicate operation.\n#ifdef LFS_MIGRATE\n    if (lfs->lfs1) {\n        tired = false;\n    }\n#endif\n\n    if (tired && lfs_pair_cmp(dir->pair, (const lfs_block_t[2]){0, 1}) != 0) {\n        // we're writing too much, time to relocate\n        goto relocate;\n    }\n\n    // begin loop to commit compaction to blocks until a compact sticks\n    while (true) {\n        {\n            // setup commit state\n            struct lfs_commit commit = {\n                .block = dir->pair[1],\n                .off = 0,\n                .ptag = 0xffffffff,\n                .crc = 0xffffffff,\n\n                .begin = 0,\n                .end = (lfs->cfg->metadata_max ?\n                    lfs->cfg->metadata_max : lfs->cfg->block_size) - 8,\n            };\n\n            // erase block to write to\n            int err = lfs_bd_erase(lfs, dir->pair[1]);\n            if (err) {\n                if (err == LFS_ERR_CORRUPT) {\n                    goto relocate;\n                }\n                return err;\n            }\n\n            // write out header\n            dir->rev = lfs_tole32(dir->rev);\n            err = lfs_dir_commitprog(lfs, &commit,\n                    &dir->rev, sizeof(dir->rev));\n            dir->rev = lfs_fromle32(dir->rev);\n            if (err) {\n                if (err == LFS_ERR_CORRUPT) {\n                    goto relocate;\n                }\n                return err;\n            }\n\n            // traverse the directory, this time writing out all unique tags\n            err = lfs_dir_traverse(lfs,\n                    source, 0, 0xffffffff, attrs, attrcount,\n                    LFS_MKTAG(0x400, 0x3ff, 0),\n                    LFS_MKTAG(LFS_TYPE_NAME, 0, 0),\n                    begin, end, -begin,\n                    lfs_dir_commit_commit, &(struct lfs_dir_commit_commit){\n                        lfs, &commit});\n            if (err) {\n                if (err == LFS_ERR_CORRUPT) {\n                    goto relocate;\n                }\n                return err;\n            }\n\n            // commit tail, which may be new after last size check\n            if (!lfs_pair_isnull(dir->tail)) {\n                lfs_pair_tole32(dir->tail);\n                err = lfs_dir_commitattr(lfs, &commit,\n                        LFS_MKTAG(LFS_TYPE_TAIL + dir->split, 0x3ff, 8),\n                        dir->tail);\n                lfs_pair_fromle32(dir->tail);\n                if (err) {\n                    if (err == LFS_ERR_CORRUPT) {\n                        goto relocate;\n                    }\n                    return err;\n                }\n            }\n\n            // bring over gstate?\n            lfs_gstate_t delta = {0};\n            if (!relocated) {\n                lfs_gstate_xor(&delta, &lfs->gdisk);\n                lfs_gstate_xor(&delta, &lfs->gstate);\n            }\n            lfs_gstate_xor(&delta, &lfs->gdelta);\n            delta.tag &= ~LFS_MKTAG(0, 0, 0x3ff);\n\n            err = lfs_dir_getgstate(lfs, dir, &delta);\n            if (err) {\n                return err;\n            }\n\n            if (!lfs_gstate_iszero(&delta)) {\n                lfs_gstate_tole32(&delta);\n                err = lfs_dir_commitattr(lfs, &commit,\n                        LFS_MKTAG(LFS_TYPE_MOVESTATE, 0x3ff,\n                            sizeof(delta)), &delta);\n                if (err) {\n                    if (err == LFS_ERR_CORRUPT) {\n                        goto relocate;\n                    }\n                    return err;\n                }\n            }\n\n            // complete commit with crc\n            err = lfs_dir_commitcrc(lfs, &commit);\n            if (err) {\n                if (err == LFS_ERR_CORRUPT) {\n                    goto relocate;\n                }\n                return err;\n            }\n\n            // successful compaction, swap dir pair to indicate most recent\n            LFS_ASSERT(commit.off % lfs->cfg->prog_size == 0);\n            lfs_pair_swap(dir->pair);\n            dir->count = end - begin;\n            dir->off = commit.off;\n            dir->etag = commit.ptag;\n            // update gstate\n            lfs->gdelta = (lfs_gstate_t){0};\n            if (!relocated) {\n                lfs->gdisk = lfs->gstate;\n            }\n        }\n        break;\n\nrelocate:\n        // commit was corrupted, drop caches and prepare to relocate block\n        relocated = true;\n        lfs_cache_drop(lfs, &lfs->pcache);\n        if (!tired) {\n            LFS_DEBUG(\"Bad block at 0x%\"PRIx32, dir->pair[1]);\n        }\n\n        // can't relocate superblock, filesystem is now frozen\n        if (lfs_pair_cmp(dir->pair, (const lfs_block_t[2]){0, 1}) == 0) {\n            LFS_WARN(\"Superblock 0x%\"PRIx32\" has become unwritable\",\n                    dir->pair[1]);\n            return LFS_ERR_NOSPC;\n        }\n\n        // relocate half of pair\n        int err = lfs_alloc(lfs, &dir->pair[1]);\n        if (err && (err != LFS_ERR_NOSPC || !tired)) {\n            return err;\n        }\n\n        tired = false;\n        continue;\n    }\n\n    return relocated ? LFS_OK_RELOCATED : 0;\n}\n```\n</target_code>\n<additional code>Here are the definitions of symbols that are close to the target function lfs_dir_compact:\nstatic bool lfs_dir_needsrelocation(lfs_t *lfs, lfs_mdir_t *dir) {\n    // If our revision count == n * block_cycles, we should force a relocation,\n    // this is how littlefs wear-levels at the metadata-pair level. Note that we\n    // actually use (block_cycles+1)|1, this is to avoid two corner cases:\n    // 1. block_cycles = 1, which would prevent relocations from terminating\n    // 2. block_cycles = 2n, which, due to aliasing, would only ever relocate\n    //    one metadata block in the pair, effectively making this useless\n    return (lfs->cfg->block_cycles > 0\n            && ((dir->rev + 1) % ((lfs->cfg->block_cycles+1)|1) == 0));\n}\n...\nstatic inline int lfs_pair_cmp(\n        const lfs_block_t paira[2],\n        const lfs_block_t pairb[2]) {\n    return !(paira[0] == pairb[0] || paira[1] == pairb[1] ||\n             paira[0] == pairb[1] || paira[1] == pairb[0]);\n}\n...\nstatic int lfs_bd_erase(lfs_t *lfs, lfs_block_t block) {\n    LFS_ASSERT(block < lfs->block_count);\n    int err = lfs->cfg->erase(lfs->cfg, block);\n    LFS_ASSERT(err <= 0);\n    return err;\n}\n...\nstatic int lfs_dir_commitprog(lfs_t *lfs, struct lfs_commit *commit,\n        const void *buffer, lfs_size_t size) {\n    int err = lfs_bd_prog(lfs,\n            &lfs->pcache, &lfs->rcache, false,\n            commit->block, commit->off ,\n            (const uint8_t*)buffer, size);\n    if (err) {\n        return err;\n    }\n\n    commit->crc = lfs_crc(commit->crc, buffer, size);\n    commit->off += size;\n    return 0;\n}\n...\nstatic int lfs_dir_traverse(lfs_t *lfs,\n        const lfs_mdir_t *dir, lfs_off_t off, lfs_tag_t ptag,\n        const struct lfs_mattr *attrs, int attrcount,\n        lfs_tag_t tmask, lfs_tag_t ttag,\n        uint16_t begin, uint16_t end, int16_t diff,\n        int (*cb)(void *data, lfs_tag_t tag, const void *buffer), void *data) {\n    // This function in inherently recursive, but bounded. To allow tool-based\n    // analysis without unnecessary code-cost we use an explicit stack\n    struct lfs_dir_traverse stack[LFS_DIR_TRAVERSE_DEPTH-1];\n    unsigned sp = 0;\n    int res;\n\n    // iterate over directory and attrs\n    lfs_tag_t tag;\n    const void *buffer;\n    struct lfs_diskoff disk = {0};\n    while (true) {\n        {\n            if (off+lfs_tag_dsize(ptag) < dir->off) {\n                off += lfs_tag_dsize(ptag);\n                int err = lfs_bd_read(lfs,\n                        NULL, &lfs->rcache, sizeof(tag),\n                        dir->pair[0], off, &tag, sizeof(tag));\n                if (err) {\n                    return err;\n                }\n\n                tag = (lfs_frombe32(tag) ^ ptag) | 0x80000000;\n                disk.block = dir->pair[0];\n                disk.off = off+sizeof(lfs_tag_t);\n                buffer = &disk;\n                ptag = tag;\n            } else if (attrcount > 0) {\n                tag = attrs[0].tag;\n                buffer = attrs[0].buffer;\n                attrs += 1;\n                attrcount -= 1;\n            } else {\n                // finished traversal, pop from stack?\n                res = 0;\n                break;\n            }\n\n            // do we need to filter?\n            lfs_tag_t mask = LFS_MKTAG(0x7ff, 0, 0);\n            if ((mask & tmask & tag) != (mask & tmask & ttag)) {\n                continue;\n            }\n\n            if (lfs_tag_id(tmask) != 0) {\n                LFS_ASSERT(sp < LFS_DIR_TRAVERSE_DEPTH);\n                // recurse, scan for duplicates, and update tag based on\n                // creates/deletes\n                stack[sp] = (struct lfs_dir_traverse){\n                    .dir        = dir,\n                    .off        = off,\n                    .ptag       = ptag,\n                    .attrs      = attrs,\n                    .attrcount  = attrcount,\n                    .tmask      = tmask,\n                    .ttag       = ttag,\n                    .begin      = begin,\n                    .end        = end,\n                    .diff       = diff,\n                    .cb         = cb,\n                    .data       = data,\n                    .tag        = tag,\n                    .buffer     = buffer,\n                    .disk       = disk,\n                };\n                sp += 1;\n\n                tmask = 0;\n                ttag = 0;\n                begin = 0;\n                end = 0;\n                diff = 0;\n                cb = lfs_dir_traverse_filter;\n                data = &stack[sp-1].tag;\n                continue;\n            }\n        }\n\npopped:\n        // in filter range?\n        if (lfs_tag_id(tmask) != 0 &&\n                !(lfs_tag_id(tag) >= begin && lfs_tag_id(tag) < end)) {\n            continue;\n        }\n\n        // handle special cases for mcu-side operations\n        if (lfs_tag_type3(tag) == LFS_FROM_NOOP) {\n            // do nothing\n        } else if (lfs_tag_type3(tag) == LFS_FROM_MOVE) {\n            // Without this condition, lfs_dir_traverse can exhibit an\n            // extremely expensive O(n^3) of nested loops when renaming.\n            // This happens because lfs_dir_traverse tries to filter tags by\n            // the tags in the source directory, triggering a second\n            // lfs_dir_traverse with its own filter operation.\n            //\n            // traverse with commit\n            // '-> traverse with filter\n            //     '-> traverse with move\n            //         '-> traverse with filter\n            //\n            // However we don't actually care about filtering the second set of\n            // tags, since duplicate tags have no effect when filtering.\n            //\n            // This check skips this unnecessary recursive filtering explicitly,\n            // reducing this runtime from O(n^3) to O(n^2).\n            if (cb == lfs_dir_traverse_filter) {\n                continue;\n            }\n\n            // recurse into move\n            stack[sp] = (struct lfs_dir_traverse){\n                .dir        = dir,\n                .off        = off,\n                .ptag       = ptag,\n                .attrs      = attrs,\n                .attrcount  = attrcount,\n                .tmask      = tmask,\n                .ttag       = ttag,\n                .begin      = begin,\n                .end        = end,\n                .diff       = diff,\n                .cb         = cb,\n                .data       = data,\n                .tag        = LFS_MKTAG(LFS_FROM_NOOP, 0, 0),\n            };\n            sp += 1;\n\n            uint16_t fromid = lfs_tag_size(tag);\n            uint16_t toid = lfs_tag_id(tag);\n            dir = buffer;\n            off = 0;\n            ptag = 0xffffffff;\n            attrs = NULL;\n            attrcount = 0;\n            tmask = LFS_MKTAG(0x600, 0x3ff, 0);\n            ttag = LFS_MKTAG(LFS_TYPE_STRUCT, 0, 0);\n            begin = fromid;\n            end = fromid+1;\n            diff = toid-fromid+diff;\n        } else if (lfs_tag_type3(tag) == LFS_FROM_USERATTRS) {\n            for (unsigned i = 0; i < lfs_tag_size(tag); i++) {\n                const struct lfs_attr *a = buffer;\n                res = cb(data, LFS_MKTAG(LFS_TYPE_USERATTR + a[i].type,\n                        lfs_tag_id(tag) + diff, a[i].size), a[i].buffer);\n                if (res < 0) {\n                    return res;\n                }\n\n                if (res) {\n                    break;\n                }\n            }\n        } else {\n            res = cb(data, tag + LFS_MKTAG(0, diff, 0), buffer);\n            if (res < 0) {\n                return res;\n            }\n\n            if (res) {\n                break;\n            }\n        }\n    }\n\n    if (sp > 0) {\n        // pop from the stack and return, fortunately all pops share\n        // a destination\n        dir         = stack[sp-1].dir;\n        off         = stack[sp-1].off;\n        ptag        = stack[sp-1].ptag;\n        attrs       = stack[sp-1].attrs;\n        attrcount   = stack[sp-1].attrcount;\n        tmask       = stack[sp-1].tmask;\n        ttag        = stack[sp-1].ttag;\n        begin       = stack[sp-1].begin;\n        end         = stack[sp-1].end;\n        diff        = stack[sp-1].diff;\n        cb          = stack[sp-1].cb;\n        data        = stack[sp-1].data;\n        tag         = stack[sp-1].tag;\n        buffer      = stack[sp-1].buffer;\n        disk        = stack[sp-1].disk;\n        sp -= 1;\n        goto popped;\n    } else {\n        return res;\n    }\n}\n...\nstatic inline bool lfs_pair_isnull(const lfs_block_t pair[2]) {\n    return pair[0] == LFS_BLOCK_NULL || pair[1] == LFS_BLOCK_NULL;\n}\n...\nstatic inline void lfs_pair_tole32(lfs_block_t pair[2]) {\n    pair[0] = lfs_tole32(pair[0]);\n    pair[1] = lfs_tole32(pair[1]);\n}\n...\nstatic int lfs_dir_commitattr(lfs_t *lfs, struct lfs_commit *commit,\n        lfs_tag_t tag, const void *buffer) {\n    // check if we fit\n    lfs_size_t dsize = lfs_tag_dsize(tag);\n    if (commit->off + dsize > commit->end) {\n        return LFS_ERR_NOSPC;\n    }\n\n    // write out tag\n    lfs_tag_t ntag = lfs_tobe32((tag & 0x7fffffff) ^ commit->ptag);\n    int err = lfs_dir_commitprog(lfs, commit, &ntag, sizeof(ntag));\n    if (err) {\n        return err;\n    }\n\n    if (!(tag & 0x80000000)) {\n        // from memory\n        err = lfs_dir_commitprog(lfs, commit, buffer, dsize-sizeof(tag));\n        if (err) {\n            return err;\n        }\n    } else {\n        // from disk\n        const struct lfs_diskoff *disk = buffer;\n        for (lfs_off_t i = 0; i < dsize-sizeof(tag); i++) {\n            // rely on caching to make this efficient\n            uint8_t dat;\n            err = lfs_bd_read(lfs,\n                    NULL, &lfs->rcache, dsize-sizeof(tag)-i,\n                    disk->block, disk->off+i, &dat, 1);\n            if (err) {\n                return err;\n            }\n\n            err = lfs_dir_commitprog(lfs, commit, &dat, 1);\n            if (err) {\n                return err;\n            }\n        }\n    }\n\n    commit->ptag = tag & 0x7fffffff;\n    return 0;\n}\n...\nstatic inline void lfs_pair_fromle32(lfs_block_t pair[2]) {\n    pair[0] = lfs_fromle32(pair[0]);\n    pair[1] = lfs_fromle32(pair[1]);\n}\n...\nstatic inline void lfs_gstate_xor(lfs_gstate_t *a, const lfs_gstate_t *b) {\n    a->tag ^= b->tag;\n    a->pair[0] ^= b->pair[0];\n    a->pair[1] ^= b->pair[1];\n}\n...\nstatic int lfs_dir_getgstate(lfs_t *lfs, const lfs_mdir_t *dir,\n        lfs_gstate_t *gstate) {\n    lfs_gstate_t temp;\n    lfs_stag_t res = lfs_dir_get(lfs, dir, LFS_MKTAG(0x7ff, 0, 0),\n            LFS_MKTAG(LFS_TYPE_MOVESTATE, 0, sizeof(temp)), &temp);\n    if (res < 0 && res != LFS_ERR_NOENT) {\n        return res;\n    }\n\n    if (res != LFS_ERR_NOENT) {\n        // xor together to find resulting gstate\n        lfs_gstate_fromle32(&temp);\n        lfs_gstate_xor(gstate, &temp);\n    }\n\n    return 0;\n}\n...\nstatic inline bool lfs_gstate_iszero(const lfs_gstate_t *a) {\n    return a->tag == 0\n            && a->pair[0] == 0\n            && a->pair[1] == 0;\n}\n...\nstatic inline void lfs_gstate_tole32(lfs_gstate_t *a) {\n    a->tag     = lfs_tole32(a->tag);\n    a->pair[0] = lfs_tole32(a->pair[0]);\n    a->pair[1] = lfs_tole32(a->pair[1]);\n}\n...\nstatic int lfs_dir_commitcrc(lfs_t *lfs, struct lfs_commit *commit) {\n    // align to program units\n    //\n    // this gets a bit complex as we have two types of crcs:\n    // - 5-word crc with fcrc to check following prog (middle of block)\n    // - 2-word crc with no following prog (end of block)\n    const lfs_off_t end = lfs_alignup(\n            lfs_min(commit->off + 5*sizeof(uint32_t), lfs->cfg->block_size),\n            lfs->cfg->prog_size);\n\n    lfs_off_t off1 = 0;\n    uint32_t crc1 = 0;\n\n    // create crc tags to fill up remainder of commit, note that\n    // padding is not crced, which lets fetches skip padding but\n    // makes committing a bit more complicated\n    while (commit->off < end) {\n        lfs_off_t noff = (\n                lfs_min(end - (commit->off+sizeof(lfs_tag_t)), 0x3fe)\n                + (commit->off+sizeof(lfs_tag_t)));\n        // too large for crc tag? need padding commits\n        if (noff < end) {\n            noff = lfs_min(noff, end - 5*sizeof(uint32_t));\n        }\n\n        // space for fcrc?\n        uint8_t eperturb = (uint8_t)-1;\n        if (noff >= end && noff <= lfs->cfg->block_size - lfs->cfg->prog_size) {\n            // first read the leading byte, this always contains a bit\n            // we can perturb to avoid writes that don't change the fcrc\n            int err = lfs_bd_read(lfs,\n                    NULL, &lfs->rcache, lfs->cfg->prog_size,\n                    commit->block, noff, &eperturb, 1);\n            if (err && err != LFS_ERR_CORRUPT) {\n                return err;\n            }\n\n        #ifdef LFS_MULTIVERSION\n            // unfortunately fcrcs break mdir fetching < lfs2.1, so only write\n            // these if we're a >= lfs2.1 filesystem\n            if (lfs_fs_disk_version(lfs) <= 0x00020000) {\n                // don't write fcrc\n            } else\n        #endif\n            {\n                // find the expected fcrc, don't bother avoiding a reread\n                // of the eperturb, it should still be in our cache\n                struct lfs_fcrc fcrc = {\n                    .size = lfs->cfg->prog_size,\n                    .crc = 0xffffffff\n                };\n                err = lfs_bd_crc(lfs,\n                        NULL, &lfs->rcache, lfs->cfg->prog_size,\n                        commit->block, noff, fcrc.size, &fcrc.crc);\n                if (err && err != LFS_ERR_CORRUPT) {\n                    return err;\n                }\n\n                lfs_fcrc_tole32(&fcrc);\n                err = lfs_dir_commitattr(lfs, commit,\n                        LFS_MKTAG(LFS_TYPE_FCRC, 0x3ff, sizeof(struct lfs_fcrc)),\n                        &fcrc);\n                if (err) {\n                    return err;\n                }\n            }\n        }\n\n        // build commit crc\n        struct {\n            lfs_tag_t tag;\n            uint32_t crc;\n        } ccrc;\n        lfs_tag_t ntag = LFS_MKTAG(\n                LFS_TYPE_CCRC + (((uint8_t)~eperturb) >> 7), 0x3ff,\n                noff - (commit->off+sizeof(lfs_tag_t)));\n        ccrc.tag = lfs_tobe32(ntag ^ commit->ptag);\n        commit->crc = lfs_crc(commit->crc, &ccrc.tag, sizeof(lfs_tag_t));\n        ccrc.crc = lfs_tole32(commit->crc);\n\n        int err = lfs_bd_prog(lfs,\n                &lfs->pcache, &lfs->rcache, false,\n                commit->block, commit->off, &ccrc, sizeof(ccrc));\n        if (err) {\n            return err;\n        }\n\n        // keep track of non-padding checksum to verify\n        if (off1 == 0) {\n            off1 = commit->off + sizeof(lfs_tag_t);\n            crc1 = commit->crc;\n        }\n\n        commit->off = noff;\n        // perturb valid bit?\n        commit->ptag = ntag ^ ((0x80UL & ~eperturb) << 24);\n        // reset crc for next commit\n        commit->crc = 0xffffffff;\n\n        // manually flush here since we don't prog the padding, this confuses\n        // the caching layer\n        if (noff >= end || noff >= lfs->pcache.off + lfs->cfg->cache_size) {\n            // flush buffers\n            int err = lfs_bd_sync(lfs, &lfs->pcache, &lfs->rcache, false);\n            if (err) {\n                return err;\n            }\n        }\n    }\n\n    // successful commit, check checksums to make sure\n    //\n    // note that we don't need to check padding commits, worst\n    // case if they are corrupted we would have had to compact anyways\n    lfs_off_t off = commit->begin;\n    uint32_t crc = 0xffffffff;\n    int err = lfs_bd_crc(lfs,\n            NULL, &lfs->rcache, off1+sizeof(uint32_t),\n            commit->block, off, off1-off, &crc);\n    if (err) {\n        return err;\n    }\n\n    // check non-padding commits against known crc\n    if (crc != crc1) {\n        return LFS_ERR_CORRUPT;\n    }\n\n    // make sure to check crc in case we happen to pick\n    // up an unrelated crc (frozen block?)\n    err = lfs_bd_crc(lfs,\n            NULL, &lfs->rcache, sizeof(uint32_t),\n            commit->block, off1, sizeof(uint32_t), &crc);\n    if (err) {\n        return err;\n    }\n\n    if (crc != 0) {\n        return LFS_ERR_CORRUPT;\n    }\n\n    return 0;\n}\n...\nstatic inline void lfs_pair_swap(lfs_block_t pair[2]) {\n    lfs_block_t t = pair[0];\n    pair[0] = pair[1];\n    pair[1] = t;\n}\n...\nstatic inline void lfs_cache_drop(lfs_t *lfs, lfs_cache_t *rcache) {\n    // do not zero, cheaper if cache is readonly or only going to be\n    // written with identical data (during relocates)\n    (void)lfs;\n    rcache->block = LFS_BLOCK_NULL;\n}\n...\nstatic int lfs_alloc(lfs_t *lfs, lfs_block_t *block) {\n    while (true) {\n        // scan our lookahead buffer for free blocks\n        while (lfs->lookahead.next < lfs->lookahead.size) {\n            if (!(lfs->lookahead.buffer[lfs->lookahead.next / 8]\n                    & (1U << (lfs->lookahead.next % 8)))) {\n                // found a free block\n                *block = (lfs->lookahead.start + lfs->lookahead.next)\n                        % lfs->block_count;\n\n                // eagerly find next free block to maximize how many blocks\n                // lfs_alloc_ckpoint makes available for scanning\n                while (true) {\n                    lfs->lookahead.next += 1;\n                    lfs->lookahead.ckpoint -= 1;\n\n                    if (lfs->lookahead.next >= lfs->lookahead.size\n                            || !(lfs->lookahead.buffer[lfs->lookahead.next / 8]\n                                & (1U << (lfs->lookahead.next % 8)))) {\n                        return 0;\n                    }\n                }\n            }\n\n            lfs->lookahead.next += 1;\n            lfs->lookahead.ckpoint -= 1;\n        }\n\n        // In order to keep our block allocator from spinning forever when our\n        // filesystem is full, we mark points where there are no in-flight\n        // allocations with a checkpoint before starting a set of allocations.\n        //\n        // If we've looked at all blocks since the last checkpoint, we report\n        // the filesystem as out of storage.\n        //\n        if (lfs->lookahead.ckpoint <= 0) {\n            LFS_ERROR(\"No more free space 0x%\"PRIx32,\n                    (lfs->lookahead.start + lfs->lookahead.next)\n                        % lfs->block_count);\n            return LFS_ERR_NOSPC;\n        }\n\n        // No blocks in our lookahead buffer, we need to scan the filesystem for\n        // unused blocks in the next lookahead window.\n        int err = lfs_alloc_scan(lfs);\n        if(err) {\n            return err;\n        }\n    }\n}\n...\nstatic int lfs_bd_prog(lfs_t *lfs,\n        lfs_cache_t *pcache, lfs_cache_t *rcache, bool validate,\n        lfs_block_t block, lfs_off_t off,\n        const void *buffer, lfs_size_t size) {\n    const uint8_t *data = buffer;\n    LFS_ASSERT(block == LFS_BLOCK_INLINE || block < lfs->block_count);\n    LFS_ASSERT(off + size <= lfs->cfg->block_size);\n\n    while (size > 0) {\n        if (block == pcache->block &&\n                off >= pcache->off &&\n                off < pcache->off + lfs->cfg->cache_size) {\n            // already fits in pcache?\n            lfs_size_t diff = lfs_min(size,\n                    lfs->cfg->cache_size - (off-pcache->off));\n            memcpy(&pcache->buffer[off-pcache->off], data, diff);\n\n            data += diff;\n            off += diff;\n            size -= diff;\n\n            pcache->size = lfs_max(pcache->size, off - pcache->off);\n            if (pcache->size == lfs->cfg->cache_size) {\n                // eagerly flush out pcache if we fill up\n                int err = lfs_bd_flush(lfs, pcache, rcache, validate);\n                if (err) {\n                    return err;\n                }\n            }\n\n            continue;\n        }\n\n        // pcache must have been flushed, either by programming and\n        // entire block or manually flushing the pcache\n        LFS_ASSERT(pcache->block == LFS_BLOCK_NULL);\n\n        // prepare pcache, first condition can no longer fail\n        pcache->block = block;\n        pcache->off = lfs_aligndown(off, lfs->cfg->prog_size);\n        pcache->size = 0;\n    }\n\n    return 0;\n}\n...\nuint32_t lfs_crc(uint32_t crc, const void *buffer, size_t size) {\n    static const uint32_t rtable[16] = {\n        0x00000000, 0x1db71064, 0x3b6e20c8, 0x26d930ac,\n        0x76dc4190, 0x6b6b51f4, 0x4db26158, 0x5005713c,\n        0xedb88320, 0xf00f9344, 0xd6d6a3e8, 0xcb61b38c,\n        0x9b64c2b0, 0x86d3d2d4, 0xa00ae278, 0xbdbdf21c,\n    };\n\n    const uint8_t *data = buffer;\n\n    for (size_t i = 0; i < size; i++) {\n        crc = (crc >> 4) ^ rtable[(crc ^ (data[i] >> 0)) & 0xf];\n        crc = (crc >> 4) ^ rtable[(crc ^ (data[i] >> 4)) & 0xf];\n    }\n\n    return crc;\n}\n...\nstatic inline lfs_size_t lfs_tag_dsize(lfs_tag_t tag) {\n    return sizeof(tag) + lfs_tag_size(tag + lfs_tag_isdelete(tag));\n}\n...\nstatic int lfs_bd_read(lfs_t *lfs,\n        const lfs_cache_t *pcache, lfs_cache_t *rcache, lfs_size_t hint,\n        lfs_block_t block, lfs_off_t off,\n        void *buffer, lfs_size_t size) {\n    uint8_t *data = buffer;\n    if (off+size > lfs->cfg->block_size\n            || (lfs->block_count && block >= lfs->block_count)) {\n        return LFS_ERR_CORRUPT;\n    }\n\n    while (size > 0) {\n        lfs_size_t diff = size;\n\n        if (pcache && block == pcache->block &&\n                off < pcache->off + pcache->size) {\n            if (off >= pcache->off) {\n                // is already in pcache?\n                diff = lfs_min(diff, pcache->size - (off-pcache->off));\n                memcpy(data, &pcache->buffer[off-pcache->off], diff);\n\n                data += diff;\n                off += diff;\n                size -= diff;\n                continue;\n            }\n\n            // pcache takes priority\n            diff = lfs_min(diff, pcache->off-off);\n        }\n\n        if (block == rcache->block &&\n                off < rcache->off + rcache->size) {\n            if (off >= rcache->off) {\n                // is already in rcache?\n                diff = lfs_min(diff, rcache->size - (off-rcache->off));\n                memcpy(data, &rcache->buffer[off-rcache->off], diff);\n\n                data += diff;\n                off += diff;\n                size -= diff;\n                continue;\n            }\n\n            // rcache takes priority\n            diff = lfs_min(diff, rcache->off-off);\n        }\n\n        if (size >= hint && off % lfs->cfg->read_size == 0 &&\n                size >= lfs->cfg->read_size) {\n            // bypass cache?\n            diff = lfs_aligndown(diff, lfs->cfg->read_size);\n            int err = lfs->cfg->read(lfs->cfg, block, off, data, diff);\n            if (err) {\n                return err;\n            }\n\n            data += diff;\n            off += diff;\n            size -= diff;\n            continue;\n        }\n\n        // load to cache, first condition can no longer fail\n        LFS_ASSERT(!lfs->block_count || block < lfs->block_count);\n        rcache->block = block;\n        rcache->off = lfs_aligndown(off, lfs->cfg->read_size);\n        rcache->size = lfs_min(\n                lfs_min(\n                    lfs_alignup(off+hint, lfs->cfg->read_size),\n                    lfs->cfg->block_size)\n                - rcache->off,\n                lfs->cfg->cache_size);\n        int err = lfs->cfg->read(lfs->cfg, rcache->block,\n                rcache->off, rcache->buffer, rcache->size);\n        LFS_ASSERT(err <= 0);\n        if (err) {\n            return err;\n        }\n    }\n\n    return 0;\n}\n...\nstatic inline uint16_t lfs_tag_id(lfs_tag_t tag) {\n    return (tag & 0x000ffc00) >> 10;\n}\n...\nstatic inline uint16_t lfs_tag_type3(lfs_tag_t tag) {\n    return (tag & 0x7ff00000) >> 20;\n}\n...\nstatic inline lfs_size_t lfs_tag_size(lfs_tag_t tag) {\n    return tag & 0x000003ff;\n}\n...\nstatic lfs_stag_t lfs_dir_get(lfs_t *lfs, const lfs_mdir_t *dir,\n        lfs_tag_t gmask, lfs_tag_t gtag, void *buffer) {\n    return lfs_dir_getslice(lfs, dir,\n            gmask, gtag,\n            0, buffer, lfs_tag_size(gtag));\n}\n...\nstatic inline void lfs_gstate_fromle32(lfs_gstate_t *a) {\n    a->tag     = lfs_fromle32(a->tag);\n    a->pair[0] = lfs_fromle32(a->pair[0]);\n    a->pair[1] = lfs_fromle32(a->pair[1]);\n}\n...\nstatic int lfs_bd_crc(lfs_t *lfs,\n        const lfs_cache_t *pcache, lfs_cache_t *rcache, lfs_size_t hint,\n        lfs_block_t block, lfs_off_t off, lfs_size_t size, uint32_t *crc) {\n    lfs_size_t diff = 0;\n\n    for (lfs_off_t i = 0; i < size; i += diff) {\n        uint8_t dat[8];\n        diff = lfs_min(size-i, sizeof(dat));\n        int err = lfs_bd_read(lfs,\n                pcache, rcache, hint-i,\n                block, off+i, &dat, diff);\n        if (err) {\n            return err;\n        }\n\n        *crc = lfs_crc(*crc, &dat, diff);\n    }\n\n    return 0;\n}\n...\nstatic void lfs_fcrc_tole32(struct lfs_fcrc *fcrc) {\n    fcrc->size = lfs_tole32(fcrc->size);\n    fcrc->crc = lfs_tole32(fcrc->crc);\n}\n...\nstatic int lfs_bd_sync(lfs_t *lfs,\n        lfs_cache_t *pcache, lfs_cache_t *rcache, bool validate) {\n    lfs_cache_drop(lfs, rcache);\n\n    int err = lfs_bd_flush(lfs, pcache, rcache, validate);\n    if (err) {\n        return err;\n    }\n\n    err = lfs->cfg->sync(lfs->cfg);\n    LFS_ASSERT(err <= 0);\n    return err;\n}\n...\nstatic int lfs_alloc_scan(lfs_t *lfs) {\n    // move lookahead buffer to the first unused block\n    //\n    // note we limit the lookahead buffer to at most the amount of blocks\n    // checkpointed, this prevents the math in lfs_alloc from underflowing\n    lfs->lookahead.start = (lfs->lookahead.start + lfs->lookahead.next) \n            % lfs->block_count;\n    lfs->lookahead.next = 0;\n    lfs->lookahead.size = lfs_min(\n            8*lfs->cfg->lookahead_size,\n            lfs->lookahead.ckpoint);\n\n    // find mask of free blocks from tree\n    memset(lfs->lookahead.buffer, 0, lfs->cfg->lookahead_size);\n    int err = lfs_fs_traverse_(lfs, lfs_alloc_lookahead, lfs, true);\n    if (err) {\n        lfs_alloc_drop(lfs);\n        return err;\n    }\n\n    return 0;\n}\n</additional code>\n<target_code>\nHere is the code fragment that you need to analyze:\n```c\nint err = lfs_alloc(lfs, &dir->pair[1]);\n```\nFocus on the above code fragment and judge whether it violates the rule 17.2 or not.\n</target_code>\n",
  "is_rule_violated": false,
  "scenario": "No violation. In the shown code lfs_dir_compact calls lfs_alloc(lfs, &dir->pair[1]). The definition of lfs_alloc (and its helper lfs_alloc_scan) does not call lfs_dir_compact (they call allocation-related routines such as lfs_alloc_scan -> lfs_fs_traverse_ -> lfs_alloc_lookahead). There is no evidence in the provided code of lfs_alloc (or functions it calls) invoking lfs_dir_compact, so this call does not create direct or indirect recursion."
}