{
  "user_message": "An agent A claimed that the following lfs_fs_parent_match code violates the MISRA C 2023 rule 8.13.\n<misra_rule>\nMISRA C 2023 Rule 8.13 is A pointer should point to a const-qualified type whenever possible.\n\n</misra_rule>\n<target_code>\nHere is the original code of lfs_fs_parent_match.\n```c\nstatic int lfs_fs_parent_match(void *data,\n        lfs_tag_t tag, const void *buffer) {\n    struct lfs_fs_parent_match *find = data;\n    lfs_t *lfs = find->lfs;\n    const struct lfs_diskoff *disk = buffer;\n    (void)tag;\n\n    lfs_block_t child[2];\n    int err = lfs_bd_read(lfs,\n            &lfs->pcache, &lfs->rcache, lfs->cfg->block_size,\n            disk->block, disk->off, &child, sizeof(child));\n    if (err) {\n        return err;\n    }\n\n    lfs_pair_fromle32(child);\n    return (lfs_pair_cmp(child, find->pair) == 0) ? LFS_CMP_EQ : LFS_CMP_LT;\n}\n```\n</target_code>\n<response format>\nProvide your answer with these fields.\n- explanation: your evaluation of the scenario provided by the agent A.\n- is_report_correct: whether the report is correct or not (true/false). True means there is a violation.\n</response format>\n<scenario>\nThe agent A provided the following violation scenario:\nThe parameter 'data' is declared as void * but is only read: it is cast to struct lfs_fs_parent_match *find and only read (find->lfs, find->pair). Therefore the parameter could be declared const void * (and find as const struct lfs_fs_parent_match *). This violates MISRA C 2023 Rule 8.13 unless the function must match a preexisting non-const callback signature that cannot be changed.\n</scenario>\n\n<execution_log>\nThe agent A also provided the following output log:\n[lfs_fs_parent_match] stage=enter data=0x7fff50da75a8 tag=536871944 buffer=0x7fff50da7530 lfs=0x7fff50da78e0\n  disk: block=0 off=116\n  bd_read err=0\n  find->pair: [0]=27 [1]=26\n  cmp_result=-1\n---\n[lfs_fs_parent_match] stage=after_read_before_leconv data=0x7fff50da75a8 tag=536871944 buffer=0x7fff50da7530 lfs=0x7fff50da78e0\n  disk: block=0 off=116\n  bd_read err=0\n  child before le-conv: [0]=2 [1]=3\n  find->pair: [0]=27 [1]=26\n  cmp_result=-1\n---\n[lfs_fs_parent_match] stage=after_leconv_and_cmp data=0x7fff50da75a8 tag=536871944 buffer=0x7fff50da7530 lfs=0x7fff50da78e0\n  disk: block=0 off=116\n  bd_read err=0\n  child before le-conv: [0]=2 [1]=3\n  child after le-conv:  [0]=2 [1]=3\n  find->pair: [0]=27 [1]=26\n  cmp_result=1\n---\n[lfs_fs_parent_match] stage=enter data=0x7fff50da75a8 tag=536870920 buffer=0x7fff50da7530 lfs=0x7fff50da78e0\n  disk: block=13 off=76\n  bd_read err=0\n  find->pair: [0]=27 [1]=26\n  cmp_result=-1\n---\n[lfs_fs_parent_match] stage=after_read_before_leconv data=0x7fff50da75a8 tag=536870920 buffer=0x7fff50da7530 lfs=0x7fff50da78e0\n  disk: block=13 off=76\n  bd_read err=0\n  child before le-conv: [0]=4 [1]=5\n  find->pair: [0]=27 [1]=26\n  cmp_result=-1\n---\n[lfs_fs_parent_match] stage=after_leconv_and_cmp data=0x7fff50da75a8 tag=536870920 buffer=0x7fff50da7530 lfs=0x7fff50da78e0\n  disk: block=13 off=76\n  bd_read err=0\n  child before le-conv: [0]=4 [1]=5\n  child after le-conv:  [0]=4 [1]=5\n  find->pair: [0]=27 [1]=26\n  cmp_result=1\n---\n[lfs_fs_parent_match] stage=enter data=0x7fff50da75a8 tag=536871944 buffer=0x7fff50da7530 lfs=0x7fff50da78e0\n  disk: block=13 off=156\n  bd_read err=0\n  find->pair: [0]=27 [1]=26\n  cmp_result=-1\n---\n[lfs_fs_parent_match] stage=after_read_before_leconv data=0x7fff50da75a8 tag=536871944 buffer=0x7fff50da7530 lfs=0x7fff50da78e0\n  disk: block=13 off=156\n  bd_read err=0\n  child before le-conv: [0]=7 [1]=8\n  find->pair: [0]=27 [1]=26\n  cmp_result=-1\n---\n[lfs_fs_parent_match] stage=after_leconv_and_cmp data=0x7fff50da75a8 tag=536871944 buffer=0x7fff50da7530 lfs=0x7fff50da78e0\n  disk: block=13 off=156\n  bd_read err=0\n  child before le-conv: [0]=7 [1]=8\n  child after le-conv:  [0]=7 [1]=8\n  find->pair: [0]=27 [1]=26\n  cmp_result=1\n---\n[lfs_fs_parent_match] stage=enter data=0x7fff50da75a8 tag=536870920 buffer=0x7fff50da7530 lfs=0x7fff50da78e0\n  disk: block=20 off=76\n  bd_read err=0\n  find->pair: [0]=27 [1]=26\n  cmp_result=-1\n---\n[lfs_fs_parent_match] stage=after_read_before_leconv data=0x7fff50da75a8 tag=536870920 buffer=0x7fff50da7530 lfs=0x7fff50da78e0\n  disk: block=20 off=76\n  bd_read err=0\n  child before le-conv: [0]=10 [1]=11\n  find->pair: [0]=27 [1]=26\n  cmp_result=-1\n---\n[lfs_fs_parent_match] stage=after_leconv_and_cmp data=0x7fff50da75a8 tag=536870920 buffer=0x7fff50da7530 lfs=0x7fff50da78e0\n  disk: block=20 off=76\n  bd_read err=0\n  child before le-conv: [0]=10 [1]=11\n  child after le-conv:  [0]=10 [1]=11\n  find->pair: [0]=27 [1]=26\n  cmp_result=1\n---\n[lfs_fs_parent_match] stage=enter data=0x7fff50da75a8 tag=536871944 buffer=0x7fff50da7530 lfs=0x7fff50da78e0\n  disk: block=20 off=156\n  bd_read err=0\n  find->pair: [0]=27 [1]=26\n  cmp_result=-1\n---\n[lfs_fs_parent_match] stage=after_read_before_leconv data=0x7fff50da75a8 tag=536871944 buffer=0x7fff50da7530 lfs=0x7fff50da78e0\n  disk: block=20 off=156\n  bd_read err=0\n  child before le-conv: [0]=15 [1]=16\n  find->pair: [0]=27 [1]=26\n  cmp_result=-1\n---\n[lfs_fs_parent_match] stage=after_leconv_and_cmp data=0x7fff50da75a8 tag=536871944 buffer=0x7fff50da7530 lfs=0x7fff50da78e0\n  disk: block=20 off=156\n  bd_read err=0\n  child before le-conv: [0]=15 [1]=16\n  child after le-conv:  [0]=15 [1]=16\n  find->pair: [0]=27 [1]=26\n  cmp_result=1\n---\n[lfs_fs_parent_match] stage=enter data=0x7fff50da75a8 tag=536872968 buffer=0x7fff50da7530 lfs=0x7fff50da78e0\n  disk: block=20 off=236\n  bd_read err=0\n  find->pair: [0]=27 [1]=26\n  cmp_result=-1\n---\n[lfs_fs_parent_match] stage=after_read_before_leconv data=0x7fff50da75a8 tag=536872968 buffer=0x7fff50da7530 lfs=0x7fff50da78e0\n  disk: block=20 off=236\n  bd_read err=0\n  child before le-conv: [0]=18 [1]=19\n  find->pair:\n</execution_log>\n<additional code>Here are the definitions of symbols that are close to the target function lfs_fs_parent_match:\ntypedef uint32_t lfs_block_t\n...\nstruct lfs_diskoff {\n    lfs_block_t block;\n    lfs_off_t off;\n}\n...\ntypedef uint32_t lfs_tag_t\n...\ntypedef struct lfs {\n    lfs_cache_t rcache;\n    lfs_cache_t pcache;\n\n    lfs_block_t root[2];\n    struct lfs_mlist {\n        struct lfs_mlist *next;\n        uint16_t id;\n        uint8_t type;\n        lfs_mdir_t m;\n    } *mlist;\n    uint32_t seed;\n\n    lfs_gstate_t gstate;\n    lfs_gstate_t gdisk;\n    lfs_gstate_t gdelta;\n\n    struct lfs_lookahead {\n        lfs_block_t start;\n        lfs_block_t size;\n        lfs_block_t next;\n        lfs_block_t ckpoint;\n        uint8_t *buffer;\n    } lookahead;\n\n    const struct lfs_config *cfg;\n    lfs_size_t block_count;\n    lfs_size_t name_max;\n    lfs_size_t file_max;\n    lfs_size_t attr_max;\n    lfs_size_t inline_max;\n\n#ifdef LFS_MIGRATE\n    struct lfs1 *lfs1;\n#endif\n} lfs_t\n</additional code>\n\n<instruction>\nJudge whether the report is correct or not.\n</instruction>\n",
  "is_report_correct": true,
  "explanation": "Agent A's observation is correct in principle: in lfs_fs_parent_match the parameter data is only read (cast to struct lfs_fs_parent_match * and used without modification), so it could be const-qualified (e.g. const void *data and const struct lfs_fs_parent_match *find). MISRA C:2023 Rule 8.13 requires pointers to be const-qualified whenever possible, so the code as shown is a breach of that rule unless there is an overriding reason. The usual valid exception is that the function must match a preexisting non-const callback/signature that cannot be changed; in that case the non-const void * parameter is required and the rule does not force a prototype change. The provided code/auxiliary material does not show the callback type that this function must match, so without evidence of such a constraint the report of a Rule 8.13 violation is justified. Recommended remediation: change the parameter to const void * and use a const struct lfs_fs_parent_match *find, or if the function must match an external non-const prototype, document the reason and provide an appropriate MISRA justification or wrapper."
}