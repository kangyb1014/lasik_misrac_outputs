{
  "user_message": "An agent A claimed that the following lfs_dir_getread code violates the MISRA C 2023 rule 17.8.\n<misra_rule>\nMISRA C 2023 Rule 17.8 is A function parameter should not be modified.\nNote that the object referred to by a pointer parameter may be modified, but the pointer itself shall not be modified.\n</misra_rule>\n<target_code>\nHere is the original code of lfs_dir_getread.\n```c\nstatic int lfs_dir_getread(lfs_t *lfs, const lfs_mdir_t *dir,\n        const lfs_cache_t *pcache, lfs_cache_t *rcache, lfs_size_t hint,\n        lfs_tag_t gmask, lfs_tag_t gtag,\n        lfs_off_t off, void *buffer, lfs_size_t size) {\n    uint8_t *data = buffer;\n    if (off+size > lfs->cfg->block_size) {\n        return LFS_ERR_CORRUPT;\n    }\n\n    while (size > 0) {\n        lfs_size_t diff = size;\n\n        if (pcache && pcache->block == LFS_BLOCK_INLINE &&\n                off < pcache->off + pcache->size) {\n            if (off >= pcache->off) {\n                // is already in pcache?\n                diff = lfs_min(diff, pcache->size - (off-pcache->off));\n                memcpy(data, &pcache->buffer[off-pcache->off], diff);\n\n                data += diff;\n                off += diff;\n                size -= diff;\n                continue;\n            }\n\n            // pcache takes priority\n            diff = lfs_min(diff, pcache->off-off);\n        }\n\n        if (rcache->block == LFS_BLOCK_INLINE &&\n                off < rcache->off + rcache->size) {\n            if (off >= rcache->off) {\n                // is already in rcache?\n                diff = lfs_min(diff, rcache->size - (off-rcache->off));\n                memcpy(data, &rcache->buffer[off-rcache->off], diff);\n\n                data += diff;\n                off += diff;\n                size -= diff;\n                continue;\n            }\n\n            // rcache takes priority\n            diff = lfs_min(diff, rcache->off-off);\n        }\n\n        // load to cache, first condition can no longer fail\n        rcache->block = LFS_BLOCK_INLINE;\n        rcache->off = lfs_aligndown(off, lfs->cfg->read_size);\n        rcache->size = lfs_min(lfs_alignup(off+hint, lfs->cfg->read_size),\n                lfs->cfg->cache_size);\n        int err = lfs_dir_getslice(lfs, dir, gmask, gtag,\n                rcache->off, rcache->buffer, rcache->size);\n        if (err < 0) {\n            return err;\n        }\n    }\n\n    return 0;\n}\n```\n</target_code>\n<response format>\nProvide your answer with these fields.\n- explanation: your evaluation of the scenario provided by the agent A.\n- is_report_correct: whether the report is correct or not (true/false). True means there is a violation.\n</response format>\n<scenario>\nThe agent A provided the following violation scenario:\nThe fragment modifies the value parameters 'off' and 'size' (off += diff; size -= diff), which are function parameters and thus shall not be modified under MISRA C 2023 Rule 17.8. (Modifying the local pointer 'data' is acceptable, and modifying objects pointed to by pointer parameters is allowed.)\n</scenario>\n\n<execution_log>\nThe agent A also provided the following output log:\nENTER lfs_dir_getread: off=0 size=1 hint=60 gmask=0xfff7fc00 gtag=0x20100000\nRCACHE HIT before modify: off=0 size=1 diff=1\nRCACHE HIT after modify: off=1 size=0\nEXIT lfs_dir_getread: off=1 size=0\nENTER lfs_dir_getread: off=1 size=1 hint=59 gmask=0xfff7fc00 gtag=0x20100000\nRCACHE HIT before modify: off=1 size=1 diff=1\nRCACHE HIT after modify: off=2 size=0\nEXIT lfs_dir_getread: off=2 size=0\nENTER lfs_dir_getread: off=2 size=1 hint=58 gmask=0xfff7fc00 gtag=0x20100000\nRCACHE HIT before modify: off=2 size=1 diff=1\nRCACHE HIT after modify: off=3 size=0\nEXIT lfs_dir_getread: off=3 size=0\nENTER lfs_dir_getread: off=3 size=1 hint=57 gmask=0xfff7fc00 gtag=0x20100000\nRCACHE HIT before modify: off=3 size=1 diff=1\nRCACHE HIT after modify: off=4 size=0\nEXIT lfs_dir_getread: off=4 size=0\nENTER lfs_dir_getread: off=4 size=1 hint=56 gmask=0xfff7fc00 gtag=0x20100000\nRCACHE HIT before modify: off=4 size=1 diff=1\nRCACHE HIT after modify: off=5 size=0\nEXIT lfs_dir_getread: off=5 size=0\nENTER lfs_dir_getread: off=5 size=1 hint=55 gmask=0xfff7fc00 gtag=0x20100000\nRCACHE HIT before modify: off=5 size=1 diff=1\nRCACHE HIT after modify: off=6 size=0\nEXIT lfs_dir_getread: off=6 size=0\nENTER lfs_dir_getread: off=6 size=1 hint=54 gmask=0xfff7fc00 gtag=0x20100000\nRCACHE HIT before modify: off=6 size=1 diff=1\nRCACHE HIT after modify: off=7 size=0\nEXIT lfs_dir_getread: off=7 size=0\nENTER lfs_dir_getread: off=7 size=1 hint=53 gmask=0xfff7fc00 gtag=0x20100000\nRCACHE HIT before modify: off=7 size=1 diff=1\nRCACHE HIT after modify: off=8 size=0\nEXIT lfs_dir_getread: off=8 size=0\nENTER lfs_dir_getread: off=8 size=1 hint=52 gmask=0xfff7fc00 gtag=0x20100000\nRCACHE HIT before modify: off=8 size=1 diff=1\nRCACHE HIT after modify: off=9 size=0\nEXIT lfs_dir_getread: off=9 size=0\nENTER lfs_dir_getread: off=9 size=1 hint=51 gmask=0xfff7fc00 gtag=0x20100000\nRCACHE HIT before modify: off=9 size=1 diff=1\nRCACHE HIT after modify: off=10 size=0\nEXIT lfs_dir_getread: off=10 size=0\nENTER lfs_dir_getread: off=10 size=1 hint=50 gmask=0xfff7fc00 gtag=0x20100000\nRCACHE HIT before modify: off=10 size=1 diff=1\nRCACHE HIT after modify: off=11 size=0\nEXIT lfs_dir_getread: off=11 size=0\nENTER lfs_dir_getread: off=11 size=1 hint=49 gmask=0xfff7fc00 gtag=0x20100000\nRCACHE HIT before modify: off=11 size=1 diff=1\nRCACHE HIT after modify: off=12 size=0\nEXIT lfs_dir_getread: off=12 size=0\nENTER lfs_dir_getread: off=12 size=1 hint=48 gmask=0xfff7fc00 gtag=0x20100000\nRCACHE HIT before modify: off=12 size=1 diff=1\nRCACHE HIT after modify: off=13 size=0\nEXIT lfs_dir_getread: off=13 size=0\nENTER lfs_dir_getread: off=13 size=1 hint=47 gmask=0xfff7fc00 gtag=0x20100000\nRCACHE HIT before modify: off=13 size=1 diff=1\nRCACHE HIT after modify: off=14 size=0\nEXIT lfs_dir_getread: off=14 size=0\nENTER lfs_dir_getread: off=14 size=1 hint=46 gmask=0xfff7fc00 gtag=0x20100000\nRCACHE HIT before modify: off=14 size=1 diff=1\nRCACHE HIT after modify: off=15 size=0\nEXIT lfs_dir_getread: off=15 size=0\nENTER lfs_dir_getread: off=15 size=1 hint=45 gmask=0xfff7fc00 gtag=0x20100000\nRCACHE HIT before modify: off=15 size=1 diff=1\nRCACHE HIT after modify: off=16 size=0\nEXIT lfs_dir_getread: off=16 size=0\nENTER lfs_dir_getread: off=16 size=1 hint=44 gmask=0xfff7fc00 gtag=0x20100000\nRCACHE HIT before modify: off=16 size=1 diff=1\nRCACHE HIT after modify: off=17 size=0\nEXIT lfs_dir_getread: off=17 size=0\nENTER lfs_dir_getread: off=17 size=1 hint=43 gmask=0xfff7fc00 gtag=0x20100000\nRCACHE HIT before modify: off=17 size=1 diff=1\nRCACHE HIT after modify: off=18 size=0\nEXIT lfs_dir_getread: off=18 size=0\nENTER lfs_dir_getread: off=18 size=1 hint=42 gmask=0xfff7fc00 gtag=0x20100000\nRCACHE HIT before modify: off=18 size=1 diff=1\nRCACHE HIT after modify: off=19 size=0\nEXIT lfs_dir_getread: off=19 size=0\nENTER lfs_dir_getread: off=19 size=1 hint=41 gmask=0xfff7fc00 gtag=0x20100000\nRCACHE HIT before modify: off=19 size=1 diff=1\nRCACHE HIT after modify: off=20 size=0\nEXIT lfs_dir_getread: off=20 size=0\nENTER lfs_dir_getread: off=20 size=1 hint=40 gmask=0xfff7fc00 gtag=0x20100000\nRCACHE HIT before modify: off=20 size=1 diff=1\nRCACHE HI\n</execution_log>\n<additional code>Here are the definitions of symbols that are close to the target function lfs_dir_getread:\ntypedef uint32_t lfs_size_t\n...\ntypedef uint32_t lfs_off_t\n...\ntypedef struct lfs_cache {\n    lfs_block_t block;\n    lfs_off_t off;\n    lfs_size_t size;\n    uint8_t *buffer;\n} lfs_cache_t\n...\ntypedef struct lfs {\n    lfs_cache_t rcache;\n    lfs_cache_t pcache;\n\n    lfs_block_t root[2];\n    struct lfs_mlist {\n        struct lfs_mlist *next;\n        uint16_t id;\n        uint8_t type;\n        lfs_mdir_t m;\n    } *mlist;\n    uint32_t seed;\n\n    lfs_gstate_t gstate;\n    lfs_gstate_t gdisk;\n    lfs_gstate_t gdelta;\n\n    struct lfs_lookahead {\n        lfs_block_t start;\n        lfs_block_t size;\n        lfs_block_t next;\n        lfs_block_t ckpoint;\n        uint8_t *buffer;\n    } lookahead;\n\n    const struct lfs_config *cfg;\n    lfs_size_t block_count;\n    lfs_size_t name_max;\n    lfs_size_t file_max;\n    lfs_size_t attr_max;\n    lfs_size_t inline_max;\n\n#ifdef LFS_MIGRATE\n    struct lfs1 *lfs1;\n#endif\n} lfs_t\n</additional code>\n\n<instruction>\nJudge whether the report is correct or not.\n</instruction>\n",
  "is_report_correct": true,
  "explanation": "Agent A is correct. MISRA C 2023 Rule 17.8 states that a function parameter shall not be modified. In lfs_dir_getread the non\u2011pointer value parameters 'off' and 'size' are assigned to (e.g. off += diff; size -= diff;), which violates the rule. The intent of the rule is that value parameters must not be altered; only objects pointed to by pointer parameters may be modified. To conform, make local copies of these parameters (for example lfs_off_t cur_off = off; lfs_size_t cur_size = size;) and use those local variables instead of modifying the formal parameters."
}