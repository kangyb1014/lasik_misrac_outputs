{
  "user_message": "An agent A claimed that the following lfs_dir_split code violates the MISRA C 2023 rule 8.13.\n<misra_rule>\nMISRA C 2023 Rule 8.13 is A pointer should point to a const-qualified type whenever possible.\n\n</misra_rule>\n<target_code>\nHere is the original code of lfs_dir_split.\n```c\nstatic int lfs_dir_split(lfs_t *lfs,\n        lfs_mdir_t *dir, const struct lfs_mattr *attrs, int attrcount,\n        lfs_mdir_t *source, uint16_t split, uint16_t end) {\n    // create tail metadata pair\n    lfs_mdir_t tail;\n    int err = lfs_dir_alloc(lfs, &tail);\n    if (err) {\n        return err;\n    }\n\n    tail.split = dir->split;\n    tail.tail[0] = dir->tail[0];\n    tail.tail[1] = dir->tail[1];\n\n    // note we don't care about LFS_OK_RELOCATED\n    int res = lfs_dir_compact(lfs, &tail, attrs, attrcount, source, split, end);\n    if (res < 0) {\n        return res;\n    }\n\n    dir->tail[0] = tail.pair[0];\n    dir->tail[1] = tail.pair[1];\n    dir->split = true;\n\n    // update root if needed\n    if (lfs_pair_cmp(dir->pair, lfs->root) == 0 && split == 0) {\n        lfs->root[0] = tail.pair[0];\n        lfs->root[1] = tail.pair[1];\n    }\n\n    return 0;\n}\n```\n</target_code>\n<response format>\nProvide your answer with these fields.\n- explanation: your evaluation of the scenario provided by the agent A.\n- is_report_correct: whether the report is correct or not (true/false). True means there is a violation.\n</response format>\n<scenario>\nThe agent A provided the following violation scenario:\nThe parameter 'source' is declared as lfs_mdir_t *source but is not modified inside lfs_dir_split: it is only passed to lfs_dir_compact. If lfs_dir_compact does not modify the pointed-to lfs_mdir_t, then 'source' could and should be declared as const lfs_mdir_t *source. In that case Rule 8.13 is violated because a pointer that could point to a const-qualified type is not const-qualified.\n</scenario>\n\n<execution_log>\nThe agent A also provided the following output log:\nlfs_dir_split ENTRY: lfs=0x7ffccfb91368 dir=0x7ffccfb91108 source=0x7ffccfb91108 split=3 end=7 attrcount=4 attrs=0x7ffccfb91250\n--- dir_before: ptr=0x7ffccfb91108 len=32 ---\n0100 0000 0000 0000 0100 0000 0002 0000\n04fc 0f50 0700 0000 3900 0000 3a00 0000\n--- tail_alloc_before: ptr=0x7ffccfb90f38 len=32 ---\n3c00 0000 3b00 0000 ffff ffff 0400 0000\nffff ffff 0000 0000 ffff ffff ffff ffff\n--- source_before: ptr=0x7ffccfb91108 len=32 ---\n0100 0000 0000 0000 0100 0000 0002 0000\n04fc 0f50 0700 0000 3900 0000 3a00 0000\nlfs_dir_compact returned res=0\n--- tail_after: ptr=0x7ffccfb90f38 len=32 ---\n3b00 0000 3c00 0000 0000 0000 f000 0000\n0bfc 0f50 0400 0000 3900 0000 3a00 0000\n--- source_after: ptr=0x7ffccfb91108 len=32 ---\n0100 0000 0000 0000 0100 0000 0002 0000\n04fc 0f50 0700 0000 3900 0000 3a00 0000\n--- dir_after: ptr=0x7ffccfb91108 len=32 ---\n0100 0000 0000 0000 0100 0000 0002 0000\n04fc 0f50 0700 0001 3b00 0000 3c00 0000\n--- lfs_root_after: ptr=0x7ffccfb91398 len=8 ---\n0100 0000 0000 0000 \nlfs_dir_split EXIT: returned 0\nlfs_dir_split ENTRY: lfs=0x7ffccfb91368 dir=0x7ffccfb91108 source=0x7ffccfb91108 split=4 end=8 attrcount=4 attrs=0x7ffccfb91250\n--- dir_before: ptr=0x7ffccfb91108 len=32 ---\n3b00 0000 3c00 0000 0000 0000 0002 0000\n04fc 0f50 0800 0000 4300 0000 4400 0000\n--- tail_alloc_before: ptr=0x7ffccfb90f38 len=32 ---\n4600 0000 4500 0000 ffff ffff 0400 0000\nffff ffff 0000 0000 ffff ffff ffff ffff\n--- source_before: ptr=0x7ffccfb91108 len=32 ---\n3b00 0000 3c00 0000 0000 0000 0002 0000\n04fc 0f50 0800 0000 4300 0000 4400 0000\nlfs_dir_compact returned res=0\n--- tail_after: ptr=0x7ffccfb90f38 len=32 ---\n4500 0000 4600 0000 0000 0000 f000 0000\n0bfc 0f50 0400 0000 4300 0000 4400 0000\n--- source_after: ptr=0x7ffccfb91108 len=32 ---\n3b00 0000 3c00 0000 0000 0000 0002 0000\n04fc 0f50 0800 0000 4300 0000 4400 0000\n--- dir_after: ptr=0x7ffccfb91108 len=32 ---\n3b00 0000 3c00 0000 0000 0000 0002 0000\n04fc 0f50 0800 0001 4500 0000 4600 0000\n--- lfs_root_after: ptr=0x7ffccfb91398 len=8 ---\n0100 0000 0000 0000 \nlfs_dir_split EXIT: returned 0\nlfs_dir_split ENTRY: lfs=0x7ffccfb91368 dir=0x7ffccfb91108 source=0x7ffccfb91108 split=3 end=7 attrcount=4 attrs=0x7ffccfb91250\n--- dir_before: ptr=0x7ffccfb91108 len=32 ---\n0100 0000 0000 0000 0300 0000 c001 0000\n08fc 0f50 0700 0100 1e00 0000 1f00 0000\n--- tail_alloc_before: ptr=0x7ffccfb90f38 len=32 ---\n2100 0000 2000 0000 2000 0000 0400 0000\nffff ffff 0000 0000 ffff ffff ffff ffff\n--- source_before: ptr=0x7ffccfb91108 len=32 ---\n0100 0000 0000 0000 0300 0000 c001 0000\n08fc 0f50 0700 0100 1e00 0000 1f00 0000\nlfs_dir_compact returned res=0\n--- tail_after: ptr=0x7ffccfb90f38 len=32 ---\n2000 0000 2100 0000 2100 0000 f000 0000\n0efc 0f50 0400 0000 1e00 0000 1f00 0000\n--- source_after: ptr=0x7ffccfb91108 len=32 ---\n0100 0000 0000 0000 0300 0000 c001 0000\n08fc 0f50 0700 0100 1e00 0000 1f00 0000\n--- dir_after: ptr=0x7ffccfb91108 len=32 ---\n0100 0000 0000 0000 0300 0000 c001 0000\n08fc 0f50 0700 0101 2000 0000 2100 0000\n--- lfs_root_after: ptr=0x7ffccfb91398 len=8 ---\n0100 0000 0000 0000 \nlfs_dir_split EXIT: returned 0\nlfs_dir_split ENTRY: lfs=0x7ffccfb91368 dir=0x7ffccfb91108 source=0x7ffccfb91108 split=4 end=8 attrcount=4 attrs=0x7ffccfb91250\n--- dir_before: ptr=0x7ffccfb91108 len=32 ---\n2000 0000 2100 0000 2100 0000 0002 0000\n04fc 0f50 0800 0000 2800 0000 2900 0000\n--- tail_alloc_before: ptr=0x7ffccfb90f38 len=32 ---\n2b00 0000 2a00 0000 2a00 0000 0400 0000\nffff ffff 0000 0000 ffff ffff ffff ffff\n--- source_before: ptr=0x7ffccfb91108 len=32 ---\n2000 0000 2100 0000 2100 0000 0002 0000\n04fc 0f50 0800 0000 2800 0000 2900 0000\nlfs_dir_compact returned res=0\n--- tail_after: ptr=0x7ffccfb90f38 len=32 ---\n2a00 0000 2b00 0000 2b00 0000 f000 0000\n0efc 0f50 0400 0000 2800 0000 2900 0000\n--- source_after: ptr=0x7ffccfb91108 len=32 ---\n2000 0000 2100 0000 2100 0000 0002 0000\n04fc 0f50 0800 0000 2800 0000 2900 0000\n--- dir_after: ptr=0x7ffccfb91108 len=32 ---\n2000 0000 2100 0000 2100 0000 0002 0000\n04fc 0f50 0800 0001 2a00 0000 2b00 0000\n--- lfs_root_after: ptr=0x7ffccfb91398 len=8 ---\n0100 0000 0000 0000 \nlfs_dir_split EXIT:\n</execution_log>\n<additional code>Here are the definitions of symbols that are close to the target function lfs_dir_split:\ntypedef struct lfs {\n    lfs_cache_t rcache;\n    lfs_cache_t pcache;\n\n    lfs_block_t root[2];\n    struct lfs_mlist {\n        struct lfs_mlist *next;\n        uint16_t id;\n        uint8_t type;\n        lfs_mdir_t m;\n    } *mlist;\n    uint32_t seed;\n\n    lfs_gstate_t gstate;\n    lfs_gstate_t gdisk;\n    lfs_gstate_t gdelta;\n\n    struct lfs_lookahead {\n        lfs_block_t start;\n        lfs_block_t size;\n        lfs_block_t next;\n        lfs_block_t ckpoint;\n        uint8_t *buffer;\n    } lookahead;\n\n    const struct lfs_config *cfg;\n    lfs_size_t block_count;\n    lfs_size_t name_max;\n    lfs_size_t file_max;\n    lfs_size_t attr_max;\n    lfs_size_t inline_max;\n\n#ifdef LFS_MIGRATE\n    struct lfs1 *lfs1;\n#endif\n} lfs_t\n...\ntypedef struct lfs_mdir {\n    lfs_block_t pair[2];\n    uint32_t rev;\n    lfs_off_t off;\n    uint32_t etag;\n    uint16_t count;\n    bool erased;\n    bool split;\n    lfs_block_t tail[2];\n} lfs_mdir_t\n...\nstruct lfs_mattr {\n    lfs_tag_t tag;\n    const void *buffer;\n}\n</additional code>\n\n<instruction>\nJudge whether the report is correct or not.\n</instruction>\n",
  "is_report_correct": false,
  "explanation": "The claim is not proven by the provided snippet. While lfs_dir_split itself does not write through the parameter source (it only passes it to lfs_dir_compact and the runtime log shows source unchanged), MISRA 8.13 can only be enforced safely by examining the whole call chain. If lfs_dir_compact has a non-const parameter for source (lfs_mdir_t *), then lfs_dir_split cannot unilaterally change its prototype to const lfs_mdir_t * without also changing lfs_dir_compact (or inserting a cast). The report assumes lfs_dir_compact does not modify the pointed object, but that is not established from the code shown \u2014 the execution log shows no modification for the observed runs but does not prove lfs_dir_compact never modifies it in all cases. Therefore, on the evidence given the assertion of a definite MISRA 8.13 violation is not correct. To confirm a real violation, inspect the declaration/definition of lfs_dir_compact and all other callers: if none modify the pointed-to lfs_mdir_t and all prototypes can be changed, then source should be declared const and the violation would be valid."
}