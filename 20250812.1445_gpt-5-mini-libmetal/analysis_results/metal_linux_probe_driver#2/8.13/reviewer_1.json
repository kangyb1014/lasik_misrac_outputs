{
  "user_message": "An agent A claimed that the following metal_linux_probe_driver code violates the MISRA C 2023 rule 8.13.\n<misra_rule>\nMISRA C 2023 Rule 8.13 is A pointer should point to a const-qualified type whenever possible.\n.\n</misra_rule>\n<target_code>\nHere is the original code of metal_linux_probe_driver.\n```c\nstatic int metal_linux_probe_driver(struct linux_bus *lbus,\n\t\t\t\t    struct linux_driver *ldrv)\n{\n\tchar command[256];\n\tint ret;\n\n\tldrv->sdrv = sysfs_open_driver(lbus->bus_name, ldrv->drv_name);\n\n\t/* Try probing the module and then open the driver. */\n\tif (!ldrv->sdrv) {\n\t\tret = snprintf(command, sizeof(command),\n\t\t\t       \"modprobe %s > /dev/null 2>&1\", ldrv->mod_name);\n\t\tif (ret >= (int)sizeof(command))\n\t\t\treturn -EOVERFLOW;\n\t\tret = system(command);\n\t\tif (ret < 0) {\n\t\t\tmetal_log(METAL_LOG_WARNING,\n\t\t\t\t  \"%s: executing system command '%s' failed.\\n\",\n\t\t\t\t  __func__, command);\n\t\t}\n\t\tldrv->sdrv = sysfs_open_driver(lbus->bus_name, ldrv->drv_name);\n\t}\n\n\t/* Try sudo probing the module and then open the driver. */\n\tif (!ldrv->sdrv) {\n\t\tret = snprintf(command, sizeof(command),\n\t\t\t       \"sudo modprobe %s > /dev/null 2>&1\", ldrv->mod_name);\n\t\tif (ret >= (int)sizeof(command))\n\t\t\treturn -EOVERFLOW;\n\t\tret = system(command);\n\t\tif (ret < 0) {\n\t\t\tmetal_log(METAL_LOG_WARNING,\n\t\t\t\t  \"%s: executing system command '%s' failed.\\n\",\n\t\t\t\t  __func__, command);\n\t\t}\n\t\tldrv->sdrv = sysfs_open_driver(lbus->bus_name, ldrv->drv_name);\n\t}\n\n\t/* If all else fails... */\n\treturn ldrv->sdrv ? 0 : -ENODEV;\n}\n```\n</target_code>\n<scenario>\nThe agent A provided the following violation scenario:The parameter 'lbus' is not const-qualified although it is only read (only lbus->bus_name is accessed). According to MISRA C 2023 Rule 8.13 it should be declared as const struct linux_bus *lbus. Note: 'ldrv' must remain non-const because the function assigns to ldrv->sdrv, so it is correctly non-const.\n</scenario>\n<test_code>\nAlso, the agent A provided the following modified code that prints out the log to support their scenario:\n```c\n\nstatic int metal_linux_probe_driver(struct linux_bus *lbus,\n                                    struct linux_driver *ldrv)\n{\n    char command[256];\n    int ret;\n    FILE *logf = fopen(\"/tmp/logs/19.txt\", \"a\");\n\n    if (logf) {\n        fprintf(logf, \"ENTER %s: lbus=%p, lbus->bus_name='%s', ldrv=%p, ldrv->drv_name='%s', ldrv->mod_name='%s'\\n\",\n                __func__, (void *)lbus, lbus ? lbus->bus_name : \"(null)\", (void *)ldrv,\n                ldrv ? ldrv->drv_name : \"(null)\", ldrv ? ldrv->mod_name : \"(null)\");\n        fclose(logf);\n    }\n\n    ldrv->sdrv = sysfs_open_driver(lbus->bus_name, ldrv->drv_name);\n\n    if (logf == NULL) /* reopen when needed to avoid holding the file */\n        logf = fopen(\"/tmp/logs/19.txt\", \"a\");\n    if (logf) {\n        fprintf(logf, \"%s: after initial sysfs_open_driver -> sdrv=%p\\n\",\n                __func__, (void *)ldrv->sdrv);\n        fclose(logf);\n    }\n\n    /* Try probing the module and then open the driver. */\n    if (!ldrv->sdrv) {\n        ret = snprintf(command, sizeof(command),\n                       \"modprobe %s > /dev/null 2>&1\", ldrv->mod_name);\n\n        if (logf == NULL)\n            logf = fopen(\"/tmp/logs/19.txt\", \"a\");\n        if (logf) {\n            fprintf(logf, \"%s: snprintf returned %d, command='%s'\\n\",\n                    __func__, ret, command);\n            fclose(logf);\n        }\n\n        if (ret >= (int)sizeof(command))\n            return -EOVERFLOW;\n        ret = system(command);\n\n        if (logf == NULL)\n            logf = fopen(\"/tmp/logs/19.txt\", \"a\");\n        if (logf) {\n            fprintf(logf, \"%s: system(command) returned %d\\n\", __func__, ret);\n            if (ret < 0)\n                fprintf(logf, \"%s: system error: errno=%d (%s)\\n\", __func__, errno, strerror(errno));\n            fclose(logf);\n        }\n        metal_log(METAL_LOG_WARNING,\n                  \"%s: executing system command '%s' failed.\\n\",\n                  __func__, command);\n\n        ldrv->sdrv = sysfs_open_driver(lbus->bus_name, ldrv->drv_name);\n\n        if (logf == NULL)\n            logf = fopen(\"/tmp/logs/19.txt\", \"a\");\n        if (logf) {\n            fprintf(logf, \"%s: after sysfs_open_driver (modprobe) -> sdrv=%p\\n\",\n                    __func__, (void *)ldrv->sdrv);\n            fclose(logf);\n        }\n    }\n\n    /* Try sudo probing the module and then open the driver. */\n    if (!ldrv->sdrv) {\n        ret = snprintf(command, sizeof(command),\n                       \"sudo modprobe %s > /dev/null 2>&1\", ldrv->mod_name);\n\n        if (logf == NULL)\n            logf = fopen(\"/tmp/logs/19.txt\", \"a\");\n        if (logf) {\n            fprintf(logf, \"%s: snprintf (sudo) returned %d, command='%s'\\n\",\n                    __func__, ret, command);\n            fclose(logf);\n        }\n\n        if (ret >= (int)sizeof(command))\n            return -EOVERFLOW;\n        ret = system(command);\n\n        if (logf == NULL)\n            logf = fopen(\"/tmp/logs/19.txt\", \"a\");\n        if (logf) {\n            fprintf(logf, \"%s: system(sudo) returned %d\\n\", __func__, ret);\n            if (ret < 0)\n                fprintf(logf, \"%s: system(sudo) error: errno=%d (%s)\\n\", __func__, errno, strerror(errno));\n            fclose(logf);\n        }\n        metal_log(METAL_LOG_WARNING,\n                  \"%s: executing system command '%s' failed.\\n\",\n                  __func__, command);\n\n        ldrv->sdrv = sysfs_open_driver(lbus->bus_name, ldrv->drv_name);\n\n        if (logf == NULL)\n            logf = fopen(\"/tmp/logs/19.txt\", \"a\");\n        if (logf) {\n            fprintf(logf, \"%s: after sysfs_open_driver (sudo) -> sdrv=%p\\n\",\n                    __func__, (void *)ldrv->sdrv);\n            fclose(logf);\n        }\n    }\n\n    /* If all else fails... */\n    if (logf == NULL)\n        logf = fopen(\"/tmp/logs/19.txt\", \"a\");\n    if (logf) {\n        fprintf(logf, \"%s: exit -> returning %d, final sdrv=%p\\n\",\n                __func__, ldrv->sdrv ? 0 : -ENODEV, (void *)ldrv->sdrv);\n        fclose(logf);\n    }\n\n    return ldrv->sdrv ? 0 : -ENODEV;\n}\n\n```\nAfter executing all tests, we received the following output from the test code.\nFor this task, assume the following:\n- The test suite is exhaustive and has covered all edge cases.\n- There are no missing scenarios.\n- You must not include any caveats or question the test results.\n\nBased on this, analyze the output and validate the scenario accordingly.\n```\nENTER metal_linux_probe_driver: lbus=0x7f97b9debb60, lbus->bus_name='platform', ldrv=0x7f97b9debbc0, ldrv->drv_name='uio_pdrv_genirq', ldrv->mod_name='uio_pdrv_genirq'\nENTER metal_linux_probe_driver: lbus=0x55718b670260, lbus->bus_name='platform', ldrv=0x55718b6702c0, ldrv->drv_name='uio_pdrv_genirq', ldrv->mod_name='uio_pdrv_genirq'\n\n```\n\n</test_code>\n<response format>\nProvide your answer with these fields.\n- explanation: your evaluation of the scenario provided by the agent A.\n- is_report_correct: whether the report is correct or not (true/false)\n</response format>\n<instruction>   \nJudge whether the report is correct or not.\n</instruction>\n",
  "is_report_correct": true,
  "explanation": "The report is correct. In the shown function lbus is only read (only lbus->bus_name is accessed) and never used to modify the pointed-to object, so per MISRA C 2023 Rule 8.13 the parameter should be declared as pointer to const (e.g. const struct linux_bus *lbus). ldrv must remain non-const because ldrv->sdrv is written; changing lbus to const is safe and backwards-compatible (non-const actuals may be passed to a const parameter)."
}