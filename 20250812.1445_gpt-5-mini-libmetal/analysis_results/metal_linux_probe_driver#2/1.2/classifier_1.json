{
  "user_message": "<misra_rule>\nMISRA C 2023 Rule 1.2 is: Language extensions should not be used.\nYou should report only when the code uses any language compiler extensions that are explicitly stated as an extension in compiler documentations.\n</misra_rule>\n<response format>\nProvide your answer with these fields.\n- is_rule_violated: whether the rule is violated or not (true/false),\n- scenario: a specific violation scenario.\n</response format>\n<target_code>\nHere is the code of metal_linux_probe_driver:\n```c\nstatic int metal_linux_probe_driver(struct linux_bus *lbus,\n\t\t\t\t    struct linux_driver *ldrv)\n{\n\tchar command[256];\n\tint ret;\n\n\tldrv->sdrv = sysfs_open_driver(lbus->bus_name, ldrv->drv_name);\n\n\t/* Try probing the module and then open the driver. */\n\tif (!ldrv->sdrv) {\n\t\tret = snprintf(command, sizeof(command),\n\t\t\t       \"modprobe %s > /dev/null 2>&1\", ldrv->mod_name);\n\t\tif (ret >= (int)sizeof(command))\n\t\t\treturn -EOVERFLOW;\n\t\tret = system(command);\n\t\tif (ret < 0) {\n\t\t\tmetal_log(METAL_LOG_WARNING,\n\t\t\t\t  \"%s: executing system command '%s' failed.\\n\",\n\t\t\t\t  __func__, command);\n\t\t}\n\t\tldrv->sdrv = sysfs_open_driver(lbus->bus_name, ldrv->drv_name);\n\t}\n\n\t/* Try sudo probing the module and then open the driver. */\n\tif (!ldrv->sdrv) {\n\t\tret = snprintf(command, sizeof(command),\n\t\t\t       \"sudo modprobe %s > /dev/null 2>&1\", ldrv->mod_name);\n\t\tif (ret >= (int)sizeof(command))\n\t\t\treturn -EOVERFLOW;\n\t\tret = system(command);\n\t\tif (ret < 0) {\n\t\t\tmetal_log(METAL_LOG_WARNING,\n\t\t\t\t  \"%s: executing system command '%s' failed.\\n\",\n\t\t\t\t  __func__, command);\n\t\t}\n\t\tldrv->sdrv = sysfs_open_driver(lbus->bus_name, ldrv->drv_name);\n\t}\n\n\t/* If all else fails... */\n\treturn ldrv->sdrv ? 0 : -ENODEV;\n}\n```\n</target_code>\n<additional code>Here are the definitions of symbols that are close to the target function metal_linux_probe_driver:\nstruct linux_bus {\n\tstruct metal_bus\tbus;\n\tconst char\t\t*bus_name;\n\tstruct linux_driver\tdrivers[MAX_DRIVERS];\n\tstruct sysfs_bus\t*sbus;\n}\n...\nstruct linux_driver {\n\tconst char\t\t*drv_name;\n\tconst char\t\t*mod_name;\n\tconst char\t\t*cls_name;\n\tstruct sysfs_driver\t*sdrv;\n\tint\t\t\t(*dev_open)(struct linux_bus *lbus,\n\t\t\t\t\t    struct linux_device *ldev);\n\tvoid\t\t\t(*dev_close)(struct linux_bus *lbus,\n\t\t\t\t\t     struct linux_device *ldev);\n\tvoid\t\t\t(*dev_irq_ack)(struct linux_bus *lbus,\n\t\t\t\t\t     struct linux_device *ldev,\n\t\t\t\t\t     int irq);\n\tint\t\t\t(*dev_dma_map)(struct linux_bus *lbus,\n\t\t\t\t\t\tstruct linux_device *ldev,\n\t\t\t\t\t\tuint32_t dir,\n\t\t\t\t\t\tstruct metal_sg *sg_in,\n\t\t\t\t\t\tint nents_in,\n\t\t\t\t\t\tstruct metal_sg *sg_out);\n\tvoid\t\t\t(*dev_dma_unmap)(struct linux_bus *lbus,\n\t\t\t\t\t\tstruct linux_device *ldev,\n\t\t\t\t\t\tuint32_t dir,\n\t\t\t\t\t\tstruct metal_sg *sg,\n\t\t\t\t\t\tint nents);\n}\n...\n#define metal_log(level, fmt, __VA_ARGS__) ({if(_metal.common.log_handler&&level<=_metal.common.log_level)_metal.common.log_handler(level,metal_fmt(fmt),##__VA_ARGS__);\\\n})\n</additional code>\n<target_code>\nHere is the code fragment that you need to analyze:\n```c\n#define metal_log(level, fmt, __VA_ARGS__) ({if(_metal.common.log_handler&&level<=_metal.common.log_level)_metal.common.log_handler(level,metal_fmt(fmt),##__VA_ARGS__;\\)\n})\n```\nFocus on the above code fragment and judge whether it violates the rule 1.2 or not.\n</target_code>\n",
  "is_rule_violated": true,
  "scenario": "The macro metal_log uses GCC language extensions: the statement-expression form '({ ... })' and the GCC variadic-macro token-pasting extension '##__VA_ARGS__' to swallow a trailing comma. Both are documented compiler extensions (GCC) and therefore violate MISRA C 2023 Rule 1.2 (language extensions should not be used)."
}