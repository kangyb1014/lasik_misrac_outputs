{
  "user_message": "An agent A claimed that the following metal_uio_dev_open code violates the MISRA C 2023 rule 17.8.\n<misra_rule>\nMISRA C 2023 Rule 17.8 is A function parameter should not be modified.\nNote that the object referred to by a pointer parameter may be modified, but the pointer itself shall not be modified..\n</misra_rule>\n<target_code>\nHere is the original code of metal_uio_dev_open.\n```c\nstatic int metal_uio_dev_open(struct linux_bus *lbus, struct linux_device *ldev)\n{\n\tchar *instance, path[SYSFS_PATH_MAX];\n\tstruct linux_driver *ldrv = ldev->ldrv;\n\tunsigned long *phys, offset = 0, size = 0;\n\tstruct metal_io_region *io;\n\tstruct dlist *dlist;\n\tint result, i;\n\tvoid *virt;\n\tint irq_info;\n\n\n\tldev->fd = -1;\n\tldev->device.irq_info = (void *)-1;\n\n\tldev->sdev = sysfs_open_device(lbus->bus_name, ldev->dev_name);\n\tif (!ldev->sdev) {\n\t\tmetal_log(METAL_LOG_ERROR, \"device %s:%s not found\\n\",\n\t\t\t  lbus->bus_name, ldev->dev_name);\n\t\treturn -ENODEV;\n\t}\n\tmetal_log(METAL_LOG_DEBUG, \"opened sysfs device %s:%s\\n\",\n\t\t  lbus->bus_name, ldev->dev_name);\n\n\tresult = metal_uio_dev_bind(ldev, ldrv);\n\tif (result)\n\t\treturn result;\n\n\tresult = snprintf(path, sizeof(path), \"%s/uio\", ldev->sdev->path);\n\tif (result >= (int)sizeof(path))\n\t\treturn -EOVERFLOW;\n\tdlist = sysfs_open_directory_list(path);\n\tif (!dlist) {\n\t\tmetal_log(METAL_LOG_ERROR, \"failed to scan class path %s\\n\",\n\t\t\t  path);\n\t\treturn -errno;\n\t}\n\n\tdlist_for_each_data(dlist, instance, char) {\n\t\tresult = snprintf(ldev->cls_path, sizeof(ldev->cls_path),\n\t\t\t\t  \"%s/%s\", path, instance);\n\t\tif (result >= (int)sizeof(ldev->cls_path))\n\t\t\treturn -EOVERFLOW;\n\t\tresult = snprintf(ldev->dev_path, sizeof(ldev->dev_path),\n\t\t\t\t  \"/dev/%s\", instance);\n\t\tif (result >= (int)sizeof(ldev->dev_path))\n\t\t\treturn -EOVERFLOW;\n\t\tbreak;\n\t}\n\tsysfs_close_list(dlist);\n\n\tif (sysfs_path_is_dir(ldev->cls_path) != 0) {\n\t\tmetal_log(METAL_LOG_ERROR, \"invalid device class path %s\\n\",\n\t\t\t  ldev->cls_path);\n\t\treturn -ENODEV;\n\t}\n\n\ti = 0;\n\tdo {\n\t\tif (!access(ldev->dev_path, F_OK))\n\t\t\tbreak;\n\t\tusleep(10);\n\t\ti++;\n\t} while (i < 1000);\n\tif (i >= 1000) {\n\t\tmetal_log(METAL_LOG_ERROR, \"failed to open file %s, timeout.\\n\",\n\t\t\t  ldev->dev_path);\n\t\treturn -ENODEV;\n\t}\n\tresult = metal_open(ldev->dev_path, 0);\n\tif (result < 0) {\n\t\tmetal_log(METAL_LOG_ERROR, \"failed to open device %s\\n\",\n\t\t\t  ldev->dev_path, strerror(-result));\n\t\treturn result;\n\t}\n\tldev->fd = result;\n\n\tmetal_log(METAL_LOG_DEBUG, \"opened %s:%s as %s\\n\",\n\t\t  lbus->bus_name, ldev->dev_name, ldev->dev_path);\n\n\tfor (i = 0, result = 0; !result && i < METAL_MAX_DEVICE_REGIONS; i++) {\n\t\tphys = &ldev->region_phys[ldev->device.num_regions];\n\t\tresult = (result ? result :\n\t\t\t metal_uio_read_map_attr(ldev, i, \"offset\", &offset));\n\t\tresult = (result ? result :\n\t\t\t metal_uio_read_map_attr(ldev, i, \"addr\", phys));\n\t\tresult = (result ? result :\n\t\t\t metal_uio_read_map_attr(ldev, i, \"size\", &size));\n\t\tresult = (result ? result :\n\t\t\t metal_map(ldev->fd, i * getpagesize(), size, 0, 0, &virt));\n\t\tif (!result) {\n\t\t\tio = &ldev->device.regions[ldev->device.num_regions];\n\t\t\tmetal_io_init(io, virt, phys, size, -1, 0, NULL);\n\t\t\tldev->device.num_regions++;\n\t\t}\n\t}\n\n\tirq_info = 1;\n\tif (write(ldev->fd, &irq_info, sizeof(irq_info)) <= 0) {\n\t\tmetal_log(METAL_LOG_INFO,\n\t\t\t  \"%s: No IRQ for device %s.\\n\",\n\t\t\t  __func__, ldev->dev_name);\n\t\tldev->device.irq_num =  0;\n\t\tldev->device.irq_info = (void *)-1;\n\t} else {\n\t\tldev->device.irq_num =  1;\n\t\tldev->device.irq_info = (void *)(intptr_t)ldev->fd;\n\t\tmetal_linux_irq_register_dev(&ldev->device, ldev->fd);\n\t}\n\n\treturn 0;\n}\n```\n</target_code>\n<scenario>\nThe agent A provided the following violation scenario:Violation: the function modifies its non-pointer parameters. Specifically, 'flags' is changed (flags |= MAP_SHARED; and later flags = MAP_PRIVATE | MAP_ANONYMOUS;) and 'fd' is assigned (fd = -1;) inside the function. (Writing to *result is allowed because it modifies the object pointed to by a pointer parameter, not the pointer itself.)\n</scenario>\n<test_code>\nAlso, the agent A provided the following modified code that prints out the log to support their scenario:\n```c\n\nstatic int metal_uio_dev_open(struct linux_bus *lbus, struct linux_device *ldev)\n{\n\tchar *instance, path[SYSFS_PATH_MAX];\n\tstruct linux_driver *ldrv = ldev->ldrv;\n\tunsigned long *phys, offset = 0, size = 0;\n\tstruct metal_io_region *io;\n\tstruct dlist *dlist;\n\tint result, i;\n\tvoid *virt;\n\tint irq_info;\n\n\t/* Log initial entry and relevant state */\n\t{\n\t\tFILE *logf = fopen(\"/tmp/logs/13.txt\", \"a\");\n\t\tif (logf) {\n\t\t\tfprintf(logf, \"ENTER metal_uio_dev_open: bus=%s device=%s ldev->fd=%d ldev->device.irq_info=%p\\n\",\n\t\t\t\tlbus->bus_name ? lbus->bus_name : \"(null)\",\n\t\t\t\tldev->dev_name ? ldev->dev_name : \"(null)\",\n\t\t\t\tldev->fd, ldev->device.irq_info);\n\t\t\tfclose(logf);\n\t\t}\n\t}\n\n\tldev->fd = -1;\n\tldev->device.irq_info = (void *)-1;\n\n\t/* Log after clearing fd and irq_info (this is the observed state change of ldev->fd) */\n\t{\n\t\tFILE *logf = fopen(\"/tmp/logs/13.txt\", \"a\");\n\t\tif (logf) {\n\t\t\tfprintf(logf, \"AFTER init: ldev->fd=%d ldev->device.irq_info=%p\\n\",\n\t\t\t\tldev->fd, ldev->device.irq_info);\n\t\t\tfclose(logf);\n\t\t}\n\t}\n\n\tldev->sdev = sysfs_open_device(lbus->bus_name, ldev->dev_name);\n\tif (!ldev->sdev) {\n\t\t{\n\t\t\tFILE *logf = fopen(\"/tmp/logs/13.txt\", \"a\");\n\t\t\tif (logf) {\n\t\t\t\tfprintf(logf, \"ERROR: sysfs_open_device failed for %s:%s\\n\",\n\t\t\t\t\tlbus->bus_name ? lbus->bus_name : \"(null)\",\n\t\t\t\t\tldev->dev_name ? ldev->dev_name : \"(null)\");\n\t\t\t\tfclose(logf);\n\t\t\t}\n\t\t}\n\t\tmetal_log(METAL_LOG_ERROR, \"device %s:%s not found\\n\",\n\t\t\t  lbus->bus_name, ldev->dev_name);\n\t\treturn -ENODEV;\n\t}\n\tmetal_log(METAL_LOG_DEBUG, \"opened sysfs device %s:%s\\n\",\n\t\t  lbus->bus_name, ldev->dev_name);\n\n\t/* Log sdev path */\n\t{\n\t\tFILE *logf = fopen(\"/tmp/logs/13.txt\", \"a\");\n\t\tif (logf) {\n\t\t\tfprintf(logf, \"sdev->path=%s\\n\", ldev->sdev->path ? ldev->sdev->path : \"(null)\");\n\t\t\tfclose(logf);\n\t\t}\n\t}\n\n\tresult = metal_uio_dev_bind(ldev, ldrv);\n\t{\n\t\tFILE *logf = fopen(\"/tmp/logs/13.txt\", \"a\");\n\t\tif (logf) {\n\t\t\tfprintf(logf, \"metal_uio_dev_bind returned %d\\n\", result);\n\t\t\tfclose(logf);\n\t\t}\n\t}\n\tif (result)\n\t\treturn result;\n\n\tresult = snprintf(path, sizeof(path), \"%s/uio\", ldev->sdev->path);\n\tif (result >= (int)sizeof(path)) {\n\t\t{\n\t\t\tFILE *logf = fopen(\"/tmp/logs/13.txt\", \"a\");\n\t\t\tif (logf) {\n\t\t\t\tfprintf(logf, \"ERROR: snprintf overflow creating path (needed %d, max %zu)\\n\", result, sizeof(path));\n\t\t\t\tfclose(logf);\n\t\t\t}\n\t\t}\n\t\treturn -EOVERFLOW;\n\t}\n\tdlist = sysfs_open_directory_list(path);\n\tif (!dlist) {\n\t\tmetal_log(METAL_LOG_ERROR, \"failed to scan class path %s\\n\",\n\t\t\t  path);\n\t\t{\n\t\t\tFILE *logf = fopen(\"/tmp/logs/13.txt\", \"a\");\n\t\t\tif (logf) {\n\t\t\t\tfprintf(logf, \"ERROR: sysfs_open_directory_list(%s) failed, errno=%d\\n\", path, errno);\n\t\t\t\tfclose(logf);\n\t\t\t}\n\t\t}\n\t\treturn -errno;\n\t}\n\n\tdlist_for_each_data(dlist, instance, char) {\n\t\tresult = snprintf(ldev->cls_path, sizeof(ldev->cls_path),\n\t\t\t\t  \"%s/%s\", path, instance);\n\t\tif (result >= (int)sizeof(ldev->cls_path))\n\t\t\treturn -EOVERFLOW;\n\t\tresult = snprintf(ldev->dev_path, sizeof(ldev->dev_path),\n\t\t\t\t  \"/dev/%s\", instance);\n\t\tif (result >= (int)sizeof(ldev->dev_path))\n\t\t\treturn -EOVERFLOW;\n\t\t/* Log selected instance and paths */\n\t\t{\n\t\t\tFILE *logf = fopen(\"/tmp/logs/13.txt\", \"a\");\n\t\t\tif (logf) {\n\t\t\t\tfprintf(logf, \"FOUND instance=%s cls_path=%s dev_path=%s\\n\",\n\t\t\t\t\tinstance ? instance : \"(null)\", ldev->cls_path, ldev->dev_path);\n\t\t\t\tfclose(logf);\n\t\t\t}\n\t\t}\n\t\tbreak;\n\t}\n\tsysfs_close_list(dlist);\n\n\tif (sysfs_path_is_dir(ldev->cls_path) != 0) {\n\t\tmetal_log(METAL_LOG_ERROR, \"invalid device class path %s\\n\",\n\t\t\t  ldev->cls_path);\n\t\t{\n\t\t\tFILE *logf = fopen(\"/tmp/logs/13.txt\", \"a\");\n\t\t\tif (logf) {\n\t\t\t\tfprintf(logf, \"ERROR: cls_path not a directory: %s\\n\", ldev->cls_path);\n\t\t\t\tfclose(logf);\n\t\t\t}\n\t\t}\n\t\treturn -ENODEV;\n\t}\n\n\ti = 0;\n\tdo {\n\t\tif (!access(ldev->dev_path, F_OK))\n\t\t\tbreak;\n\t\tusleep(10);\n\t\ti++;\n\t} while (i < 1000);\n\tif (i >= 1000) {\n\t\tmetal_log(METAL_LOG_ERROR, \"failed to open file %s, timeout.\\n\",\n\t\t\t  ldev->dev_path);\n\t\t{\n\t\t\tFILE *logf = fopen(\"/tmp/logs/13.txt\", \"a\");\n\t\t\tif (logf) {\n\t\t\t\tfprintf(logf, \"ERROR: timeout waiting for dev_path=%s after %d attempts\\n\", ldev->dev_path, i);\n\t\t\t\tfclose(logf);\n\t\t\t}\n\t\t}\n\t\treturn -ENODEV;\n\t}\n\tresult = metal_open(ldev->dev_path, 0);\n\tif (result < 0) {\n\t\tmetal_log(METAL_LOG_ERROR, \"failed to open device %s\\n\",\n\t\t\t  ldev->dev_path, strerror(-result));\n\t\t{\n\t\t\tFILE *logf = fopen(\"/tmp/logs/13.txt\", \"a\");\n\t\t\tif (logf) {\n\t\t\t\tfprintf(logf, \"ERROR: metal_open(%s) returned %d (%s)\\n\", ldev->dev_path, result, strerror(-result));\n\t\t\t\tfclose(logf);\n\t\t\t}\n\t\t}\n\t\treturn result;\n\t}\n\tldev->fd = result;\n\n\t/* Log the assignment to ldev->fd (evidence of state change) */\n\t{\n\t\tFILE *logf = fopen(\"/tmp/logs/13.txt\", \"a\");\n\t\tif (logf) {\n\t\t\tfprintf(logf, \"AFTER metal_open: assigned ldev->fd=%d (result=%d)\\n\", ldev->fd, result);\n\t\t\tfclose(logf);\n\t\t}\n\t}\n\n\tmetal_log(METAL_LOG_DEBUG, \"opened %s:%s as %s\\n\",\n\t\t  lbus->bus_name, ldev->dev_name, ldev->dev_path);\n\n\tfor (i = 0, result = 0; !result && i < METAL_MAX_DEVICE_REGIONS; i++) {\n\t\tphys = &ldev->region_phys[ldev->device.num_regions];\n\t\tresult = (result ? result :\n\t\t\t metal_uio_read_map_attr(ldev, i, \"offset\", &offset));\n\t\tresult = (result ? result :\n\t\t\t metal_uio_read_map_attr(ldev, i, \"addr\", phys));\n\t\tresult = (result ? result :\n\t\t\t metal_uio_read_map_attr(ldev, i, \"size\", &size));\n\t\tresult = (result ? result :\n\t\t\t metal_map(ldev->fd, i * getpagesize(), size, 0, 0, &virt));\n\t\tif (!result) {\n\t\t\tio = &ldev->device.regions[ldev->device.num_regions];\n\t\t\tmetal_io_init(io, virt, phys, size, -1, 0, NULL);\n\t\t\tldev->device.num_regions++;\n\t\t}\n\t\t/* Log each region attempt */\n\t\t{\n\t\t\tFILE *logf = fopen(\"/tmp/logs/13.txt\", \"a\");\n\t\t\tif (logf) {\n\t\t\t\tfprintf(logf, \"region i=%d num_regions=%d offset=%lu phys=%lu size=%lu result=%d virt=%p\\n\",\n\t\t\t\t\ti, ldev->device.num_regions, offset, phys ? (unsigned long)*phys : 0UL, size, result, virt);\n\t\t\t\tfclose(logf);\n\t\t\t}\n\t\t}\n\t}\n\n\tirq_info = 1;\n\tif (write(ldev->fd, &irq_info, sizeof(irq_info)) <= 0) {\n\t\tmetal_log(METAL_LOG_INFO,\n\t\t\t  \"%s: No IRQ for device %s.\\n\",\n\t\t\t  __func__, ldev->dev_name);\n\t\tldev->device.irq_num =  0;\n\t\tldev->device.irq_info = (void *)-1;\n\t\t/* Log lack of IRQ and state */\n\t\t{\n\t\t\tFILE *logf = fopen(\"/tmp/logs/13.txt\", \"a\");\n\t\t\tif (logf) {\n\t\t\t\tfprintf(logf, \"NO IRQ: write to fd=%d failed; irq_num=%d irq_info=%p\\n\",\n\t\t\t\t\tldev->fd, ldev->device.irq_num, ldev->device.irq_info);\n\t\t\t\tfclose(logf);\n\t\t\t}\n\t\t}\n\t} else {\n\t\tldev->device.irq_num =  1;\n\t\tldev->device.irq_info = (void *)(intptr_t)ldev->fd;\n\t\tmetal_linux_irq_register_dev(&ldev->device, ldev->fd);\n\t\t/* Log successful IRQ registration and state */\n\t\t{\n\t\t\tFILE *logf = fopen(\"/tmp/logs/13.txt\", \"a\");\n\t\t\tif (logf) {\n\t\t\t\tfprintf(logf, \"IRQ registered: fd=%d irq_num=%d irq_info=%p\\n\",\n\t\t\t\t\tldev->fd, ldev->device.irq_num, ldev->device.irq_info);\n\t\t\t\tfclose(logf);\n\t\t\t}\n\t\t}\n\t}\n\n\t/* Final state log before normal return */\n\t{\n\t\tFILE *logf = fopen(\"/tmp/logs/13.txt\", \"a\");\n\t\tif (logf) {\n\t\t\tfprintf(logf, \"EXIT metal_uio_dev_open: ldev->fd=%d device.num_regions=%d irq_num=%d irq_info=%p\\n\",\n\t\t\t\tldev->fd, ldev->device.num_regions, ldev->device.irq_num, ldev->device.irq_info);\n\t\t\tfclose(logf);\n\t\t}\n\t}\n\n\treturn 0;\n}\n\n```\nThe test code was compiled successfully, but the test log is empty for metal_uio_dev_open. The test suite might not cover this function or the test code might be not suitable to print important information.\n</test_code>\n<response format>\nProvide your answer with these fields.\n- explanation: your evaluation of the scenario provided by the agent A.\n- is_report_correct: whether the report is correct or not (true/false)\n</response format>\n<instruction>   \nJudge whether the report is correct or not.\n</instruction>\n",
  "is_report_correct": false,
  "explanation": "Incorrect. The function parameters are pointers (struct linux_bus *lbus, struct linux_device *ldev). MISRA C 2023 Rule 17.8 permits modifying the object referred to by a pointer parameter (e.g. ldev->fd = -1, ldev->device.irq_info = ...), but forbids reassigning the pointer parameter itself. In the provided code no pointer parameter (ldev or lbus) is reassigned. There is no 'flags' or parameter named 'fd' in this function \u2014 ldev->fd is a member of the object pointed to by ldev, not a function parameter. Therefore the reported violation is not applicable to this function."
}