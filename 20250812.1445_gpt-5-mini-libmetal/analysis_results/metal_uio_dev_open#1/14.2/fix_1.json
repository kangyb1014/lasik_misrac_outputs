{
  "user_message": "<target code>Here is the code that failed to compile:\n```c\n\nstatic int metal_uio_dev_open(struct linux_bus *lbus, struct linux_device *ldev)\n{\n\tchar *instance, path[SYSFS_PATH_MAX];\n\tstruct linux_driver *ldrv = ldev->ldrv;\n\tunsigned long *phys, offset = 0, size = 0;\n\tstruct metal_io_region *io;\n\tstruct dlist *dlist;\n\tint result, i;\n\tvoid *virt;\n\tint irq_info;\n\n\t/* Probe log file handle. We keep it open during this function to\n\t * capture the control flow and states relevant to the for-loop\n\t * that demonstrates the MISRA Rule 14.2 violation scenario.\n\t */\n\tFILE *logf = fopen(\"/tmp/logs/12.txt\", \"a\");\n\tif (logf) {\n\t\tfprintf(logf, \"\\n=== metal_uio_dev_open start: device=%s:%s\\n\",\n\t\t\tlbus->bus_name ? lbus->bus_name : \"(null)\",\n\t\t\tldev->dev_name ? ldev->dev_name : \"(null)\");\n\t\tfflush(logf);\n\t}\n\n\tldev->fd = -1;\n\tldev->device.irq_info = (void *)-1;\n\n\tldev->sdev = sysfs_open_device(lbus->bus_name, ldev->dev_name);\n\tif (!ldev->sdev) {\n\t\tmetal_log(METAL_LOG_ERROR, \"device %s:%s not found\\n\",\n\t\t\tlbus->bus_name, ldev->dev_name);\n\t\tif (logf) {\n\t\t\tfprintf(logf, \"sysfs_open_device failed for %s:%s\\n\",\n\t\t\t\tlbus->bus_name, ldev->dev_name);\n\t\t\tfclose(logf);\n\t\t}\n\t\treturn -ENODEV;\n\t}\n\tmetal_log(METAL_LOG_DEBUG, \"opened sysfs device %s:%s\\n\",\n\t\tlbus->bus_name, ldev->dev_name);\n\tif (logf) {\n\t\tfprintf(logf, \"opened sysfs device: sdev->path=%s\\n\",\n\t\t\tldev->sdev->path ? ldev->sdev->path : \"(null)\");\n\t\tfflush(logf);\n\t}\n\n\tresult = metal_uio_dev_bind(ldev, ldrv);\n\tif (result) {\n\t\tif (logf) {\n\t\t\tfprintf(logf, \"metal_uio_dev_bind returned %d\\n\", result);\n\t\t\tfclose(logf);\n\t\t}\n\t\treturn result;\n\t}\n\n\tresult = snprintf(path, sizeof(path), \"%s/uio\", ldev->sdev->path);\n\tif (result >= (int)sizeof(path)) {\n\t\tif (logf) {\n\t\t\tfprintf(logf, \"snprintf path overflow\\n\");\n\t\t\tfclose(logf);\n\t\t}\n\t\treturn -EOVERFLOW;\n\t}\n\tdlist = sysfs_open_directory_list(path);\n\tif (!dlist) {\n\t\tmetal_log(METAL_LOG_ERROR, \"failed to scan class path %s\\n\",\n\t\t\tpath);\n\t\tif (logf) {\n\t\t\tfprintf(logf, \"sysfs_open_directory_list failed for path=%s\\n\", path);\n\t\t\tfclose(logf);\n\t\t}\n\t\treturn -errno;\n\t}\n\n\tdlist_for_each_data(dlist, instance, char) {\n\t\tresult = snprintf(ldev->cls_path, sizeof(ldev->cls_path),\n\t\t\t\t  \"%s/%s\", path, instance);\n\t\tif (result >= (int)sizeof(ldev->cls_path)) {\n\t\t\tif (logf) { fprintf(logf, \"cls_path overflow\\n\"); fclose(logf); }\n\t\t\treturn -EOVERFLOW;\n\t\t}\n\t\tresult = snprintf(ldev->dev_path, sizeof(ldev->dev_path),\n\t\t\t\t  \"/dev/%s\", instance);\n\t\tif (result >= (int)sizeof(ldev->dev_path)) {\n\t\t\tif (logf) { fprintf(logf, \"dev_path overflow\\n\"); fclose(logf); }\n\t\t\treturn -EOVERFLOW;\n\t\t}\n\t\tbreak;\n\t}\n\tsysfs_close_list(dlist);\n\n\tif (sysfs_path_is_dir(ldev->cls_path) != 0) {\n\t\tmetal_log(METAL_LOG_ERROR, \"invalid device class path %s\\n\",\n\t\t\tldev->cls_path);\n\t\tif (logf) { fprintf(logf, \"invalid class path=%s\\n\", ldev->cls_path); fclose(logf); }\n\t\treturn -ENODEV;\n\t}\n\n\ti = 0;\n\tdo {\n\t\tif (!access(ldev->dev_path, F_OK))\n\t\t\tbreak;\n\t\tusleep(10);\n\t\ti++;\n\t} while (i < 1000);\n\tif (i >= 1000) {\n\t\tmetal_log(METAL_LOG_ERROR, \"failed to open file %s, timeout.\\n\",\n\t\t\tldev->dev_path);\n\t\tif (logf) { fprintf(logf, \"timeout waiting for dev_path=%s\\n\", ldev->dev_path); fclose(logf); }\n\t\treturn -ENODEV;\n\t}\n\tresult = metal_open(ldev->dev_path, 0);\n\tif (result < 0) {\n\t\tmetal_log(METAL_LOG_ERROR, \"failed to open device %s\\n\",\n\t\t\tldev->dev_path, strerror(-result));\n\t\tif (logf) { fprintf(logf, \"metal_open failed for %s: %d\\n\", ldev->dev_path, result); fclose(logf); }\n\t\treturn result;\n\t}\n\tldev->fd = result;\n\n\tmetal_log(METAL_LOG_DEBUG, \"opened %s:%s as %s\\n\",\n\t\tlbus->bus_name, ldev->dev_name, ldev->dev_path);\n\tif (logf) {\n\t\tfprintf(logf, \"device fd=%d\\n\", ldev->fd);\n\t\tfflush(logf);\n\t}\n\n\t/*\n\t * The original code used a for-loop which initialized both 'i' and\n\t * 'result' in the first clause and had the second clause depend on\n\t * 'result' while 'result' was assigned within the loop body. This\n\t * is the situation reported as violating MISRA C 2023 Rule 14.2.\n\t *\n\t * To capture the control flow and state for repro/evidence we\n\t * explicitly keep the same logic but expand the loop into a\n\t * while-loop with detailed logging around condition evaluation,\n\t * body execution and increment.\n\t */\n\n\t/* Initialize loop variables exactly as original for-clause */\n\ti = 0;\n\tresult = 0;\n\tif (logf) {\n\t\tfprintf(logf, \"loop-init: i=%d result=%d\\n\", i, result);\n\t\tfflush(logf);\n\t}\n\n\t/* Loop condition and body with probes */\n\twhile (!result && i < METAL_MAX_DEVICE_REGIONS) {\n\t\tif (logf) {\n\t\t\tfprintf(logf, \"cond-eval: i=%d result=%d\\n\", i, result);\n\t\t\tfflush(logf);\n\t\t}\n\n\t\t/* begin original loop body */\n\t\tphys = &ldev->region_phys[ldev->device.num_regions];\n\n\t\t/* Each assignment to 'result' mirrors the original short-circuit style\n\t\t * but we add logging after each to capture when and how 'result'\n\t\t * changes during the body execution.\n\t\t */\n\t\tresult = (result ? result :\n\t\t\t metal_uio_read_map_attr(ldev, i, \"offset\", &offset));\n\t\tif (logf) { fprintf(logf, \"after read_map_attr(offset): i=%d result=%d offset=%lu\\n\", i, result, offset); fflush(logf); }\n\n\t\tresult = (result ? result :\n\t\t\t metal_uio_read_map_attr(ldev, i, \"addr\", phys));\n\t\tif (logf) { fprintf(logf, \"after read_map_attr(addr): i=%d result=%d phys=%lu\\n\", i, result, (unsigned long)*phys); fflush(logf); }\n\n\t\tresult = (result ? result :\n\t\t\t metal_uio_read_map_attr(ldev, i, \"size\", &size));\n\t\tif (logf) { fprintf(logf, \"after read_map_attr(size): i=%d result=%d size=%lu\\n\", i, result, size); fflush(logf); }\n\n\t\tresult = (result ? result :\n\t\t\t metal_map(ldev->fd, i * getpagesize(), size, 0, 0, &virt));\n\t\tif (logf) { fprintf(logf, \"after metal_map: i=%d result=%d virt=%p\\n\", i, result, virt); fflush(logf); }\n\n\t\tif (!result) {\n\t\t\naio = &ldev->device.regions[ldev->device.num_regions];\n\t\t\t/* preserve original behaviour */\n\t\t\tmetal_io_init(io, virt, phys, size, -1, 0, NULL);\n\t\t\tldev->device.num_regions++;\n\t\t\tif (logf) {\n\t\t\t\tfprintf(logf, \"mapped region: idx=%d phys=%lu size=%lu virt=%p num_regions=%d\\n\",\n\t\t\t\t\ti, (unsigned long)*phys, size, virt, ldev->device.num_regions);\n\t\t\t\tfflush(logf);\n\t\t\t}\n\t\t} else {\n\t\t\tif (logf) {\n\t\t\t\tfprintf(logf, \"mapping failed at iteration %d with result=%d\\n\", i, result);\n\t\t\t\tfflush(logf);\n\t\t\t}\n\t\t}\n\t\t/* end original loop body */\n\n\t\tif (logf) {\n\t\t\tfprintf(logf, \"before-incr: i=%d result=%d\\n\", i, result);\n\t\t\tfflush(logf);\n\t\t}\n\n\t\t/* increment as original for-clause's third expression */\n\t\ti++;\n\n\t\tif (logf) {\n\t\t\tfprintf(logf, \"after-incr: i=%d result=%d\\n\", i, result);\n\t\t\tfflush(logf);\n\t\t}\n\t}\n\n\tif (logf) {\n\t\tfprintf(logf, \"loop-exit: i=%d result=%d num_regions=%d\\n\",\n\t\t\ti, result, ldev->device.num_regions);\n\t\tfflush(logf);\n\t\t/* keep log open for any later logs in this function, then close at end */\n\t}\n\n\tirq_info = 1;\n\tif (write(ldev->fd, &irq_info, sizeof(irq_info)) <= 0) {\n\t\tmetal_log(METAL_LOG_INFO,\n\t\t\t\"%s: No IRQ for device %s.\\n\",\n\t\t\t__func__, ldev->dev_name);\n\t\tldev->device.irq_num =  0;\n\t\tldev->device.irq_info = (void *)-1;\n\t\tif (logf) { fprintf(logf, \"no IRQ for device %s\\n\", ldev->dev_name); fflush(logf); }\n\t} else {\n\t\tldev->device.irq_num =  1;\n\t\tldev->device.irq_info = (void *)(intptr_t)ldev->fd;\n\t\tmetal_linux_irq_register_dev(&ldev->device, ldev->fd);\n\t\tif (logf) { fprintf(logf, \"registered IRQ: irq_num=%d irq_info=%p\\n\", ldev->device.irq_num, ldev->device.irq_info); fflush(logf); }\n\t}\n\n\tif (logf) {\n\t\tfprintf(logf, \"=== metal_uio_dev_open end: return=0\\n\");\n\t\tfclose(logf);\n\t}\n\n\treturn 0;\n}\n\n```\n</target code>\n<build error>\nThe build failed with the following error:\n```\n-- Build type:  \n-- Host:    Linux/x86_64\n-- Target:  Linux/x86_64\n-- Machine: Generic\n-- Vendor: none\n/tmp/tmplb520r49/src/lib/system/linux/device.c: In function 'metal_uio_dev_open':\n/tmp/tmplb520r49/src/lib/system/linux/device.c:336:1: error: 'aio' undeclared (first use in this function); did you mean 'io'?\n  336 | aio = &ldev->device.regions[ldev->device.num_regions];\n      | ^~~\n      | io\n/tmp/tmplb520r49/src/lib/system/linux/device.c:336:1: note: each undeclared identifier is reported only once for each function it appears in\ngmake[2]: *** [lib/CMakeFiles/metal-shared.dir/build.make:216: lib/CMakeFiles/metal-shared.dir/system/linux/device.c.o] Error 1\ngmake[1]: *** [CMakeFiles/Makefile2:291: lib/CMakeFiles/metal-shared.dir/all] Error 2\ngmake: *** [Makefile:146: all] Error 2\n```\n</build error>\n<response format>\nProvide your answer with these answers.\n- fixed_test_code: the fixed test code that compiles successfully.\n- explanation: a brief explanation of the changes you made to fix the code.\nHere are the constraints for the test code:\n- The test code MUST be compilable and executable.\n- The test code MUST include line breaks.\n- The test code MUST preserve the original logic of metal_uio_dev_open as much as possible.\n- You MUST not define the main function.\n- You MUST not define macros.\n- The test code MUST not contain any mock functions.\n</response format>\n<instruction>\nPlease fix the code so that it compiles successfully.\n</instruction>\n",
  "fixed_test_code": "static int metal_uio_dev_open(struct linux_bus *lbus, struct linux_device *ldev)\n{\n\tchar *instance, path[SYSFS_PATH_MAX];\n\tstruct linux_driver *ldrv = ldev->ldrv;\n\tunsigned long *phys, offset = 0, size = 0;\n\tstruct metal_io_region *io;\n\tstruct dlist *dlist;\n\tint result, i;\n\tvoid *virt;\n\tint irq_info;\n\n\t/* Probe log file handle. We keep it open during this function to\n\t * capture the control flow and states relevant to the for-loop\n\t * that demonstrates the MISRA Rule 14.2 violation scenario.\n\t */\n\tFILE *logf = fopen(\"/tmp/logs/12.txt\", \"a\");\n\tif (logf) {\n\t\tfprintf(logf, \"\\n=== metal_uio_dev_open start: device=%s:%s\\n\",\n\t\t\tlbus->bus_name ? lbus->bus_name : \"(null)\",\n\t\t\tldev->dev_name ? ldev->dev_name : \"(null)\");\n\t\tfflush(logf);\n\t}\n\n\tldev->fd = -1;\n\tldev->device.irq_info = (void *)-1;\n\n\tldev->sdev = sysfs_open_device(lbus->bus_name, ldev->dev_name);\n\tif (!ldev->sdev) {\n\t\tmetal_log(METAL_LOG_ERROR, \"device %s:%s not found\\n\",\n\t\t\tlbus->bus_name, ldev->dev_name);\n\t\tif (logf) {\n\t\t\tfprintf(logf, \"sysfs_open_device failed for %s:%s\\n\",\n\t\t\t\tlbus->bus_name, ldev->dev_name);\n\t\t\tfclose(logf);\n\t\t}\n\t\treturn -ENODEV;\n\t}\n\tmetal_log(METAL_LOG_DEBUG, \"opened sysfs device %s:%s\\n\",\n\t\tlbus->bus_name, ldev->dev_name);\n\tif (logf) {\n\t\tfprintf(logf, \"opened sysfs device: sdev->path=%s\\n\",\n\t\t\tldev->sdev->path ? ldev->sdev->path : \"(null)\");\n\t\tfflush(logf);\n\t}\n\n\tresult = metal_uio_dev_bind(ldev, ldrv);\n\tif (result) {\n\t\tif (logf) {\n\t\t\tfprintf(logf, \"metal_uio_dev_bind returned %d\\n\", result);\n\t\t\tfclose(logf);\n\t\t}\n\t\treturn result;\n\t}\n\n\tresult = snprintf(path, sizeof(path), \"%s/uio\", ldev->sdev->path);\n\tif (result >= (int)sizeof(path)) {\n\t\tif (logf) {\n\t\t\tfprintf(logf, \"snprintf path overflow\\n\");\n\t\t\tfclose(logf);\n\t\t}\n\t\treturn -EOVERFLOW;\n\t}\n\tdlist = sysfs_open_directory_list(path);\n\tif (!dlist) {\n\t\tmetal_log(METAL_LOG_ERROR, \"failed to scan class path %s\\n\",\n\t\t\tpath);\n\t\tif (logf) {\n\t\t\tfprintf(logf, \"sysfs_open_directory_list failed for path=%s\\n\", path);\n\t\t\tfclose(logf);\n\t\t}\n\t\treturn -errno;\n\t}\n\n\tdlist_for_each_data(dlist, instance, char) {\n\t\tresult = snprintf(ldev->cls_path, sizeof(ldev->cls_path),\n\t\t\t  \"%s/%s\", path, instance);\n\t\tif (result >= (int)sizeof(ldev->cls_path)) {\n\t\t\tif (logf) { fprintf(logf, \"cls_path overflow\\n\"); fclose(logf); }\n\t\t\treturn -EOVERFLOW;\n\t\t}\n\t\tresult = snprintf(ldev->dev_path, sizeof(ldev->dev_path),\n\t\t\t  \"/dev/%s\", instance);\n\t\tif (result >= (int)sizeof(ldev->dev_path)) {\n\t\t\tif (logf) { fprintf(logf, \"dev_path overflow\\n\"); fclose(logf); }\n\t\t\treturn -EOVERFLOW;\n\t\t}\n\t\tbreak;\n\t}\n\tsysfs_close_list(dlist);\n\n\tif (sysfs_path_is_dir(ldev->cls_path) != 0) {\n\t\tmetal_log(METAL_LOG_ERROR, \"invalid device class path %s\\n\",\n\t\t\tldev->cls_path);\n\t\tif (logf) { fprintf(logf, \"invalid class path=%s\\n\", ldev->cls_path); fclose(logf); }\n\t\treturn -ENODEV;\n\t}\n\n\ti = 0;\n\tdo {\n\t\tif (!access(ldev->dev_path, F_OK))\n\t\t\tbreak;\n\t\tusleep(10);\n\t\ti++;\n\t} while (i < 1000);\n\tif (i >= 1000) {\n\t\tmetal_log(METAL_LOG_ERROR, \"failed to open file %s, timeout.\\n\",\n\t\t\tldev->dev_path);\n\t\tif (logf) { fprintf(logf, \"timeout waiting for dev_path=%s\\n\", ldev->dev_path); fclose(logf); }\n\t\treturn -ENODEV;\n\t}\n\tresult = metal_open(ldev->dev_path, 0);\n\tif (result < 0) {\n\t\tmetal_log(METAL_LOG_ERROR, \"failed to open device %s\\n\",\n\t\t\tldev->dev_path, strerror(-result));\n\t\tif (logf) { fprintf(logf, \"metal_open failed for %s: %d\\n\", ldev->dev_path, result); fclose(logf); }\n\t\treturn result;\n\t}\n\tldev->fd = result;\n\n\tmetal_log(METAL_LOG_DEBUG, \"opened %s:%s as %s\\n\",\n\t\tlbus->bus_name, ldev->dev_name, ldev->dev_path);\n\tif (logf) {\n\t\tfprintf(logf, \"device fd=%d\\n\", ldev->fd);\n\t\tfflush(logf);\n\t}\n\n\t/*\n\t * The original code used a for-loop which initialized both 'i' and\n\t * 'result' in the first clause and had the second clause depend on\n\t * 'result' while 'result' was assigned within the loop body. This\n\t * is the situation reported as violating MISRA C 2023 Rule 14.2.\n\t *\n\t * To capture the control flow and state for repro/evidence we\n\t * explicitly keep the same logic but expand the loop into a\n\t * while-loop with detailed logging around condition evaluation,\n\t * body execution and increment.\n\t */\n\n\t/* Initialize loop variables exactly as original for-clause */\n\ti = 0;\n\tresult = 0;\n\tif (logf) {\n\t\tfprintf(logf, \"loop-init: i=%d result=%d\\n\", i, result);\n\t\tfflush(logf);\n\t}\n\n\t/* Loop condition and body with probes */\n\twhile (!result && i < METAL_MAX_DEVICE_REGIONS) {\n\t\tif (logf) {\n\t\t\tfprintf(logf, \"cond-eval: i=%d result=%d\\n\", i, result);\n\t\t\tfflush(logf);\n\t\t}\n\n\t\t/* begin original loop body */\n\t\tphys = &ldev->region_phys[ldev->device.num_regions];\n\n\t\t/* Each assignment to 'result' mirrors the original short-circuit style\n\t\t * but we add logging after each to capture when and how 'result'\n\t\t * changes during the body execution.\n\t\t */\n\t\tresult = (result ? result :\n\t\t\t metal_uio_read_map_attr(ldev, i, \"offset\", &offset));\n\t\tif (logf) { fprintf(logf, \"after read_map_attr(offset): i=%d result=%d offset=%lu\\n\", i, result, offset); fflush(logf); }\n\n\t\tresult = (result ? result :\n\t\t\t metal_uio_read_map_attr(ldev, i, \"addr\", phys));\n\t\tif (logf) { fprintf(logf, \"after read_map_attr(addr): i=%d result=%d phys=%lu\\n\", i, result, (unsigned long)*phys); fflush(logf); }\n\n\t\tresult = (result ? result :\n\t\t\t metal_uio_read_map_attr(ldev, i, \"size\", &size));\n\t\tif (logf) { fprintf(logf, \"after read_map_attr(size): i=%d result=%d size=%lu\\n\", i, result, size); fflush(logf); }\n\n\t\tresult = (result ? result :\n\t\t\t metal_map(ldev->fd, i * getpagesize(), size, 0, 0, &virt));\n\t\tif (logf) { fprintf(logf, \"after metal_map: i=%d result=%d virt=%p\\n\", i, result, virt); fflush(logf); }\n\n\t\tif (!result) {\n\t\t\t\n\t\tio = &ldev->device.regions[ldev->device.num_regions];\n\t\t\t/* preserve original behaviour */\n\t\t\tmetal_io_init(io, virt, phys, size, -1, 0, NULL);\n\t\t\tldev->device.num_regions++;\n\t\t\tif (logf) {\n\t\t\t\tfprintf(logf, \"mapped region: idx=%d phys=%lu size=%lu virt=%p num_regions=%d\\n\",\n\t\t\t\t\ti, (unsigned long)*phys, size, virt, ldev->device.num_regions);\n\t\t\t\tfflush(logf);\n\t\t\t}\n\t\t} else {\n\t\t\tif (logf) {\n\t\t\t\tfprintf(logf, \"mapping failed at iteration %d with result=%d\\n\", i, result);\n\t\t\t\tfflush(logf);\n\t\t\t}\n\t\t}\n\t\t/* end original loop body */\n\n\t\tif (logf) {\n\t\t\tfprintf(logf, \"before-incr: i=%d result=%d\\n\", i, result);\n\t\t\tfflush(logf);\n\t\t}\n\n\t\t/* increment as original for-clause's third expression */\n\t\ti++;\n\n\t\tif (logf) {\n\t\t\tfprintf(logf, \"after-incr: i=%d result=%d\\n\", i, result);\n\t\t\tfflush(logf);\n\t\t}\n\t}\n\n\tif (logf) {\n\t\tfprintf(logf, \"loop-exit: i=%d result=%d num_regions=%d\\n\",\n\t\t\ti, result, ldev->device.num_regions);\n\t\tfflush(logf);\n\t\t/* keep log open for any later logs in this function, then close at end */\n\t}\n\n\tirq_info = 1;\n\tif (write(ldev->fd, &irq_info, sizeof(irq_info)) <= 0) {\n\t\tmetal_log(METAL_LOG_INFO,\n\t\t\t\"%s: No IRQ for device %s.\\n\",\n\t\t\t__func__, ldev->dev_name);\n\t\tldev->device.irq_num =  0;\n\t\tldev->device.irq_info = (void *)-1;\n\t\tif (logf) { fprintf(logf, \"no IRQ for device %s\\n\", ldev->dev_name); fflush(logf); }\n\t} else {\n\t\tldev->device.irq_num =  1;\n\t\tldev->device.irq_info = (void *)(intptr_t)ldev->fd;\n\t\tmetal_linux_irq_register_dev(&ldev->device, ldev->fd);\n\t\tif (logf) { fprintf(logf, \"registered IRQ: irq_num=%d irq_info=%p\\n\", ldev->device.irq_num, ldev->device.irq_info); fflush(logf); }\n\t}\n\n\tif (logf) {\n\t\tfprintf(logf, \"=== metal_uio_dev_open end: return=0\\n\");\n\t\tfclose(logf);\n\t}\n\n\treturn 0;\n}\n",
  "explanation": "There was a simple typo: the code used an undeclared identifier 'aio' where the pointer variable 'io' (declared at the top) was intended. I replaced 'aio = &ldev->device.regions[...]' with 'io = &ldev->device.regions[...]'. No other logic was changed."
}