{
  "user_message": "Target function code is:\n```c\nstatic int metal_shmem_try_map(struct metal_page_size *ps, int fd, size_t size,\n\t\t\t       struct metal_io_region **result)\n{\n\tsize_t pages, page, phys_size;\n\tstruct metal_io_region *io;\n\tmetal_phys_addr_t *phys;\n\tuint8_t *virt;\n\tvoid *mem;\n\tint error;\n\n\tsize = metal_align_up(size, ps->page_size);\n\tpages = size / ps->page_size;\n\n\terror = metal_map(fd, 0, size, 1, ps->mmap_flags, &mem);\n\tif (error) {\n\t\tmetal_log(METAL_LOG_WARNING,\n\t\t\t  \"failed to mmap shmem %ld,0x%x - %s\\n\",\n\t\t\t  size, ps->mmap_flags, strerror(-error));\n\t\treturn error;\n\t}\n\n\terror = mlock(mem, size);\n\tif (error) {\n\t\tmetal_log(METAL_LOG_WARNING, \"failed to mlock shmem - %s\\n\",\n\t\t\t  strerror(errno));\n\t}\n\n\tphys_size = sizeof(*phys) * pages;\n\tphys = malloc(phys_size);\n\tif (!phys) {\n\t\tmetal_unmap(mem, size);\n\t\treturn -ENOMEM;\n\t}\n\n\tio = malloc(sizeof(*io));\n\tif (!io) {\n\t\tfree(phys);\n\t\tmetal_unmap(mem, size);\n\t\treturn -ENOMEM;\n\t}\n\n\tif (_metal.pagemap_fd < 0) {\n\t\tphys[0] = 0;\n\t\tmetal_log(METAL_LOG_WARNING,\n\t\t\"shmem - failed to get va2pa mapping. use offset as pa.\\n\");\n\t\tmetal_io_init(io, mem, phys, size, -1, 0, &metal_shmem_io_ops);\n\t} else {\n\t\tfor (virt = mem, page = 0; page < pages; page++) {\n\t\t\tsize_t offset = page * ps->page_size;\n\n\t\t\terror = metal_virt2phys(virt + offset, &phys[page]);\n\t\t\tif (error < 0)\n\t\t\t\tphys[page] = METAL_BAD_OFFSET;\n\t\t}\n\t\tmetal_io_init(io, mem, phys, size, ps->page_shift, 0,\n\t\t\t&metal_shmem_io_ops);\n\t}\n\t*result = io;\n\n\treturn 0;\n}\n```\n\nStatic call graph of the target function is:\n```json\n{'metal_shmem_try_map': {'callees': ['metal_map', 'metal_unmap', 'metal_io_init', 'metal_virt2phys'], 'callers': ['metal_shmem_open']}, 'metal_map': {'callees': [], 'callers': ['metal_uio_dev_open', 'metal_shmem_try_map']}, 'metal_unmap': {'callees': [], 'callers': ['metal_uio_dev_close', 'metal_shmem_io_close', 'metal_shmem_try_map']}, 'metal_io_init': {'callees': [], 'callers': ['metal_uio_dev_open', 'metal_shmem_try_map']}, 'metal_virt2phys': {'callees': [], 'callers': ['metal_shmem_try_map']}, 'metal_shmem_open': {'callees': ['metal_shmem_open_generic', 'metal_open', 'metal_shmem_try_map'], 'callers': ['shmem_child']}}\n```\n\n\nList additional symbols that are required to analyze the target function to determine if the target function code violates the following MISRA C rule:\nLanguage extensions should not be used. You should report only when the code uses any language compiler extensions that are explicitly stated as an extension in compiler documentations.\nThe list will be included in the prompt for the next agent, so be concise and clear.\nExplain why each symbol is required in the analysis of the target function for the MISRA C rule.\n",
  "close_symbols": [
    "metal_align_up",
    "metal_map",
    "metal_unmap",
    "metal_log",
    "metal_io_init",
    "metal_virt2phys",
    "metal_shmem_io_ops",
    "metal_phys_addr_t",
    "struct metal_page_size",
    "_metal",
    "METAL_BAD_OFFSET",
    "METAL_LOG_WARNING",
    "strerror",
    "mlock",
    "errno",
    "malloc",
    "free"
  ],
  "explanation": "For checking use of compiler/language extensions you must inspect any symbol whose definition could hide an extension (GCC/Clang __attribute__, asm, typeof, statement-expr, nested functions, compiler-specific builtins, variadic-macro tricks, or other documented compiler extensions). Reason for each symbol:\n\n- metal_align_up: often a macro. Need to see its definition to detect use of statement-expressions, typeof, or other macro extensions.\n- metal_map: prototype/implementation may use GCC attributes, inline asm, or nonstandard calling conventions\u2014inspect for compiler extensions.\n- metal_unmap: same rationale as metal_map (attributes or nonstandard constructs in declaration/implementation).\n- metal_log: commonly a macro or variadic wrapper; examine whether it uses variadic-macro extensions, statement-expressions, or attributes.\n- metal_io_init: its declaration/definition may include attributes or nonstandard parameter types; check for extensions.\n- metal_virt2phys: implementation or prototype may employ compiler extensions (attributes, builtin intrinsics); inspect it.\n- metal_shmem_io_ops: object/initializer may use designated initializers or compiler-specific section/attribute annotations; examine its definition for __attribute__ or other extensions.\n- metal_phys_addr_t: typedef may be to an extended integer type (e.g. __int128) or use compiler-specific typedefs; check its definition.\n- struct metal_page_size: field types or macros used in its definition could hide extensions (packed, uses __attribute__, etc.).\n- _metal: the global structure/variable (and its type) must be inspected for attributes, reserved-name usage that might map to compiler internals, or other extensions.\n- METAL_BAD_OFFSET: constant/macro\u2014its definition might use compiler-specific expressions or extensions.\n- METAL_LOG_WARNING: macro/enum\u2014may hide variadic/extension usage; inspect definition.\n- strerror: standard C function, but check whether a local wrapper/macro is used that employs extensions.\n- mlock: POSIX function\u2014inspect header/definition in the build environment for attribute annotations or extension usage.\n- errno: often a macro expanding to thread-local or compiler builtin; inspect to ensure it does not rely on compiler-specific extensions in this context.\n- malloc / free: standard functions, but the implementation/declarations in the build may include attributes or macros; include to be thorough.\n\nInspecting these symbols (their headers, macros and implementations) lets the analyzer determine whether any language/compiler-specific extensions are being used by the target function through macros, typedefs, attributes, inline assembly, or other constructs that are not standard C and therefore would violate the MISRA restriction on language extensions."
}