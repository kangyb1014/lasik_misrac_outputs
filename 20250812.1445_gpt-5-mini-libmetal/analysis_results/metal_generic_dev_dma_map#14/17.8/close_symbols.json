{
  "user_message": "Target function code is:\n```c\nint metal_generic_dev_dma_map(struct metal_bus *bus,\n\t\t\t     struct metal_device *device,\n\t\t\t     uint32_t dir,\n\t\t\t     struct metal_sg *sg_in,\n\t\t\t     int nents_in,\n\t\t\t     struct metal_sg *sg_out)\n{\n\tint i;\n\t(void)bus;\n\t(void)device;\n\n\tif (sg_out != sg_in)\n\t\tmemcpy(sg_out, sg_in, nents_in*(sizeof(struct metal_sg)));\n\tfor (i = 0; i < nents_in; i++) {\n\t\tif (dir == METAL_DMA_DEV_W) {\n\t\t\tmetal_cache_flush(sg_out[i].virt, sg_out[i].len);\n\t\t}\n\t\tmetal_cache_invalidate(sg_out[i].virt, sg_out[i].len);\n\t}\n\n\treturn nents_in;\n}\n```\n\nStatic call graph of the target function is:\n```json\n{'metal_generic_dev_dma_map': {'callees': ['metal_cache_flush', 'metal_cache_invalidate'], 'callers': []}, 'metal_cache_flush': {'callees': [], 'callers': ['metal_generic_dev_dma_map']}, 'metal_cache_invalidate': {'callees': [], 'callers': ['metal_generic_dev_dma_map', 'metal_generic_dev_dma_unmap']}}\n```\n\n\nList additional symbols that are required to analyze the target function to determine if the target function code violates the following MISRA C rule:\nA function parameter should not be modified. Note that the object referred to by a pointer parameter may be modified, but the pointer itself shall not be modified.\nThe list will be included in the prompt for the next agent, so be concise and clear.\nExplain why each symbol is required in the analysis of the target function for the MISRA C rule.\n",
  "close_symbols": [
    "struct metal_sg",
    "memcpy",
    "metal_cache_flush",
    "metal_cache_invalidate",
    "METAL_DMA_DEV_W"
  ],
  "explanation": "Required symbols and why they are needed to check the MISRA rule (function parameter shall not be modified):\n\n- struct metal_sg: The function indexes sg_out (sg_out[i]) and accesses members (virt, len). The struct definition is needed to determine the types of those members (e.g., whether virt is a pointer, its type/size) and to confirm that the code writes through the object(s) pointed to by sg_out (allowed) rather than modifying the sg_out pointer itself (disallowed).\n\n- memcpy: The call memcpy(sg_out, sg_in, nents_in*sizeof(struct metal_sg)) copies into the memory pointed to by sg_out. The memcpy prototype/behavior must be known to confirm it writes to the object(s) pointed to (which is permitted) and does not modify the sg_out pointer parameter itself (it returns a pointer but that return is unused here).\n\n- metal_cache_flush: This callee is invoked with sg_out[i].virt. Its declaration/signature is needed to ensure it does not take a pointer-to-pointer (e.g., void **), which could allow modification of the caller's pointer parameter via indirection. If its parameters are simple pointers (void *, addr_t, etc.), it cannot change the sg_out pointer variable itself\u2014only the pointed-to object (which is allowed).\n\n- metal_cache_invalidate: Same rationale as metal_cache_flush \u2014 need its prototype to verify it does not accept a pointer-to-pointer that could modify a pointer parameter in the caller.\n\n- METAL_DMA_DEV_W: The macro/constant used in the dir comparison should be known to ensure the comparison is a value check only and does not involve any side effects that could modify the dir parameter. (Also to confirm dir's expected domain so analysis can reason about the conditional path.)\n\nThese symbols are sufficient to determine whether any statement in the function modifies the parameter variables themselves (sg_out, sg_in, dir, etc.) versus merely modifying the objects they point to (which MISRA permits)."
}