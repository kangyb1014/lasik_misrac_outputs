{
  "user_message": "An agent A claimed that the following metal_generic_dev_dma_map code violates the MISRA C 2023 rule 8.13.\n<misra_rule>\nMISRA C 2023 Rule 8.13 is A pointer should point to a const-qualified type whenever possible.\n.\n</misra_rule>\n<target_code>\nHere is the original code of metal_generic_dev_dma_map.\n```c\nint metal_generic_dev_dma_map(struct metal_bus *bus,\n\t\t\t     struct metal_device *device,\n\t\t\t     uint32_t dir,\n\t\t\t     struct metal_sg *sg_in,\n\t\t\t     int nents_in,\n\t\t\t     struct metal_sg *sg_out)\n{\n\tint i;\n\t(void)bus;\n\t(void)device;\n\n\tif (sg_out != sg_in)\n\t\tmemcpy(sg_out, sg_in, nents_in*(sizeof(struct metal_sg)));\n\tfor (i = 0; i < nents_in; i++) {\n\t\tif (dir == METAL_DMA_DEV_W) {\n\t\t\tmetal_cache_flush(sg_out[i].virt, sg_out[i].len);\n\t\t}\n\t\tmetal_cache_invalidate(sg_out[i].virt, sg_out[i].len);\n\t}\n\n\treturn nents_in;\n}\n```\n</target_code>\n<scenario>\nThe agent A provided the following violation scenario:The parameter 'sg_in' is declared as 'struct metal_sg *sg_in' but is only read (used as the source for memcpy and compared to sg_out) and never modified. Per MISRA C 2023 Rule 8.13 it should be declared as pointing to a const-qualified type, e.g. 'const struct metal_sg *sg_in'.\n</scenario>\n<test_code>\nAlso, the agent A provided the following modified code that prints out the log to support their scenario:\n```c\n\nint metal_generic_dev_dma_map(struct metal_bus *bus,\n\t\t\t     struct metal_device *device,\n\t\t\t     uint32_t dir,\n\t\t\t     struct metal_sg *sg_in,\n\t\t\t     int nents_in,\n\t\t\t     struct metal_sg *sg_out)\n{\n\tint i;\n\tFILE *logf = fopen(\"/tmp/logs/115.txt\", \"a\");\n\n\t/* Log entry and key parameter values */\n\tif (logf) {\n\t\tfprintf(logf, \"ENTER: metal_generic_dev_dma_map\\n\");\n\t\tfprintf(logf, \"  bus=%p device=%p sg_in=%p sg_out=%p nents_in=%d dir=0x%x\\n\",\n\t\t\t(void *)bus, (void *)device, (void *)sg_in, (void *)sg_out, nents_in, (unsigned)dir);\n\t\tif (sg_in == NULL) fprintf(logf, \"  NOTE: sg_in is NULL\\n\");\n\t\tif (sg_out == NULL) fprintf(logf, \"  NOTE: sg_out is NULL\\n\");\n\t\tif (sg_out != sg_in)\n\t\t\tfprintf(logf, \"  Action: memcpy will be performed from sg_in to sg_out (nents=%d, entry_size=%zu)\\n\",\n\t\t\t\tnents_in, (size_t)sizeof(struct metal_sg));\n\t\telse\n\t\t\tfprintf(logf, \"  Action: sg_out == sg_in, no memcpy will be performed\\n\");\n\t}\n\n\t(void)bus;\n\t(void)device;\n\n\t/* Preserve original behavior: copy descriptors if src and dst differ */\n\tif (sg_out != sg_in)\n\t\tmemcpy(sg_out, sg_in, nents_in * (sizeof(struct metal_sg)));\n\n\t/* Log a small sample of SG entries (if available) to show source vs destination values.\n\t   Only attempt to dereference sg_in/sg_out if pointers are non-NULL. */\n\tif (logf) {\n\t\tint sample = nents_in < 5 ? nents_in : 5;\n\t\tfor (i = 0; i < sample; i++) {\n\t\t\tif (sg_in != NULL) {\n\t\t\t\t/* Log fields commonly present in struct metal_sg (virt and len used below)\n\t\t\t\t   We cast pointers to (void*) for %p. */\n\t\t\t\tfprintf(logf, \"  SAMPLE %d: sg_in[%d].virt=%p sg_in[%d].len=%zu\\n\",\n\t\t\t\t\t i, i, (void *)sg_in[i].virt, i, (size_t)sg_in[i].len);\n\t\t\t} else {\n\t\t\t\tfprintf(logf, \"  SAMPLE %d: sg_in is NULL\\n\", i);\n\t\t\t}\n\t\t\tif (sg_out != NULL) {\n\t\t\t\tfprintf(logf, \"  SAMPLE %d: sg_out[%d].virt=%p sg_out[%d].len=%zu\\n\",\n\t\t\t\t\t i, i, (void *)sg_out[i].virt, i, (size_t)sg_out[i].len);\n\t\t\t} else {\n\t\t\t\tfprintf(logf, \"  SAMPLE %d: sg_out is NULL\\n\", i);\n\t\t\t}\n\t\t}\n\t}\n\n\tfor (i = 0; i < nents_in; i++) {\n\t\tif (dir == METAL_DMA_DEV_W) {\n\t\t\tif (logf)\n\t\t\t\tfprintf(logf, \"  ITER %d: dir==METAL_DMA_DEV_W -> flush sg_out[%d].virt=%p len=%zu\\n\",\n\t\t\t\t\t i, i, (void *)sg_out[i].virt, (size_t)sg_out[i].len);\n\t\t\tmetal_cache_flush(sg_out[i].virt, sg_out[i].len);\n\t\t} else {\n\t\t\tif (logf)\n\t\t\t\tfprintf(logf, \"  ITER %d: dir!=METAL_DMA_DEV_W -> no flush for sg_out[%d]\\n\", i, i);\n\t\t}\n\t\tmetal_cache_invalidate(sg_out[i].virt, sg_out[i].len);\n\t\tif (logf)\n\t\t\tfprintf(logf, \"  ITER %d: invalidated sg_out[%d].virt=%p len=%zu\\n\",\n\t\t\t\t i, i, (void *)sg_out[i].virt, (size_t)sg_out[i].len);\n\t}\n\n\tif (logf) {\n\t\tfprintf(logf, \"EXIT: metal_generic_dev_dma_map returning %d\\n\\n\", nents_in);\n\t\tfclose(logf);\n\t}\n\n\treturn nents_in;\n}\n\n```\nThe test code was compiled successfully, but the test log is empty for metal_generic_dev_dma_map. The test suite might not cover this function or the test code might be not suitable to print important information.\n</test_code>\n<response format>\nProvide your answer with these fields.\n- explanation: your evaluation of the scenario provided by the agent A.\n- is_report_correct: whether the report is correct or not (true/false)\n</response format>\n<instruction>   \nJudge whether the report is correct or not.\n</instruction>\n",
  "is_report_correct": true,
  "explanation": "Agent A is correct. In the function sg_in is only read: it is compared to sg_out and used as the source argument to memcpy, and never written through. Per MISRA C 2023 Rule 8.13 a pointer that is only used to access data should be declared to point to const-qualified type when possible (e.g. const struct metal_sg *sg_in). Changing the parameter to const is compatible with memcpy\u2019s prototype (const void *src) and the other uses (pointer comparison) and would not break the function body. The only caveat is an API/ABI compatibility decision outside the rule \u2014 if the function must match an existing non-const API, that may prevent changing the signature; but strictly by Rule 8.13 the current declaration is a violation."
}