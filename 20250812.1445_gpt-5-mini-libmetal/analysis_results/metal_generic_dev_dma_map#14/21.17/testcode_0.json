{
  "user_message": "<misra_rule>\nMISRA C 2023 Rule 21.17 is: Use of the string handling functions from <string.h> shall not result in accesses beyond the bounds of the objects referenced by their pointer parameters.\nThis rule strictly applies to the Standard Library functions in <string.h> such as memcpy, memmove, memset, memcmp, strcpy, strncpy, strcat, strncat, strlen, and strspn.\n</misra_rule>\n\nAnother agent reported that the target code violated the Rule 21.17.\nHere is the comment from the agent.\n<violation scenario>\nIf nents_in exceeds the number of struct metal_sg elements actually allocated/pointed-to by sg_in or sg_out (or either pointer is NULL while nents_in > 0), the memcpy call copies nents_in * sizeof(struct metal_sg) bytes and will read from or write to memory beyond the source/target buffers. Example: sg_in points to an array of 2 elements but nents_in == 3 \u2014 memcpy will read past sg_in[1], violating the rule.\n</violation scenario>\n\nYour job is to insert logging code to capture the control flow and state information of the program.\nInsert logging code so that other agents can reproduce and get evidence for the violation scenario.\n<response format>\n- test_code: a modified metal_generic_dev_dma_map code that contains useful probe functions that print useful logs to a file \"/tmp/logs/119.txt\". The logs should contain the control path and state information of the violation scenario. If test code is not required to validate the scenario, you can leave this blank.\nHere are the constraints for the test code:\n- The test code MUST preserve the original logic of metal_generic_dev_dma_map as much as possible.\nYou CAN just insert probe functions to the original code.\n- DO NOT introduce new violations to demonstrate your scenario.\n- The test code MUST be compilable and executable.\n- The test code MUST include line breaks.\n- You MUST NOT define the main function.\n- You MUST NOT define macros.\n</response format>\n<target_code>\nHere is the code of metal_generic_dev_dma_map:\n```c\nint metal_generic_dev_dma_map(struct metal_bus *bus,\n\t\t\t     struct metal_device *device,\n\t\t\t     uint32_t dir,\n\t\t\t     struct metal_sg *sg_in,\n\t\t\t     int nents_in,\n\t\t\t     struct metal_sg *sg_out)\n{\n\tint i;\n\t(void)bus;\n\t(void)device;\n\n\tif (sg_out != sg_in)\n\t\tmemcpy(sg_out, sg_in, nents_in*(sizeof(struct metal_sg)));\n\tfor (i = 0; i < nents_in; i++) {\n\t\tif (dir == METAL_DMA_DEV_W) {\n\t\t\tmetal_cache_flush(sg_out[i].virt, sg_out[i].len);\n\t\t}\n\t\tmetal_cache_invalidate(sg_out[i].virt, sg_out[i].len);\n\t}\n\n\treturn nents_in;\n}\n```\n</target_code>\nPlease provide the modified metal_generic_dev_dma_map code.\n",
  "test_code": "#include <stdio.h>\n#include <string.h>\n#include <stdint.h>\n#include <stddef.h>\n#include <errno.h>\n\n/* Minimal stubs so this compilation unit is self-contained. */\nstruct metal_bus { int _unused; };\nstruct metal_device { int _unused; };\nstruct metal_sg {\n    void *virt;\n    size_t len;\n};\n\n/* Define a DMA direction value used by the original code. */\nenum { METAL_DMA_DEV_W = 1 };\n\n/* Cache helper stubs (no-ops) to preserve original logic but make this file\n   independently compilable/executable. */\nstatic void metal_cache_flush(void *addr, size_t len)\n{\n    (void)addr; (void)len;\n}\nstatic void metal_cache_invalidate(void *addr, size_t len)\n{\n    (void)addr; (void)len;\n}\n\n/*\n * Modified metal_generic_dev_dma_map with logging probes.\n * Logs are appended to /tmp/logs/119.txt and capture parameters,\n * pointer values, computed byte counts and per-iteration indices so\n * reproducing agents can observe conditions that lead to out-of-bounds\n * accesses in the original code path.\n *\n * The function preserves the original logic and behavior.\n */\nint metal_generic_dev_dma_map(struct metal_bus *bus,\n                             struct metal_device *device,\n                             uint32_t dir,\n                             struct metal_sg *sg_in,\n                             int nents_in,\n                             struct metal_sg *sg_out)\n{\n    int i;\n    (void)bus;\n    (void)device;\n\n    /* Open log file in append mode. If logging fails, continue without\n       aborting \u2014 we must preserve original behavior. */\n    FILE *log = fopen(\"/tmp/logs/119.txt\", \"a\");\n    if (log) {\n        fprintf(log, \"--- metal_generic_dev_dma_map ENTER ---\\n\");\n        fprintf(log, \"params: sg_in=%p, sg_out=%p, nents_in=%d, dir=%u\\n\",\n                (void*)sg_in, (void*)sg_out, nents_in, (unsigned)dir);\n\n        /* Compute and log the byte count used for memcpy. Avoid computing\n           pointer arithmetic off NULL pointers (undefined). */\n        size_t bytes = (size_t)nents_in * sizeof(struct metal_sg);\n        fprintf(log, \"computed memcpy bytes = %zu (nents_in * sizeof(struct metal_sg))\\n\", bytes);\n\n        if (sg_in == NULL && nents_in > 0) {\n            fprintf(log, \"WARNING: sg_in is NULL while nents_in > 0\\n\");\n        }\n        if (sg_out == NULL && nents_in > 0) {\n            fprintf(log, \"WARNING: sg_out is NULL while nents_in > 0\\n\");\n        }\n\n        if (sg_in != NULL) {\n            /* We only compute the end address when sg_in is non-NULL to\n               avoid undefined behaviour. This shows the intended source\n               range for memcpy. */\n            void *src_start = (void*)sg_in;\n            void *src_end = (void*)((char*)sg_in + bytes);\n            fprintf(log, \"memcpy src range: [%p .. %p)\\n\", src_start, src_end);\n        } else {\n            fprintf(log, \"memcpy src range: [NULL]\\n\");\n        }\n\n        if (sg_out != NULL) {\n            void *dst_start = (void*)sg_out;\n            void *dst_end = (void*)((char*)sg_out + bytes);\n            fprintf(log, \"memcpy dst range: [%p .. %p)\\n\", dst_start, dst_end);\n        } else {\n            fprintf(log, \"memcpy dst range: [NULL]\\n\");\n        }\n\n        fprintf(log, \"will perform memcpy if (sg_out != sg_in) -> %s\\n\",\n                (sg_out != sg_in) ? \"true\" : \"false\");\n        fflush(log);\n    }\n\n    if (sg_out != sg_in)\n        memcpy(sg_out, sg_in, nents_in*(sizeof(struct metal_sg)));\n\n    for (i = 0; i < nents_in; i++) {\n        /* Log each iteration's index and the pointer values that will be\n           accessed by the cache operations. We avoid dereferencing sg_in\n           here; only access sg_out as the original code does. */\n        if (log) {\n            if (sg_out != NULL) {\n                /* Accessing sg_out[i] mirrors the original behavior; it may\n                   itself read out-of-bounds if nents_in exceeds the actual\n                   allocation. We log the pointer values as observed. */\n                fprintf(log, \"iter %d: sg_out[%d] @ %p: virt=%p, len=%zu\\n\",\n                        i, i, (void*)&sg_out[i], sg_out[i].virt, sg_out[i].len);\n            } else {\n                fprintf(log, \"iter %d: sg_out is NULL, cannot log sg_out[i]\\n\", i);\n            }\n            fflush(log);\n        }\n\n        if (dir == METAL_DMA_DEV_W) {\n            metal_cache_flush(sg_out[i].virt, sg_out[i].len);\n        }\n        metal_cache_invalidate(sg_out[i].virt, sg_out[i].len);\n    }\n\n    if (log) {\n        fprintf(log, \"--- metal_generic_dev_dma_map EXIT (return %d) ---\\n\", nents_in);\n        fclose(log);\n    }\n\n    return nents_in;\n}\n"
}