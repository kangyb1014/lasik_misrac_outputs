{
  "user_message": "An agent A claimed that the following metal_uio_dev_dma_map code violates the MISRA C 2023 rule 1.2.\n<misra_rule>\nMISRA C 2023 Rule 1.2 is Language extensions should not be used.\nYou should report only when the code uses any language compiler extensions that are explicitly stated as an extension in compiler documentations..\n</misra_rule>\n<target_code>\nHere is the original code of metal_uio_dev_dma_map.\n```c\nstatic int metal_uio_dev_dma_map(struct linux_bus *lbus,\n\t\t\t\t struct linux_device *ldev,\n\t\t\t\t uint32_t dir,\n\t\t\t\t struct metal_sg *sg_in,\n\t\t\t\t int nents_in,\n\t\t\t\t struct metal_sg *sg_out)\n{\n\tint i, j;\n\tvoid *vaddr_sg_lo, *vaddr_sg_hi, *vaddr_lo, *vaddr_hi;\n\tstruct metal_io_region *io;\n\n\t(void)lbus;\n\t(void)dir;\n\n\t/* Check if the the input virt address is MMIO address */\n\tfor (i = 0; i < nents_in; i++) {\n\t\tvaddr_sg_lo = sg_in[i].virt;\n\t\tvaddr_sg_hi = vaddr_sg_lo + sg_in[i].len;\n\t\tfor (j = 0, io = ldev->device.regions;\n\t\t     j < (int)ldev->device.num_regions; j++, io++) {\n\t\t\tvaddr_lo = io->virt;\n\t\t\tvaddr_hi = vaddr_lo + io->size;\n\t\t\tif (vaddr_sg_lo >= vaddr_lo &&\n\t\t\t    vaddr_sg_hi <= vaddr_hi) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif (j == (int)ldev->device.num_regions) {\n\t\t\tmetal_log(METAL_LOG_WARNING,\n\t\t\t  \"%s,%s: input address isn't MMIO addr: 0x%x,%d.\\n\",\n\t\t\t__func__, ldev->dev_name, vaddr_sg_lo, sg_in[i].len);\n\t\t\treturn -EINVAL;\n\t\t}\n\t}\n\tif (sg_out != sg_in)\n\t\tmemcpy(sg_out, sg_in, nents_in*(sizeof(struct metal_sg)));\n\treturn nents_in;\n}\n```\n</target_code>\n<scenario>\nThe agent A provided the following violation scenario:The expression performs pointer arithmetic on a void* (vaddr_sg_lo + sg_in[i].len). Arithmetic on void* is a compiler extension (e.g. GCC/Clang treat void* as a char* for arithmetic) and is not valid in standard C, so this violates MISRA C 2023 Rule 1.2.\n</scenario>\n<test_code>\nAlso, the agent A provided the following modified code that prints out the log to support their scenario:\n```c\nstatic void ensure_log_dir(void)\n{\n    /* best-effort create directory; ignore errors if it already exists */\n    (void)mkdir(\"/tmp/logs\", 0777);\n}\nstatic void probe_log(const char *fmt, ...)\n{\n    FILE *f;\n    va_list ap;\n\n    ensure_log_dir();\n    f = fopen(\"/tmp/logs/120.txt\", \"a\");\n    if (!f)\n        return;\n    va_start(ap, fmt);\n    vfprintf(f, fmt, ap);\n    va_end(ap);\n    fprintf(f, \"\\n\");\n    fclose(f);\n}\n\nstatic int metal_uio_dev_dma_map(struct linux_bus *lbus,\n                 struct linux_device *ldev,\n                 uint32_t dir,\n                 struct metal_sg *sg_in,\n                 int nents_in,\n                 struct metal_sg *sg_out)\n{\n    int i, j;\n    void *vaddr_sg_lo, *vaddr_sg_hi, *vaddr_lo, *vaddr_hi;\n    struct metal_io_region *io;\n\n    (void)lbus;\n    (void)dir;\n\n    /* Entry probe */\n    probe_log(\"ENTER: %s: ldev=%p dev_name=%s nents_in=%d dir=%u\",\n          __func__, (void *)ldev,\n          (ldev && ldev->dev_name) ? ldev->dev_name : \"(null)\",\n          nents_in, (unsigned)dir);\n\n    /* Check if the the input virt address is MMIO address */\n    for (i = 0; i < nents_in; i++) {\n        /* original computation (uses void* arithmetic as in target code) */\n        vaddr_sg_lo = sg_in[i].virt;\n        vaddr_sg_hi = vaddr_sg_lo + sg_in[i].len;\n\n        /* For robust logging compute an equivalent using char* arithmetic */\n        {\n            void *vaddr_sg_hi_alt = (void *)(((char *)vaddr_sg_lo) + (size_t)sg_in[i].len);\n            probe_log(\"ITER[%d]: sg_in[%d]: virt=%p len=%llu; vaddr_sg_hi(original_void_arith)=%p vaddr_sg_hi(alt_char_arith)=%p\",\n                  i, i, vaddr_sg_lo, (unsigned long long)sg_in[i].len,\n                  vaddr_sg_hi, vaddr_sg_hi_alt);\n        }\n\n        for (j = 0, io = ldev->device.regions;\n             j < (int)ldev->device.num_regions; j++, io++) {\n            vaddr_lo = io->virt;\n            vaddr_hi = vaddr_lo + io->size;\n\n            /* Also log region bounds and an alt computation for vaddr_hi */\n            {\n                void *vaddr_hi_alt = (void *)(((char *)vaddr_lo) + (size_t)io->size);\n                probe_log(\"  CHECK region[%d]: virt=%p size=%llu; vaddr_hi(original_void_arith)=%p vaddr_hi(alt_char_arith)=%p\",\n                      j, vaddr_lo, (unsigned long long)io->size, vaddr_hi, vaddr_hi_alt);\n            }\n\n            if (vaddr_sg_lo >= vaddr_lo &&\n                vaddr_sg_hi <= vaddr_hi) {\n                probe_log(\"  MATCH at region[%d] for sg_in[%d]: sg_lo=%p sg_hi=%p region_lo=%p region_hi=%p\",\n                      j, i, vaddr_sg_lo, vaddr_sg_hi, vaddr_lo, vaddr_hi);\n                break;\n            }\n        }\n        if (j == (int)ldev->device.num_regions) {\n            probe_log(\"VIOLATION: input address isn't MMIO addr for sg_in[%d]: virt=%p len=%llu; returning -EINVAL\",\n                  i, vaddr_sg_lo, (unsigned long long)sg_in[i].len);\n            metal_log(METAL_LOG_WARNING,\n              \"%s,%s: input address isn't MMIO addr: 0x%x,%d.\\n\",\n            __func__, ldev->dev_name, vaddr_sg_lo, sg_in[i].len);\n            return -EINVAL;\n        }\n    }\n    if (sg_out != sg_in)\n        memcpy(sg_out, sg_in, nents_in*(sizeof(struct metal_sg)));\n\n    probe_log(\"EXIT: %s: returning nents_in=%d\", __func__, nents_in);\n    return nents_in;\n}\n\n```\nThe test code was compiled successfully, but the test log is empty for metal_uio_dev_dma_map. The test suite might not cover this function or the test code might be not suitable to print important information.\n</test_code>\n<response format>\nProvide your answer with these fields.\n- explanation: your evaluation of the scenario provided by the agent A.\n- is_report_correct: whether the report is correct or not (true/false)\n</response format>\n<instruction>   \nJudge whether the report is correct or not.\n</instruction>\n",
  "is_report_correct": true,
  "explanation": "The report is correct. The code performs pointer arithmetic on void* (e.g. vaddr_sg_hi = vaddr_sg_lo + sg_in[i].len and vaddr_hi = vaddr_lo + io->size). In standard C pointer arithmetic requires an object type with known size; arithmetic on void* is not valid and is provided by compilers (GCC/Clang) as a documented language extension (treating void as having size 1). MISRA C 2023 Rule 1.2 disallows use of such compiler language extensions, so the usage here violates that rule. A compliant fix is to use a character pointer for arithmetic (e.g. (char *)vaddr_sg_lo + (size_t)sg_in[i].len) or otherwise convert to an integer type for pointer arithmetic."
}