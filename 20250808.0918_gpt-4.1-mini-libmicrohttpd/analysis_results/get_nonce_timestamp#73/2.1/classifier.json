{
  "user_message": "<misra_rule>\nMISRA C 2023 Rule 2.1 is: A project shall not contain unreachable code.\n\n</misra_rule>\n<response format>\nProvide your answer with these fields.\n- is_rule_violated: whether the rule is violated or not (true/false),\n- scenario: a specific violation scenario.\n- test_code: a modified get_nonce_timestamp code that contains useful probe functions that print useful logs to a file \"/tmp/logs/585.txt\". The logs should contain the control path and state information of the violation scenario. If the MISRA C rule is not violated, you can just return an empty string for the test code.\nHere are the constraints for the test code:\n- DO NOT introduce new violations to demonstrate your scenario.\n- The test code MUST be compilable and executable.\n- The test code MUST include line breaks.\n- The test code MUST preserve the original logic of get_nonce_timestamp as much as possible.\n- You MUST NOT define the main function.\n- You MUST NOT define macros.\n- The test code MUST not contain any mock functions.\n</response format>\n<target_code>\nHere is the code of get_nonce_timestamp:\n```c\nstatic bool\nget_nonce_timestamp (const char *const nonce,\n                     size_t noncelen,\n                     uint64_t *const ptimestamp)\n{\n  if (0 == noncelen)\n    noncelen = strlen (nonce);\n\n  if (true\n#ifdef MHD_MD5_SUPPORT\n      && (NONCE_STD_LEN (MD5_DIGEST_SIZE) != noncelen)\n#endif /* MHD_MD5_SUPPORT */\n#if defined(MHD_SHA256_SUPPORT) || defined(MHD_SHA512_256_SUPPORT)\n      && (NONCE_STD_LEN (SHA256_SHA512_256_DIGEST_SIZE) != noncelen)\n#endif /* MHD_SHA256_SUPPORT */\n      )\n    return false;\n\n  if (TIMESTAMP_CHARS_LEN !=\n      MHD_strx_to_uint64_n_ (nonce + noncelen - TIMESTAMP_CHARS_LEN,\n                             TIMESTAMP_CHARS_LEN,\n                             ptimestamp))\n    return false;\n  return true;\n}\n```\n</target_code>\n<additional code>Here are the definitions of symbols that are close to the target function get_nonce_timestamp:\n#define NONCE_STD_LEN(digest_size) ((digest_size)*2+TIMESTAMP_CHARS_LEN)\n...\n#define MD5_DIGEST_SIZE (MD5_DIGEST_SIZE_WORDS*MD5_BYTES_IN_WORD)\n...\n#define SHA256_SHA512_256_DIGEST_SIZE SHA512_256_DIGEST_SIZE\n...\n#define TIMESTAMP_CHARS_LEN (TIMESTAMP_BIN_SIZE*2)\n...\nsize_t\nMHD_strx_to_uint64_n_ (const char *str,\n                       size_t maxlen,\n                       uint64_t *out_val)\n{\n  size_t i;\n  uint64_t res;\n  int digit;\n  if (! str || ! out_val)\n    return 0;\n\n  res = 0;\n  i = 0;\n  while (i < maxlen && (digit = toxdigitvalue (str[i])) >= 0)\n  {\n    if ( (res > (UINT64_MAX / 16)) ||\n         ((res == (UINT64_MAX / 16)) &&\n          ( (uint64_t) digit > (UINT64_MAX % 16)) ) )\n      return 0;\n\n    res *= 16;\n    res += (unsigned int) digit;\n    i++;\n  }\n\n  if (i)\n    *out_val = res;\n  return i;\n}\n</additional code>\nJudge whether the above get_nonce_timestamp code violates the rule 2.1 or not.",
  "is_rule_violated": true,
  "scenario": "Inside the conditionals with preprocessor directives, due to mutually exclusive or contradictory conditions for noncelen length checks, some branches may become unreachable depending on which macros are defined or not. For example, if neither MHD_MD5_SUPPORT nor MHD_SHA256_SUPPORT or MHD_SHA512_256_SUPPORT are defined, the chained logical condition after 'if (true && ...)' simplifies and may cause parts of the code to be unreachable.",
  "test_code": "#include <stdbool.h>\n#include <stdio.h>\n#include <stdint.h>\n#include <string.h>\n#include <stddef.h>\n#include <stdlib.h>\n#include <ctype.h>\n\n#define TIMESTAMP_BIN_SIZE 8\n#define TIMESTAMP_CHARS_LEN (TIMESTAMP_BIN_SIZE*2)\n#define MD5_DIGEST_SIZE 16\n#define SHA512_256_DIGEST_SIZE 32\n\nstatic FILE * log_file = NULL;\n\nsize_t toxdigitvalue(char c) {\n  if ('0' <= c && c <= '9') return c - '0';\n  if ('a' <= c && c <= 'f') return c - 'a' + 10;\n  if ('A' <= c && c <= 'F') return c - 'A' + 10;\n  return -1;\n}\n\n#define NONCE_STD_LEN(digest_size) ((digest_size)*2 + TIMESTAMP_CHARS_LEN)\n\nsize_t\nMHD_strx_to_uint64_n_ (const char *str,\n                       size_t maxlen,\n                       uint64_t *out_val)\n{\n  size_t i;\n  uint64_t res;\n  int digit;\n  if (! str || ! out_val)\n    return 0;\n\n  res = 0;\n  i = 0;\n  while (i < maxlen && (digit = toxdigitvalue(str[i])) >= 0) {\n    if ( (res > (UINT64_MAX / 16)) ||\n         ((res == (UINT64_MAX / 16)) && ((uint64_t)digit > (UINT64_MAX % 16))))\n      return 0;\n\n    res *= 16;\n    res += (unsigned int) digit;\n    i++;\n  }\n\n  if (i)\n    *out_val = res;\n  return i;\n}\n\n// To mimic the scenario, compile with all relevant macros UNDEFINED\n\nstatic bool\nget_nonce_timestamp (const char *const nonce,\n                     size_t noncelen,\n                     uint64_t *const ptimestamp)\n{\n  if (!log_file) {\n    log_file = fopen(\"/tmp/logs/585.txt\", \"w\");\n    if (!log_file) {\n      return false;\n    }\n  }\n\n  fprintf(log_file, \"Entered get_nonce_timestamp\\n\");\n  if (0 == noncelen) {\n    noncelen = strlen(nonce);\n    fprintf(log_file, \"noncelen was 0, updated to strlen: %zu\\n\", noncelen);\n  }\n\n  // This condition:\n  if (true\n      #ifdef MHD_MD5_SUPPORT\n      && (NONCE_STD_LEN(MD5_DIGEST_SIZE) != noncelen)\n      #endif\n      #if defined(MHD_SHA256_SUPPORT) || defined(MHD_SHA512_256_SUPPORT)\n      && (NONCE_STD_LEN(SHA512_256_DIGEST_SIZE) != noncelen)\n      #endif\n      ) {\n    fprintf(log_file, \"Returning false due to length mismatch condition\\n\");\n    fclose(log_file);\n    log_file = NULL;\n    return false;\n  }\n\n  fprintf(log_file, \"Passed length checks, proceeding to timestamp parsing\\n\");\n\n  if (TIMESTAMP_CHARS_LEN != MHD_strx_to_uint64_n_(nonce + noncelen - TIMESTAMP_CHARS_LEN,\n                                                   TIMESTAMP_CHARS_LEN,\n                                                   ptimestamp))\n  {\n    fprintf(log_file, \"Returning false due to timestamp chars length mismatch\\n\");\n    fclose(log_file);\n    log_file = NULL;\n    return false;\n  }\n\n  fprintf(log_file, \"Returning true successfully\\n\");\n  fclose(log_file);\n  log_file = NULL;\n  return true;\n}\n"
}