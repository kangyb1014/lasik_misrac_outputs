{
  "user_message": "<misra_rule>\nMISRA C 2023 Rule 1.2 is: Language extensions should not be used.\nYou should report only when the code uses any language compiler extensions that are explicitly stated as an extension in compiler documentations.\n</misra_rule>\n<response format>\nProvide your answer with these fields.\n- is_rule_violated: whether the rule is violated or not (true/false),\n- scenario: a specific violation scenario.\n- test_code: a modified get_nonce_timestamp code that contains useful probe functions that print useful logs to a file \"/tmp/logs/584.txt\". The logs should contain the control path and state information of the violation scenario. If the MISRA C rule is not violated, you can just return an empty string for the test code.\nHere are the constraints for the test code:\n- DO NOT introduce new violations to demonstrate your scenario.\n- The test code MUST be compilable and executable.\n- The test code MUST include line breaks.\n- The test code MUST preserve the original logic of get_nonce_timestamp as much as possible.\n- You MUST NOT define the main function.\n- You MUST NOT define macros.\n- The test code MUST not contain any mock functions.\n</response format>\n<target_code>\nHere is the code of get_nonce_timestamp:\n```c\nstatic bool\nget_nonce_timestamp (const char *const nonce,\n                     size_t noncelen,\n                     uint64_t *const ptimestamp)\n{\n  if (0 == noncelen)\n    noncelen = strlen (nonce);\n\n  if (true\n#ifdef MHD_MD5_SUPPORT\n      && (NONCE_STD_LEN (MD5_DIGEST_SIZE) != noncelen)\n#endif /* MHD_MD5_SUPPORT */\n#if defined(MHD_SHA256_SUPPORT) || defined(MHD_SHA512_256_SUPPORT)\n      && (NONCE_STD_LEN (SHA256_SHA512_256_DIGEST_SIZE) != noncelen)\n#endif /* MHD_SHA256_SUPPORT */\n      )\n    return false;\n\n  if (TIMESTAMP_CHARS_LEN !=\n      MHD_strx_to_uint64_n_ (nonce + noncelen - TIMESTAMP_CHARS_LEN,\n                             TIMESTAMP_CHARS_LEN,\n                             ptimestamp))\n    return false;\n  return true;\n}\n```\n</target_code>\n<additional code>Here are the definitions of symbols that are close to the target function get_nonce_timestamp:\n#define NONCE_STD_LEN(digest_size) ((digest_size)*2+TIMESTAMP_CHARS_LEN)\n...\n#define MD5_DIGEST_SIZE (MD5_DIGEST_SIZE_WORDS*MD5_BYTES_IN_WORD)\n...\n#define SHA256_SHA512_256_DIGEST_SIZE SHA512_256_DIGEST_SIZE\n...\n#define TIMESTAMP_CHARS_LEN (TIMESTAMP_BIN_SIZE*2)\n</additional code>\nJudge whether the above get_nonce_timestamp code violates the rule 1.2 or not.",
  "is_rule_violated": false,
  "scenario": "The code uses preprocessor directives to conditionally compile parts of the condition based on macros MHD_MD5_SUPPORT, MHD_SHA256_SUPPORT, and MHD_SHA512_256_SUPPORT, which is standard C preprocessor usage and not a language extension. There are no compiler-specific language extensions, such as attributes, pragmas outside standard, or non-standard keywords used in the function.",
  "test_code": ""
}