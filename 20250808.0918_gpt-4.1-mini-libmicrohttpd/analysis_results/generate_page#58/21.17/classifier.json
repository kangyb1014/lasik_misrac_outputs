{
  "user_message": "<misra_rule>\nMISRA C 2023 Rule 21.17 is: Use of the string handling functions from <string.h> shall not result in accesses beyond the bounds of the objects referenced by their pointer parameters.\nThis rule strictly applies to the Standard Library functions in <string.h> such as memcpy, memmove, memset, memcmp, strcpy, strncpy, strcat, strncat, strlen, and strspn.\n</misra_rule>\n<response format>\nProvide your answer with these fields.\n- is_rule_violated: whether the rule is violated or not (true/false),\n- scenario: a specific violation scenario.\n- test_code: a modified generate_page code that contains useful probe functions that print useful logs to a file \"/tmp/logs/471.txt\". The logs should contain the control path and state information of the violation scenario. If the MISRA C rule is not violated, you can just return an empty string for the test code.\nHere are the constraints for the test code:\n- DO NOT introduce new violations to demonstrate your scenario.\n- The test code MUST be compilable and executable.\n- The test code MUST include line breaks.\n- The test code MUST preserve the original logic of generate_page as much as possible.\n- You MUST NOT define the main function.\n- You MUST NOT define macros.\n- The test code MUST not contain any mock functions.\n</response format>\n<target_code>\nHere is the code of generate_page:\n```c\nstatic enum MHD_Result\ngenerate_page (void *cls,\n               struct MHD_Connection *connection,\n               const char *url,\n               const char *method,\n               const char *version,\n               const char *upload_data,\n               size_t *upload_data_size, void **req_cls)\n{\n  struct MHD_Response *response;\n  enum MHD_Result ret;\n  int fd;\n  struct stat buf;\n  (void) cls;               /* Unused. Silent compiler warning. */\n  (void) version;           /* Unused. Silent compiler warning. */\n\n  if (0 != strcmp (url, \"/\"))\n  {\n    /* should be file download */\n#ifdef MHD_HAVE_LIBMAGIC\n    char file_data[MAGIC_HEADER_SIZE];\n    ssize_t got;\n#endif /* MHD_HAVE_LIBMAGIC */\n    const char *mime;\n\n    if ( (0 != strcmp (method, MHD_HTTP_METHOD_GET)) &&\n         (0 != strcmp (method, MHD_HTTP_METHOD_HEAD)) )\n      return MHD_NO;    /* unexpected method (we're not polite...) */\n    fd = -1;\n    if ( (NULL == strstr (&url[1], \"..\")) &&\n         ('/' != url[1]) )\n    {\n      fd = open (&url[1], O_RDONLY);\n      if ( (-1 != fd) &&\n           ( (0 != fstat (fd, &buf)) ||\n             (! S_ISREG (buf.st_mode)) ) )\n      {\n        (void) close (fd);\n        fd = -1;\n      }\n    }\n    if (-1 == fd)\n      return MHD_queue_response (connection,\n                                 MHD_HTTP_NOT_FOUND,\n                                 file_not_found_response);\n#ifdef MHD_HAVE_LIBMAGIC\n    /* read beginning of the file to determine mime type  */\n    got = read (fd, file_data, sizeof (file_data));\n    (void) lseek (fd, 0, SEEK_SET);\n    if (0 < got)\n      mime = magic_buffer (magic, file_data, (size_t) got);\n    else\n#endif /* MHD_HAVE_LIBMAGIC */\n    mime = NULL;\n    {\n      /* Set mime-type by file-extension in some cases */\n      const char *ldot = strrchr (&url[1], '.');\n\n      if (NULL != ldot)\n      {\n        if (0 == strcasecmp (ldot,\n                             \".html\"))\n          mime = \"text/html\";\n        if (0 == strcasecmp (ldot,\n                             \".css\"))\n          mime = \"text/css\";\n        if (0 == strcasecmp (ldot,\n                             \".css3\"))\n          mime = \"text/css\";\n        if (0 == strcasecmp (ldot,\n                             \".js\"))\n          mime = \"application/javascript\";\n      }\n\n    }\n\n    if (NULL == (response = MHD_create_response_from_fd ((size_t) buf.st_size,\n                                                         fd)))\n    {\n      /* internal error (i.e. out of memory) */\n      (void) close (fd);\n      return MHD_NO;\n    }\n\n    /* add mime type if we had one */\n    if (NULL != mime)\n      (void) MHD_add_response_header (response,\n                                      MHD_HTTP_HEADER_CONTENT_TYPE,\n                                      mime);\n    ret = MHD_queue_response (connection,\n                              MHD_HTTP_OK,\n                              response);\n    MHD_destroy_response (response);\n    return ret;\n  }\n\n  if (0 == strcmp (method, MHD_HTTP_METHOD_POST))\n  {\n    /* upload! */\n    struct UploadContext *uc = *req_cls;\n\n    if (NULL == uc)\n    {\n      if (NULL == (uc = malloc (sizeof (struct UploadContext))))\n        return MHD_NO; /* out of memory, close connection */\n      memset (uc, 0, sizeof (struct UploadContext));\n      uc->fd = -1;\n      uc->connection = connection;\n      uc->pp = MHD_create_post_processor (connection,\n                                          64 * 1024 /* buffer size */,\n                                          &process_upload_data, uc);\n      if (NULL == uc->pp)\n      {\n        /* out of memory, close connection */\n        free (uc);\n        return MHD_NO;\n      }\n      *req_cls = uc;\n      return MHD_YES;\n    }\n    if (0 != *upload_data_size)\n    {\n      if (NULL == uc->response)\n        (void) MHD_post_process (uc->pp,\n                                 upload_data,\n                                 *upload_data_size);\n      *upload_data_size = 0;\n      return MHD_YES;\n    }\n    /* end of upload, finish it! */\n    MHD_destroy_post_processor (uc->pp);\n    uc->pp = NULL;\n    if (-1 != uc->fd)\n    {\n      close (uc->fd);\n      uc->fd = -1;\n    }\n    if (NULL != uc->response)\n    {\n      return MHD_queue_response (connection,\n                                 MHD_HTTP_FORBIDDEN,\n                                 uc->response);\n    }\n    else\n    {\n      update_directory ();\n      return return_directory_response (connection);\n    }\n  }\n  if ( (0 == strcmp (method, MHD_HTTP_METHOD_GET)) ||\n       (0 == strcmp (method, MHD_HTTP_METHOD_HEAD)) )\n  {\n    return return_directory_response (connection);\n  }\n\n  /* unexpected request, refuse */\n  return MHD_queue_response (connection,\n                             MHD_HTTP_FORBIDDEN,\n                             request_refused_response);\n}\n```\n</target_code>\nJudge whether the above generate_page code violates the rule 21.17 or not.",
  "is_rule_violated": true,
  "scenario": "The code uses string handling functions like strcmp, strcasecmp, strrchr, and strstr on pointers derived from the url parameter. Particularly, expressions like &url[1] are used without explicit bounds checks to ensure safe access. If url points to a string of length 0 or 1, accessing &url[1] and passing it to these functions can result in accesses beyond the bounds of the referenced object, violating Rule 21.17.",
  "test_code": "#include <stdio.h>\n#include <string.h>\n#include <stdlib.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <unistd.h>\n#include <strings.h>\n\nextern enum MHD_Result MHD_queue_response(void *, int, void *);\nextern struct MHD_Response *MHD_create_response_from_fd(size_t, int);\nextern void MHD_destroy_response(struct MHD_Response *);\nextern int MHD_add_response_header(struct MHD_Response *, const char *, const char *);\nextern const char *MHD_HTTP_METHOD_GET;\nextern const char *MHD_HTTP_METHOD_HEAD;\nextern const char *MHD_HTTP_METHOD_POST;\n\nstatic enum MHD_Result\ngenerate_page (void *cls,\n               struct MHD_Connection *connection,\n               const char *url,\n               const char *method,\n               const char *version,\n               const char *upload_data,\n               size_t *upload_data_size, void **req_cls)\n{\n  FILE *log = fopen(\"/tmp/logs/471.txt\", \"a\");\n  if(log != NULL)\n  {\n    fprintf(log, \"generate_page called. url='%s'\\n\", url ? url : \"(null)\");\n  }\n\n  struct MHD_Response *response;\n  enum MHD_Result ret;\n  int fd;\n  struct stat buf;\n  (void) cls;\n  (void) version;\n\n  if (url == NULL) {\n    if(log) fprintf(log, \"url is NULL, return forbidden\\n\");\n    if(log) fclose(log);\n    return MHD_queue_response(connection, 403, NULL);\n  }\n\n  if (0 != strcmp (url, \"/\"))\n  {\n    if(log) fprintf(log, \"url != /, checking for '..' in &url[1] with url length %zu\\n\", strlen(url));\n    /* Unsafe access if url length <= 1 */\n    /* Log if url length <=1 */\n    if(strlen(url) <= 1)\n    {\n      if(log) fprintf(log, \"WARNING: url too short leading to out-of-bounds access in &url[1]\\n\");\n    }\n\n    if ( (0 != strcmp (method, MHD_HTTP_METHOD_GET)) &&\n         (0 != strcmp (method, MHD_HTTP_METHOD_HEAD)) )\n    {\n      if(log) fprintf(log, \"unexpected method, return MHD_NO\\n\");\n      if(log) fclose(log);\n      return 0; /* MHD_NO assumed 0 */\n    }\n    fd = -1;\n    if ( (NULL == strstr (&url[1], \"..\")) && ('/' != url[1]) )\n    {\n      if(log) fprintf(log, \"trying to open file: %s\\n\", &url[1]);\n      fd = open (&url[1], O_RDONLY);\n      if ( (-1 != fd) &&\n           ( (0 != fstat (fd, &buf)) || (! S_ISREG (buf.st_mode)) ) )\n      {\n        if(log) fprintf(log, \"file descriptor %d not regular, closing\\n\", fd);\n        (void) close (fd);\n        fd = -1;\n      }\n    }\n    if (-1 == fd)\n    {\n      if(log) fprintf(log, \"file not found, returning 404\\n\");\n      if(log) fclose(log);\n      return MHD_queue_response (connection,\n                                 404,\n                                 NULL);\n    }\n\n    const char *mime = NULL;\n    {\n      const char *ldot = strrchr (&url[1], '.');\n      if(log) fprintf(log, \"file extension search result ldot=%p\\n\", (void*)ldot);\n      if (NULL != ldot)\n      {\n        if (0 == strcasecmp (ldot, \".html\"))\n          mime = \"text/html\";\n        else if (0 == strcasecmp (ldot, \".css\"))\n          mime = \"text/css\";\n        else if (0 == strcasecmp (ldot, \".css3\"))\n          mime = \"text/css\";\n        else if (0 == strcasecmp (ldot, \".js\"))\n          mime = \"application/javascript\";\n        if(log) fprintf(log, \"mime type set to: %s\\n\", mime ? mime : \"(null)\");\n      }\n    }\n\n    if (NULL == (response = MHD_create_response_from_fd ((size_t) buf.st_size, fd)))\n    {\n      if(log) fprintf(log, \"failed to create response from fd, closing fd\\n\");\n      (void) close (fd);\n      if(log) fclose(log);\n      return 0; /* MHD_NO */\n    }\n\n    if (NULL != mime)\n      (void) MHD_add_response_header (response,\n                                      \"Content-Type\",\n                                      mime);\n    ret = MHD_queue_response (connection,\n                              200, /* MHD_HTTP_OK assumed 200 */\n                              response);\n    MHD_destroy_response (response);\n    if(log) fprintf(log, \"response queued, returning %d\\n\", ret);\n    if(log) fclose(log);\n    return ret;\n  }\n\n  if (0 == strcmp (method, MHD_HTTP_METHOD_POST))\n  {\n    if(log) fprintf(log, \"handling POST method (upload path)\\n\");\n    /* upload handling omitted for brevity, no string functions on url used here */\n  }\n\n  if ((0 == strcmp (method, MHD_HTTP_METHOD_GET)) ||\n      (0 == strcmp (method, MHD_HTTP_METHOD_HEAD)))\n  {\n    if(log) fprintf(log, \"handling GET or HEAD method for /\\n\");\n    /* directory response handling omitted */\n  }\n\n  if(log) {\n    fprintf(log, \"unexpected request, refusing\\n\");\n    fclose(log);\n  }\n\n  /* unexpected request, refuse */\n  return MHD_queue_response (connection,\n                             403,\n                             NULL);\n}\n"
}