{
  "user_message": "An agent A claimed that the following MHD_pool_create code violates the MISRA C 2023 rule 1.2.\n<misra_rule>\nMISRA C 2023 Rule 1.2 is Language extensions should not be used.\nYou should report only when the code uses any language compiler extensions that are explicitly stated as an extension in compiler documentations..\n</misra_rule>\n<target_code>\nHere is the original code of MHD_pool_create.\n```c\nstruct MemoryPool *\nMHD_pool_create (size_t max)\n{\n  struct MemoryPool *pool;\n  size_t alloc_size;\n\n  mhd_assert (max > 0);\n  alloc_size = 0;\n  pool = malloc (sizeof (struct MemoryPool));\n  if (NULL == pool)\n    return NULL;\n#if defined(MAP_ANONYMOUS) || defined(_WIN32)\n  if ( (max <= 32 * 1024) ||\n       (max < MHD_sys_page_size_ * 4 / 3) )\n  {\n    pool->memory = MAP_FAILED;\n  }\n  else\n  {\n    /* Round up allocation to page granularity. */\n    alloc_size = max + MHD_sys_page_size_ - 1;\n    alloc_size -= alloc_size % MHD_sys_page_size_;\n#if defined(MAP_ANONYMOUS) && ! defined(_WIN32)\n    pool->memory = mmap (NULL,\n                         alloc_size,\n                         PROT_READ | PROT_WRITE,\n                         MAP_PRIVATE | MAP_ANONYMOUS,\n                         -1,\n                         0);\n#elif defined(_WIN32)\n    pool->memory = VirtualAlloc (NULL,\n                                 alloc_size,\n                                 MEM_COMMIT | MEM_RESERVE,\n                                 PAGE_READWRITE);\n#endif /* _WIN32 */\n  }\n#else  /* ! _WIN32 && ! MAP_ANONYMOUS */\n  pool->memory = MAP_FAILED;\n#endif /* ! _WIN32 && ! MAP_ANONYMOUS */\n  if (MAP_FAILED == pool->memory)\n  {\n    alloc_size = ROUND_TO_ALIGN (max);\n    pool->memory = malloc (alloc_size);\n    if (NULL == pool->memory)\n    {\n      free (pool);\n      return NULL;\n    }\n    pool->is_mmap = false;\n  }\n#if defined(MAP_ANONYMOUS) || defined(_WIN32)\n  else\n  {\n    pool->is_mmap = true;\n  }\n#endif /* _WIN32 || MAP_ANONYMOUS */\n  mhd_assert (0 == (((uintptr_t) pool->memory) % ALIGN_SIZE));\n  pool->pos = 0;\n  pool->end = alloc_size;\n  pool->size = alloc_size;\n  mhd_assert (0 < alloc_size);\n  _MHD_POISON_MEMORY (pool->memory, pool->size);\n  return pool;\n}\n```\n</target_code>\n<scenario>\nThe agent A provided the following violation scenario:Use of compiler or platform-specific language extensions such as mmap with MAP_ANONYMOUS, Windows VirtualAlloc, and platform-specific macros like MAP_FAILED which might be defined as language/compiler/platform extensions, potentially violating MISRA C 2023 Rule 1.2 which prohibits compiler language extensions.\n</scenario>\n<test_code>\nAlso, the agent A provided the following modified code that prints out the log to support their scenario:\n```c\nstatic FILE *log_file = NULL;\nstatic void log_state(const char *msg, size_t val) {\n  if (log_file) {\n    fprintf(log_file, \"%s: %zu\\n\", msg, val);\n    fflush(log_file);\n  }\n}\nstatic void log_ptr(const char *msg, void *ptr) {\n  if (log_file) {\n    fprintf(log_file, \"%s: %p\\n\", msg, ptr);\n    fflush(log_file);\n  }\n}\nstatic void mhd_assert(int cond) {\n  if (!cond) {\n    fprintf(stderr, \"Assertion failed\\n\");\n    exit(EXIT_FAILURE);\n  }\n}\nstatic const size_t ALIGN_SIZE = sizeof(void*);\nstatic size_t ROUND_TO_ALIGN(size_t size) {\n  return (size + ALIGN_SIZE - 1) & ~(ALIGN_SIZE - 1);\n}\nstatic void _MHD_POISON_MEMORY(void *ptr, size_t size) {\n  /* No operation in this test code */\n  (void)ptr;\n  (void)size;\n}\n\nstruct MemoryPool *\nMHD_pool_create(size_t max)\n{\n  struct MemoryPool *pool;\n  size_t alloc_size;\n\n  log_file = fopen(\"/tmp/logs/624.txt\", \"a\");\n  /* Ignore failure to open log file, fallback silently */\n\n  mhd_assert(max > 0);\n  log_state(\"Entered MHD_pool_create with max\", max);\n\n  alloc_size = 0;\n  pool = malloc(sizeof(struct MemoryPool));\n  if (NULL == pool) {\n    log_state(\"malloc failed for pool\", 0);\n    if (log_file) fclose(log_file);\n    return NULL;\n  }\n  log_ptr(\"Allocated pool pointer\", pool);\n\n#if defined(MAP_ANONYMOUS) || defined(_WIN32)\n  if ((max <= 32 * 1024) || (max < MHD_sys_page_size_ * 4 / 3))\n  {\n    pool->memory = MAP_FAILED;\n    log_ptr(\"Set pool->memory to MAP_FAILED due to size check\", pool->memory);\n  }\n  else\n  {\n    /* Round up allocation to page granularity. */\n    alloc_size = max + MHD_sys_page_size_ - 1;\n    alloc_size -= alloc_size % MHD_sys_page_size_;\n    log_state(\"Rounded alloc_size\", alloc_size);\n#if defined(MAP_ANONYMOUS) && !defined(_WIN32)\n    pool->memory = mmap(NULL,\n                        alloc_size,\n                        PROT_READ | PROT_WRITE,\n                        MAP_PRIVATE | MAP_ANONYMOUS,\n                        -1,\n                        0);\n    log_ptr(\"mmap returned\", pool->memory);\n#elif defined(_WIN32)\n    pool->memory = VirtualAlloc(NULL,\n                                alloc_size,\n                                MEM_COMMIT | MEM_RESERVE,\n                                PAGE_READWRITE);\n    log_ptr(\"VirtualAlloc returned\", pool->memory);\n#endif\n  }\n#else /* ! _WIN32 && ! MAP_ANONYMOUS */\n  pool->memory = MAP_FAILED;\n  log_ptr(\"Set pool->memory to MAP_FAILED due to fallback\", pool->memory);\n#endif\n\n  if (MAP_FAILED == pool->memory)\n  {\n    alloc_size = ROUND_TO_ALIGN(max);\n    log_state(\"Fallback alloc_size\", alloc_size);\n    pool->memory = malloc(alloc_size);\n    log_ptr(\"Fallback malloc returned\", pool->memory);\n    if (NULL == pool->memory)\n    {\n      free(pool);\n      log_state(\"Fallback malloc failed, pool freed\", 0);\n      if (log_file) fclose(log_file);\n      return NULL;\n    }\n    pool->is_mmap = false;\n  }\n#if defined(MAP_ANONYMOUS) || defined(_WIN32)\n  else\n  {\n    pool->is_mmap = true;\n  }\n#endif\n\n  mhd_assert(0 == (((uintptr_t) pool->memory) % ALIGN_SIZE));\n  pool->pos = 0;\n  pool->end = alloc_size;\n  pool->size = alloc_size;\n  mhd_assert(0 < alloc_size);\n  _MHD_POISON_MEMORY(pool->memory, pool->size);\n  log_ptr(\"Returning pool pointer\", pool);\n\n  if (log_file) fclose(log_file);\n  return pool;\n}\n\n```\nThe test code failed to compile, so we could not obtain any output.\n\n</test_code>\n<response format>\nProvide your answer with these fields.\n- explanation: your evaluation of the scenario provided by the agent A.\n- is_report_correct: whether the report is correct or not (true/false)\n</response format>\n<instruction>   \nJudge whether the report is correct or not.\n</instruction>\n",
  "is_report_correct": false,
  "explanation": "MISRA C 2023 Rule 1.2 prohibits the use of language compiler extensions. The given code uses platform-specific APIs such as mmap with MAP_ANONYMOUS on POSIX systems and VirtualAlloc on Windows. These APIs are not part of standard C but are system APIs exposed via system headers for memory management. However, these are not \"language extensions\" in the sense of compiler language extensions; rather, they are standard platform APIs accessed through system headers. The code does use platform-specific macros and constants (MAP_ANONYMOUS, MAP_FAILED, _WIN32), but these are not language extensions themselves\u2014they are preprocessor macros defined by the platform SDKs. Rule 1.2 focuses specifically on language/compiler extensions that alter or extend the core C language beyond the standard, such as compiler-specific keywords or constructs. Use of platform libraries and system calls is not considered a compiler language extension per MISRA C guidelines. Agent A\u2019s reasoning that use of mmap, VirtualAlloc, and associated macros violates Rule 1.2 is not correct, since these are standard OS/library interfaces rather than compiler-specific language extensions. Therefore, the report claiming violation of MISRA C Rule 1.2 is incorrect."
}