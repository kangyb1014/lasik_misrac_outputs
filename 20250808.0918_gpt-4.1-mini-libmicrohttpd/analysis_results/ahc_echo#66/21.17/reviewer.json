{
  "user_message": "An agent A claimed that the following ahc_echo code violates the MISRA C 2023 rule 21.17.\n<misra_rule>\nMISRA C 2023 Rule 21.17 is Use of the string handling functions from <string.h> shall not result in accesses beyond the bounds of the objects referenced by their pointer parameters.\nThis rule strictly applies to the Standard Library functions in <string.h> such as memcpy, memmove, memset, memcmp, strcpy, strncpy, strcat, strncat, strlen, and strspn..\n</misra_rule>\n<target_code>\nHere is the original code of ahc_echo.\n```c\nstatic enum MHD_Result\nahc_echo (void *cls,\n          struct MHD_Connection *connection,\n          const char *url,\n          const char *method,\n          const char *version,\n          const char *upload_data, size_t *upload_data_size, void **req_cls)\n{\n  static int aptr;\n  struct MHD_Response *response;\n  enum MHD_Result ret;\n  struct MHD_BasicAuthInfo *auth_info;\n  int fail;\n  (void) cls;               /* Unused. Silent compiler warning. */\n  (void) url;               /* Unused. Silent compiler warning. */\n  (void) version;           /* Unused. Silent compiler warning. */\n  (void) upload_data;       /* Unused. Silent compiler warning. */\n  (void) upload_data_size;  /* Unused. Silent compiler warning. */\n\n  if (0 != strcmp (method, \"GET\"))\n    return MHD_NO;              /* unexpected method */\n  if (&aptr != *req_cls)\n  {\n    /* do never respond on first call */\n    *req_cls = &aptr;\n    return MHD_YES;\n  }\n  *req_cls = NULL;                  /* reset when done */\n\n  /* require: \"Aladdin\" with password \"open sesame\" */\n  auth_info = MHD_basic_auth_get_username_password3 (connection);\n  fail = ( (NULL == auth_info) ||\n           (strlen (\"Aladdin\") != auth_info->username_len) ||\n           (0 != memcmp (auth_info->username, \"Aladdin\",\n                         auth_info->username_len)) ||\n           /* The next check against NULL is optional,\n            * if 'password' is NULL then 'password_len' is always zero. */\n           (NULL == auth_info->password) ||\n           (strlen (\"open sesame\") != auth_info->password_len) ||\n           (0 != memcmp (auth_info->password, \"open sesame\",\n                         auth_info->password_len)) );\n  if (fail)\n  {\n    response =\n      MHD_create_response_from_buffer_static (strlen (DENIED),\n                                              (const void *) DENIED);\n    ret = MHD_queue_basic_auth_required_response3 (connection,\n                                                   \"TestRealm\",\n                                                   MHD_NO,\n                                                   response);\n  }\n  else\n  {\n    response =\n      MHD_create_response_from_buffer_static (strlen (PAGE),\n                                              (const void *) PAGE);\n    ret = MHD_queue_response (connection, MHD_HTTP_OK, response);\n  }\n  if (NULL != auth_info)\n    MHD_free (auth_info);\n  MHD_destroy_response (response);\n  return ret;\n}\n```\n</target_code>\n<scenario>\nThe agent A provided the following violation scenario:If the authentication info obtained from MHD_basic_auth_get_username_password3 contains username_len or password_len value larger than the actual buffer lengths of auth_info->username or auth_info->password, then the calls to memcmp with auth_info->username_len and auth_info->password_len as length parameters can access beyond the bounds of these buffers violating Rule 21.17.\n</scenario>\n<test_code>\nAlso, the agent A provided the following modified code that prints out the log to support their scenario:\n```c\n\nstatic enum MHD_Result\nahc_echo (void *cls,\n          struct MHD_Connection *connection,\n          const char *url,\n          const char *method,\n          const char *version,\n          const char *upload_data, size_t *upload_data_size, void **req_cls)\n{\n  static int aptr;\n  struct MHD_Response *response;\n  enum MHD_Result ret;\n  struct MHD_BasicAuthInfo *auth_info;\n  int fail;\n  FILE *log_fp = fopen(\"/tmp/logs/535.txt\", \"a\");\n\n  (void) cls;\n  (void) url;\n  (void) version;\n  (void) upload_data;\n  (void) upload_data_size;\n\n  if (log_fp) {\n    fprintf(log_fp, \"Entered ahc_echo with method=%s\\n\", method);\n  }\n\n  if (0 != strcmp (method, \"GET\")) {\n    if (log_fp) {\n      fprintf(log_fp, \"Method is not GET, returning MHD_NO\\n\");\n      fclose(log_fp);\n    }\n    return MHD_NO;\n  }\n\n  if (&aptr != *req_cls)\n  {\n    if (log_fp) {\n      fprintf(log_fp, \"First call, setting *req_cls and returning MHD_YES\\n\");\n    }\n    *req_cls = &aptr;\n    if (log_fp) fclose(log_fp);\n    return MHD_YES;\n  }\n\n  *req_cls = NULL;\n\n  auth_info = MHD_basic_auth_get_username_password3 (connection);\n\n  if (log_fp) {\n    if (auth_info == NULL) {\n      fprintf(log_fp, \"auth_info is NULL\\n\");\n    } else {\n      fprintf(log_fp, \"auth_info->username_len=%zu, auth_info->password_len=%zu\\n\",\n              auth_info->username_len, auth_info->password_len);\n      fprintf(log_fp, \"auth_info->username='%s', auth_info->password='%s'\\n\",\n              auth_info->username ? auth_info->username : \"(null)\",\n              auth_info->password ? auth_info->password : \"(null)\");\n    }\n  }\n\n  /* Introduce a check to log if auth_info lengths may be inconsistent to simulate violation */\n  if (auth_info != NULL) {\n    size_t username_buffer_len = strlen(auth_info->username ? auth_info->username : \"\") + 1;\n    size_t password_buffer_len = auth_info->password ? strlen(auth_info->password) + 1 : 0;\n    if (log_fp) {\n      fprintf(log_fp, \"username_buffer_len=%zu, password_buffer_len=%zu\\n\", username_buffer_len, password_buffer_len);\n    }\n    if ((auth_info->username_len > username_buffer_len) ||\n        (auth_info->password_len > password_buffer_len)) {\n      if (log_fp) {\n        fprintf(log_fp, \"Potential buffer overflow: auth_info lengths exceed buffer lengths!\\n\");\n      }\n    }\n  }\n\n  fail = ((NULL == auth_info) ||\n          (strlen(\"Aladdin\") != auth_info->username_len) ||\n          (0 != memcmp(auth_info->username, \"Aladdin\", auth_info->username_len)) ||\n          (NULL == auth_info->password) ||\n          (strlen(\"open sesame\") != auth_info->password_len) ||\n          (0 != memcmp(auth_info->password, \"open sesame\", auth_info->password_len)));\n\n  if (fail)\n  {\n    response =\n      MHD_create_response_from_buffer(strlen(DENIED), (void *)DENIED, MHD_RESPMEM_PERSISTENT);\n    ret = MHD_queue_basic_auth_required_response3(connection, \"TestRealm\", MHD_NO, response);\n  }\n  else\n  {\n    response =\n      MHD_create_response_from_buffer(strlen(PAGE), (void *)PAGE, MHD_RESPMEM_PERSISTENT);\n    ret = MHD_queue_response(connection, MHD_HTTP_OK, response);\n  }\n\n  if (NULL != auth_info)\n    MHD_free(auth_info);\n  MHD_destroy_response(response);\n\n  if (log_fp) {\n    fprintf(log_fp, \"Exiting ahc_echo with ret=%d\\n\", ret);\n    fclose(log_fp);\n  }\n  return ret;\n}\n\n```\nThe test code failed to compile, so we could not obtain any output.\n\n</test_code>\n<response format>\nProvide your answer with these fields.\n- explanation: your evaluation of the scenario provided by the agent A.\n- is_report_correct: whether the report is correct or not (true/false)\n</response format>\n<instruction>   \nJudge whether the report is correct or not.\n</instruction>\n",
  "is_report_correct": true,
  "explanation": "The reported violation concerns the use of memcmp with a length parameter (auth_info->username_len or auth_info->password_len) that may exceed the actual buffer length of the corresponding strings. Rule 21.17 prohibits accesses beyond the bounds of objects when using standard string functions. The key question is whether auth_info->username_len and auth_info->password_len are guaranteed to not exceed the actual sizes of auth_info->username and auth_info->password buffers respectively. The code assumes these lengths are valid and directly uses them as the length argument to memcmp. However, the source or documentation of MHD_basic_auth_get_username_password3 is not included here, so it's unclear whether these lengths are reliably bounded. The provided scenario correctly points out that if these length fields are not trustworthy, memcmp can cause buffer overruns, violating Rule 21.17. The test code attempts to detect such inconsistencies but does not provide conclusive evidence as it failed to compile. Despite this, the reasoning is valid: the code does not perform explicit bounds checking, and so there is a potential for out-of-bounds access if auth_info contains inconsistent length information. Therefore, the agent's report that the code may violate MISRA C 2023 Rule 21.17 is correct because the code as written relies on unverified lengths that can lead to buffer overreads in string handling functions."
}