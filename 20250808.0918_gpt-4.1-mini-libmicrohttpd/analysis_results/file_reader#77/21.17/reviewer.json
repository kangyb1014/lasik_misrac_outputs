{
  "user_message": "An agent A claimed that the following file_reader code violates the MISRA C 2023 rule 21.17.\n<misra_rule>\nMISRA C 2023 Rule 21.17 is Use of the string handling functions from <string.h> shall not result in accesses beyond the bounds of the objects referenced by their pointer parameters.\nThis rule strictly applies to the Standard Library functions in <string.h> such as memcpy, memmove, memset, memcmp, strcpy, strncpy, strcat, strncat, strlen, and strspn..\n</misra_rule>\n<target_code>\nHere is the original code of file_reader.\n```c\nstatic ssize_t\nfile_reader (void *cls,\n             uint64_t pos,\n             char *buf,\n             size_t max)\n{\n  struct MHD_Response *response = cls;\n#if ! defined(_WIN32) || defined(__CYGWIN__)\n  ssize_t n;\n#else  /* _WIN32 && !__CYGWIN__ */\n  const HANDLE fh = (HANDLE) (uintptr_t) _get_osfhandle (response->fd);\n#endif /* _WIN32 && !__CYGWIN__ */\n  const int64_t offset64 = (int64_t) (pos + response->fd_off);\n\n  if (offset64 < 0)\n    return MHD_CONTENT_READER_END_WITH_ERROR; /* seek to required position is not possible */\n\n#if ! defined(_WIN32) || defined(__CYGWIN__)\n  if (max > SSIZE_MAX)\n    max = SSIZE_MAX; /* Clamp to maximum return value. */\n\n#if defined(HAVE_PREAD64)\n  n = pread64 (response->fd, buf, max, offset64);\n#elif defined(HAVE_PREAD)\n  if ( (sizeof(off_t) < sizeof (uint64_t)) &&\n       (offset64 > (uint64_t) INT32_MAX) )\n    return MHD_CONTENT_READER_END_WITH_ERROR; /* Read at required position is not possible. */\n\n  n = pread (response->fd, buf, max, (off_t) offset64);\n#else  /* ! HAVE_PREAD */\n#if defined(HAVE_LSEEK64)\n  if (lseek64 (response->fd,\n               offset64,\n               SEEK_SET) != offset64)\n    return MHD_CONTENT_READER_END_WITH_ERROR; /* can't seek to required position */\n#else  /* ! HAVE_LSEEK64 */\n  if ( (sizeof(off_t) < sizeof (uint64_t)) &&\n       (offset64 > (uint64_t) INT32_MAX) )\n    return MHD_CONTENT_READER_END_WITH_ERROR; /* seek to required position is not possible */\n\n  if (lseek (response->fd,\n             (off_t) offset64,\n             SEEK_SET) != (off_t) offset64)\n    return MHD_CONTENT_READER_END_WITH_ERROR; /* can't seek to required position */\n#endif /* ! HAVE_LSEEK64 */\n  n = read (response->fd,\n            buf,\n            max);\n\n#endif /* ! HAVE_PREAD */\n  if (0 == n)\n    return MHD_CONTENT_READER_END_OF_STREAM;\n  if (n < 0)\n    return MHD_CONTENT_READER_END_WITH_ERROR;\n  return n;\n#else /* _WIN32 && !__CYGWIN__ */\n  if (INVALID_HANDLE_VALUE == fh)\n    return MHD_CONTENT_READER_END_WITH_ERROR; /* Value of 'response->fd' is not valid. */\n  else\n  {\n    OVERLAPPED f_ol = {0, 0, {{0, 0}}, 0};   /* Initialize to zero. */\n    ULARGE_INTEGER pos_uli;\n    DWORD toRead = (max > INT32_MAX) ? INT32_MAX : (DWORD) max;\n    DWORD resRead;\n\n    pos_uli.QuadPart = (uint64_t) offset64;   /* Simple transformation 64bit -> 2x32bit. */\n    f_ol.Offset = pos_uli.LowPart;\n    f_ol.OffsetHigh = pos_uli.HighPart;\n    if (! ReadFile (fh, (void *) buf, toRead, &resRead, &f_ol))\n      return MHD_CONTENT_READER_END_WITH_ERROR;   /* Read error. */\n    if (0 == resRead)\n      return MHD_CONTENT_READER_END_OF_STREAM;\n    return (ssize_t) resRead;\n  }\n#endif /* _WIN32 && !__CYGWIN__ */\n}\n```\n</target_code>\n<scenario>\nThe agent A provided the following violation scenario:A potential violation scenario occurs if the 'max' parameter passed to 'file_reader' exceeds the actual size of the buffer pointed to by 'buf'. Specifically, since 'buf' is a pointer to a char buffer assumed to hold at least 'max' bytes, passing a larger 'max' than the allocated buffer size would cause the read or pread64 call to write beyond 'buf' bounds, violating Rule 21.17. The function does clamp 'max' when it exceeds SSIZE_MAX, but does not validate against the actual buffer size, hence risking out-of-bounds writes if the caller is incorrect.\n</scenario>\n<test_code>\nAlso, the agent A provided the following modified code that prints out the log to support their scenario:\n```c\n\nstatic ssize_t\nfile_reader (void *cls,\n             uint64_t pos,\n             char *buf,\n             size_t max)\n{\n  struct MHD_Response *response = cls;\n#if ! defined(_WIN32) || defined(__CYGWIN__)\n  ssize_t n;\n#else  /* _WIN32 && !__CYGWIN__ */\n  const HANDLE fh = (HANDLE) (uintptr_t) _get_osfhandle (response->fd);\n#endif /* _WIN32 && !__CYGWIN__ */\n  const int64_t offset64 = (int64_t) (pos + response->fd_off);\n\n  FILE *log = fopen(\"/tmp/logs/623.txt\", \"a\");\n  if (log != NULL) {\n    fprintf(log, \"Entering file_reader: pos=%llu, max=%zu, fd_off=%llu\\n\", (unsigned long long)pos, max, (unsigned long long)response->fd_off);\n    fprintf(log, \"Buffer pointer: %p\\n\", (void*)buf);\n  }\n\n  if (offset64 < 0)\n  {\n    if (log) fprintf(log, \"Error: offset < 0: %lld\\n\", (long long)offset64);\n    if (log) fclose(log);\n    return MHD_CONTENT_READER_END_WITH_ERROR; /* seek to required position is not possible */\n  }\n\n#if ! defined(_WIN32) || defined(__CYGWIN__)\n  if (max > SSIZE_MAX) {\n    if (log) fprintf(log, \"Clamping max from %zu to SSIZE_MAX %ld\\n\", max, (long)SSIZE_MAX);\n    max = SSIZE_MAX; /* Clamp to maximum return value. */\n  }\n\n#if defined(HAVE_PREAD64)\n  n = pread64 (response->fd, buf, max, offset64);\n#elif defined(HAVE_PREAD)\n  if ( (sizeof(off_t) < sizeof (uint64_t)) &&\n       (offset64 > (uint64_t) INT32_MAX) ) {\n    if (log) fprintf(log, \"Error: offset too large for pread: %lld\\n\", (long long)offset64);\n    if (log) fclose(log);\n    return MHD_CONTENT_READER_END_WITH_ERROR; /* Read at required position is not possible. */\n  }\n\n  n = pread (response->fd, buf, max, (off_t) offset64);\n#else  /* ! HAVE_PREAD */\n#if defined(HAVE_LSEEK64)\n  if (lseek64 (response->fd,\n               offset64,\n               SEEK_SET) != offset64) {\n    if (log) fprintf(log, \"Error: lseek64 failed at offset: %lld\\n\", (long long)offset64);\n    if (log) fclose(log);\n    return MHD_CONTENT_READER_END_WITH_ERROR; /* can't seek to required position */\n  }\n#else  /* ! HAVE_LSEEK64 */\n  if ( (sizeof(off_t) < sizeof (uint64_t)) &&\n       (offset64 > (uint64_t) INT32_MAX) ) {\n    if (log) fprintf(log, \"Error: offset too large for lseek: %lld\\n\", (long long)offset64);\n    if (log) fclose(log);\n    return MHD_CONTENT_READER_END_WITH_ERROR; /* seek to required position is not possible */\n  }\n\n  if (lseek (response->fd,\n             (off_t) offset64,\n             SEEK_SET) != (off_t) offset64) {\n    if (log) fprintf(log, \"Error: lseek failed at offset: %lld\\n\", (long long)offset64);\n    if (log) fclose(log);\n    return MHD_CONTENT_READER_END_WITH_ERROR; /* can't seek to required position */\n  }\n#endif /* ! HAVE_LSEEK64 */\n  n = read (response->fd,\n            buf,\n            max);\n\n#endif /* ! HAVE_PREAD */\n  if (0 == n) {\n    if (log) fprintf(log, \"End of stream reached\\n\");\n    if (log) fclose(log);\n    return MHD_CONTENT_READER_END_OF_STREAM;\n  }\n  if (n < 0) {\n    if (log) fprintf(log, \"Read error: %zd\\n\", n);\n    if (log) fclose(log);\n    return MHD_CONTENT_READER_END_WITH_ERROR;\n  }\n\n  if (log) fprintf(log, \"Read %zd bytes successfully\\n\", n);\n  if (log) fclose(log);\n  return n;\n#else /* _WIN32 && !__CYGWIN__ */\n  if (INVALID_HANDLE_VALUE == fh) {\n    if (log) fprintf(log, \"Invalid file handle\\n\");\n    if (log) fclose(log);\n    return MHD_CONTENT_READER_END_WITH_ERROR; /* Value of 'response->fd' is not valid. */\n  } else\n  {\n    OVERLAPPED f_ol = {0, 0, {{0, 0}}, 0};   /* Initialize to zero. */\n    ULARGE_INTEGER pos_uli;\n    DWORD toRead = (max > INT32_MAX) ? INT32_MAX : (DWORD) max;\n    DWORD resRead;\n\n    if (log) fprintf(log, \"Windows read: toRead=%lu\\n\", (unsigned long)toRead);\n\n    pos_uli.QuadPart = (uint64_t) offset64;   /* Simple transformation 64bit -> 2x32bit. */\n    f_ol.Offset = pos_uli.LowPart;\n    f_ol.OffsetHigh = pos_uli.HighPart;\n\n    if (! ReadFile (fh, (void *) buf, toRead, &resRead, &f_ol)) {\n      if (log) fprintf(log, \"ReadFile failed\\n\");\n      if (log) fclose(log);\n      return MHD_CONTENT_READER_END_WITH_ERROR;   /* Read error. */\n    }\n    if (0 == resRead) {\n      if (log) fprintf(log, \"ReadFile read 0 bytes (end of stream)\\n\");\n      if (log) fclose(log);\n      return MHD_CONTENT_READER_END_OF_STREAM;\n    }\n\n    if (log) fprintf(log, \"ReadFile read %lu bytes\\n\", (unsigned long) resRead);\n    if (log) fclose(log);\n    return (ssize_t) resRead;\n  }\n#endif /* _WIN32 && !__CYGWIN__ */\n}\n\n```\nThe test code failed to compile, so we could not obtain any output.\n\n</test_code>\n<response format>\nProvide your answer with these fields.\n- explanation: your evaluation of the scenario provided by the agent A.\n- is_report_correct: whether the report is correct or not (true/false)\n</response format>\n<instruction>   \nJudge whether the report is correct or not.\n</instruction>\n",
  "is_report_correct": false,
  "explanation": "MISRA C 2023 Rule 21.17 requires that use of string handling functions from <string.h> must not cause out-of-bounds access for the referenced objects. The code in the provided file_reader function does not use any string.h functions such as memcpy, memset, strcpy, strncpy, strcat, etc. Instead, it uses I/O system calls like pread64, pread, read, and ReadFile to read bytes into a buffer. These functions write data into the buffer but are not part of string.h and the rule specifically applies to those string handling functions. Furthermore, the agent A's scenario hinges on an incorrect assumption that the max parameter could exceed the actual size of the buf buffer, causing the read function to write out of bounds. While that assumption may describe a potential caller error (violating general safe programming), it is not a violation of MISRA Rule 21.17 as it relates strictly to <string.h> functions. The code does clamp max to SSIZE_MAX to avoid overly large read requests but does not validate against buffer size, which is outside the scope of the rule. The violation scenario is thus not a violation of MISRA Rule 21.17 because the rule applies only to string.h functions, which are not used here. Therefore, agent A's claim that this code violates Rule 21.17 is incorrect."
}