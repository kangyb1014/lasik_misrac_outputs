{
  "user_message": "An agent A claimed that the following file_reader code violates the MISRA C 2023 rule 1.2.\n<misra_rule>\nMISRA C 2023 Rule 1.2 is Language extensions should not be used.\nYou should report only when the code uses any language compiler extensions that are explicitly stated as an extension in compiler documentations..\n</misra_rule>\n<target_code>\nHere is the original code of file_reader.\n```c\nstatic ssize_t\nfile_reader (void *cls,\n             uint64_t pos,\n             char *buf,\n             size_t max)\n{\n  struct MHD_Response *response = cls;\n#if ! defined(_WIN32) || defined(__CYGWIN__)\n  ssize_t n;\n#else  /* _WIN32 && !__CYGWIN__ */\n  const HANDLE fh = (HANDLE) (uintptr_t) _get_osfhandle (response->fd);\n#endif /* _WIN32 && !__CYGWIN__ */\n  const int64_t offset64 = (int64_t) (pos + response->fd_off);\n\n  if (offset64 < 0)\n    return MHD_CONTENT_READER_END_WITH_ERROR; /* seek to required position is not possible */\n\n#if ! defined(_WIN32) || defined(__CYGWIN__)\n  if (max > SSIZE_MAX)\n    max = SSIZE_MAX; /* Clamp to maximum return value. */\n\n#if defined(HAVE_PREAD64)\n  n = pread64 (response->fd, buf, max, offset64);\n#elif defined(HAVE_PREAD)\n  if ( (sizeof(off_t) < sizeof (uint64_t)) &&\n       (offset64 > (uint64_t) INT32_MAX) )\n    return MHD_CONTENT_READER_END_WITH_ERROR; /* Read at required position is not possible. */\n\n  n = pread (response->fd, buf, max, (off_t) offset64);\n#else  /* ! HAVE_PREAD */\n#if defined(HAVE_LSEEK64)\n  if (lseek64 (response->fd,\n               offset64,\n               SEEK_SET) != offset64)\n    return MHD_CONTENT_READER_END_WITH_ERROR; /* can't seek to required position */\n#else  /* ! HAVE_LSEEK64 */\n  if ( (sizeof(off_t) < sizeof (uint64_t)) &&\n       (offset64 > (uint64_t) INT32_MAX) )\n    return MHD_CONTENT_READER_END_WITH_ERROR; /* seek to required position is not possible */\n\n  if (lseek (response->fd,\n             (off_t) offset64,\n             SEEK_SET) != (off_t) offset64)\n    return MHD_CONTENT_READER_END_WITH_ERROR; /* can't seek to required position */\n#endif /* ! HAVE_LSEEK64 */\n  n = read (response->fd,\n            buf,\n            max);\n\n#endif /* ! HAVE_PREAD */\n  if (0 == n)\n    return MHD_CONTENT_READER_END_OF_STREAM;\n  if (n < 0)\n    return MHD_CONTENT_READER_END_WITH_ERROR;\n  return n;\n#else /* _WIN32 && !__CYGWIN__ */\n  if (INVALID_HANDLE_VALUE == fh)\n    return MHD_CONTENT_READER_END_WITH_ERROR; /* Value of 'response->fd' is not valid. */\n  else\n  {\n    OVERLAPPED f_ol = {0, 0, {{0, 0}}, 0};   /* Initialize to zero. */\n    ULARGE_INTEGER pos_uli;\n    DWORD toRead = (max > INT32_MAX) ? INT32_MAX : (DWORD) max;\n    DWORD resRead;\n\n    pos_uli.QuadPart = (uint64_t) offset64;   /* Simple transformation 64bit -> 2x32bit. */\n    f_ol.Offset = pos_uli.LowPart;\n    f_ol.OffsetHigh = pos_uli.HighPart;\n    if (! ReadFile (fh, (void *) buf, toRead, &resRead, &f_ol))\n      return MHD_CONTENT_READER_END_WITH_ERROR;   /* Read error. */\n    if (0 == resRead)\n      return MHD_CONTENT_READER_END_OF_STREAM;\n    return (ssize_t) resRead;\n  }\n#endif /* _WIN32 && !__CYGWIN__ */\n}\n```\n</target_code>\n<scenario>\nThe agent A provided the following violation scenario:The code uses the type \"ssize_t\" which is not part of standard C but a POSIX extension, and the Windows section uses Windows-specific types and API calls such as HANDLE, OVERLAPPED, and ReadFile, which are compiler or platform-specific extensions as documented by Microsoft but not standard C language constructs.\n</scenario>\n<test_code>\nAlso, the agent A provided the following modified code that prints out the log to support their scenario:\n```c\nstruct MHD_Response_struct {\n  int fd;\n  uint64_t fd_off;\n};\n\nstatic ssize_t\nfile_reader (void *cls,\n             uint64_t pos,\n             char *buf,\n             size_t max)\n{\n  FILE *log = fopen(\"/tmp/logs/616.txt\", \"a\");\n  if (log == NULL)\n  {\n    return MHD_CONTENT_READER_END_WITH_ERROR;\n  }\n\n  struct MHD_Response *response = cls;\n\n#if ! defined(_WIN32) || defined(__CYGWIN__)\n  ssize_t n;\n#else  /* _WIN32 && !__CYGWIN__ */\n  const HANDLE fh = (HANDLE) (uintptr_t) _get_osfhandle (response->fd);\n#endif /* _WIN32 && !__CYGWIN__ */\n\n  const int64_t offset64 = (int64_t) (pos + response->fd_off);\n\n  fprintf(log, \"Enter file_reader: pos=%lu, fd_off=%lu, offset64=%ld\\n\", (unsigned long)pos, (unsigned long)response->fd_off, (long)offset64);\n\n  if (offset64 < 0)\n  {\n    fprintf(log, \"offset64 < 0: returning error\\n\");\n    fclose(log);\n    return MHD_CONTENT_READER_END_WITH_ERROR; /* seek to required position is not possible */\n  }\n\n#if ! defined(_WIN32) || defined(__CYGWIN__)\n  if (max > SSIZE_MAX)\n  {\n    fprintf(log, \"max > SSIZE_MAX: adjusting max from %zu to %ld\\n\", max, (long)SSIZE_MAX);\n    max = SSIZE_MAX; /* Clamp to maximum return value. */\n  }\n\n#if defined(HAVE_PREAD64)\n  fprintf(log, \"Using pread64\\n\");\n  n = pread64 (response->fd, buf, max, offset64);\n#elif defined(HAVE_PREAD)\n  if ( (sizeof(off_t) < sizeof (uint64_t)) &&\n       (offset64 > (uint64_t) INT32_MAX) )\n  {\n    fprintf(log, \"offset64 too large for off_t: returning error\\n\");\n    fclose(log);\n    return MHD_CONTENT_READER_END_WITH_ERROR; /* Read at required position is not possible. */\n  }\n\n  fprintf(log, \"Using pread\\n\");\n  n = pread (response->fd, buf, max, (off_t) offset64);\n#else  /* ! HAVE_PREAD */\n#if defined(HAVE_LSEEK64)\n  fprintf(log, \"Using lseek64 then read\\n\");\n  if (lseek64 (response->fd,\n               offset64,\n               SEEK_SET) != offset64)\n  {\n    fprintf(log, \"lseek64 failed: returning error\\n\");\n    fclose(log);\n    return MHD_CONTENT_READER_END_WITH_ERROR; /* can't seek to required position */\n  }\n#else  /* ! HAVE_LSEEK64 */\n  if ( (sizeof(off_t) < sizeof (uint64_t)) &&\n       (offset64 > (uint64_t) INT32_MAX) )\n  {\n    fprintf(log, \"offset64 too large for off_t (lseel): returning error\\n\");\n    fclose(log);\n    return MHD_CONTENT_READER_END_WITH_ERROR; /* seek to required position is not possible */\n  }\n\n  if (lseek (response->fd,\n             (off_t) offset64,\n             SEEK_SET) != (off_t) offset64)\n  {\n    fprintf(log, \"lseek failed: returning error\\n\");\n    fclose(log);\n    return MHD_CONTENT_READER_END_WITH_ERROR; /* can't seek to required position */\n  }\n#endif /* ! HAVE_LSEEK64 */\n  n = read (response->fd,\n            buf,\n            max);\n\n#endif /* ! HAVE_PREAD */\n\n  if (0 == n)\n  {\n    fprintf(log, \"Read returned 0: end of stream\\n\");\n    fclose(log);\n    return MHD_CONTENT_READER_END_OF_STREAM;\n  }\n  if (n < 0)\n  {\n    fprintf(log, \"Read returned < 0: error\\n\");\n    fclose(log);\n    return MHD_CONTENT_READER_END_WITH_ERROR;\n  }\n\n  fprintf(log, \"Read %zd bytes successfully\\n\", n);\n  fclose(log);\n  return n;\n#else /* _WIN32 && !__CYGWIN__ */\n  if (INVALID_HANDLE_VALUE == fh)\n  {\n    fprintf(log, \"INVALID_HANDLE_VALUE: returning error\\n\");\n    fclose(log);\n    return MHD_CONTENT_READER_END_WITH_ERROR; /* Value of 'response->fd' is not valid. */\n  }\n  else\n  {\n    OVERLAPPED f_ol = {0, 0, {{0, 0}}, 0};   /* Initialize to zero. */\n    ULARGE_INTEGER pos_uli;\n    DWORD toRead = (max > INT32_MAX) ? INT32_MAX : (DWORD) max;\n    DWORD resRead;\n\n    pos_uli.QuadPart = (uint64_t) offset64;   /* Simple transformation 64bit -> 2x32bit. */\n    f_ol.Offset = pos_uli.LowPart;\n    f_ol.OffsetHigh = pos_uli.HighPart;\n\n    fprintf(log, \"Using Windows ReadFile\\n\");\n\n    if (! ReadFile (fh, (void *) buf, toRead, &resRead, &f_ol))\n    {\n      fprintf(log, \"ReadFile error\\n\");\n      fclose(log);\n      return MHD_CONTENT_READER_END_WITH_ERROR;   /* Read error. */\n    }\n    if (0 == resRead)\n    {\n      fprintf(log, \"ReadFile returned 0: end of stream\\n\");\n      fclose(log);\n      return MHD_CONTENT_READER_END_OF_STREAM;\n    }\n    fprintf(log, \"ReadFile read %lu bytes successfully\\n\", (unsigned long) resRead);\n    fclose(log);\n    return (ssize_t) resRead;\n  }\n#endif /* _WIN32 && !__CYGWIN__ */\n}\n\n```\nThe test code failed to compile, so we could not obtain any output.\n\n</test_code>\n<response format>\nProvide your answer with these fields.\n- explanation: your evaluation of the scenario provided by the agent A.\n- is_report_correct: whether the report is correct or not (true/false)\n</response format>\n<instruction>   \nJudge whether the report is correct or not.\n</instruction>\n",
  "is_report_correct": false,
  "explanation": "MISRA C 2023 Rule 1.2 states that language extensions should not be used. The reported code uses types and APIs that are platform-specific but not language extensions. The type ssize_t is defined by POSIX, not standard ISO C \u2014 therefore it can be considered a system or platform extension rather than a language extension. Similarly, HANDLE, OVERLAPPED, and ReadFile are Windows API types and functions, which are platform-specific rather than language extensions. MISRA's Rule 1.2 targets compiler or language extensions explicitly documented as such (e.g., GNU __attribute__, Microsoft __declspec, or other non-standard keywords or constructs that extend the C language itself). Platform-specific types and APIs are not language extensions in this sense, but are rather platform-specific code, which Rule 1.2 does not forbid. Therefore, the usage of ssize_t (POSIX type) and Windows API calls in platform-specific conditional compilation does not constitute violation of Rule 1.2. It is common practice and acceptable to use platform-specific APIs guarded by macros. Hence, the agent A's report that the code violates MISRA C 2023 Rule 1.2 is incorrect. The subsequent test code failing to compile further confirms that the environment probably does not supply these platform types or functions, but that is unrelated to language extensions misuse according to MISRA. Thus, the report is not correct."
}