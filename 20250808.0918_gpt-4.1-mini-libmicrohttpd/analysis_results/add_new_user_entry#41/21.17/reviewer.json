{
  "user_message": "An agent A claimed that the following add_new_user_entry code violates the MISRA C 2023 rule 21.17.\n<misra_rule>\nMISRA C 2023 Rule 21.17 is Use of the string handling functions from <string.h> shall not result in accesses beyond the bounds of the objects referenced by their pointer parameters.\nThis rule strictly applies to the Standard Library functions in <string.h> such as memcpy, memmove, memset, memcmp, strcpy, strncpy, strcat, strncat, strlen, and strspn..\n</misra_rule>\n<target_code>\nHere is the original code of add_new_user_entry.\n```c\nstatic int\nadd_new_user_entry (const char *const username,\n                    const char *const password,\n                    const char *const realm,\n                    int allow_area_1,\n                    int allow_area_2)\n{\n  struct UserEntry *entry;\n  enum MHD_Result res;\n\n  if ((sizeof(user_ids) / sizeof(user_ids[0])) <= user_ids_used)\n    return 0; /* No more space to add new entry */\n\n  entry = user_ids + user_ids_used;\n\n  entry->username = username;\n  entry->realm = realm;\n\n  res = MHD_YES;\n\n  if (MHD_NO != res)\n    res = MHD_digest_auth_calc_userhash (MHD_DIGEST_AUTH_ALGO3_MD5,\n                                         username,\n                                         realm,\n                                         entry->userhash_md5,\n                                         sizeof(entry->userhash_md5));\n  if (MHD_NO != res)\n    res = MHD_digest_auth_calc_userdigest (MHD_DIGEST_AUTH_ALGO3_MD5,\n                                           username,\n                                           realm,\n                                           password,\n                                           entry->userdigest_md5,\n                                           sizeof(entry->userdigest_md5));\n\n  if (MHD_NO != res)\n    res = MHD_digest_auth_calc_userhash (MHD_DIGEST_AUTH_ALGO3_SHA256,\n                                         username,\n                                         realm,\n                                         entry->userhash_sha256,\n                                         sizeof(entry->userhash_sha256));\n  if (MHD_NO != res)\n    res = MHD_digest_auth_calc_userdigest (MHD_DIGEST_AUTH_ALGO3_SHA256,\n                                           username,\n                                           realm,\n                                           password,\n                                           entry->userdigest_sha256,\n                                           sizeof(entry->userdigest_sha256));\n\n  if (MHD_NO != res)\n    res = MHD_digest_auth_calc_userhash (MHD_DIGEST_AUTH_ALGO3_SHA512_256,\n                                         username,\n                                         realm,\n                                         entry->userhash_sha512_256,\n                                         sizeof(entry->userhash_sha512_256));\n  if (MHD_NO != res)\n    res =\n      MHD_digest_auth_calc_userdigest (MHD_DIGEST_AUTH_ALGO3_SHA512_256,\n                                       username,\n                                       realm,\n                                       password,\n                                       entry->userdigest_sha512_256,\n                                       sizeof(entry->userdigest_sha512_256));\n\n  if (MHD_NO == res)\n    return 0; /* Failure exit point */\n\n  entry->allow_area_1 = allow_area_1;\n  entry->allow_area_2 = allow_area_2;\n\n  user_ids_used++;\n\n  return ! 0;\n}\n```\n</target_code>\n<scenario>\nThe agent A provided the following violation scenario:A violation occurs if one of the <string.h> functions (like memcpy in MHD_digest_auth_calc_userhash or MHD_digest_auth_calc_userdigest) writes beyond the bounds of the destination buffers such as entry->userhash_md5 or entry->userdigest_md5, due to incorrect size argument or incorrect buffer size assumption.\n</scenario>\n<test_code>\nAlso, the agent A provided the following modified code that prints out the log to support their scenario:\n```c\nextern enum MHD_Result MHD_digest_auth_calc_userhash(enum MHD_DigestAuthAlgo3 algo, const char *user, const char *realm,\n                                                             void *dest, size_t dest_size);\nextern enum MHD_Result MHD_digest_auth_calc_userdigest(enum MHD_DigestAuthAlgo3 algo, const char *user, const char *realm, const char *password,\n                                                        void *dest, size_t dest_size);\n\nstatic int add_new_user_entry (const char *const username,\n                               const char *const password,\n                               const char *const realm,\n                               int allow_area_1,\n                               int allow_area_2)\n{\n  FILE *f;\n  struct UserEntry *entry;\n  enum MHD_Result res;\n\n  f = fopen(\"/tmp/logs/335.txt\", \"a\");\n  fprintf(f, \"add_new_user_entry called with username='%s', password='%s', realm='%s'\\n\", username, password, realm);\n  fclose(f);\n\n  if ((sizeof(user_ids) / sizeof(user_ids[0])) <= user_ids_used)\n  {\n    f = fopen(\"/tmp/logs/335.txt\", \"a\");\n    fprintf(f, \"No more space to add new entry: user_ids_used=%zu\\n\", user_ids_used);\n    fclose(f);\n    return 0; /* No more space to add new entry */\n  }\n\n  entry = user_ids + user_ids_used;\n\n  entry->username = username;\n  entry->realm = realm;\n\n  res = MHD_YES;\n\n  if (MHD_NO != res)\n  {\n    f = fopen(\"/tmp/logs/335.txt\", \"a\");\n    fprintf(f, \"Calling MHD_digest_auth_calc_userhash MD5\\n\");\n    fclose(f);\n    res = MHD_digest_auth_calc_userhash(MHD_DIGEST_AUTH_ALGO3_MD5,\n                                        username,\n                                        realm,\n                                        entry->userhash_md5,\n                                        sizeof(entry->userhash_md5));\n  }\n  if (MHD_NO != res)\n  {\n    f = fopen(\"/tmp/logs/335.txt\", \"a\");\n    fprintf(f, \"Calling MHD_digest_auth_calc_userdigest MD5\\n\");\n    fclose(f);\n    res = MHD_digest_auth_calc_userdigest(MHD_DIGEST_AUTH_ALGO3_MD5,\n                                          username,\n                                          realm,\n                                          password,\n                                          entry->userdigest_md5,\n                                          sizeof(entry->userdigest_md5));\n  }\n\n  if (MHD_NO != res)\n  {\n    f = fopen(\"/tmp/logs/335.txt\", \"a\");\n    fprintf(f, \"Calling MHD_digest_auth_calc_userhash SHA256\\n\");\n    fclose(f);\n    res = MHD_digest_auth_calc_userhash(MHD_DIGEST_AUTH_ALGO3_SHA256,\n                                        username,\n                                        realm,\n                                        entry->userhash_sha256,\n                                        sizeof(entry->userhash_sha256));\n  }\n  if (MHD_NO != res)\n  {\n    f = fopen(\"/tmp/logs/335.txt\", \"a\");\n    fprintf(f, \"Calling MHD_digest_auth_calc_userdigest SHA256\\n\");\n    fclose(f);\n    res = MHD_digest_auth_calc_userdigest(MHD_DIGEST_AUTH_ALGO3_SHA256,\n                                          username,\n                                          realm,\n                                          password,\n                                          entry->userdigest_sha256,\n                                          sizeof(entry->userdigest_sha256));\n  }\n\n  if (MHD_NO != res)\n  {\n    f = fopen(\"/tmp/logs/335.txt\", \"a\");\n    fprintf(f, \"Calling MHD_digest_auth_calc_userhash SHA512_256\\n\");\n    fclose(f);\n    res = MHD_digest_auth_calc_userhash(MHD_DIGEST_AUTH_ALGO3_SHA512_256,\n                                        username,\n                                        realm,\n                                        entry->userhash_sha512_256,\n                                        sizeof(entry->userhash_sha512_256));\n  }\n  if (MHD_NO != res)\n  {\n    f = fopen(\"/tmp/logs/335.txt\", \"a\");\n    fprintf(f, \"Calling MHD_digest_auth_calc_userdigest SHA512_256\\n\");\n    fclose(f);\n    res = MHD_digest_auth_calc_userdigest(MHD_DIGEST_AUTH_ALGO3_SHA512_256,\n                                          username,\n                                          realm,\n                                          password,\n                                          entry->userdigest_sha512_256,\n                                          sizeof(entry->userdigest_sha512_256));\n  }\n\n  if (MHD_NO == res)\n  {\n    f = fopen(\"/tmp/logs/335.txt\", \"a\");\n    fprintf(f, \"Failure exit point\\n\");\n    fclose(f);\n    return 0; /* Failure exit point */\n  }\n\n  entry->allow_area_1 = allow_area_1;\n  entry->allow_area_2 = allow_area_2;\n\n  user_ids_used++;\n\n  f = fopen(\"/tmp/logs/335.txt\", \"a\");\n  fprintf(f, \"User entry added successfully, user_ids_used=%zu\\n\", user_ids_used);\n  fclose(f);\n\n  return 1;\n}\n\n```\nThe test code failed to compile, so we could not obtain any output.\n\n</test_code>\n<response format>\nProvide your answer with these fields.\n- explanation: your evaluation of the scenario provided by the agent A.\n- is_report_correct: whether the report is correct or not (true/false)\n</response format>\n<instruction>   \nJudge whether the report is correct or not.\n</instruction>\n",
  "is_report_correct": false,
  "explanation": "The provided code in add_new_user_entry uses functions like MHD_digest_auth_calc_userhash and MHD_digest_auth_calc_userdigest to write into buffers such as entry->userhash_md5, entry->userdigest_md5, etc., passing the buffer pointer and its sizeof() as the size argument. Since the sizes passed are computed using sizeof on the destination buffer arrays, they represent the actual buffer sizes. The critical point to determine compliance with MISRA C 2023 Rule 21.17 is whether these size arguments correctly represent the destination object bounds and whether MHD_digest_auth_calc_userhash and MHD_digest_auth_calc_userdigest internally respect these sizes and do not write beyond the buffer limits. The code snippet provided does not show any direct usage of string.h functions like memcpy, strcpy, etc. Instead, it calls wrapper functions presumably performing internal buffer writes. Without their source code or a contract guaranteeing safe usage, we cannot definitively state that these functions do not cause out-of-bounds accesses. However, the provided test code attempts to log the calls but fails to compile, so no evidence from run-time behavior or failures is available. Consequently, from the visible code, the usage appears correct: buffer sizes are passed correctly to the functions. The user-supplied functions must themselves comply with the rule internally. The agent A\u2019s claim that violation occurs due to incorrect size argument or buffer size assumption is not supported by the provided code. The size arguments correspond to the buffer sizes. Therefore, based on the given code and scenario, the report that this function violates MISRA C 2023 Rule 21.17 is not justified. The lack of compilation of their test code and no other evidence further weakens their claim."
}