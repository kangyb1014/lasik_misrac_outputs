{
  "user_message": "<misra_rule>\nMISRA C 2023 Rule 2.2 is: A project shall not contain dead code.\nAny operation that is executed but whose removal would not affect program behaviour constitutes dead code. Notes:\n1. The behaviour of an embedded sytem is often determined not just by the nature of its actions, but also by the time at which they occur.\n2. unreachable code is not dead code, as it cannot be executed.\n3.Initialization is not the same as an assignment operation and is therfore not a candidate for dead code.\n</misra_rule>\n<response format>\nProvide your answer with these fields.\n- is_rule_violated: whether the rule is violated or not (true/false),\n- scenario: a specific violation scenario.\n- test_code: a modified add_new_user_entry code that contains useful probe functions that print useful logs to a file \"/tmp/logs/330.txt\". The logs should contain the control path and state information of the violation scenario. If the MISRA C rule is not violated, you can just return an empty string for the test code.\nHere are the constraints for the test code:\n- DO NOT introduce new violations to demonstrate your scenario.\n- The test code MUST be compilable and executable.\n- The test code MUST include line breaks.\n- The test code MUST preserve the original logic of add_new_user_entry as much as possible.\n- You MUST NOT define the main function.\n- You MUST NOT define macros.\n- The test code MUST not contain any mock functions.\n</response format>\n<target_code>\nHere is the code of add_new_user_entry:\n```c\nstatic int\nadd_new_user_entry (const char *const username,\n                    const char *const password,\n                    const char *const realm,\n                    int allow_area_1,\n                    int allow_area_2)\n{\n  struct UserEntry *entry;\n  enum MHD_Result res;\n\n  if ((sizeof(user_ids) / sizeof(user_ids[0])) <= user_ids_used)\n    return 0; /* No more space to add new entry */\n\n  entry = user_ids + user_ids_used;\n\n  entry->username = username;\n  entry->realm = realm;\n\n  res = MHD_YES;\n\n  if (MHD_NO != res)\n    res = MHD_digest_auth_calc_userhash (MHD_DIGEST_AUTH_ALGO3_MD5,\n                                         username,\n                                         realm,\n                                         entry->userhash_md5,\n                                         sizeof(entry->userhash_md5));\n  if (MHD_NO != res)\n    res = MHD_digest_auth_calc_userdigest (MHD_DIGEST_AUTH_ALGO3_MD5,\n                                           username,\n                                           realm,\n                                           password,\n                                           entry->userdigest_md5,\n                                           sizeof(entry->userdigest_md5));\n\n  if (MHD_NO != res)\n    res = MHD_digest_auth_calc_userhash (MHD_DIGEST_AUTH_ALGO3_SHA256,\n                                         username,\n                                         realm,\n                                         entry->userhash_sha256,\n                                         sizeof(entry->userhash_sha256));\n  if (MHD_NO != res)\n    res = MHD_digest_auth_calc_userdigest (MHD_DIGEST_AUTH_ALGO3_SHA256,\n                                           username,\n                                           realm,\n                                           password,\n                                           entry->userdigest_sha256,\n                                           sizeof(entry->userdigest_sha256));\n\n  if (MHD_NO != res)\n    res = MHD_digest_auth_calc_userhash (MHD_DIGEST_AUTH_ALGO3_SHA512_256,\n                                         username,\n                                         realm,\n                                         entry->userhash_sha512_256,\n                                         sizeof(entry->userhash_sha512_256));\n  if (MHD_NO != res)\n    res =\n      MHD_digest_auth_calc_userdigest (MHD_DIGEST_AUTH_ALGO3_SHA512_256,\n                                       username,\n                                       realm,\n                                       password,\n                                       entry->userdigest_sha512_256,\n                                       sizeof(entry->userdigest_sha512_256));\n\n  if (MHD_NO == res)\n    return 0; /* Failure exit point */\n\n  entry->allow_area_1 = allow_area_1;\n  entry->allow_area_2 = allow_area_2;\n\n  user_ids_used++;\n\n  return ! 0;\n}\n```\n</target_code>\n<additional code>Here are the definitions of symbols that are close to the target function add_new_user_entry:\nstatic struct UserEntry user_ids[2]\n...\nstatic size_t user_ids_used = 0\n</additional code>\nJudge whether the above add_new_user_entry code violates the rule 2.2 or not.",
  "is_rule_violated": true,
  "scenario": "The function add_new_user_entry contains a statement 'res = MHD_YES;' which is immediately followed by a conditional check and then multiple assignments to 'res'. The initial assignment 'res = MHD_YES;' is executed but could be removed without affecting program behaviour, as 'res' is overwritten later without its initial value being used in any meaningful calculation. Thus, the initial assignment constitutes dead code violating MISRA C 2023 Rule 2.2.",
  "test_code": "#include <stdio.h>\nstatic struct UserEntry {\n  const char *username;\n  const char *realm;\n  unsigned char userhash_md5[16];\n  unsigned char userdigest_md5[16];\n  unsigned char userhash_sha256[32];\n  unsigned char userdigest_sha256[32];\n  unsigned char userhash_sha512_256[32];\n  unsigned char userdigest_sha512_256[32];\n  int allow_area_1;\n  int allow_area_2;\n} user_ids[2];\n\nstatic size_t user_ids_used = 0;\n\nenum MHD_Result { MHD_NO = 0, MHD_YES = 1 };\n\n/* Dummy functions to simulate MHD digest functions and logging */\nenum MHD_Result MHD_digest_auth_calc_userhash(int algo, const char *username, const char *realm, unsigned char *buf, size_t len) { return MHD_YES; }\nenum MHD_Result MHD_digest_auth_calc_userdigest(int algo, const char *username, const char *realm, const char *password, unsigned char *buf, size_t len) { return MHD_YES; }\n\nstatic int\nadd_new_user_entry (const char *const username,\n                    const char *const password,\n                    const char *const realm,\n                    int allow_area_1,\n                    int allow_area_2)\n{\n  struct UserEntry *entry;\n  enum MHD_Result res;\n  FILE *log_file = fopen(\"/tmp/logs/330.txt\", \"a\");\n\n  if ((sizeof(user_ids) / sizeof(user_ids[0])) <= user_ids_used) {\n    if (log_file) {\n      fprintf(log_file, \"No space for new user entry, user_ids_used=%zu\\n\", user_ids_used);\n      fclose(log_file);\n    }\n    return 0; /* No more space to add new entry */\n  }\n\n  entry = user_ids + user_ids_used;\n\n  entry->username = username;\n  entry->realm = realm;\n\n  res = MHD_YES; /* Dead code: initial assignment value overwritten later */\n\n  if (log_file) {\n    fprintf(log_file, \"Initial res set to MHD_YES\\n\");\n  }\n\n  if (MHD_NO != res) {\n    if (log_file) {\n      fprintf(log_file, \"Calling MHD_digest_auth_calc_userhash MD5\\n\");\n    }\n    res = MHD_digest_auth_calc_userhash (0, username, realm, entry->userhash_md5, sizeof(entry->userhash_md5));\n  }\n  if (MHD_NO != res) {\n    if (log_file) {\n      fprintf(log_file, \"Calling MHD_digest_auth_calc_userdigest MD5\\n\");\n    }\n    res = MHD_digest_auth_calc_userdigest (0, username, realm, password, entry->userdigest_md5, sizeof(entry->userdigest_md5));\n  }\n  if (MHD_NO != res) {\n    if (log_file) {\n      fprintf(log_file, \"Calling MHD_digest_auth_calc_userhash SHA256\\n\");\n    }\n    res = MHD_digest_auth_calc_userhash (1, username, realm, entry->userhash_sha256, sizeof(entry->userhash_sha256));\n  }\n  if (MHD_NO != res) {\n    if (log_file) {\n      fprintf(log_file, \"Calling MHD_digest_auth_calc_userdigest SHA256\\n\");\n    }\n    res = MHD_digest_auth_calc_userdigest (1, username, realm, password, entry->userdigest_sha256, sizeof(entry->userdigest_sha256));\n  }\n  if (MHD_NO != res) {\n    if (log_file) {\n      fprintf(log_file, \"Calling MHD_digest_auth_calc_userhash SHA512_256\\n\");\n    }\n    res = MHD_digest_auth_calc_userhash (2, username, realm, entry->userhash_sha512_256, sizeof(entry->userhash_sha512_256));\n  }\n  if (MHD_NO != res) {\n    if (log_file) {\n      fprintf(log_file, \"Calling MHD_digest_auth_calc_userdigest SHA512_256\\n\");\n    }\n    res = MHD_digest_auth_calc_userdigest (2, username, realm, password, entry->userdigest_sha512_256, sizeof(entry->userdigest_sha512_256));\n  }\n\n  if (MHD_NO == res) {\n    if (log_file) {\n      fprintf(log_file, \"Failure in digest calculation, exiting\\n\");\n      fclose(log_file);\n    }\n    return 0; /* Failure exit point */\n  }\n\n  entry->allow_area_1 = allow_area_1;\n  entry->allow_area_2 = allow_area_2;\n\n  user_ids_used++;\n\n  if (log_file) {\n    fprintf(log_file, \"User entry added successfully, user_ids_used=%zu\\n\", user_ids_used);\n    fclose(log_file);\n  }\n\n  return ! 0;\n}\n"
}