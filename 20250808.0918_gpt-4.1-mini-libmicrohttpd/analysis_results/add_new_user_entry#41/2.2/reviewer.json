{
  "user_message": "An agent A claimed that the following add_new_user_entry code violates the MISRA C 2023 rule 2.2.\n<misra_rule>\nMISRA C 2023 Rule 2.2 is A project shall not contain dead code.\nAny operation that is executed but whose removal would not affect program behaviour constitutes dead code. Notes:\n1. The behaviour of an embedded sytem is often determined not just by the nature of its actions, but also by the time at which they occur.\n2. unreachable code is not dead code, as it cannot be executed.\n3.Initialization is not the same as an assignment operation and is therfore not a candidate for dead code..\n</misra_rule>\n<target_code>\nHere is the original code of add_new_user_entry.\n```c\nstatic int\nadd_new_user_entry (const char *const username,\n                    const char *const password,\n                    const char *const realm,\n                    int allow_area_1,\n                    int allow_area_2)\n{\n  struct UserEntry *entry;\n  enum MHD_Result res;\n\n  if ((sizeof(user_ids) / sizeof(user_ids[0])) <= user_ids_used)\n    return 0; /* No more space to add new entry */\n\n  entry = user_ids + user_ids_used;\n\n  entry->username = username;\n  entry->realm = realm;\n\n  res = MHD_YES;\n\n  if (MHD_NO != res)\n    res = MHD_digest_auth_calc_userhash (MHD_DIGEST_AUTH_ALGO3_MD5,\n                                         username,\n                                         realm,\n                                         entry->userhash_md5,\n                                         sizeof(entry->userhash_md5));\n  if (MHD_NO != res)\n    res = MHD_digest_auth_calc_userdigest (MHD_DIGEST_AUTH_ALGO3_MD5,\n                                           username,\n                                           realm,\n                                           password,\n                                           entry->userdigest_md5,\n                                           sizeof(entry->userdigest_md5));\n\n  if (MHD_NO != res)\n    res = MHD_digest_auth_calc_userhash (MHD_DIGEST_AUTH_ALGO3_SHA256,\n                                         username,\n                                         realm,\n                                         entry->userhash_sha256,\n                                         sizeof(entry->userhash_sha256));\n  if (MHD_NO != res)\n    res = MHD_digest_auth_calc_userdigest (MHD_DIGEST_AUTH_ALGO3_SHA256,\n                                           username,\n                                           realm,\n                                           password,\n                                           entry->userdigest_sha256,\n                                           sizeof(entry->userdigest_sha256));\n\n  if (MHD_NO != res)\n    res = MHD_digest_auth_calc_userhash (MHD_DIGEST_AUTH_ALGO3_SHA512_256,\n                                         username,\n                                         realm,\n                                         entry->userhash_sha512_256,\n                                         sizeof(entry->userhash_sha512_256));\n  if (MHD_NO != res)\n    res =\n      MHD_digest_auth_calc_userdigest (MHD_DIGEST_AUTH_ALGO3_SHA512_256,\n                                       username,\n                                       realm,\n                                       password,\n                                       entry->userdigest_sha512_256,\n                                       sizeof(entry->userdigest_sha512_256));\n\n  if (MHD_NO == res)\n    return 0; /* Failure exit point */\n\n  entry->allow_area_1 = allow_area_1;\n  entry->allow_area_2 = allow_area_2;\n\n  user_ids_used++;\n\n  return ! 0;\n}\n```\n</target_code>\n<scenario>\nThe agent A provided the following violation scenario:The function add_new_user_entry contains a statement 'res = MHD_YES;' which is immediately followed by a conditional check and then multiple assignments to 'res'. The initial assignment 'res = MHD_YES;' is executed but could be removed without affecting program behaviour, as 'res' is overwritten later without its initial value being used in any meaningful calculation. Thus, the initial assignment constitutes dead code violating MISRA C 2023 Rule 2.2.\n</scenario>\n<test_code>\nAlso, the agent A provided the following modified code that prints out the log to support their scenario:\n```c\nenum MHD_DigestAuthAlgo3 { ALG_MD5 = 0, ALG_SHA256 = 1, ALG_SHA512_256 = 2 };\nenum MHD_Result MHD_digest_auth_calc_userhash(enum MHD_DigestAuthAlgo3 algo3, const char *username, const char *realm, void *buf, size_t len) { return MHD_YES; }\nenum MHD_Result MHD_digest_auth_calc_userdigest(enum MHD_DigestAuthAlgo3 algo3, const char *username, const char *realm, const char *password, void *buf, size_t len) { return MHD_YES; }\n\nstatic int\nadd_new_user_entry (const char *const username,\n                    const char *const password,\n                    const char *const realm,\n                    int allow_area_1,\n                    int allow_area_2)\n{\n  struct UserEntry *entry;\n  enum MHD_Result res;\n  FILE *log_file = fopen(\"/tmp/logs/330.txt\", \"a\");\n\n  if ((sizeof(user_ids) / sizeof(user_ids[0])) <= user_ids_used) {\n    if (log_file) {\n      fprintf(log_file, \"No space for new user entry, user_ids_used=%zu\\n\", user_ids_used);\n      fclose(log_file);\n    }\n    return 0; /* No more space to add new entry */\n  }\n\n  entry = user_ids + user_ids_used;\n\n  entry->username = username;\n  entry->realm = realm;\n\n  res = MHD_YES; /* Dead code: initial assignment value overwritten later */\n\n  if (log_file) {\n    fprintf(log_file, \"Initial res set to MHD_YES\\n\");\n  }\n\n  if (MHD_NO != res) {\n    if (log_file) {\n      fprintf(log_file, \"Calling MHD_digest_auth_calc_userhash MD5\\n\");\n    }\n    res = MHD_digest_auth_calc_userhash (ALG_MD5, username, realm, entry->userhash_md5, sizeof(entry->userhash_md5));\n  }\n  if (MHD_NO != res) {\n    if (log_file) {\n      fprintf(log_file, \"Calling MHD_digest_auth_calc_userdigest MD5\\n\");\n    }\n    res = MHD_digest_auth_calc_userdigest (ALG_MD5, username, realm, password, entry->userdigest_md5, sizeof(entry->userdigest_md5));\n  }\n  if (MHD_NO != res) {\n    if (log_file) {\n      fprintf(log_file, \"Calling MHD_digest_auth_calc_userhash SHA256\\n\");\n    }\n    res = MHD_digest_auth_calc_userhash (ALG_SHA256, username, realm, entry->userhash_sha256, sizeof(entry->userhash_sha256));\n  }\n  if (MHD_NO != res) {\n    if (log_file) {\n      fprintf(log_file, \"Calling MHD_digest_auth_calc_userdigest SHA256\\n\");\n    }\n    res = MHD_digest_auth_calc_userdigest (ALG_SHA256, username, realm, password, entry->userdigest_sha256, sizeof(entry->userdigest_sha256));\n  }\n  if (MHD_NO != res) {\n    if (log_file) {\n      fprintf(log_file, \"Calling MHD_digest_auth_calc_userhash SHA512_256\\n\");\n    }\n    res = MHD_digest_auth_calc_userhash (ALG_SHA512_256, username, realm, entry->userhash_sha512_256, sizeof(entry->userhash_sha512_256));\n  }\n  if (MHD_NO != res) {\n    if (log_file) {\n      fprintf(log_file, \"Calling MHD_digest_auth_calc_userdigest SHA512_256\\n\");\n    }\n    res = MHD_digest_auth_calc_userdigest (ALG_SHA512_256, username, realm, password, entry->userdigest_sha512_256, sizeof(entry->userdigest_sha512_256));\n  }\n\n  if (MHD_NO == res) {\n    if (log_file) {\n      fprintf(log_file, \"Failure in digest calculation, exiting\\n\");\n      fclose(log_file);\n    }\n    return 0; /* Failure exit point */\n  }\n\n  entry->allow_area_1 = allow_area_1;\n  entry->allow_area_2 = allow_area_2;\n\n  user_ids_used++;\n\n  if (log_file) {\n    fprintf(log_file, \"User entry added successfully, user_ids_used=%zu\\n\", user_ids_used);\n    fclose(log_file);\n  }\n\n  return !0;\n}\n\n```\nThe test code failed to compile, so we could not obtain any output.\n\n</test_code>\n<response format>\nProvide your answer with these fields.\n- explanation: your evaluation of the scenario provided by the agent A.\n- is_report_correct: whether the report is correct or not (true/false)\n</response format>\n<instruction>   \nJudge whether the report is correct or not.\n</instruction>\n",
  "is_report_correct": false,
  "explanation": "MISRA C 2023 Rule 2.2 forbids dead code, defined as executed code whose removal would not affect program behavior. In this code, the variable 'res' is initialized to MHD_YES, but immediately afterward, it is checked (if MHD_NO != res) and then potentially overwritten by function calls. Since the initial value of 'res' is relied upon in the first 'if' condition to decide whether to call MHD_digest_auth_calc_userhash, the initial assignment to MHD_YES does affect program flow. Removing it would leave 'res' uninitialized before the first condition, leading to undefined behavior. Therefore, the initial assignment is not dead code but a necessary initialization for the control flow. The agent's claim that this initial assignment can be removed without affecting behavior is incorrect. Furthermore, unreachable code is explicitly excluded from dead code, but here the code is reachable and its execution path depends on 'res'. The test code failing to compile does not invalidate this logical analysis. Hence, the report that the code violates MISRA C 2023 Rule 2.2 due to this initial assignment is incorrect."
}