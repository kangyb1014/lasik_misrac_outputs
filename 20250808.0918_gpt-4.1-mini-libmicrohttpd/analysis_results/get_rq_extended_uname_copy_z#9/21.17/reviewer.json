{
  "user_message": "An agent A claimed that the following get_rq_extended_uname_copy_z code violates the MISRA C 2023 rule 21.17.\n<misra_rule>\nMISRA C 2023 Rule 21.17 is Use of the string handling functions from <string.h> shall not result in accesses beyond the bounds of the objects referenced by their pointer parameters.\nThis rule strictly applies to the Standard Library functions in <string.h> such as memcpy, memmove, memset, memcmp, strcpy, strncpy, strcat, strncat, strlen, and strspn..\n</misra_rule>\n<target_code>\nHere is the original code of get_rq_extended_uname_copy_z.\n```c\nstatic ssize_t\nget_rq_extended_uname_copy_z (const char *uname_ext, size_t uname_ext_len,\n                              char *buf, size_t buf_size)\n{\n  size_t r;\n  size_t w;\n  if ((size_t) SSIZE_MAX < uname_ext_len)\n    return -1; /* Too long input string */\n\n  if (MHD_DAUTH_EXT_PARAM_MIN_LEN > uname_ext_len)\n    return -1; /* Required prefix is missing */\n\n  if (! MHD_str_equal_caseless_bin_n_ (uname_ext, MHD_DAUTH_EXT_PARAM_PREFIX,\n                                       MHD_STATICSTR_LEN_ ( \\\n                                         MHD_DAUTH_EXT_PARAM_PREFIX)))\n    return -1; /* Only UTF-8 is supported, as it is implied by RFC 7616 */\n\n  r = MHD_STATICSTR_LEN_ (MHD_DAUTH_EXT_PARAM_PREFIX);\n  /* Skip language tag */\n  while (r < uname_ext_len && '\\'' != uname_ext[r])\n  {\n    const char chr = uname_ext[r];\n    if ((' ' == chr) || ('\\t' == chr) || ('\\\"' == chr) || (',' == chr) ||\n        (';' == chr) )\n      return -1; /* Wrong char in language tag */\n    r++;\n  }\n  if (r >= uname_ext_len)\n    return -1; /* The end of the language tag was not found */\n  r++; /* Advance to the next char */\n\n  w = MHD_str_pct_decode_strict_n_ (uname_ext + r, uname_ext_len - r,\n                                    buf, buf_size);\n  if ((0 == w) && (0 != uname_ext_len - r))\n    return -1; /* Broken percent encoding */\n  buf[w] = 0; /* Zero terminate the result */\n  mhd_assert (SSIZE_MAX > w);\n  return (ssize_t) w;\n}\n```\n</target_code>\n<scenario>\nThe agent A provided the following violation scenario:If the buf_size provided to get_rq_extended_uname_copy_z is zero, the code attempts to write a null terminator at buf[0], causing an out-of-bounds write, violating MISRA C 2023 Rule 21.17 regarding string handling functions not accessing beyond the bounds of the objects referenced by their pointer parameters.\n</scenario>\n<test_code>\nAlso, the agent A provided the following modified code that prints out the log to support their scenario:\n```c\nconst char MHD_DAUTH_EXT_PARAM_PREFIX[] = \"prefix'\";\nconst size_t MHD_DAUTH_EXT_PARAM_MIN_LEN = MHD_STATICSTR_LEN_(MHD_DAUTH_EXT_PARAM_PREFIX);\n\nstatic ssize_t\nget_rq_extended_uname_copy_z (const char *uname_ext, size_t uname_ext_len,\n                              char *buf, size_t buf_size)\n{\n  FILE *log = fopen(\"/tmp/logs/79.txt\", \"a\");\n  size_t r;\n  size_t w;\n\n  if ((size_t) SSIZE_MAX < uname_ext_len)\n  {\n    fprintf(log, \"Input length exceeds SSIZE_MAX: %zu\\n\", uname_ext_len);\n    fclose(log);\n    return -1; /* Too long input string */\n  }\n\n  if (MHD_DAUTH_EXT_PARAM_MIN_LEN > uname_ext_len)\n  {\n    fprintf(log, \"Input length less than minimum: %zu\\n\", uname_ext_len);\n    fclose(log);\n    return -1; /* Required prefix is missing */\n  }\n\n  if (! MHD_str_equal_caseless_bin_n_ (uname_ext, MHD_DAUTH_EXT_PARAM_PREFIX,\n                                       MHD_STATICSTR_LEN_ (MHD_DAUTH_EXT_PARAM_PREFIX)))\n  {\n    fprintf(log, \"Prefix mismatch\\n\");\n    fclose(log);\n    return -1; /* Prefix mismatch */\n  }\n\n  r = MHD_STATICSTR_LEN_ (MHD_DAUTH_EXT_PARAM_PREFIX);\n  fprintf(log, \"Starting language tag scan at position %zu\\n\", r);\n\n  /* Skip language tag */\n  while (r < uname_ext_len && '\\'' != uname_ext[r])\n  {\n    const char chr = uname_ext[r];\n    fprintf(log, \"Checking char at %zu: %c\\n\", r, chr);\n    if ((' ' == chr) || ('\\t' == chr) || ('\"' == chr) || (',' == chr) ||\n        (';' == chr) )\n    {\n      fprintf(log, \"Invalid char detected in language tag: %c at %zu\\n\", chr, r);\n      fclose(log);\n      return -1; /* Wrong char in language tag */\n    }\n    r++;\n  }\n\n  if (r >= uname_ext_len)\n  {\n    fprintf(log, \"End of language tag not found, position: %zu\\n\", r);\n    fclose(log);\n    return -1; /* The end of the language tag was not found */\n  }\n  r++; /* Advance to the next char */\n\n  w = MHD_str_pct_decode_strict_n_ (uname_ext + r, uname_ext_len - r, buf, buf_size);\n  fprintf(log, \"Decoded length: %zu, buf_size: %zu\\n\", w, buf_size);\n\n  if ((0 == w) && (0 != uname_ext_len - r))\n  {\n    fprintf(log, \"Broken percent encoding detected\\n\");\n    fclose(log);\n    return -1; /* Broken percent encoding */\n  }\n\n  if (w >= buf_size)\n  {\n    /* This would be out-of-bounds write, log and handle gracefully */\n    fprintf(log, \"Potential out-of-bounds write detected: w=%zu, buf_size=%zu\\n\", w, buf_size);\n    fclose(log);\n    return -1;\n  }\n\n  buf[w] = 0; /* Zero terminate the result */\n  fprintf(log, \"Buffer zero-terminated at position %zu\\n\", w);\n\n  fclose(log);\n  return (ssize_t) w;\n}\n\n```\nThe test code failed to compile, so we could not obtain any output.\n\n</test_code>\n<response format>\nProvide your answer with these fields.\n- explanation: your evaluation of the scenario provided by the agent A.\n- is_report_correct: whether the report is correct or not (true/false)\n</response format>\n<instruction>   \nJudge whether the report is correct or not.\n</instruction>\n",
  "is_report_correct": true,
  "explanation": "The original code calls MHD_str_pct_decode_strict_n_ with buf and buf_size parameters, and then writes a null terminator at buf[w]. However, if buf_size is zero, then w (the number of bytes written) could be zero or greater, and writing buf[w] = 0 will be an out-of-bounds write. The code does not explicitly check that w < buf_size before writing the terminator '\\0'. The agent A's violation scenario is valid because writing buf[0] when buf_size==0 is out-of-bounds access, violating Rule 21.17. The provided test code attempts to add this check but fails to compile, which does not negate the correctness of the violation claim. Thus, the report by agent A is correct: the original code can result in out-of-bounds write when buf_size is zero, violating MISRA C 2023 Rule 21.17 regarding string handling functions and buffer boundaries."
}