{
  "user_message": "An agent A claimed that the following MHD_set_connection_value_n code violates the MISRA C 2023 rule 1.2.\n<misra_rule>\nMISRA C 2023 Rule 1.2 is Language extensions should not be used.\nYou should report only when the code uses any language compiler extensions that are explicitly stated as an extension in compiler documentations..\n</misra_rule>\n<target_code>\nHere is the original code of MHD_set_connection_value_n.\n```c\n_MHD_EXTERN enum MHD_Result\nMHD_set_connection_value_n (struct MHD_Connection *connection,\n                            enum MHD_ValueKind kind,\n                            const char *key,\n                            size_t key_size,\n                            const char *value,\n                            size_t value_size)\n{\n  if ( (MHD_GET_ARGUMENT_KIND != kind) &&\n       ( ((key ? strlen (key) : 0) != key_size) ||\n         ((value ? strlen (value) : 0) != value_size) ) )\n    return MHD_NO; /* binary zero is allowed only in GET arguments */\n\n  return MHD_set_connection_value_n_nocheck_ (connection,\n                                              kind,\n                                              key,\n                                              key_size,\n                                              value,\n                                              value_size);\n}\n```\n</target_code>\n<scenario>\nThe agent A provided the following violation scenario:The code uses the identifier '_MHD_EXTERN' which is potentially a compiler language extension for symbol visibility or linkage, depending on the compiler documentation. Such use constitutes a language extension, violating MISRA C 2023 Rule 1.2.\n</scenario>\n<test_code>\nAlso, the agent A provided the following modified code that prints out the log to support their scenario:\n```c\nstruct MHD_Request_Queue\n{\n  struct MHD_HTTP_Req_Header *headers_received;\n  struct MHD_HTTP_Req_Header *headers_received_tail;\n};\n\nstatic enum MHD_Result\nMHD_set_connection_value_n_nocheck_ (struct MHD_Connection *connection,\n                                     enum MHD_ValueKind kind,\n                                     const char *key,\n                                     size_t key_size,\n                                     const char *value,\n                                     size_t value_size)\n{\n  FILE *log = fopen(\"/tmp/logs/408.txt\", \"a\");\n  if (NULL != log)\n  {\n    fprintf(log, \"In MHD_set_connection_value_n_nocheck_: key_size=%zu, value_size=%zu\\n\", key_size, value_size);\n    fclose(log);\n  }\n  struct MHD_HTTP_Req_Header *pos;\n\n  pos = MHD_connection_alloc_memory_(connection,\n                                    sizeof(struct MHD_HTTP_Req_Header));\n  if (NULL == pos)\n  {\n    log = fopen(\"/tmp/logs/408.txt\", \"a\");\n    if (NULL != log)\n    {\n      fprintf(log, \"Allocation failed in MHD_set_connection_value_n_nocheck_\\n\");\n      fclose(log);\n    }\n    return MHD_NO;\n  }\n  pos->header = key;\n  pos->header_size = key_size;\n  pos->value = value;\n  pos->value_size = value_size;\n  pos->kind = kind;\n  pos->next = NULL;\n\n  if (NULL == connection->rq.headers_received_tail)\n  {\n    connection->rq.headers_received = pos;\n    connection->rq.headers_received_tail = pos;\n  }\n  else\n  {\n    connection->rq.headers_received_tail->next = pos;\n    connection->rq.headers_received_tail = pos;\n  }\n  log = fopen(\"/tmp/logs/408.txt\", \"a\");\n  if (NULL != log)\n  {\n    fprintf(log, \"Header appended successfully in MHD_set_connection_value_n_nocheck_\\n\");\n    fclose(log);\n  }\n\n  return MHD_YES;\n}\n_MHD_EXTERN enum MHD_Result\nMHD_set_connection_value_n (struct MHD_Connection *connection,\n                            enum MHD_ValueKind kind,\n                            const char *key,\n                            size_t key_size,\n                            const char *value,\n                            size_t value_size)\n{\n  FILE *log = fopen(\"/tmp/logs/408.txt\", \"a\");\n  if (NULL != log)\n  {\n    fprintf(log, \"Entered MHD_set_connection_value_n with kind=%d\\n\", (int)kind);\n    fclose(log);\n  }\n\n  if ( (MHD_GET_ARGUMENT_KIND != kind) &&\n       ( ((key ? strlen (key) : 0) != key_size) ||\n         ((value ? strlen (value) : 0) != value_size) ) )\n  {\n    log = fopen(\"/tmp/logs/408.txt\", \"a\");\n    if (NULL != log)\n    {\n      fprintf(log, \"Violation condition met: key or value size mismatch\\n\");\n      fclose(log);\n    }\n    return MHD_NO; /* binary zero is allowed only in GET arguments */\n  }\n\n  return MHD_set_connection_value_n_nocheck_(connection,\n                                             kind,\n                                             key,\n                                             key_size,\n                                             value,\n                                             value_size);\n}\n\n```\nThe test code failed to compile, so we could not obtain any output.\n\n</test_code>\n<response format>\nProvide your answer with these fields.\n- explanation: your evaluation of the scenario provided by the agent A.\n- is_report_correct: whether the report is correct or not (true/false)\n</response format>\n<instruction>   \nJudge whether the report is correct or not.\n</instruction>\n",
  "is_report_correct": false,
  "explanation": "The identifier '_MHD_EXTERN' appears to be a macro used to modify linkage or visibility attributes. Such macros are common in C projects to handle platform-specific symbol export/import attributes (for example, __declspec(dllexport) on Windows or __attribute__((visibility)) on GCC). However, the use of _MHD_EXTERN itself is not a language extension but a user-defined macro. The MISRA C 2023 Rule 1.2 prohibits use of language extensions explicitly documented as such by the compiler vendor, not user-defined macros. Without the definition of _MHD_EXTERN to show that it expands into compiler language extensions, there is no sufficient evidence to claim a Rule 1.2 violation. Furthermore, the test code failing to build indicates that the exact usage likely depends on project-specific macro definitions and is not inherently a language extension. Therefore, the report that this code violates MISRA C 2023 Rule 1.2 because of '_MHD_EXTERN' is incorrect."
}