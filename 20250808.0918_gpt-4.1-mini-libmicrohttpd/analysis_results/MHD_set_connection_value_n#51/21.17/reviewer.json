{
  "user_message": "An agent A claimed that the following MHD_set_connection_value_n code violates the MISRA C 2023 rule 21.17.\n<misra_rule>\nMISRA C 2023 Rule 21.17 is Use of the string handling functions from <string.h> shall not result in accesses beyond the bounds of the objects referenced by their pointer parameters.\nThis rule strictly applies to the Standard Library functions in <string.h> such as memcpy, memmove, memset, memcmp, strcpy, strncpy, strcat, strncat, strlen, and strspn..\n</misra_rule>\n<target_code>\nHere is the original code of MHD_set_connection_value_n.\n```c\n_MHD_EXTERN enum MHD_Result\nMHD_set_connection_value_n (struct MHD_Connection *connection,\n                            enum MHD_ValueKind kind,\n                            const char *key,\n                            size_t key_size,\n                            const char *value,\n                            size_t value_size)\n{\n  if ( (MHD_GET_ARGUMENT_KIND != kind) &&\n       ( ((key ? strlen (key) : 0) != key_size) ||\n         ((value ? strlen (value) : 0) != value_size) ) )\n    return MHD_NO; /* binary zero is allowed only in GET arguments */\n\n  return MHD_set_connection_value_n_nocheck_ (connection,\n                                              kind,\n                                              key,\n                                              key_size,\n                                              value,\n                                              value_size);\n}\n```\n</target_code>\n<scenario>\nThe agent A provided the following violation scenario:If the key or value pointers point to strings containing embedded null characters, the calls to strlen(key) or strlen(value) will read beyond the 'key_size' or 'value_size' bounds, potentially violating memory safety and MISRA C 2023 Rule 21.17 by accessing beyond allocated object bounds.\n</scenario>\n<test_code>\nAlso, the agent A provided the following modified code that prints out the log to support their scenario:\n```c\n\n_MHD_EXTERN enum MHD_Result\nMHD_set_connection_value_n (struct MHD_Connection *connection,\n                            enum MHD_ValueKind kind,\n                            const char *key,\n                            size_t key_size,\n                            const char *value,\n                            size_t value_size)\n{\n  FILE *log_file = fopen(\"/tmp/logs/415.txt\", \"a\");\n  if (log_file == NULL) {\n    /* If file cannot be opened, continue without logging */\n  }\n\n  if (log_file != NULL) {\n    fprintf(log_file, \"Entering MHD_set_connection_value_n\\n\");\n    fprintf(log_file, \"kind = %d\\n\", (int)kind);\n    fprintf(log_file, \"key pointer = %p, key_size = %zu\\n\", (void *)key, key_size);\n    fprintf(log_file, \"value pointer = %p, value_size = %zu\\n\", (void *)value, value_size);\n  }\n\n  if ((MHD_GET_ARGUMENT_KIND != kind) &&\n      (((key ? strlen(key) : 0) != key_size) ||\n       ((value ? strlen(value) : 0) != value_size)))\n  {\n    if (log_file != NULL) {\n      size_t key_strlen = key ? strlen(key) : 0;\n      size_t value_strlen = value ? strlen(value) : 0;\n      fprintf(log_file, \"Violation detected: strlen(key) = %zu vs key_size = %zu\\n\", key_strlen, key_size);\n      fprintf(log_file, \"Violation detected: strlen(value) = %zu vs value_size = %zu\\n\", value_strlen, value_size);\n      fprintf(log_file, \"Returning MHD_NO due to binary zero not allowed except GET arguments\\n\");\n      fclose(log_file);\n      log_file = NULL;\n    }\n    return MHD_NO; /* binary zero is allowed only in GET arguments */\n  }\n\n  if (log_file != NULL) {\n    fprintf(log_file, \"Validation passed, calling MHD_set_connection_value_n_nocheck_\\n\");\n    fclose(log_file);\n    log_file = NULL;\n  }\n\n  return MHD_set_connection_value_n_nocheck_ (connection,\n                                              kind,\n                                              key,\n                                              key_size,\n                                              value,\n                                              value_size);\n}\n\n```\nThe test code failed to compile, so we could not obtain any output.\n\n</test_code>\n<response format>\nProvide your answer with these fields.\n- explanation: your evaluation of the scenario provided by the agent A.\n- is_report_correct: whether the report is correct or not (true/false)\n</response format>\n<instruction>   \nJudge whether the report is correct or not.\n</instruction>\n",
  "is_report_correct": true,
  "explanation": "The code calls strlen() on the pointers 'key' and 'value' without verifying that these strings are null-terminated and do not contain embedded null characters within the sizes key_size and value_size. If either 'key' or 'value' points to a buffer containing embedded nulls or non-null-terminated data within key_size or value_size, strlen() may read beyond the valid memory bounds, violating MISRA C 2023 Rule 21.17. The scenario provided by agent A is thus plausible: strlen() can cause out-of-bounds access if the assumptions about null termination and absence of embedded zeros do not hold. Therefore, the report that the code violates Rule 21.17 is correct."
}