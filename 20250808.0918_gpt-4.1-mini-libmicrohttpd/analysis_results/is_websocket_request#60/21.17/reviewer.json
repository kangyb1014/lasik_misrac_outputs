{
  "user_message": "An agent A claimed that the following is_websocket_request code violates the MISRA C 2023 rule 21.17.\n<misra_rule>\nMISRA C 2023 Rule 21.17 is Use of the string handling functions from <string.h> shall not result in accesses beyond the bounds of the objects referenced by their pointer parameters.\nThis rule strictly applies to the Standard Library functions in <string.h> such as memcpy, memmove, memset, memcmp, strcpy, strncpy, strcat, strncat, strlen, and strspn..\n</misra_rule>\n<target_code>\nHere is the original code of is_websocket_request.\n```c\nstatic enum MHD_Result\nis_websocket_request (struct MHD_Connection *con, const char *upg_header,\n                      const char *con_header)\n{\n\n  (void) con;  /* Unused. Silent compiler warning. */\n\n  return ((upg_header != NULL) && (con_header != NULL)\n          && (0 == strcmp (upg_header, WS_UPGRADE_VALUE))\n          && (NULL != strstr (con_header, \"Upgrade\")))\n         ? MHD_YES\n         : MHD_NO;\n}\n```\n</target_code>\n<scenario>\nThe agent A provided the following violation scenario:A potential violation would occur if the pointers 'upg_header' or 'con_header' point to buffers smaller than the length of the strings being compared or searched. For example, if 'upg_header' points to a buffer smaller than strlen(WS_UPGRADE_VALUE)+1 (for the terminating null), the call to strcmp could read beyond the valid object bounds.\n</scenario>\n<test_code>\nAlso, the agent A provided the following modified code that prints out the log to support their scenario:\n```c\n\nstatic enum MHD_Result\nis_websocket_request(struct MHD_Connection *con, const char *upg_header,\n                      const char *con_header)\n{\n  FILE *log = fopen(\"/tmp/logs/487.txt\", \"a\");\n  if (log == NULL) {\n    /* Cannot open log file, proceed without logging. */\n    (void)con;\n    return ((upg_header != NULL) && (con_header != NULL)\n            && (0 == strcmp(upg_header, WS_UPGRADE_VALUE))\n            && (NULL != strstr(con_header, \"Upgrade\")))\n           ? MHD_YES\n           : MHD_NO;\n  }\n\n  fprintf(log, \"Entered is_websocket_request\\n\");\n  fprintf(log, \"upg_header: %p, con_header: %p\\n\", (const void*)upg_header, (const void*)con_header);\n\n  if (upg_header == NULL) {\n    fprintf(log, \"upg_header is NULL\\n\");\n    fclose(log);\n    return MHD_NO;\n  }\n  if (con_header == NULL) {\n    fprintf(log, \"con_header is NULL\\n\");\n    fclose(log);\n    return MHD_NO;\n  }\n\n  size_t upg_len = strlen(upg_header);\n  size_t ws_len = strlen(WS_UPGRADE_VALUE);\n  fprintf(log, \"upg_header length: %zu, WS_UPGRADE_VALUE length: %zu\\n\", upg_len, ws_len);\n\n  /* Probe potential risk: log if upg_header length is less than WS_UPGRADE_VALUE length */\n  if (upg_len < ws_len) {\n    fprintf(log, \"Warning: upg_header length (%zu) smaller than WS_UPGRADE_VALUE (%zu), risk of out-of-bounds in strcmp\\n\", upg_len, ws_len);\n  }\n\n  int strcmp_res = strcmp(upg_header, WS_UPGRADE_VALUE);\n  fprintf(log, \"strcmp(upg_header, WS_UPGRADE_VALUE) = %d\\n\", strcmp_res);\n\n  const char *strstr_res = strstr(con_header, \"Upgrade\");\n  fprintf(log, \"strstr(con_header, \\\"Upgrade\\\") = %p\\n\", (const void*)strstr_res);\n\n  enum MHD_Result result = (strcmp_res == 0 && strstr_res != NULL) ? MHD_YES : MHD_NO;\n\n  fprintf(log, \"Returning result: %d\\n\", result);\n  fclose(log);\n  (void)con;  /* Unused. Silent compiler warning. */\n  return result;\n}\n\n```\nThe test code failed to compile, so we could not obtain any output.\n\n</test_code>\n<response format>\nProvide your answer with these fields.\n- explanation: your evaluation of the scenario provided by the agent A.\n- is_report_correct: whether the report is correct or not (true/false)\n</response format>\n<instruction>   \nJudge whether the report is correct or not.\n</instruction>\n",
  "is_report_correct": true,
  "explanation": "MISRA C 2023 Rule 21.17 mandates that standard string functions shall not access memory beyond the bounds of the objects they reference. The reported code calls strcmp(upg_header, WS_UPGRADE_VALUE) and strstr(con_header, \"Upgrade\") only after checking that upg_header and con_header are not NULL, but it does not validate that these pointers reference buffers large enough to safely contain the required strings including null terminators.\n\nThe agent A's scenario correctly highlights that if upg_header points to a buffer smaller than strlen(WS_UPGRADE_VALUE) + 1, strcmp may read beyond the buffer's bounds, violating Rule 21.17. Similarly, strstr called on con_header requires that con_header's buffer contains at least a null-terminated string safely accessible.\n\nBecause the code does not ensure that the buffers pointed to by upg_header and con_header are adequately sized or null-terminated before using these functions, it risks out-of-bounds access. While runtime or static analysis could detect such possible risks, the code as written is non-compliant with the MISRA requirement that usage of these functions must be safe and bounded.\n\nTherefore, the reported violation is valid. The test code attempts to log lengths to confirm the risk but failed to compile, which does not invalidate the theoretical violation inherent in the original code.\n\nIn summary, the code potentially violates MISRA C 2023 Rule 21.17 because it does not guarantee that inputs to strcmp and strstr are valid, null-terminated strings within properly sized buffers, and thus may read beyond object bounds."
}