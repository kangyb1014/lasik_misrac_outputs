{
  "user_message": "<target code>Here is the code that failed to compile:\n```c\n\nstatic enum MHD_Result\nadd_response_header_connection (struct MHD_Response *response,\n                                const char *value)\n{\n  FILE *log = fopen(\"/tmp/logs/63.txt\", \"a\");\n  static const char *key = MHD_HTTP_HEADER_CONNECTION;\n  static const size_t key_len = MHD_STATICSTR_LEN_(MHD_HTTP_HEADER_CONNECTION);\n  size_t value_len;\n  size_t old_value_len;\n  size_t buf_size;\n  size_t norm_len;\n  char *buf;\n  struct MHD_HTTP_Res_Header *hdr;\n  bool value_has_close;\n  bool already_has_close;\n  size_t pos = 0;\n\n  if ((NULL != strchr(value, '\\r')) || (NULL != strchr(value, '\\n')))\n  {\n    fprintf(log, \"Invalid characters in value\\n\");\n    fclose(log);\n    return MHD_NO;\n  }\n\n  if ((0 != (response->flags_auto & MHD_RAF_HAS_CONNECTION_HDR)))\n  {\n    hdr = MHD_get_response_element_n_(response, MHD_HEADER_KIND, key, key_len);\n    already_has_close = (0 != (response->flags_auto & MHD_RAF_HAS_CONNECTION_CLOSE));\n    fprintf(log, \"Existing header found. Already has close: %d\\n\", already_has_close);\n  }\n  else\n  {\n    hdr = NULL;\n    already_has_close = false;\n    fprintf(log, \"No existing header found.\\n\");\n  }\n\n  if (NULL != hdr)\n  {\n    old_value_len = hdr->value_size + 2;\n    fprintf(log, \"Old value length (including \", \") extra: %zu\\n\", old_value_len);\n  }\n  else\n  {\n    old_value_len = 0;\n    fprintf(log, \"Old value length: 0\\n\");\n  }\n\n  value_len = strlen(value);\n  fprintf(log, \"Value length: %zu\\n\", value_len);\n  if (value_len >= SSIZE_MAX)\n  {\n    fprintf(log, \"Value length >= SSIZE_MAX, aborting.\\n\");\n    fclose(log);\n    return MHD_NO;\n  }\n\n  norm_len = value_len + value_len / 2 + 1;\n  fprintf(log, \"Normalized length: %zu\\n\", norm_len);\n  if (norm_len >= SSIZE_MAX)\n  {\n    fprintf(log, \"Normalized length >= SSIZE_MAX, aborting.\\n\");\n    fclose(log);\n    return MHD_NO;\n  }\n\n  buf_size = old_value_len + (size_t)norm_len;\n  fprintf(log, \"Buffer size: %zu\\n\", buf_size);\n\n  buf = malloc(buf_size);\n  if (NULL == buf)\n  {\n    fprintf(log, \"Memory allocation failed.\\n\");\n    fclose(log);\n    return MHD_NO;\n  }\n\n  ssize_t norm_len_s = (ssize_t)norm_len;\n  value_has_close = MHD_str_remove_token_caseless_(value, value_len, \"close\",\n                                                    MHD_STATICSTR_LEN_(\"close\"),\n                                                    buf + old_value_len,\n                                                    &norm_len_s);\n  fprintf(log, \"Value has close: %d, norm_len_s: %zd\\n\", value_has_close, norm_len_s);\n  if (norm_len_s < 0)\n  {\n    fprintf(log, \"Normalization length error.\\n\");\n    free(buf);\n    fclose(log);\n    return MHD_NO;\n  }\n  norm_len = (size_t)norm_len_s;\n\n#ifdef UPGRADE_SUPPORT\n  if ((NULL != response->upgrade_handler) && value_has_close)\n  {\n    fprintf(log, \"Upgrade handler present with 'close' token, aborting.\\n\");\n    free(buf);\n    fclose(log);\n    return MHD_NO;\n  }\n#endif\n\n  if (0 != norm_len)\n  {\n    MHD_str_remove_tokens_caseless_(buf + old_value_len, &norm_len, \"keep-alive\",\n                                   MHD_STATICSTR_LEN_(\"keep-alive\"));\n    fprintf(log, \"Tokens \"keep-alive\" removed if present. New norm_len: %zu\\n\", norm_len);\n  }\n\n  if ((norm_len == 0) && !value_has_close)\n  {\n    fprintf(log, \"Normalized value empty and no close token.\\n\");\n    free(buf);\n    fclose(log);\n    return MHD_NO;\n  }\n\n  if (value_has_close && !already_has_close)\n  {\n    mhd_assert(buf_size >= old_value_len + norm_len + MHD_STATICSTR_LEN_(\"close, \") + 1);\n    if (0 != norm_len)\n    {\n      memmove(buf + MHD_STATICSTR_LEN_(\"close, \") + old_value_len,\n              buf + old_value_len, norm_len + 1);\n      fprintf(log, \"Shifting tokens to insert 'close, '.\\n\");\n    }\n    memcpy(buf, \"close\", MHD_STATICSTR_LEN_(\"close\"));\n    pos += MHD_STATICSTR_LEN_(\"close\");\n    fprintf(log, \"Inserted 'close' token at buffer start, pos: %zu\\n\", pos);\n  }\n\n  if (0 != old_value_len)\n  {\n    if (0 != pos)\n    {\n      buf[pos++] = ',';\n      buf[pos++] = ' ';\n    }\n    memcpy(buf + pos, hdr->value, hdr->value_size);\n    pos += hdr->value_size;\n    fprintf(log, \"Copied old header value at pos %zu, new pos %zu\\n\", pos - hdr->value_size, pos);\n  }\n\n  if (0 != norm_len)\n  {\n    if (0 != pos)\n    {\n      buf[pos++] = ',';\n      buf[pos++] = ' ';\n    }\n    mhd_assert(((value_has_close && !already_has_close) ?\n                (MHD_STATICSTR_LEN_(\"close, \") + old_value_len == pos) :\n                (old_value_len == pos)));\n    pos += norm_len;\n    fprintf(log, \"Added new normalized tokens at pos %zu, new pos %zu\\n\", pos - norm_len, pos);\n  }\n\n  mhd_assert(buf_size > pos);\n  buf[pos] = 0;\n  fprintf(log, \"Final buffer null-terminated at pos %zu. Buffer size: %zu\\n\", pos, buf_size);\n\n  // Other logic unchanged ...\n\n  fclose(log);\n  return MHD_YES;\n}\n\n```\n</target code>\n<build error>\nThe build failed with the following error:\n```\nresponse.c: In function 'add_response_header_connection':\nresponse.c:377:18: warning: too many arguments for format [-Wformat-extra-args]\n  377 |     fprintf(log, \"Old value length (including \", \") extra: %zu\\n\", old_value_len);\n      |                  ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\nresponse.c:443:27: error: expected ')' before 'keep'\n  443 |     fprintf(log, \"Tokens \"keep-alive\" removed if present. New norm_len: %zu\\n\", norm_len);\n      |            ~              ^~~~\n      |                           )\nmake[3]: *** [Makefile:2182: libmicrohttpd_la-response.lo] Error 1\nmake[2]: *** [Makefile:449: all-recursive] Error 1\nmake[1]: *** [Makefile:788: all-recursive] Error 1\nmake: *** [Makefile:693: all] Error 2\n```\n</build error>\n<response format>\nProvide your answer with these answers.\n- fixed_test_code: the fixed test code that compiles successfully.\n- explanation: a brief explanation of the changes you made to fix the code.\nHere are the constraints for the test code:\n- The test code MUST be compilable and executable.\n- The test code MUST include line breaks.\n- The test code MUST preserve the original logic of add_response_header_connection as much as possible.\n- You MUST not define the main function.\n- You MUST not define macros.\n- The test code MUST not contain any mock functions.\n</response format>\n<instruction>\nPlease fix the code so that it compiles successfully.\n</instruction>\n",
  "fixed_test_code": "static enum MHD_Result\nadd_response_header_connection (struct MHD_Response *response,\n                                const char *value)\n{\n  FILE *log = fopen(\"/tmp/logs/63.txt\", \"a\");\n  static const char *key = MHD_HTTP_HEADER_CONNECTION;\n  static const size_t key_len = MHD_STATICSTR_LEN_(MHD_HTTP_HEADER_CONNECTION);\n  size_t value_len;\n  size_t old_value_len;\n  size_t buf_size;\n  size_t norm_len;\n  char *buf;\n  struct MHD_HTTP_Res_Header *hdr;\n  bool value_has_close;\n  bool already_has_close;\n  size_t pos = 0;\n\n  if ((NULL != strchr(value, '\\r')) || (NULL != strchr(value, '\\n')))\n  {\n    fprintf(log, \"Invalid characters in value\\n\");\n    fclose(log);\n    return MHD_NO;\n  }\n\n  if ((0 != (response->flags_auto & MHD_RAF_HAS_CONNECTION_HDR)))\n  {\n    hdr = MHD_get_response_element_n_(response, MHD_HEADER_KIND, key, key_len);\n    already_has_close = (0 != (response->flags_auto & MHD_RAF_HAS_CONNECTION_CLOSE));\n    fprintf(log, \"Existing header found. Already has close: %d\\n\", already_has_close);\n  }\n  else\n  {\n    hdr = NULL;\n    already_has_close = false;\n    fprintf(log, \"No existing header found.\\n\");\n  }\n\n  if (NULL != hdr)\n  {\n    old_value_len = hdr->value_size + 2;\n    fprintf(log, \"Old value length (including ) extra: %zu\\n\", old_value_len);\n  }\n  else\n  {\n    old_value_len = 0;\n    fprintf(log, \"Old value length: 0\\n\");\n  }\n\n  value_len = strlen(value);\n  fprintf(log, \"Value length: %zu\\n\", value_len);\n  if (value_len >= SSIZE_MAX)\n  {\n    fprintf(log, \"Value length >= SSIZE_MAX, aborting.\\n\");\n    fclose(log);\n    return MHD_NO;\n  }\n\n  norm_len = value_len + value_len / 2 + 1;\n  fprintf(log, \"Normalized length: %zu\\n\", norm_len);\n  if (norm_len >= SSIZE_MAX)\n  {\n    fprintf(log, \"Normalized length >= SSIZE_MAX, aborting.\\n\");\n    fclose(log);\n    return MHD_NO;\n  }\n\n  buf_size = old_value_len + (size_t)norm_len;\n  fprintf(log, \"Buffer size: %zu\\n\", buf_size);\n\n  buf = malloc(buf_size);\n  if (NULL == buf)\n  {\n    fprintf(log, \"Memory allocation failed.\\n\");\n    fclose(log);\n    return MHD_NO;\n  }\n\n  ssize_t norm_len_s = (ssize_t)norm_len;\n  value_has_close = MHD_str_remove_token_caseless_(value, value_len, \"close\",\n                                                    MHD_STATICSTR_LEN_(\"close\"),\n                                                    buf + old_value_len,\n                                                    &norm_len_s);\n  fprintf(log, \"Value has close: %d, norm_len_s: %zd\\n\", value_has_close, norm_len_s);\n  if (norm_len_s < 0)\n  {\n    fprintf(log, \"Normalization length error.\\n\");\n    free(buf);\n    fclose(log);\n    return MHD_NO;\n  }\n  norm_len = (size_t)norm_len_s;\n\n#ifdef UPGRADE_SUPPORT\n  if ((NULL != response->upgrade_handler) && value_has_close)\n  {\n    fprintf(log, \"Upgrade handler present with 'close' token, aborting.\\n\");\n    free(buf);\n    fclose(log);\n    return MHD_NO;\n  }\n#endif\n\n  if (0 != norm_len)\n  {\n    MHD_str_remove_tokens_caseless_(buf + old_value_len, &norm_len, \"keep-alive\",\n                                   MHD_STATICSTR_LEN_(\"keep-alive\"));\n    fprintf(log, \"Tokens \\\"keep-alive\\\" removed if present. New norm_len: %zu\\n\", norm_len);\n  }\n\n  if ((norm_len == 0) && !value_has_close)\n  {\n    fprintf(log, \"Normalized value empty and no close token.\\n\");\n    free(buf);\n    fclose(log);\n    return MHD_NO;\n  }\n\n  if (value_has_close && !already_has_close)\n  {\n    mhd_assert(buf_size >= old_value_len + norm_len + MHD_STATICSTR_LEN_(\"close, \") + 1);\n    if (0 != norm_len)\n    {\n      memmove(buf + MHD_STATICSTR_LEN_(\"close, \") + old_value_len,\n              buf + old_value_len, norm_len + 1);\n      fprintf(log, \"Shifting tokens to insert 'close, '.\\n\");\n    }\n    memcpy(buf, \"close\", MHD_STATICSTR_LEN_(\"close\"));\n    pos += MHD_STATICSTR_LEN_(\"close\");\n    fprintf(log, \"Inserted 'close' token at buffer start, pos: %zu\\n\", pos);\n  }\n\n  if (0 != old_value_len)\n  {\n    if (0 != pos)\n    {\n      buf[pos++] = ',';\n      buf[pos++] = ' ';\n    }\n    memcpy(buf + pos, hdr->value, hdr->value_size);\n    pos += hdr->value_size;\n    fprintf(log, \"Copied old header value at pos %zu, new pos %zu\\n\", pos - hdr->value_size, pos);\n  }\n\n  if (0 != norm_len)\n  {\n    if (0 != pos)\n    {\n      buf[pos++] = ',';\n      buf[pos++] = ' ';\n    }\n    mhd_assert(((value_has_close && !already_has_close) ?\n                (MHD_STATICSTR_LEN_(\"close, \") + old_value_len == pos) :\n                (old_value_len == pos)));\n    pos += norm_len;\n    fprintf(log, \"Added new normalized tokens at pos %zu, new pos %zu\\n\", pos - norm_len, pos);\n  }\n\n  mhd_assert(buf_size > pos);\n  buf[pos] = 0;\n  fprintf(log, \"Final buffer null-terminated at pos %zu. Buffer size: %zu\\n\", pos, buf_size);\n\n  // Other logic unchanged ...\n\n  fclose(log);\n  return MHD_YES;\n}\n",
  "explanation": "The first fix was to correct the call to fprintf that caused a \"too many arguments for format\" warning: it had two separate string literals that caused an incorrect format string, so they were combined into one correct string literal.\n\nThe second fix was to escape the double quotes inside the string literal in another fprintf call around the \"keep-alive\" token, changing it to use escaped quotes (\\\"keep-alive\\\") so the string literal is valid.\n\nThese changes ensure the format strings for fprintf are syntactically valid and prevent compiler errors without altering the original logic."
}