{
  "user_message": "An agent A claimed that the following run_usock code violates the MISRA C 2023 rule 21.17.\n<misra_rule>\nMISRA C 2023 Rule 21.17 is Use of the string handling functions from <string.h> shall not result in accesses beyond the bounds of the objects referenced by their pointer parameters.\nThis rule strictly applies to the Standard Library functions in <string.h> such as memcpy, memmove, memset, memcmp, strcpy, strncpy, strcat, strncat, strlen, and strspn..\n</misra_rule>\n<target_code>\nHere is the original code of run_usock.\n```c\nstatic void *\nrun_usock (void *cls)\n{\n  struct WsData *ws = cls;\n  struct MHD_UpgradeResponseHandle *urh = ws->urh;\n  unsigned char buf[2048];\n  unsigned char *msg;\n  char *text;\n  ssize_t got;\n  int type;\n  int i;\n\n  make_blocking (ws->sock);\n  while (1)\n  {\n    got = recv (ws->sock, (void *) buf, sizeof (buf), 0);\n    if (0 >= got)\n    {\n      break;\n    }\n    msg = ws_receive_frame (buf, &got, &type);\n    if (NULL == msg)\n    {\n      break;\n    }\n    if (type == WS_OPCODE_TEXT_FRAME)\n    {\n      ssize_t sent;\n      int buf_size;\n      buf_size = snprintf (NULL, 0, \"User#%d: %s\", (int) ws->sock, msg);\n      if (0 < buf_size)\n      {\n        text = malloc ((size_t) buf_size + 1);\n        if (NULL != text)\n        {\n          if (snprintf (text, (size_t) buf_size + 1,\n                        \"User#%d: %s\", (int) ws->sock, msg) == buf_size)\n            sent = ws_send_frame (ws->sock, text, (size_t) buf_size);\n          else\n            sent = -1;\n          free (text);\n        }\n        else\n          sent = -1;\n      }\n      else\n        sent = -1;\n      free (msg);\n      if (-1 == sent)\n      {\n        break;\n      }\n    }\n    else\n    {\n      if (type == WS_OPCODE_CON_CLOSE_FRAME)\n      {\n        free (msg);\n        break;\n      }\n    }\n  }\n  if (0 != pthread_mutex_lock (&MUTEX))\n    abort ();\n  for (i = 0; i < MAX_CLIENTS; i++)\n  {\n    if (CLIENT_SOCKS[i] == ws->sock)\n    {\n      CLIENT_SOCKS[i] = MHD_INVALID_SOCKET;\n      break;\n    }\n  }\n  if (0 != pthread_mutex_unlock (&MUTEX))\n    abort ();\n  free (ws);\n  MHD_upgrade_action (urh, MHD_UPGRADE_ACTION_CLOSE);\n  return NULL;\n}\n```\n</target_code>\n<scenario>\nThe agent A provided the following violation scenario:If the ws_receive_frame function parses a WebSocket text frame with an incorrectly specified payload length, ws_receive_frame might allocate a buffer (msg) and write beyond that buffer's bounds when copying and unmasking the payload from the input buffer. This leads to accesses beyond the bounds of the object referenced by the pointer parameters (frame), violating Rule 21.17.\n</scenario>\n<test_code>\nAlso, the agent A provided the following modified code that prints out the log to support their scenario:\n```c\nstatic void log_to_file(const char *msg)\n{\n  FILE *f = fopen(\"/tmp/logs/207.txt\", \"a\");\n  if (f != NULL)\n  {\n    fprintf(f, \"%s\\n\", msg);\n    fclose(f);\n  }\n}\n\nstatic void * run_usock (void *cls)\n{\n  struct WsData *ws = cls;\n  struct MHD_UpgradeResponseHandle *urh = ws->urh;\n  unsigned char buf[2048];\n  unsigned char *msg;\n  char *text;\n  ssize_t got;\n  int type;\n  int i;\n\n  log_to_file(\"Entered run_usock\");\n\n  make_blocking (ws->sock);\n  while (1)\n  {\n    got = recv (ws->sock, (void *) buf, sizeof (buf), 0);\n    char logbuf[128];\n    snprintf(logbuf, sizeof(logbuf), \"recv returned %zd bytes\", got);\n    log_to_file(logbuf);\n\n    if (0 >= got)\n    {\n      log_to_file(\"recv <= 0, breaking loop\");\n      break;\n    }\n\n    msg = ws_receive_frame (buf, &got, &type);\n    if (NULL == msg)\n    {\n      log_to_file(\"ws_receive_frame returned NULL, breaking loop\");\n      break;\n    }\n\n    snprintf(logbuf, sizeof(logbuf), \"Received frame type: %d, length: %zd\", type, got);\n    log_to_file(logbuf);\n\n    if (type == WS_OPCODE_TEXT_FRAME)\n    {\n      ssize_t sent;\n      int buf_size;\n      buf_size = snprintf (NULL, 0, \"User#%d: %s\", (int) ws->sock, msg);\n      log_to_file(\"Formatting user message\");\n\n      if (0 < buf_size)\n      {\n        text = malloc ((size_t) buf_size + 1);\n        if (NULL != text)\n        {\n          if (snprintf (text, (size_t) buf_size + 1,\n                        \"User#%d: %s\", (int) ws->sock, msg) == buf_size)\n            sent = ws_send_frame (ws->sock, text, (size_t) buf_size);\n          else\n            sent = -1;\n\n          snprintf(logbuf, sizeof(logbuf), \"Sent %zd bytes\", sent);\n          log_to_file(logbuf);\n          free (text);\n        }\n        else\n          sent = -1;\n      }\n      else\n        sent = -1;\n\n      free (msg);\n\n      if (-1 == sent)\n      {\n        log_to_file(\"Send failed, breaking loop\");\n        break;\n      }\n    }\n    else\n    {\n      if (type == WS_OPCODE_CON_CLOSE_FRAME)\n      {\n        log_to_file(\"Received close frame, breaking loop\");\n        free (msg);\n        break;\n      }\n    }\n  }\n\n  if (0 != pthread_mutex_lock (&MUTEX))\n    abort ();\n  log_to_file(\"Locked mutex for client cleanup\");\n  for (i = 0; i < 10; i++)  /* replaced MAX_CLIENTS with literal 10 */\n  {\n    if (CLIENT_SOCKS[i] == ws->sock)\n    {\n      CLIENT_SOCKS[i] = -1; /* replaced MHD_INVALID_SOCKET with literal -1 */\n      break;\n    }\n  }\n  if (0 != pthread_mutex_unlock (&MUTEX))\n    abort ();\n  log_to_file(\"Unlocked mutex and freeing ws\");\n  free (ws);\n  MHD_upgrade_action (urh, /* appropriate enum value for close action, e.g. */ MHD_UPGRADE_ACTION_CLOSE);\n  log_to_file(\"Exiting run_usock\");\n  return NULL;\n}\n\n```\nThe test code failed to compile, so we could not obtain any output.\n\n</test_code>\n<response format>\nProvide your answer with these fields.\n- explanation: your evaluation of the scenario provided by the agent A.\n- is_report_correct: whether the report is correct or not (true/false)\n</response format>\n<instruction>   \nJudge whether the report is correct or not.\n</instruction>\n",
  "is_report_correct": false,
  "explanation": "The violation scenario proposed by agent A focuses on the behavior of the ws_receive_frame function, which is not provided in the submitted code. Agent A suggests that ws_receive_frame may parse payload lengths incorrectly, potentially causing buffer overflows due to out-of-bounds writes when handling the input buffer via string functions. However, since ws_receive_frame's implementation is unknown and is out of the scope of the given run_usock code, it is impossible to confirm within this review whether any string handling functions in the shown code cause or contribute to out-of-bounds accesses as per MISRA C 2023 Rule 21.17. The run_usock code itself uses safe string functions (snprintf) with calculated buffer sizes and allocates memory accordingly. Without a definitive link showing that run_usock's own string handling calls can breach buffer boundaries, the claim that run_usock violates Rule 21.17 cannot be substantiated solely based on potential behavior inside ws_receive_frame. Hence, the report is not correct regarding the given code fragment, because the violation would stem from ws_receive_frame's implementation rather than the reviewed run_usock function itself, according to the evidence provided."
}