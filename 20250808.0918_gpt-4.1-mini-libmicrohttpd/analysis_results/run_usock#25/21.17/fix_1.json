{
  "user_message": "<target code>Here is the code that failed to compile:\n```c\nextern int MAX_CLIENTS;\nextern int MHD_INVALID_SOCKET;\nextern void MHD_upgrade_action(void *urh, int action);\nstatic void log_to_file(const char *msg)\n{\n  FILE *f = fopen(\"/tmp/logs/207.txt\", \"a\");\n  if (f != NULL)\n  {\n    fprintf(f, \"%s\\n\", msg);\n    fclose(f);\n  }\n}\n\nstatic void * run_usock (void *cls)\n{\n  struct WsData *ws = cls;\n  struct MHD_UpgradeResponseHandle *urh = ws->urh;\n  unsigned char buf[2048];\n  unsigned char *msg;\n  char *text;\n  ssize_t got;\n  int type;\n  int i;\n\n  log_to_file(\"Entered run_usock\");\n\n  make_blocking (ws->sock);\n  while (1)\n  {\n    got = recv (ws->sock, (void *) buf, sizeof (buf), 0);\n    char logbuf[128];\n    snprintf(logbuf, sizeof(logbuf), \"recv returned %zd bytes\", got);\n    log_to_file(logbuf);\n\n    if (0 >= got)\n    {\n      log_to_file(\"recv <= 0, breaking loop\");\n      break;\n    }\n\n    msg = ws_receive_frame (buf, &got, &type);\n    if (NULL == msg)\n    {\n      log_to_file(\"ws_receive_frame returned NULL, breaking loop\");\n      break;\n    }\n\n    snprintf(logbuf, sizeof(logbuf), \"Received frame type: %d, length: %zd\", type, got);\n    log_to_file(logbuf);\n\n    if (type == WS_OPCODE_TEXT_FRAME)\n    {\n      ssize_t sent;\n      int buf_size;\n      buf_size = snprintf (NULL, 0, \"User#%d: %s\", (int) ws->sock, msg);\n      log_to_file(\"Formatting user message\");\n\n      if (0 < buf_size)\n      {\n        text = malloc ((size_t) buf_size + 1);\n        if (NULL != text)\n        {\n          if (snprintf (text, (size_t) buf_size + 1,\n                        \"User#%d: %s\", (int) ws->sock, msg) == buf_size)\n            sent = ws_send_frame (ws->sock, text, (size_t) buf_size);\n          else\n            sent = -1;\n\n          snprintf(logbuf, sizeof(logbuf), \"Sent %zd bytes\", sent);\n          log_to_file(logbuf);\n          free (text);\n        }\n        else\n          sent = -1;\n      }\n      else\n        sent = -1;\n\n      free (msg);\n\n      if (-1 == sent)\n      {\n        log_to_file(\"Send failed, breaking loop\");\n        break;\n      }\n    }\n    else\n    {\n      if (type == WS_OPCODE_CON_CLOSE_FRAME)\n      {\n        log_to_file(\"Received close frame, breaking loop\");\n        free (msg);\n        break;\n      }\n    }\n  }\n\n  if (0 != pthread_mutex_lock (&MUTEX))\n    abort ();\n  log_to_file(\"Locked mutex for client cleanup\");\n  for (i = 0; i < MAX_CLIENTS; i++)\n  {\n    if (CLIENT_SOCKS[i] == ws->sock)\n    {\n      CLIENT_SOCKS[i] = MHD_INVALID_SOCKET;\n      break;\n    }\n  }\n  if (0 != pthread_mutex_unlock (&MUTEX))\n    abort ();\n  log_to_file(\"Unlocked mutex and freeing ws\");\n  free (ws);\n  MHD_upgrade_action (urh, MHD_UPGRADE_ACTION_CLOSE);\n  log_to_file(\"Exiting run_usock\");\n  return NULL;\n}\n\n```\n</target code>\n<build error>\nThe build failed with the following error:\n```\nwebsocket_threaded_example.c:115:21: error: expected identifier or '(' before numeric constant\n  115 | #define MAX_CLIENTS 10\n      |                     ^~\nwebsocket_threaded_example.c:717:12: note: in expansion of macro 'MAX_CLIENTS'\n  717 | extern int MAX_CLIENTS;\n      |            ^~~~~~~~~~~\nIn file included from websocket_threaded_example.c:44:\n../../src/include/microhttpd.h:202:29: error: expected identifier or '(' before '-' token\n  202 | #define MHD_INVALID_SOCKET (-1)\n      |                             ^\nwebsocket_threaded_example.c:718:12: note: in expansion of macro 'MHD_INVALID_SOCKET'\n  718 | extern int MHD_INVALID_SOCKET;\n      |            ^~~~~~~~~~~~~~~~~~\nwebsocket_threaded_example.c:719:13: error: conflicting types for 'MHD_upgrade_action'; have 'void(void *, int)'\n  719 | extern void MHD_upgrade_action(void *urh, int action);\n      |             ^~~~~~~~~~~~~~~~~~\nIn file included from websocket_threaded_example.c:44:\n../../src/include/microhttpd.h:4381:1: note: previous declaration of 'MHD_upgrade_action' with type 'enum MHD_Result(struct MHD_UpgradeResponseHandle *, enum MHD_UpgradeAction, ...)'\n 4381 | MHD_upgrade_action (struct MHD_UpgradeResponseHandle *urh,\n      | ^~~~~~~~~~~~~~~~~~\nmake[4]: *** [Makefile:1208: websocket_threaded_example-websocket_threaded_example.o] Error 1\nmake[3]: *** [Makefile:1234: all-recursive] Error 1\nmake[2]: *** [Makefile:449: all-recursive] Error 1\nmake[1]: *** [Makefile:788: all-recursive] Error 1\nmake: *** [Makefile:693: all] Error 2\n```\n</build error>\n<response format>\nProvide your answer with these answers.\n- fixed_test_code: the fixed test code that compiles successfully.\n- explanation: a brief explanation of the changes you made to fix the code.\nHere are the constraints for the test code:\n- The test code MUST be compilable and executable.\n- The test code MUST include line breaks.\n- The test code MUST preserve the original logic of run_usock as much as possible.\n- You MUST not define the main function.\n- You MUST not define macros.\n- The test code MUST not contain any mock functions.\n</response format>\n<instruction>\nPlease fix the code so that it compiles successfully.\n</instruction>\n",
  "fixed_test_code": "static void log_to_file(const char *msg)\n{\n  FILE *f = fopen(\"/tmp/logs/207.txt\", \"a\");\n  if (f != NULL)\n  {\n    fprintf(f, \"%s\\n\", msg);\n    fclose(f);\n  }\n}\n\nstatic void * run_usock (void *cls)\n{\n  struct WsData *ws = cls;\n  struct MHD_UpgradeResponseHandle *urh = ws->urh;\n  unsigned char buf[2048];\n  unsigned char *msg;\n  char *text;\n  ssize_t got;\n  int type;\n  int i;\n\n  log_to_file(\"Entered run_usock\");\n\n  make_blocking (ws->sock);\n  while (1)\n  {\n    got = recv (ws->sock, (void *) buf, sizeof (buf), 0);\n    char logbuf[128];\n    snprintf(logbuf, sizeof(logbuf), \"recv returned %zd bytes\", got);\n    log_to_file(logbuf);\n\n    if (0 >= got)\n    {\n      log_to_file(\"recv <= 0, breaking loop\");\n      break;\n    }\n\n    msg = ws_receive_frame (buf, &got, &type);\n    if (NULL == msg)\n    {\n      log_to_file(\"ws_receive_frame returned NULL, breaking loop\");\n      break;\n    }\n\n    snprintf(logbuf, sizeof(logbuf), \"Received frame type: %d, length: %zd\", type, got);\n    log_to_file(logbuf);\n\n    if (type == WS_OPCODE_TEXT_FRAME)\n    {\n      ssize_t sent;\n      int buf_size;\n      buf_size = snprintf (NULL, 0, \"User#%d: %s\", (int) ws->sock, msg);\n      log_to_file(\"Formatting user message\");\n\n      if (0 < buf_size)\n      {\n        text = malloc ((size_t) buf_size + 1);\n        if (NULL != text)\n        {\n          if (snprintf (text, (size_t) buf_size + 1,\n                        \"User#%d: %s\", (int) ws->sock, msg) == buf_size)\n            sent = ws_send_frame (ws->sock, text, (size_t) buf_size);\n          else\n            sent = -1;\n\n          snprintf(logbuf, sizeof(logbuf), \"Sent %zd bytes\", sent);\n          log_to_file(logbuf);\n          free (text);\n        }\n        else\n          sent = -1;\n      }\n      else\n        sent = -1;\n\n      free (msg);\n\n      if (-1 == sent)\n      {\n        log_to_file(\"Send failed, breaking loop\");\n        break;\n      }\n    }\n    else\n    {\n      if (type == WS_OPCODE_CON_CLOSE_FRAME)\n      {\n        log_to_file(\"Received close frame, breaking loop\");\n        free (msg);\n        break;\n      }\n    }\n  }\n\n  if (0 != pthread_mutex_lock (&MUTEX))\n    abort ();\n  log_to_file(\"Locked mutex for client cleanup\");\n  for (i = 0; i < 10; i++)  /* replaced MAX_CLIENTS with literal 10 */\n  {\n    if (CLIENT_SOCKS[i] == ws->sock)\n    {\n      CLIENT_SOCKS[i] = -1; /* replaced MHD_INVALID_SOCKET with literal -1 */\n      break;\n    }\n  }\n  if (0 != pthread_mutex_unlock (&MUTEX))\n    abort ();\n  log_to_file(\"Unlocked mutex and freeing ws\");\n  free (ws);\n  MHD_upgrade_action (urh, /* appropriate enum value for close action, e.g. */ MHD_UPGRADE_ACTION_CLOSE);\n  log_to_file(\"Exiting run_usock\");\n  return NULL;\n}\n",
  "explanation": "The original code had issues due to conflicting declarations that collides with macros and pre-existing library definitions. Specifically:\n\n- The code declared extern variables 'MAX_CLIENTS' and 'MHD_INVALID_SOCKET', but these are already macros defined elsewhere (likely as #define MAX_CLIENTS 10 and #define MHD_INVALID_SOCKET (-1)). Redeclaring them as extern int caused compilation errors. The fix was to remove these extern declarations and instead use the literal values directly, i.e., replace 'MAX_CLIENTS' with 10 and 'MHD_INVALID_SOCKET' with -1 in the code.\n\n- The function 'MHD_upgrade_action' was declared with a conflicting signature compared to the library header. To avoid the conflict, the local extern declaration was removed, and the function call was preserved as is, assuming the correct function prototype is included by the library headers.\n\nBy removing the conflicting extern declarations and using literal constants, the code now compiles correctly without affecting the original logic. This maintains compatibility with the library and avoids macro redefinition issues."
}