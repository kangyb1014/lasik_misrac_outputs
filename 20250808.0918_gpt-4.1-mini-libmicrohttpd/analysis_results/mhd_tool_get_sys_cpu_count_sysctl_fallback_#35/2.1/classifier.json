{
  "user_message": "<misra_rule>\nMISRA C 2023 Rule 2.1 is: A project shall not contain unreachable code.\n\n</misra_rule>\n<response format>\nProvide your answer with these fields.\n- is_rule_violated: whether the rule is violated or not (true/false),\n- scenario: a specific violation scenario.\n- test_code: a modified mhd_tool_get_sys_cpu_count_sysctl_fallback_ code that contains useful probe functions that print useful logs to a file \"/tmp/logs/281.txt\". The logs should contain the control path and state information of the violation scenario. If the MISRA C rule is not violated, you can just return an empty string for the test code.\nHere are the constraints for the test code:\n- DO NOT introduce new violations to demonstrate your scenario.\n- The test code MUST be compilable and executable.\n- The test code MUST include line breaks.\n- The test code MUST preserve the original logic of mhd_tool_get_sys_cpu_count_sysctl_fallback_ as much as possible.\n- You MUST NOT define the main function.\n- You MUST NOT define macros.\n- The test code MUST not contain any mock functions.\n</response format>\n<target_code>\nHere is the code of mhd_tool_get_sys_cpu_count_sysctl_fallback_:\n```c\nstatic int\nmhd_tool_get_sys_cpu_count_sysctl_fallback_ (void)\n{\n  int ret = -1;\n  /* Do not use sysctl() function on GNU/Linux even if\n     sysctl() is available */\n#ifndef __linux__\n#ifdef HAVE_SYSCTLBYNAME\n  if (0 >= ret)\n  {\n    size_t value_size = sizeof (ret);\n    /* FreeBSD, OpenBSD, NetBSD, Darwin (and others?): The number of CPUs */\n    if ((0 != sysctlbyname (\"hw.ncpu\", &ret, &value_size,\n                            NULL, 0))\n        || (sizeof (ret) != value_size))\n      ret = -1;\n  }\n#endif /* HAVE_SYSCTLBYNAME */\n#if defined(HAVE_SYSCTL) && \\\n  defined(HAS_DECL_CTL_HW) && \\\n  defined(HAS_DECL_HW_NCPU)\n  if (0 >= ret)\n  {\n    /* FreeBSD, OpenBSD, NetBSD, Darwin (and others?): The number of CPUs */\n    int mib[2] = {CTL_HW, HW_NCPU};\n    size_t value_size = sizeof (ret);\n    if ((0 != sysctl (mib, 2, &ret, &value_size, NULL, 0))\n        || (sizeof (ret) != value_size))\n      ret = -1;\n  }\n#endif /* HAVE_SYSCTL && HAS_DECL_CTL_HW && HAS_DECL_HW_NCPU */\n#endif /* ! __linux__ */\n  if (0 >= ret)\n    return -1;\n  return ret;\n}\n```\n</target_code>\nJudge whether the above mhd_tool_get_sys_cpu_count_sysctl_fallback_ code violates the rule 2.1 or not.",
  "is_rule_violated": true,
  "scenario": "The provided function contains conditional compilation blocks that exclude the main CPU count retrieval logic when compiling on Linux systems via the #ifndef __linux__ preprocessor directive. When compiled for Linux, the entire CPU count detection code becomes unreachable, resulting in the variable 'ret' being initialized to -1 and eventually returning -1 without executing any intermediate logic. This conditional exclusion causes the code within the #ifndef __linux__ block to be unreachable in the Linux compilation scenario, violating MISRA C 2023 Rule 2.1, which forbids unreachable code in a project.",
  "test_code": "#include <stdio.h>\n#include <unistd.h>\n#include <sys/types.h>\n#include <sys/sysctl.h>\n\nstatic int\nmhd_tool_get_sys_cpu_count_sysctl_fallback_ (void)\n{\n  FILE *log_file = fopen(\"/tmp/logs/281.txt\", \"w\");\n  int ret = -1;\n\n  if (log_file != NULL)\n  {\n    fprintf(log_file, \"Initial ret = %d\\n\", ret);\n  }\n\n#ifndef __linux__\n#ifdef HAVE_SYSCTLBYNAME\n  if (0 >= ret)\n  {\n    size_t value_size = sizeof (ret);\n    if (log_file != NULL)\n    {\n      fprintf(log_file, \"Entering sysctlbyname path\\n\");\n    }\n    if ((0 != sysctlbyname (\"hw.ncpu\", &ret, &value_size, NULL, 0)) || (sizeof (ret) != value_size))\n    {\n      if (log_file != NULL)\n      {\n        fprintf(log_file, \"sysctlbyname failed, setting ret = -1\\n\");\n      }\n      ret = -1;\n    }\n    if (log_file != NULL)\n    {\n      fprintf(log_file, \"After sysctlbyname, ret = %d\\n\", ret);\n    }\n  }\n#endif /* HAVE_SYSCTLBYNAME */\n\n#if defined(HAVE_SYSCTL) && defined(HAS_DECL_CTL_HW) && defined(HAS_DECL_HW_NCPU)\n  if (0 >= ret)\n  {\n    if (log_file != NULL)\n    {\n      fprintf(log_file, \"Entering sysctl MIB path\\n\");\n    }\n    int mib[2] = {CTL_HW, HW_NCPU};\n    size_t value_size = sizeof (ret);\n    if ((0 != sysctl (mib, 2, &ret, &value_size, NULL, 0)) || (sizeof (ret) != value_size))\n    {\n      if (log_file != NULL)\n      {\n        fprintf(log_file, \"sysctl MIB call failed, setting ret = -1\\n\");\n      }\n      ret = -1;\n    }\n    if (log_file != NULL)\n    {\n      fprintf(log_file, \"After sysctl MIB, ret = %d\\n\", ret);\n    }\n  }\n#endif /* HAVE_SYSCTL && HAS_DECL_CTL_HW && HAS_DECL_HW_NCPU */\n\n#else\n  /* On Linux, this block is unreachable due to the #ifndef __linux__ */\n  if (log_file != NULL)\n  {\n    fprintf(log_file, \"Linux platform detected: unreachable sysctl code skipped\\n\");\n  }\n#endif /* ! __linux__ */\n\n  if (0 >= ret)\n  {\n    if (log_file != NULL)\n    {\n      fprintf(log_file, \"ret <= 0, returning -1\\n\");\n      fclose(log_file);\n    }\n    return -1;\n  }\n  if (log_file != NULL)\n  {\n    fprintf(log_file, \"Returning CPU count: %d\\n\", ret);\n    fclose(log_file);\n  }\n  return ret;\n}\n"
}