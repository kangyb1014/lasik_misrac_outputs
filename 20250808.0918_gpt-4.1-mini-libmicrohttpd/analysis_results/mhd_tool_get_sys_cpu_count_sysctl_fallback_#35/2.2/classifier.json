{
  "user_message": "<misra_rule>\nMISRA C 2023 Rule 2.2 is: A project shall not contain dead code.\nAny operation that is executed but whose removal would not affect program behaviour constitutes dead code. Notes:\n1. The behaviour of an embedded sytem is often determined not just by the nature of its actions, but also by the time at which they occur.\n2. unreachable code is not dead code, as it cannot be executed.\n3.Initialization is not the same as an assignment operation and is therfore not a candidate for dead code.\n</misra_rule>\n<response format>\nProvide your answer with these fields.\n- is_rule_violated: whether the rule is violated or not (true/false),\n- scenario: a specific violation scenario.\n- test_code: a modified mhd_tool_get_sys_cpu_count_sysctl_fallback_ code that contains useful probe functions that print useful logs to a file \"/tmp/logs/282.txt\". The logs should contain the control path and state information of the violation scenario. If the MISRA C rule is not violated, you can just return an empty string for the test code.\nHere are the constraints for the test code:\n- DO NOT introduce new violations to demonstrate your scenario.\n- The test code MUST be compilable and executable.\n- The test code MUST include line breaks.\n- The test code MUST preserve the original logic of mhd_tool_get_sys_cpu_count_sysctl_fallback_ as much as possible.\n- You MUST NOT define the main function.\n- You MUST NOT define macros.\n- The test code MUST not contain any mock functions.\n</response format>\n<target_code>\nHere is the code of mhd_tool_get_sys_cpu_count_sysctl_fallback_:\n```c\nstatic int\nmhd_tool_get_sys_cpu_count_sysctl_fallback_ (void)\n{\n  int ret = -1;\n  /* Do not use sysctl() function on GNU/Linux even if\n     sysctl() is available */\n#ifndef __linux__\n#ifdef HAVE_SYSCTLBYNAME\n  if (0 >= ret)\n  {\n    size_t value_size = sizeof (ret);\n    /* FreeBSD, OpenBSD, NetBSD, Darwin (and others?): The number of CPUs */\n    if ((0 != sysctlbyname (\"hw.ncpu\", &ret, &value_size,\n                            NULL, 0))\n        || (sizeof (ret) != value_size))\n      ret = -1;\n  }\n#endif /* HAVE_SYSCTLBYNAME */\n#if defined(HAVE_SYSCTL) && \\\n  defined(HAS_DECL_CTL_HW) && \\\n  defined(HAS_DECL_HW_NCPU)\n  if (0 >= ret)\n  {\n    /* FreeBSD, OpenBSD, NetBSD, Darwin (and others?): The number of CPUs */\n    int mib[2] = {CTL_HW, HW_NCPU};\n    size_t value_size = sizeof (ret);\n    if ((0 != sysctl (mib, 2, &ret, &value_size, NULL, 0))\n        || (sizeof (ret) != value_size))\n      ret = -1;\n  }\n#endif /* HAVE_SYSCTL && HAS_DECL_CTL_HW && HAS_DECL_HW_NCPU */\n#endif /* ! __linux__ */\n  if (0 >= ret)\n    return -1;\n  return ret;\n}\n```\n</target_code>\n<additional code>Here are the definitions of symbols that are close to the target function mhd_tool_get_sys_cpu_count_sysctl_fallback_:\nint\nmhd_tool_get_system_cpu_count (void)\n{\n  int res;\n\n  /* Try specialised APIs first */\n  res = mhd_tool_get_sys_cpu_count_special_api_ ();\n  if (0 < res)\n    return res;\n\n  /* Try sysctl*(). This is typically a direct interface to\n     kernel values. */\n  res = mhd_tool_get_sys_cpu_count_sysctl_ ();\n  if (0 < res)\n    return res;\n\n  /* Try sysconf() as the last resort as this is a generic interface\n     which can be implemented by parsing system files. */\n  res = mhd_tool_get_sys_cpu_count_sysconf_ ();\n#if ! defined(__linux__) && ! defined(__GLIBC__)\n  if (0 < res)\n    return res;\n#else  /* __linux__ || __GLIBC__ */\n  if (2 < res)\n    return res;\n  if (0 < res)\n  {\n    /* '1' or '2' could a be fallback number.\n     * See get_nprocs_fallback() in glibc\n       sysdeps/unix/sysv/linux/getsysstats.c */\n\n    int proc_cpu_count;\n\n    proc_cpu_count = mhd_tool_get_proc_cpu_count ();\n    if (proc_cpu_count == res)\n    {\n      /* The detected number of CPUs available for the process\n         is equal to the detected number of system CPUs.\n         Assume detected number is correct. */\n      return res;\n    }\n  }\n#endif /* __linux__ || __GLIBC__  */\n\n  /* Try available fallbacks */\n\n  res = mhd_tool_get_sys_cpu_count_sysctl_fallback_ ();\n  if (0 < res)\n    return res;\n\n  res = mhd_tool_get_sys_cpu_count_sysconf_fallback_ ();\n#if ! defined(__linux__) && ! defined(__GLIBC__)\n  if (0 < res)\n    return res;\n#else  /* __linux__ || __GLIBC__ */\n  if (2 < res)\n    return res;\n#endif /* __linux__ || __GLIBC__  */\n\n  return -1; /* Cannot detect */\n}\n</additional code>\nJudge whether the above mhd_tool_get_sys_cpu_count_sysctl_fallback_ code violates the rule 2.2 or not.",
  "is_rule_violated": true,
  "scenario": "The function mhd_tool_get_sys_cpu_count_sysctl_fallback_ contains a conditional block controlled by compile-time flags (such as __linux__, HAVE_SYSCTLBYNAME, HAVE_SYSCTL, HAS_DECL_CTL_HW, HAS_DECL_HW_NCPU). If the platform is Linux (__linux__ defined), the code inside the #ifndef __linux__ block is effectively not compiled or is dead code since it cannot be executed in that environment. This means parts of the code are never executed and removing them wouldn't change the runtime behavior on Linux. Although unreachable code is not considered dead code, code excluded by compile-time conditions that cannot be executed on a given platform can be considered dead code in that context. Therefore, if compiling for Linux, the code inside the excluded blocks is dead code because it is never used.",
  "test_code": "#include <stdio.h>\n#include <stddef.h>\n#include <sys/types.h>\n\n/* Simulate the sysctlbyname and sysctl functions for demonstration. */\n\n/* Let's assume that HAVE_SYSCTLBYNAME is defined, but __linux__ is also defined,\n   so the corresponding code block is not compiled and hence 'dead' on Linux. */\n\nstatic int\nmhd_tool_get_sys_cpu_count_sysctl_fallback_ (void)\n{\n  int ret = -1;\n  FILE *log_file = fopen(\"/tmp/logs/282.txt\", \"a\");\n  \n#ifndef __linux__\n#ifdef HAVE_SYSCTLBYNAME\n  if (0 >= ret)\n  {\n    size_t value_size = sizeof(ret);\n    if (log_file) fprintf(log_file, \"Entered sysctlbyname block with ret = %d\\n\", ret);\n    /* FreeBSD, OpenBSD, NetBSD, Darwin (and others?): The number of CPUs */\n    if ((0 != sysctlbyname(\"hw.ncpu\", &ret, &value_size, NULL, 0)) || (sizeof(ret) != value_size))\n    {\n      ret = -1;\n      if (log_file) fprintf(log_file, \"sysctlbyname failed, set ret to %d\\n\", ret);\n    }\n    else\n    {\n      if (log_file) fprintf(log_file, \"sysctlbyname succeeded, ret = %d\\n\", ret);\n    }\n  }\n#endif /* HAVE_SYSCTLBYNAME */\n\n#if defined(HAVE_SYSCTL) && defined(HAS_DECL_CTL_HW) && defined(HAS_DECL_HW_NCPU)\n  if (0 >= ret)\n  {\n    int mib[2] = {CTL_HW, HW_NCPU};\n    size_t value_size = sizeof(ret);\n    if (log_file) fprintf(log_file, \"Entered sysctl block with ret = %d\\n\", ret);\n    if ((0 != sysctl(mib, 2, &ret, &value_size, NULL, 0)) || (sizeof(ret) != value_size))\n    {\n      ret = -1;\n      if (log_file) fprintf(log_file, \"sysctl failed, set ret to %d\\n\", ret);\n    }\n    else\n    {\n      if (log_file) fprintf(log_file, \"sysctl succeeded, ret = %d\\n\", ret);\n    }\n  }\n#endif /* HAVE_SYSCTL && HAS_DECL_CTL_HW && HAS_DECL_HW_NCPU */\n#endif /* ! __linux__ */\n\n  if (0 >= ret)\n  {\n    if (log_file) fprintf(log_file, \"Returning -1 because ret = %d\\n\", ret);\n    if (log_file) fclose(log_file);\n    return -1;\n  }\n\n  if (log_file) fprintf(log_file, \"Returning ret = %d\\n\", ret);\n  if (log_file) fclose(log_file);\n  return ret;\n}\n\n/* Note: On Linux platforms where __linux__ is defined, the bulk of this function is excluded from compilation,\n   producing dead code that never executes, thereby violating MISRA C 2023 Rule 2.2. */"
}