{
  "user_message": "An agent A claimed that the following ws_receive_frame code violates the MISRA C 2023 rule 14.2.\n<misra_rule>\nMISRA C 2023 Rule 14.2 is A for loop shall be well-formed.\nThe three clauses of a for statement are the:\n1. First clause shall be empty or an expression whose set the value of the loop counter or define and intialize the loop counter.\n2. Second clause shall be an expression that has no persistent side effects, and shall use the loop count and optionally loop flags, and shall not use any other object that is modified in the for loop body.\n3.Third clause shall be an expression whose modify only the value of the loop counter, and shall not use objects that are modified in the for loop body.\n4. There shall only be one loop counter in a for loop, which shall not be modified in for loop body. A loop control flag is defined as single identifier denoting an object with essentially Boolean type that is used in the second clause. The behaviour of a for loop body includes the behaviour of any functions called within that statement..\n</misra_rule>\n<target_code>\nHere is the original code of ws_receive_frame.\n```c\nstatic unsigned char *\nws_receive_frame (unsigned char *frame, ssize_t *length, int *type)\n{\n  unsigned char masks[4];\n  unsigned char mask;\n  unsigned char *msg;\n  unsigned char flength;\n  unsigned char idx_first_mask;\n  unsigned char idx_first_data;\n  size_t data_length;\n  int i;\n  int j;\n\n  msg = NULL;\n  if (frame[0] == (WS_FIN | WS_OPCODE_TEXT_FRAME))\n  {\n    *type = WS_OPCODE_TEXT_FRAME;\n    idx_first_mask = 2;\n    mask = frame[1];\n    flength = mask & 0x7F;\n    if (flength == 126)\n    {\n      idx_first_mask = 4;\n    }\n    else if (flength == 127)\n    {\n      idx_first_mask = 10;\n    }\n    idx_first_data = (unsigned char) (idx_first_mask + 4);\n    data_length = (size_t) *length - idx_first_data;\n    masks[0] = frame[idx_first_mask + 0];\n    masks[1] = frame[idx_first_mask + 1];\n    masks[2] = frame[idx_first_mask + 2];\n    masks[3] = frame[idx_first_mask + 3];\n    msg = malloc (data_length + 1);\n    if (NULL != msg)\n    {\n      for (i = idx_first_data, j = 0; i < *length; i++, j++)\n      {\n        msg[j] = frame[i] ^ masks[j % 4];\n      }\n      *length = (ssize_t) data_length;\n      msg[j] = '\\0';\n    }\n  }\n  else if (frame[0] == (WS_FIN | WS_OPCODE_CON_CLOSE_FRAME))\n  {\n    *type = WS_OPCODE_CON_CLOSE_FRAME;\n  }\n  else\n  {\n    *type = frame[0] & 0x0F;\n  }\n  return msg;\n}\n```\n</target_code>\n<scenario>\nThe agent A provided the following violation scenario:The for loop in ws_receive_frame initializes and modifies two loop counters (i and j), violating the requirement that only one loop counter should be used in the for loop (Rule 14.2, clause 4).\n</scenario>\n<test_code>\nAlso, the agent A provided the following modified code that prints out the log to support their scenario:\n```c\n\nstatic unsigned char *\nws_receive_frame (unsigned char *frame, ssize_t *length, int *type)\n{\n  unsigned char masks[4];\n  unsigned char mask;\n  unsigned char *msg;\n  unsigned char flength;\n  unsigned int idx_first_mask;\n  unsigned int idx_first_data;\n  size_t data_length;\n  int i;\n  int j;\n\n  int fd = open(\"/tmp/logs/28.txt\", O_WRONLY | O_CREAT | O_APPEND, 0644);\n  if (fd < 0) return NULL;\n\n  msg = NULL;\n  if ((frame[0] & 0xFF) == (WS_FIN | WS_OPCODE_TEXT_FRAME))\n  {\n    dprintf(fd, \"Entering text frame processing\\n\");\n    *type = WS_OPCODE_TEXT_FRAME;\n    idx_first_mask = 2;\n    mask = frame[1];\n    flength = mask & 0x7F;\n    if (flength == 126)\n    {\n      dprintf(fd, \"flength == 126\\n\");\n      idx_first_mask = 4;\n    }\n    else if (flength == 127)\n    {\n      dprintf(fd, \"flength == 127\\n\");\n      idx_first_mask = 10;\n    }\n    idx_first_data = idx_first_mask + 4;\n    data_length = (size_t)*length - idx_first_data;\n    dprintf(fd, \"idx_first_mask=%u, idx_first_data=%u, data_length=%zu\\n\", idx_first_mask, idx_first_data, data_length);\n    masks[0] = frame[idx_first_mask + 0];\n    masks[1] = frame[idx_first_mask + 1];\n    masks[2] = frame[idx_first_mask + 2];\n    masks[3] = frame[idx_first_mask + 3];\n    msg = malloc(data_length + 1);\n    if (msg != NULL)\n    {\n      dprintf(fd, \"Allocated msg buffer, starting for loop\\n\");\n      for (i = (int)idx_first_data, j = 0; i < *length; i++, j++)\n      {\n        msg[j] = frame[i] ^ masks[j % 4];\n        dprintf(fd, \"i=%d, j=%d, frame[i]=0x%02X, masks[j%%4]=0x%02X, msg[j]=0x%02X\\n\", i, j, frame[i], masks[j % 4], msg[j]);\n      }\n      *length = (ssize_t)data_length;\n      msg[j] = '\\0';\n      dprintf(fd, \"Finished for loop, msg[%d] null terminated\\n\", j);\n    }\n    else\n    {\n      dprintf(fd, \"malloc failed for msg buffer\\n\");\n    }\n  }\n  else if ((frame[0] & 0xFF) == (WS_FIN | WS_OPCODE_CON_CLOSE_FRAME))\n  {\n    dprintf(fd, \"Received close frame\\n\");\n    *type = WS_OPCODE_CON_CLOSE_FRAME;\n  }\n  else\n  {\n    dprintf(fd, \"Other frame type: 0x%02X\\n\", frame[0] & 0x0F);\n    *type = frame[0] & 0x0F;\n  }\n  close(fd);\n  return msg;\n}\n\n```\nThe test code failed to compile, so we could not obtain any output.\n\n</test_code>\n<response format>\nProvide your answer with these fields.\n- explanation: your evaluation of the scenario provided by the agent A.\n- is_report_correct: whether the report is correct or not (true/false)\n</response format>\n<instruction>   \nJudge whether the report is correct or not.\n</instruction>\n",
  "is_report_correct": true,
  "explanation": "MISRA C 2023 Rule 14.2 mandates that a for loop shall be well-formed and specifically states that there shall be only one loop counter in a for loop, which shall not be modified in the body of the loop. In the given ws_receive_frame code, the for loop header initializes and modifies two loop variables: 'i' and 'j'. Both are incremented in the loop continuation expression. This means there are effectively two loop counters controlling the loop. According to the rule, this usage violates the requirement that only one loop counter should be present and managed exclusively by the for loop clauses without modification in the loop body or usage of more than one counter. Hence, agent A's claim that the for loop violates MISRA C 2023 Rule 14.2 clause 4 by having two loop counters is correct. The additional provided test code showing logging does not affect the analysis of the loop structure itself."
}