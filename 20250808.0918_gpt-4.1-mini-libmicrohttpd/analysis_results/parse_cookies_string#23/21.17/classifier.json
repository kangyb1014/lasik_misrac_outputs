{
  "user_message": "<misra_rule>\nMISRA C 2023 Rule 21.17 is: Use of the string handling functions from <string.h> shall not result in accesses beyond the bounds of the objects referenced by their pointer parameters.\nThis rule strictly applies to the Standard Library functions in <string.h> such as memcpy, memmove, memset, memcmp, strcpy, strncpy, strcat, strncat, strlen, and strspn.\n</misra_rule>\n<response format>\nProvide your answer with these fields.\n- is_rule_violated: whether the rule is violated or not (true/false),\n- scenario: a specific violation scenario.\n- test_code: a modified parse_cookies_string code that contains useful probe functions that print useful logs to a file \"/tmp/logs/191.txt\". The logs should contain the control path and state information of the violation scenario. If the MISRA C rule is not violated, you can just return an empty string for the test code.\nHere are the constraints for the test code:\n- DO NOT introduce new violations to demonstrate your scenario.\n- The test code MUST be compilable and executable.\n- The test code MUST include line breaks.\n- The test code MUST preserve the original logic of parse_cookies_string as much as possible.\n- You MUST NOT define the main function.\n- You MUST NOT define macros.\n- The test code MUST not contain any mock functions.\n</response format>\n<target_code>\nHere is the code of parse_cookies_string:\n```c\nstatic enum _MHD_ParseCookie\nparse_cookies_string (char *str,\n                      const size_t str_len,\n                      struct MHD_Connection *connection)\n{\n  size_t i;\n  bool non_strict;\n  /* Skip extra whitespaces and empty cookies */\n  const bool allow_wsp_empty = (0 >= connection->daemon->client_discipline);\n  /* Allow whitespaces around '=' character */\n  const bool wsp_around_eq = (-3 >= connection->daemon->client_discipline);\n  /* Allow whitespaces in quoted cookie value */\n  const bool wsp_in_quoted = (-2 >= connection->daemon->client_discipline);\n  /* Allow tab as space after semicolon between cookies */\n  const bool tab_as_sp = (0 >= connection->daemon->client_discipline);\n  /* Allow no space after semicolon between cookies */\n  const bool allow_no_space = (0 >= connection->daemon->client_discipline);\n\n  non_strict = false;\n  i = 0;\n  while (i < str_len)\n  {\n    size_t name_start;\n    size_t name_len;\n    size_t value_start;\n    size_t value_len;\n    bool val_quoted;\n    /* Skip any whitespaces and empty cookies */\n    while (' ' == str[i] || '\\t' == str[i] || ';' == str[i])\n    {\n      if (! allow_wsp_empty)\n        return MHD_PARSE_COOKIE_MALFORMED;\n      non_strict = true;\n      i++;\n      if (i == str_len)\n        return non_strict? MHD_PARSE_COOKIE_OK_LAX : MHD_PARSE_COOKIE_OK;\n    }\n    /* 'i' must point to the first char of cookie-name */\n    name_start = i;\n    /* Find the end of the cookie-name */\n    do\n    {\n      const char l = str[i];\n      if (('=' == l) || (' ' == l) || ('\\t' == l) || ('\"' == l) || (',' == l) ||\n          (';' == l) || (0 == l))\n        break;\n    } while (str_len > ++i);\n    name_len = i - name_start;\n    /* Skip any whitespaces */\n    while (str_len > i && (' ' == str[i] || '\\t' == str[i]))\n    {\n      if (! wsp_around_eq)\n        return MHD_PARSE_COOKIE_MALFORMED;\n      non_strict = true;\n      i++;\n    }\n    if ((str_len == i) || ('=' != str[i]) || (0 == name_len))\n      return MHD_PARSE_COOKIE_MALFORMED; /* Incomplete cookie name */\n    /* 'i' must point to the '=' char */\n    mhd_assert ('=' == str[i]);\n    i++;\n    /* Skip any whitespaces */\n    while (str_len > i && (' ' == str[i] || '\\t' == str[i]))\n    {\n      if (! wsp_around_eq)\n        return MHD_PARSE_COOKIE_MALFORMED;\n      non_strict = true;\n      i++;\n    }\n    /* 'i' must point to the first char of cookie-value */\n    if (str_len == i)\n    {\n      value_start = 0;\n      value_len = 0;\n#ifdef _DEBUG\n      val_quoted = false; /* This assignment used in assert */\n#endif\n    }\n    else\n    {\n      bool valid_cookie;\n      val_quoted = ('\"' == str[i]);\n      if (val_quoted)\n        i++;\n      value_start = i;\n      /* Find the end of the cookie-value */\n      while (str_len > i)\n      {\n        const char l = str[i];\n        if ((';' == l) || ('\"' == l) || (',' == l) || (';' == l) ||\n            ('\\\\' == l) || (0 == l))\n          break;\n        if ((' ' == l) || ('\\t' == l))\n        {\n          if (! val_quoted)\n            break;\n          if (! wsp_in_quoted)\n            return MHD_PARSE_COOKIE_MALFORMED;\n          non_strict = true;\n        }\n        i++;\n      }\n      value_len = i - value_start;\n      if (val_quoted)\n      {\n        if ((str_len == i) || ('\"' != str[i]))\n          return MHD_PARSE_COOKIE_MALFORMED; /* Incomplete cookie value, no closing quote */\n        i++;\n      }\n      /* Skip any whitespaces */\n      if ((str_len > i) && ((' ' == str[i]) || ('\\t' == str[i])))\n      {\n        do\n        {\n          i++;\n        } while (str_len > i && (' ' == str[i] || '\\t' == str[i]));\n        /* Whitespace at the end? */\n        if (str_len > i)\n        {\n          if (! allow_wsp_empty)\n            return MHD_PARSE_COOKIE_MALFORMED;\n          non_strict = true;\n        }\n      }\n      if (str_len == i)\n        valid_cookie = true;\n      else if (';' == str[i])\n        valid_cookie = true;\n      else\n        valid_cookie = false;\n\n      if (! valid_cookie)\n        return MHD_PARSE_COOKIE_MALFORMED; /* Garbage at the end of the cookie value */\n    }\n    mhd_assert (0 != name_len);\n    str[name_start + name_len] = 0; /* Zero-terminate the name */\n    if (0 != value_len)\n    {\n      mhd_assert (value_start + value_len <= str_len);\n      str[value_start + value_len] = 0; /* Zero-terminate the value */\n      if (MHD_NO ==\n          MHD_set_connection_value_n_nocheck_ (connection,\n                                               MHD_COOKIE_KIND,\n                                               str + name_start,\n                                               name_len,\n                                               str + value_start,\n                                               value_len))\n        return MHD_PARSE_COOKIE_NO_MEMORY;\n    }\n    else\n    {\n      if (MHD_NO ==\n          MHD_set_connection_value_n_nocheck_ (connection,\n                                               MHD_COOKIE_KIND,\n                                               str + name_start,\n                                               name_len,\n                                               \"\",\n                                               0))\n        return MHD_PARSE_COOKIE_NO_MEMORY;\n    }\n    if (str_len > i)\n    {\n      mhd_assert (0 == str[i] || ';' == str[i]);\n      mhd_assert (! val_quoted || ';' == str[i]);\n      mhd_assert (';' != str[i] || val_quoted || non_strict || 0 == value_len);\n      i++;\n      if (str_len == i)\n      { /* No next cookie after semicolon */\n        if (! allow_wsp_empty)\n          return MHD_PARSE_COOKIE_MALFORMED;\n        non_strict = true;\n      }\n      else if (' ' != str[i])\n      {/* No space after semicolon */\n        if (('\\t' == str[i]) && tab_as_sp)\n          i++;\n        else if (! allow_no_space)\n          return MHD_PARSE_COOKIE_MALFORMED;\n        non_strict = true;\n      }\n      else\n      {\n        i++;\n        if (str_len == i)\n        {\n          if (! allow_wsp_empty)\n            return MHD_PARSE_COOKIE_MALFORMED;\n          non_strict = true;\n        }\n      }\n    }\n  }\n  return non_strict? MHD_PARSE_COOKIE_OK_LAX : MHD_PARSE_COOKIE_OK;\n}\n```\n</target_code>\n<additional code>Here are the definitions of symbols that are close to the target function parse_cookies_string:\nstatic enum MHD_Result\nMHD_set_connection_value_n_nocheck_ (struct MHD_Connection *connection,\n                                     enum MHD_ValueKind kind,\n                                     const char *key,\n                                     size_t key_size,\n                                     const char *value,\n                                     size_t value_size)\n{\n  struct MHD_HTTP_Req_Header *pos;\n\n  pos = MHD_connection_alloc_memory_ (connection,\n                                      sizeof (struct MHD_HTTP_Res_Header));\n  if (NULL == pos)\n    return MHD_NO;\n  pos->header = key;\n  pos->header_size = key_size;\n  pos->value = value;\n  pos->value_size = value_size;\n  pos->kind = kind;\n  pos->next = NULL;\n  /* append 'pos' to the linked list of headers */\n  if (NULL == connection->rq.headers_received_tail)\n  {\n    connection->rq.headers_received = pos;\n    connection->rq.headers_received_tail = pos;\n  }\n  else\n  {\n    connection->rq.headers_received_tail->next = pos;\n    connection->rq.headers_received_tail = pos;\n  }\n  return MHD_YES;\n}\n...\n#define mhd_assert(ignore) ((void)0)\n</additional code>\nJudge whether the above parse_cookies_string code violates the rule 21.17 or not.",
  "is_rule_violated": true,
  "scenario": "A violation scenario occurs if the function writes zero termination characters beyond the buffer pointed to by 'str'. Specifically, the statements 'str[name_start + name_len] = 0;' and 'str[value_start + value_len] = 0;' both write within bounds only if 'name_start + name_len < str_len' and 'value_start + value_len < str_len', respectively. However, there is no explicit check for these conditions before writing the zero termination, so if 'name_start + name_len == str_len' or 'value_start + value_len == str_len', it will write beyond the buffer, violating rule 21.17.",
  "test_code": "#include <stdio.h>\n#include <stddef.h>\n#include <stdbool.h>\n\nstatic enum _MHD_ParseCookie\nparse_cookies_string (char *str,\n                      const size_t str_len,\n                      struct MHD_Connection *connection)\n{\n  FILE *log = fopen(\"/tmp/logs/191.txt\", \"w\");\n  size_t i;\n  bool non_strict;\n  /* Skip extra whitespaces and empty cookies */\n  const bool allow_wsp_empty = (0 >= connection->daemon->client_discipline);\n  /* Allow whitespaces around '=' character */\n  const bool wsp_around_eq = (-3 >= connection->daemon->client_discipline);\n  /* Allow whitespaces in quoted cookie value */\n  const bool wsp_in_quoted = (-2 >= connection->daemon->client_discipline);\n  /* Allow tab as space after semicolon between cookies */\n  const bool tab_as_sp = (0 >= connection->daemon->client_discipline);\n  /* Allow no space after semicolon between cookies */\n  const bool allow_no_space = (0 >= connection->daemon->client_discipline);\n\n  non_strict = false;\n  i = 0;\n  fprintf(log, \"Start parsing cookies, str_len=%zu\\n\", str_len);\n  while (i < str_len)\n  {\n    size_t name_start;\n    size_t name_len;\n    size_t value_start;\n    size_t value_len;\n    bool val_quoted;\n    /* Skip any whitespaces and empty cookies */\n    while (' ' == str[i] || '\\t' == str[i] || ';' == str[i])\n    {\n      fprintf(log, \"Skipping whitespace/semicolon at i=%zu char='%c'\\n\", i, str[i]);\n      if (! allow_wsp_empty) {\n        fprintf(log, \"Rule violation: no whitespace allowed here\\n\");\n        fclose(log);\n        return MHD_PARSE_COOKIE_MALFORMED;\n      }\n      non_strict = true;\n      i++;\n      if (i == str_len) {\n        fprintf(log, \"End of string reached after skipping, returning OK_LAX=%d\\n\", non_strict? MHD_PARSE_COOKIE_OK_LAX : MHD_PARSE_COOKIE_OK);\n        fclose(log);\n        return non_strict? MHD_PARSE_COOKIE_OK_LAX : MHD_PARSE_COOKIE_OK;\n      }\n    }\n    name_start = i;\n    fprintf(log, \"Found cookie name start at i=%zu\\n\", i);\n    do\n    {\n      const char l = str[i];\n      if (('=' == l) || (' ' == l) || ('\\t' == l) || ('\"' == l) || (',' == l) ||\n          (';' == l) || (0 == l))\n        break;\n    } while (str_len > ++i);\n    name_len = i - name_start;\n    fprintf(log, \"Cookie name length=%zu\\n\", name_len);\n    while (str_len > i && (' ' == str[i] || '\\t' == str[i]))\n    {\n      fprintf(log, \"Skipping whitespace after cookie name at i=%zu\\n\", i);\n      if (! wsp_around_eq) {\n        fprintf(log, \"Space around '=' not allowed, malformed\\n\");\n        fclose(log);\n        return MHD_PARSE_COOKIE_MALFORMED;\n      }\n      non_strict = true;\n      i++;\n    }\n    if ((str_len == i) || ('=' != str[i]) || (0 == name_len)) {\n      fprintf(log, \"Malformed cookie name or '=' missing at i=%zu\\n\", i);\n      fclose(log);\n      return MHD_PARSE_COOKIE_MALFORMED; /* Incomplete cookie name */\n    }\n    i++; /* skip '=' */\n    while (str_len > i && (' ' == str[i] || '\\t' == str[i]))\n    {\n      fprintf(log, \"Skipping whitespace after '=' at i=%zu\\n\", i);\n      if (! wsp_around_eq) {\n        fprintf(log, \"Space around '=' not allowed, malformed\\n\");\n        fclose(log);\n        return MHD_PARSE_COOKIE_MALFORMED;\n      }\n      non_strict = true;\n      i++;\n    }\n    if (str_len == i) {\n      value_start = 0;\n      value_len = 0;\n      val_quoted = false;\n    } else {\n      val_quoted = ('\"' == str[i]);\n      if (val_quoted) {\n        i++;\n        fprintf(log, \"Quoted cookie value detected at i=%zu\\n\", i);\n      }\n      value_start = i;\n      while (str_len > i)\n      {\n        const char l = str[i];\n        if ((';' == l) || ('\"' == l) || (',' == l) || (';' == l) || ('\\' == l) || (0 == l))\n          break;\n        if ((' ' == l) || ('\\t' == l))\n        {\n          if (! val_quoted)\n            break;\n          if (! wsp_in_quoted)\n          {\n            fprintf(log, \"Malformed: whitespace in quoted value not allowed at i=%zu\\n\", i);\n            fclose(log);\n            return MHD_PARSE_COOKIE_MALFORMED;\n          }\n          non_strict = true;\n        }\n        i++;\n      }\n      value_len = i - value_start;\n      fprintf(log, \"Cookie value length=%zu, val_quoted=%d, i=%zu\\n\", value_len, val_quoted, i);\n      if (val_quoted)\n      {\n        if ((str_len == i) || ('\"' != str[i])) {\n          fprintf(log, \"Malformed: quoted value not closed properly at i=%zu\\n\", i);\n          fclose(log);\n          return MHD_PARSE_COOKIE_MALFORMED; /* Incomplete cookie value, no closing quote */\n        }\n        i++;\n      }\n      if (name_start + name_len >= str_len) {\n        fprintf(log, \"Violation: writing zero terminator beyond str buffer for name at pos %zu\\n\", name_start + name_len);\n      }\n      str[name_start + name_len] = 0; /* Zero-terminate the name */\n      if (0 != value_len)\n      {\n        if (value_start + value_len >= str_len) {\n          fprintf(log, \"Violation: writing zero terminator beyond str buffer for value at pos %zu\\n\", value_start + value_len);\n        }\n        str[value_start + value_len] = 0; /* Zero-terminate the value */\n        if (MHD_NO ==\n            MHD_set_connection_value_n_nocheck_ (connection,\n                                                 MHD_COOKIE_KIND,\n                                                 str + name_start,\n                                                 name_len,\n                                                 str + value_start,\n                                                 value_len))\n        {\n          fprintf(log, \"Memory allocation failed for cookie value\\n\");\n          fclose(log);\n          return MHD_PARSE_COOKIE_NO_MEMORY;\n        }\n      }\n      else\n      {\n        if (MHD_NO ==\n            MHD_set_connection_value_n_nocheck_ (connection,\n                                                 MHD_COOKIE_KIND,\n                                                 str + name_start,\n                                                 name_len,\n                                                 \"\",\n                                                 0))\n        {\n          fprintf(log, \"Memory allocation failed for empty cookie value\\n\");\n          fclose(log);\n          return MHD_PARSE_COOKIE_NO_MEMORY;\n        }\n      }\n      if (str_len > i)\n      {\n        i++;\n      }\n    }\n  }\n  fclose(log);\n  return non_strict? MHD_PARSE_COOKIE_OK_LAX : MHD_PARSE_COOKIE_OK;\n}\n"
}