{
  "user_message": "<target code>Here is the code that failed to compile:\n```c\n\nstatic enum MHD_Result\npost_process_urlencoded (struct MHD_PostProcessor *pp,\n                         const char *post_data,\n                         size_t post_data_len)\n{\n  FILE *log_file = fopen(\"/tmp/logs/96.txt\", \"a\");\n  char *kbuf = (char *) &pp[1];\n  size_t poff;\n  const char *start_key = NULL;\n  const char *end_key = NULL;\n  const char *start_value = NULL;\n  const char *end_value = NULL;\n  const char *last_escape = NULL;\n\n  if (log_file)\n    fprintf(log_file, \"post_process_urlencoded start: initial state=%d\\n\", pp->state);\n\n  mhd_assert (PP_Callback != pp->state);\n\n  poff = 0;\n  while ( ( (poff < post_data_len) ||\n            (pp->state == PP_Callback) ) &&\n          (pp->state != PP_Error) )\n  {\n    if (log_file)\n      fprintf(log_file, \"loop state=%d, poff=%u\\n\", pp->state, (unsigned)poff);\n    switch (pp->state)\n    {\n    case PP_Error:\n      /* clearly impossible as per while loop invariant */\n      if (log_file)\n        fprintf(log_file, \"PP_Error reached - abort called\\n\");\n      abort ();\n      break; /* Unreachable */\n    case PP_Init:\n      if (log_file)\n        fprintf(log_file, \"PP_Init phase detected\\n\");\n      mhd_assert (NULL == start_key);\n      mhd_assert (NULL == end_key);\n      mhd_assert (NULL == start_value);\n      mhd_assert (NULL == end_value);\n      switch (post_data[poff])\n      {\n      case '=':\n        pp->state = PP_Error;\n        if (log_file)\n          fprintf(log_file, \"Error: '=' found with no key at poff=%u\\n\", (unsigned)poff);\n        continue;\n      case '&':\n        poff++;\n        if (log_file)\n          fprintf(log_file, \"Empty key without value, poff incremented to %u\\n\", (unsigned)poff);\n        continue;\n      case '\\n':\n      case '\\r':\n        pp->state = PP_Done;\n        poff++;\n        if (log_file)\n          fprintf(log_file, \"End of data detected at poff=%u\\n\", (unsigned)poff);\n        break;\n      default:\n        pp->state = PP_ProcessKey;\n        start_key = &post_data[poff];\n        pp->must_ikvi = true;\n        poff++;\n        if (log_file)\n          fprintf(log_file, \"Start key processing at poff=%u\\n\", (unsigned)poff);\n        continue;\n      }\n      break; /* end PP_Init */\n    case PP_ProcessKey:\n      if (log_file)\n        fprintf(log_file, \"PP_ProcessKey state\\n\");\n      mhd_assert (NULL == start_value);\n      mhd_assert (NULL == end_value);\n      mhd_assert (NULL != start_key || 0 == poff);\n      mhd_assert (0 != poff || NULL == start_key);\n      mhd_assert (NULL == end_key);\n      switch (post_data[poff])\n      {\n      case '=':\n        if (0 != poff)\n          end_key = &post_data[poff];\n        poff++;\n        pp->state = PP_ProcessValue;\n        break;\n      case '&':\n        if (0 != poff)\n          end_key = &post_data[poff];\n        poff++;\n        pp->state = PP_Callback;\n        break;\n      case '\\n':\n      case '\\r':\n        if (0 != poff)\n          end_key = &post_data[poff];\n        pp->state = PP_Callback;\n        break;\n      default:\n        if (0 == poff)\n          start_key = post_data;\n        poff++;\n        break;\n      }\n      mhd_assert (NULL == end_key || NULL != start_key);\n      break; /* end PP_ProcessKey */\n    case PP_ProcessValue:\n      if (NULL == start_value)\n        start_value = &post_data[poff];\n      switch (post_data[poff])\n      {\n      case '=':\n        pp->state = PP_Error;\n        continue;\n      case '&':\n        end_value = &post_data[poff];\n        poff++;\n        if (pp->must_ikvi ||\n            (start_value != end_value) )\n        {\n          pp->state = PP_Callback;\n        }\n        else\n        {\n          pp->buffer_pos = 0;\n          pp->value_offset = 0;\n          pp->state = PP_Init;\n          start_value = NULL;\n          end_value = NULL;\n        }\n        continue;\n      case '\\n':\n      case '\\r':\n        end_value = &post_data[poff];\n        if (pp->must_ikvi ||\n            (start_value != end_value) )\n          pp->state = PP_Callback;\n        else\n        {\n          poff++;\n          pp->state = PP_Done;\n        }\n        break;\n      case '%':\n        last_escape = &post_data[poff];\n        poff++;\n        break;\n      case '0':\n      case '1':\n      case '2':\n      case '3':\n      case '4':\n      case '5':\n      case '6':\n      case '7':\n      case '8':\n      case '9':\n        poff++;\n        continue;\n      default:\n        last_escape = NULL;\n        poff++;\n        continue;\n      }\n      break; /* end PP_ProcessValue */\n    case PP_Done:\n      switch (post_data[poff])\n      {\n      case '\\n':\n      case '\\r':\n        poff++;\n        continue;\n      }\n      pp->state = PP_Error;\n      break;\n    case PP_Callback:\n      if (log_file)\n        fprintf(log_file, \"PP_Callback with key processing\\n\");\n      mhd_assert ((NULL != end_key) || (NULL == start_key));\n      if (1)\n      {\n        const size_t key_len = (size_t) (end_key - start_key);\n        mhd_assert (end_key >= start_key);\n        if (0 != key_len)\n        {\n          if ( (pp->buffer_pos + key_len >= pp->buffer_size) ||\n               (pp->buffer_pos + key_len < pp->buffer_pos) )\n          {\n            pp->state = PP_Error;\n            continue;\n          }\n          memcpy (&kbuf[pp->buffer_pos],\n                  start_key,\n                  key_len);\n          pp->buffer_pos += key_len;\n          start_key = NULL;\n          end_key = NULL;\n          pp->must_unescape_key = true;\n        }\n      }\n      if (pp->must_unescape_key)\n      {\n        kbuf[pp->buffer_pos] = '\\0'; /* 0-terminate key */\n        MHD_unescape_plus (kbuf);\n        MHD_http_unescape (kbuf);\n        pp->must_unescape_key = false;\n      }\n      process_value (pp,\n                     start_value,\n                     end_value,\n                     NULL);\n      if (PP_Error == pp->state)\n        continue;\n      pp->value_offset = 0;\n      start_value = NULL;\n      end_value = NULL;\n      pp->buffer_pos = 0;\n      pp->state = PP_Init;\n      break;\n    default:\n      if (log_file)\n        fprintf(log_file, \"Internal error: unexpected state %d\\n\", pp->state);\n      MHD_PANIC (_ (\"internal error.\\n\"));\n    }\n    mhd_assert ((end_key == NULL) || (start_key != NULL));\n    mhd_assert ((end_value == NULL) || (start_value != NULL));\n  }\n\n  mhd_assert (PP_Callback != pp->state);\n\n  if (PP_Error == pp->state)\n  {\n    if (log_file)\n      fprintf(log_file, \"Function end with PP_Error state\\n\");\n    if (log_file)\n      fclose(log_file);\n    return MHD_NO;\n  }\n\n  if (NULL != start_key)\n  {\n    size_t key_len;\n    if (log_file)\n      fprintf(log_file, \"Saving remaining start_key state at end\\n\");\n    mhd_assert ((PP_ProcessKey == pp->state) || (NULL != end_key));\n    if (NULL == end_key)\n      end_key = &post_data[poff];\n    mhd_assert (end_key >= start_key);\n    key_len = (size_t) (end_key - start_key);\n    mhd_assert (0 != key_len);\n    if (pp->buffer_pos + key_len >= pp->buffer_size)\n    {\n      pp->state = PP_Error;\n      if (log_file)\n        fclose(log_file);\n      return MHD_NO;\n    }\n    memcpy (&kbuf[pp->buffer_pos],\n            start_key,\n            key_len);\n    pp->buffer_pos += key_len;\n    pp->must_unescape_key = true;\n    start_key = NULL;\n    end_key = NULL;\n  }\n  if ( (NULL != start_value) &&\n       (PP_ProcessValue == pp->state) )\n  {\n    if (log_file)\n      fprintf(log_file, \"Processing remaining value at function end\\n\");\n    if (pp->must_unescape_key)\n    {\n      kbuf[pp->buffer_pos] = '\\0';\n      MHD_unescape_plus (kbuf);\n      MHD_http_unescape (kbuf);\n      pp->must_unescape_key = false;\n    }\n    if (NULL == end_value)\n      end_value = &post_data[poff];\n    if ( (NULL != last_escape) &&\n         (2 < (end_value - last_escape)) )\n      last_escape = NULL;\n    process_value (pp,\n                   start_value,\n                   end_value,\n                   last_escape);\n    pp->must_ikvi = false;\n  }\n  if (PP_Error == pp->state)\n  {\n    if (log_file)\n      fprintf(log_file, \"Function end with PP_Error state at final check\\n\");\n    if (log_file)\n      fclose(log_file);\n    return MHD_NO;\n  }\n\n  if (log_file)\n    fprintf(log_file, \"post_process_urlencoded completed successfully\\n\");\n  if (log_file)\n    fclose(log_file);\n\n  return MHD_YES;\n}\n\n```\n</target code>\n<build error>\nThe build failed with the following error:\n```\n/tmp/tmp4d03auz4/src/build-aux/missing: line 81: makeinfo: command not found\nWARNING: 'makeinfo' is missing on your system.\n         You should only need it if you modified a '.texi' file, or\n         any other file indirectly affecting the aspect of the manual.\n         You might want to install the Texinfo package:\n         <https://www.gnu.org/software/texinfo/>\n         The spurious makeinfo call might also be the consequence of\n         using a buggy 'make' (AIX, DU, IRIX), in which case you might\n         want to install GNU make:\n         <https://www.gnu.org/software/make/>\nmake[3]: *** [Makefile:543: libmicrohttpd.info] Error 127\nmake[2]: *** [Makefile:764: all-recursive] Error 1\nmake[1]: *** [Makefile:788: all-recursive] Error 1\nmake: *** [Makefile:693: all] Error 2\n```\n</build error>\n<response format>\nProvide your answer with these answers.\n- fixed_test_code: the fixed test code that compiles successfully.\n- explanation: a brief explanation of the changes you made to fix the code.\nHere are the constraints for the test code:\n- The test code MUST be compilable and executable.\n- The test code MUST include line breaks.\n- The test code MUST preserve the original logic of post_process_urlencoded as much as possible.\n- You MUST not define the main function.\n- You MUST not define macros.\n- The test code MUST not contain any mock functions.\n</response format>\n<instruction>\nPlease fix the code so that it compiles successfully.\n</instruction>\n",
  "fixed_test_code": "static enum MHD_Result\npost_process_urlencoded (struct MHD_PostProcessor *pp,\n                         const char *post_data,\n                         size_t post_data_len)\n{\n  FILE *log_file = fopen(\"/tmp/logs/96.txt\", \"a\");\n  char *kbuf = (char *) &pp[1];\n  size_t poff;\n  const char *start_key = NULL;\n  const char *end_key = NULL;\n  const char *start_value = NULL;\n  const char *end_value = NULL;\n  const char *last_escape = NULL;\n\n  if (log_file)\n    fprintf(log_file, \"post_process_urlencoded start: initial state=%d\\n\", (int)pp->state);\n\n  mhd_assert (PP_Callback != pp->state);\n\n  poff = 0;\n  while ( ( (poff < post_data_len) ||\n            (pp->state == PP_Callback) ) &&\n          (pp->state != PP_Error) )\n  {\n    if (log_file)\n      fprintf(log_file, \"loop state=%d, poff=%u\\n\", (int)pp->state, (unsigned)poff);\n    switch (pp->state)\n    {\n    case PP_Error:\n      /* clearly impossible as per while loop invariant */\n      if (log_file)\n        fprintf(log_file, \"PP_Error reached - abort called\\n\");\n      abort ();\n      break; /* Unreachable */\n    case PP_Init:\n      if (log_file)\n        fprintf(log_file, \"PP_Init phase detected\\n\");\n      mhd_assert (NULL == start_key);\n      mhd_assert (NULL == end_key);\n      mhd_assert (NULL == start_value);\n      mhd_assert (NULL == end_value);\n      switch (post_data[poff])\n      {\n      case '=':\n        pp->state = PP_Error;\n        if (log_file)\n          fprintf(log_file, \"Error: '=' found with no key at poff=%u\\n\", (unsigned)poff);\n        continue;\n      case '&':\n        poff++;\n        if (log_file)\n          fprintf(log_file, \"Empty key without value, poff incremented to %u\\n\", (unsigned)poff);\n        continue;\n      case '\\n':\n      case '\\r':\n        pp->state = PP_Done;\n        poff++;\n        if (log_file)\n          fprintf(log_file, \"End of data detected at poff=%u\\n\", (unsigned)poff);\n        break;\n      default:\n        pp->state = PP_ProcessKey;\n        start_key = &post_data[poff];\n        pp->must_ikvi = true;\n        poff++;\n        if (log_file)\n          fprintf(log_file, \"Start key processing at poff=%u\\n\", (unsigned)poff);\n        continue;\n      }\n      break; /* end PP_Init */\n    case PP_ProcessKey:\n      if (log_file)\n        fprintf(log_file, \"PP_ProcessKey state\\n\");\n      mhd_assert (NULL == start_value);\n      mhd_assert (NULL == end_value);\n      mhd_assert (NULL != start_key || 0 == poff);\n      mhd_assert (0 != poff || NULL == start_key);\n      mhd_assert (NULL == end_key);\n      switch (post_data[poff])\n      {\n      case '=':\n        if (0 != poff)\n          end_key = &post_data[poff];\n        poff++;\n        pp->state = PP_ProcessValue;\n        break;\n      case '&':\n        if (0 != poff)\n          end_key = &post_data[poff];\n        poff++;\n        pp->state = PP_Callback;\n        break;\n      case '\\n':\n      case '\\r':\n        if (0 != poff)\n          end_key = &post_data[poff];\n        pp->state = PP_Callback;\n        break;\n      default:\n        if (0 == poff)\n          start_key = post_data;\n        poff++;\n        break;\n      }\n      mhd_assert (NULL == end_key || NULL != start_key);\n      break; /* end PP_ProcessKey */\n    case PP_ProcessValue:\n      if (NULL == start_value)\n        start_value = &post_data[poff];\n      switch (post_data[poff])\n      {\n      case '=':\n        pp->state = PP_Error;\n        continue;\n      case '&':\n        end_value = &post_data[poff];\n        poff++;\n        if (pp->must_ikvi ||\n            (start_value != end_value) )\n        {\n          pp->state = PP_Callback;\n        }\n        else\n        {\n          pp->buffer_pos = 0;\n          pp->value_offset = 0;\n          pp->state = PP_Init;\n          start_value = NULL;\n          end_value = NULL;\n        }\n        continue;\n      case '\\n':\n      case '\\r':\n        end_value = &post_data[poff];\n        if (pp->must_ikvi ||\n            (start_value != end_value) )\n          pp->state = PP_Callback;\n        else\n        {\n          poff++;\n          pp->state = PP_Done;\n        }\n        break;\n      case '%':\n        last_escape = &post_data[poff];\n        poff++;\n        break;\n      case '0':\n      case '1':\n      case '2':\n      case '3':\n      case '4':\n      case '5':\n      case '6':\n      case '7':\n      case '8':\n      case '9':\n        poff++;\n        continue;\n      default:\n        last_escape = NULL;\n        poff++;\n        continue;\n      }\n      break; /* end PP_ProcessValue */\n    case PP_Done:\n      switch (post_data[poff])\n      {\n      case '\\n':\n      case '\\r':\n        poff++;\n        continue;\n      }\n      pp->state = PP_Error;\n      break;\n    case PP_Callback:\n      if (log_file)\n        fprintf(log_file, \"PP_Callback with key processing\\n\");\n      mhd_assert ((NULL != end_key) || (NULL == start_key));\n      if (1)\n      {\n        const size_t key_len = (size_t) (end_key - start_key);\n        mhd_assert (end_key >= start_key);\n        if (0 != key_len)\n        {\n          if ( (pp->buffer_pos + key_len >= pp->buffer_size) ||\n               (pp->buffer_pos + key_len < pp->buffer_pos) )\n          {\n            pp->state = PP_Error;\n            continue;\n          }\n          memcpy (&kbuf[pp->buffer_pos],\n                  start_key,\n                  key_len);\n          pp->buffer_pos += key_len;\n          start_key = NULL;\n          end_key = NULL;\n          pp->must_unescape_key = true;\n        }\n      }\n      if (pp->must_unescape_key)\n      {\n        kbuf[pp->buffer_pos] = '\\0'; /* 0-terminate key */\n        MHD_unescape_plus (kbuf);\n        MHD_http_unescape (kbuf);\n        pp->must_unescape_key = false;\n      }\n      process_value (pp,\n                     start_value,\n                     end_value,\n                     NULL);\n      if (PP_Error == pp->state)\n        continue;\n      pp->value_offset = 0;\n      start_value = NULL;\n      end_value = NULL;\n      pp->buffer_pos = 0;\n      pp->state = PP_Init;\n      break;\n    default:\n      if (log_file)\n        fprintf(log_file, \"Internal error: unexpected state %d\\n\", (int)pp->state);\n      MHD_PANIC (_ (\"internal error.\\n\"));\n    }\n    mhd_assert ((end_key == NULL) || (start_key != NULL));\n    mhd_assert ((end_value == NULL) || (start_value != NULL));\n  }\n\n  mhd_assert (PP_Callback != pp->state);\n\n  if (PP_Error == pp->state)\n  {\n    if (log_file)\n      fprintf(log_file, \"Function end with PP_Error state\\n\");\n    if (log_file)\n      fclose(log_file);\n    return MHD_NO;\n  }\n\n  if (NULL != start_key)\n  {\n    size_t key_len;\n    if (log_file)\n      fprintf(log_file, \"Saving remaining start_key state at end\\n\");\n    mhd_assert ((PP_ProcessKey == pp->state) || (NULL != end_key));\n    if (NULL == end_key)\n      end_key = &post_data[poff];\n    mhd_assert (end_key >= start_key);\n    key_len = (size_t) (end_key - start_key);\n    mhd_assert (0 != key_len);\n    if (pp->buffer_pos + key_len >= pp->buffer_size)\n    {\n      pp->state = PP_Error;\n      if (log_file)\n        fclose(log_file);\n      return MHD_NO;\n    }\n    memcpy (&kbuf[pp->buffer_pos],\n            start_key,\n            key_len);\n    pp->buffer_pos += key_len;\n    pp->must_unescape_key = true;\n    start_key = NULL;\n    end_key = NULL;\n  }\n  if ( (NULL != start_value) &&\n       (PP_ProcessValue == pp->state) )\n  {\n    if (log_file)\n      fprintf(log_file, \"Processing remaining value at function end\\n\");\n    if (pp->must_unescape_key)\n    {\n      kbuf[pp->buffer_pos] = '\\0';\n      MHD_unescape_plus (kbuf);\n      MHD_http_unescape (kbuf);\n      pp->must_unescape_key = false;\n    }\n    if (NULL == end_value)\n      end_value = &post_data[poff];\n    if ( (NULL != last_escape) &&\n         (2 < (end_value - last_escape)) )\n      last_escape = NULL;\n    process_value (pp,\n                   start_value,\n                   end_value,\n                   last_escape);\n    pp->must_ikvi = false;\n  }\n  if (PP_Error == pp->state)\n  {\n    if (log_file)\n      fprintf(log_file, \"Function end with PP_Error state at final check\\n\");\n    if (log_file)\n      fclose(log_file);\n    return MHD_NO;\n  }\n\n  if (log_file)\n    fprintf(log_file, \"post_process_urlencoded completed successfully\\n\");\n  if (log_file)\n    fclose(log_file);\n\n  return MHD_YES;\n}\n",
  "explanation": "The original build error was related to missing 'makeinfo' during the build process, which is unrelated to the C source code itself. To ensure this function compiles successfully, I reviewed the function and fixed format specifiers in 'fprintf' calls where integer 'state' values were used directly with '%d' without casting. The 'state' field is likely an enum or unsigned type; explicit casts to '(int)' in these calls fix format specifier warnings/errors that could cause failed compilation under strict compilers. No logic or structure was changed to preserve the original functionality. This small correction enables standard-compliant compilation of the provided code."
}