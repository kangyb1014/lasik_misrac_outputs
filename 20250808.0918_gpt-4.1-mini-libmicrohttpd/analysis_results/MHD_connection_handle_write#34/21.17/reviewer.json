{
  "user_message": "An agent A claimed that the following MHD_connection_handle_write code violates the MISRA C 2023 rule 21.17.\n<misra_rule>\nMISRA C 2023 Rule 21.17 is Use of the string handling functions from <string.h> shall not result in accesses beyond the bounds of the objects referenced by their pointer parameters.\nThis rule strictly applies to the Standard Library functions in <string.h> such as memcpy, memmove, memset, memcmp, strcpy, strncpy, strcat, strncat, strlen, and strspn..\n</misra_rule>\n<target_code>\nHere is the original code of MHD_connection_handle_write.\n```c\nvoid\nMHD_connection_handle_write (struct MHD_Connection *connection)\n{\n  struct MHD_Response *response;\n  ssize_t ret;\n  if (connection->suspended)\n    return;\n\n#ifdef HTTPS_SUPPORT\n  if (MHD_TLS_CONN_NO_TLS != connection->tls_state)\n  {   /* HTTPS connection. */\n    if (MHD_TLS_CONN_CONNECTED > connection->tls_state)\n    {\n      if (! MHD_run_tls_handshake_ (connection))\n        return;\n    }\n  }\n#endif /* HTTPS_SUPPORT */\n\n#if DEBUG_STATES\n  MHD_DLOG (connection->daemon,\n            _ (\"In function %s handling connection at state: %s\\n\"),\n            MHD_FUNC_,\n            MHD_state_to_string (connection->state));\n#endif\n  switch (connection->state)\n  {\n  case MHD_CONNECTION_INIT:\n  case MHD_CONNECTION_REQ_LINE_RECEIVING:\n  case MHD_CONNECTION_REQ_LINE_RECEIVED:\n  case MHD_CONNECTION_REQ_HEADERS_RECEIVING:\n  case MHD_CONNECTION_HEADERS_RECEIVED:\n  case MHD_CONNECTION_HEADERS_PROCESSED:\n    mhd_assert (0);\n    return;\n  case MHD_CONNECTION_CONTINUE_SENDING:\n    ret = MHD_send_data_ (connection,\n                          &HTTP_100_CONTINUE\n                          [connection->continue_message_write_offset],\n                          MHD_STATICSTR_LEN_ (HTTP_100_CONTINUE)\n                          - connection->continue_message_write_offset,\n                          true);\n    if (ret < 0)\n    {\n      if (MHD_ERR_AGAIN_ == ret)\n        return;\n#ifdef HAVE_MESSAGES\n      MHD_DLOG (connection->daemon,\n                _ (\"Failed to send data in request for %s.\\n\"),\n                connection->rq.url);\n#endif\n      CONNECTION_CLOSE_ERROR (connection,\n                              NULL);\n      return;\n    }\n#if _MHD_DEBUG_SEND_DATA\n    fprintf (stderr,\n             _ (\"Sent 100 continue response: `%.*s'\\n\"),\n             (int) ret,\n             &HTTP_100_CONTINUE[connection->continue_message_write_offset]);\n#endif\n    connection->continue_message_write_offset += (size_t) ret;\n    MHD_update_last_activity_ (connection);\n    return;\n  case MHD_CONNECTION_BODY_RECEIVING:\n  case MHD_CONNECTION_BODY_RECEIVED:\n  case MHD_CONNECTION_FOOTERS_RECEIVING:\n  case MHD_CONNECTION_FOOTERS_RECEIVED:\n  case MHD_CONNECTION_FULL_REQ_RECEIVED:\n    mhd_assert (0);\n    return;\n  case MHD_CONNECTION_START_REPLY:\n    mhd_assert (0);\n    return;\n  case MHD_CONNECTION_HEADERS_SENDING:\n    {\n      struct MHD_Response *const resp = connection->rp.response;\n      const size_t wb_ready = connection->write_buffer_append_offset\n                              - connection->write_buffer_send_offset;\n      mhd_assert (connection->write_buffer_append_offset >= \\\n                  connection->write_buffer_send_offset);\n      mhd_assert (NULL != resp);\n      mhd_assert ( (0 == resp->data_size) || \\\n                   (0 == resp->data_start) || \\\n                   (NULL != resp->crc) );\n      mhd_assert ( (0 == connection->rp.rsp_write_position) || \\\n                   (resp->total_size ==\n                    connection->rp.rsp_write_position) );\n      mhd_assert ((MHD_CONN_MUST_UPGRADE != connection->keepalive) || \\\n                  (! connection->rp.props.send_reply_body));\n\n      if ( (connection->rp.props.send_reply_body) &&\n           (NULL == resp->crc) &&\n           (NULL == resp->data_iov) &&\n           /* TODO: remove the next check as 'send_reply_body' is used */\n           (0 == connection->rp.rsp_write_position) &&\n           (! connection->rp.props.chunked) )\n      {\n        mhd_assert (resp->total_size >= resp->data_size);\n        mhd_assert (0 == resp->data_start);\n        /* Send response headers alongside the response body, if the body\n         * data is available. */\n        ret = MHD_send_hdr_and_body_ (connection,\n                                      &connection->write_buffer\n                                      [connection->write_buffer_send_offset],\n                                      wb_ready,\n                                      false,\n                                      resp->data,\n                                      resp->data_size,\n                                      (resp->total_size == resp->data_size));\n      }\n      else\n      {\n        /* This is response for HEAD request or reply body is not allowed\n         * for any other reason or reply body is dynamically generated. */\n        /* Do not send the body data even if it's available. */\n        ret = MHD_send_hdr_and_body_ (connection,\n                                      &connection->write_buffer\n                                      [connection->write_buffer_send_offset],\n                                      wb_ready,\n                                      false,\n                                      NULL,\n                                      0,\n                                      ((0 == resp->total_size) ||\n                                       (! connection->rp.props.send_reply_body)\n                                      ));\n      }\n\n      if (ret < 0)\n      {\n        if (MHD_ERR_AGAIN_ == ret)\n          return;\n#ifdef HAVE_MESSAGES\n        MHD_DLOG (connection->daemon,\n                  _ (\"Failed to send the response headers for the \" \\\n                     \"request for `%s'. Error: %s\\n\"),\n                  connection->rq.url,\n                  str_conn_error_ (ret));\n#endif\n        CONNECTION_CLOSE_ERROR (connection,\n                                NULL);\n        return;\n      }\n      /* 'ret' is not negative, it's safe to cast it to 'size_t'. */\n      if (((size_t) ret) > wb_ready)\n      {\n        /* The complete header and some response data have been sent,\n         * update both offsets. */\n        mhd_assert (0 == connection->rp.rsp_write_position);\n        mhd_assert (! connection->rp.props.chunked);\n        mhd_assert (connection->rp.props.send_reply_body);\n        connection->write_buffer_send_offset += wb_ready;\n        connection->rp.rsp_write_position = ((size_t) ret) - wb_ready;\n      }\n      else\n        connection->write_buffer_send_offset += (size_t) ret;\n      MHD_update_last_activity_ (connection);\n      if (MHD_CONNECTION_HEADERS_SENDING != connection->state)\n        return;\n      check_write_done (connection,\n                        MHD_CONNECTION_HEADERS_SENT);\n      return;\n    }\n  case MHD_CONNECTION_HEADERS_SENT:\n    return;\n  case MHD_CONNECTION_NORMAL_BODY_READY:\n    response = connection->rp.response;\n    if (connection->rp.rsp_write_position <\n        connection->rp.response->total_size)\n    {\n      uint64_t data_write_offset;\n\n#if defined(MHD_USE_POSIX_THREADS) || defined(MHD_USE_W32_THREADS)\n      if (NULL != response->crc)\n        MHD_mutex_lock_chk_ (&response->mutex);\n#endif\n      if (MHD_NO == try_ready_normal_body (connection))\n      {\n        /* mutex was already unlocked by try_ready_normal_body */\n        return;\n      }\n#if defined(_MHD_HAVE_SENDFILE)\n      if (MHD_resp_sender_sendfile == connection->rp.resp_sender)\n      {\n        mhd_assert (NULL == response->data_iov);\n        ret = MHD_send_sendfile_ (connection);\n      }\n      else /* combined with the next 'if' */\n#endif /* _MHD_HAVE_SENDFILE */\n      if (NULL != response->data_iov)\n      {\n        ret = MHD_send_iovec_ (connection,\n                               &connection->rp.resp_iov,\n                               true);\n      }\n      else\n      {\n        data_write_offset = connection->rp.rsp_write_position\n                            - response->data_start;\n        if (data_write_offset > (uint64_t) SIZE_MAX)\n          MHD_PANIC (_ (\"Data offset exceeds limit.\\n\"));\n        ret = MHD_send_data_ (connection,\n                              &response->data\n                              [(size_t) data_write_offset],\n                              response->data_size\n                              - (size_t) data_write_offset,\n                              true);\n#if _MHD_DEBUG_SEND_DATA\n        if (ret > 0)\n          fprintf (stderr,\n                   _ (\"Sent %d-byte DATA response: `%.*s'\\n\"),\n                   (int) ret,\n                   (int) ret,\n                   &rp.response->data[connection->rp.rsp_write_position\n                                      - rp.response->data_start]);\n#endif\n      }\n#if defined(MHD_USE_POSIX_THREADS) || defined(MHD_USE_W32_THREADS)\n      if (NULL != response->crc)\n        MHD_mutex_unlock_chk_ (&response->mutex);\n#endif\n      if (ret < 0)\n      {\n        if (MHD_ERR_AGAIN_ == ret)\n          return;\n#ifdef HAVE_MESSAGES\n        MHD_DLOG (connection->daemon,\n                  _ (\"Failed to send the response body for the \" \\\n                     \"request for `%s'. Error: %s\\n\"),\n                  connection->rq.url,\n                  str_conn_error_ (ret));\n#endif\n        CONNECTION_CLOSE_ERROR (connection,\n                                NULL);\n        return;\n      }\n      connection->rp.rsp_write_position += (size_t) ret;\n      MHD_update_last_activity_ (connection);\n    }\n    if (connection->rp.rsp_write_position ==\n        connection->rp.response->total_size)\n      connection->state = MHD_CONNECTION_FULL_REPLY_SENT;\n    return;\n  case MHD_CONNECTION_NORMAL_BODY_UNREADY:\n    mhd_assert (0);\n    return;\n  case MHD_CONNECTION_CHUNKED_BODY_READY:\n    ret = MHD_send_data_ (connection,\n                          &connection->write_buffer\n                          [connection->write_buffer_send_offset],\n                          connection->write_buffer_append_offset\n                          - connection->write_buffer_send_offset,\n                          true);\n    if (ret < 0)\n    {\n      if (MHD_ERR_AGAIN_ == ret)\n        return;\n#ifdef HAVE_MESSAGES\n      MHD_DLOG (connection->daemon,\n                _ (\"Failed to send the chunked response body for the \" \\\n                   \"request for `%s'. Error: %s\\n\"),\n                connection->rq.url,\n                str_conn_error_ (ret));\n#endif\n      CONNECTION_CLOSE_ERROR (connection,\n                              NULL);\n      return;\n    }\n    connection->write_buffer_send_offset += (size_t) ret;\n    MHD_update_last_activity_ (connection);\n    if (MHD_CONNECTION_CHUNKED_BODY_READY != connection->state)\n      return;\n    check_write_done (connection,\n                      (connection->rp.response->total_size ==\n                       connection->rp.rsp_write_position) ?\n                      MHD_CONNECTION_CHUNKED_BODY_SENT :\n                      MHD_CONNECTION_CHUNKED_BODY_UNREADY);\n    return;\n  case MHD_CONNECTION_CHUNKED_BODY_UNREADY:\n  case MHD_CONNECTION_CHUNKED_BODY_SENT:\n    mhd_assert (0);\n    return;\n  case MHD_CONNECTION_FOOTERS_SENDING:\n    ret = MHD_send_data_ (connection,\n                          &connection->write_buffer\n                          [connection->write_buffer_send_offset],\n                          connection->write_buffer_append_offset\n                          - connection->write_buffer_send_offset,\n                          true);\n    if (ret < 0)\n    {\n      if (MHD_ERR_AGAIN_ == ret)\n        return;\n#ifdef HAVE_MESSAGES\n      MHD_DLOG (connection->daemon,\n                _ (\"Failed to send the footers for the \" \\\n                   \"request for `%s'. Error: %s\\n\"),\n                connection->rq.url,\n                str_conn_error_ (ret));\n#endif\n      CONNECTION_CLOSE_ERROR (connection,\n                              NULL);\n      return;\n    }\n    connection->write_buffer_send_offset += (size_t) ret;\n    MHD_update_last_activity_ (connection);\n    if (MHD_CONNECTION_FOOTERS_SENDING != connection->state)\n      return;\n    check_write_done (connection,\n                      MHD_CONNECTION_FULL_REPLY_SENT);\n    return;\n  case MHD_CONNECTION_FULL_REPLY_SENT:\n    mhd_assert (0);\n    return;\n  case MHD_CONNECTION_CLOSED:\n    return;\n#ifdef UPGRADE_SUPPORT\n  case MHD_CONNECTION_UPGRADE:\n    mhd_assert (0);\n    return;\n#endif /* UPGRADE_SUPPORT */\n  default:\n    mhd_assert (0);\n    CONNECTION_CLOSE_ERROR (connection,\n                            _ (\"Internal error.\\n\"));\n    break;\n  }\n  return;\n}\n```\n</target_code>\n<scenario>\nThe agent A provided the following violation scenario:A violation could occur if the function MHD_send_data_ or related functions like MHD_send_hdr_and_body_ are called with a pointer and size that do not properly ensure that the pointer references a buffer region large enough to hold the specified size. In the code, particularly in the case MHD_CONNECTION_NORMAL_BODY_READY, the pointer arithmetic and size calculation for sending response data (i.e., &response->data[(size_t) data_write_offset] with size response->data_size - (size_t) data_write_offset) assume that data_write_offset is always within data_size bounds and does not exceed it. If data_write_offset is incorrectly larger than response->data_size, the call to MHD_send_data_ can result in out-of-bounds access violating Rule 21.17. Although some assertions exist to check bounds, there is no full enforcement, and the code does not explicitly prevent this scenario at runtime, thus leading to potential violation of Rule 21.17.\n</scenario>\n<test_code>\nAlso, the agent A provided the following modified code that prints out the log to support their scenario:\n```c\nstruct rq_struct {\n    const char *url;\n};\nstruct rp_struct {\n    struct MHD_Response *response;\n    size_t rsp_write_position;\n};\nvoid CONNECTION_CLOSE_ERROR(struct MHD_Connection *connection, const char *emsg);\nstatic void log_to_file(const char *fmt, ...)\n{\n    FILE *f = fopen(\"/tmp/logs/279.txt\", \"a\");\n    if(f)\n    {\n        va_list args;\n        va_start(args, fmt);\n        vfprintf(f, fmt, args);\n        va_end(args);\n        fclose(f);\n    }\n}\n\nstatic int try_ready_normal_body(struct MHD_Connection *connection) { return 1; }\nstatic void MHD_update_last_activity_(struct MHD_Connection *connection) { /* do nothing */ }\nvoid MHD_connection_handle_write (struct MHD_Connection *connection)\n{\n    ssize_t ret = -1;\n    struct MHD_Response *response;\n\n    if (connection->suspended)\n        return;\n\n#if defined(DEBUG_STATES)\n    log_to_file(\"Entering MHD_connection_handle_write with state: %d\\n\", connection->state);\n#endif\n\n    switch (connection->state)\n    {\n    case MHD_CONNECTION_NORMAL_BODY_READY:\n        response = connection->rp.response;\n        log_to_file(\"State NORMAL_BODY_READY: rsp_write_position=%lu, total_size=%lu, data_size=%lu, data_start=%lu\\n\",\n            (unsigned long)connection->rp.rsp_write_position,\n            (unsigned long)response->total_size,\n            (unsigned long)response->data_size,\n            (unsigned long)response->data_start);\n\n        if (connection->rp.rsp_write_position < response->total_size)\n        {\n            uint64_t data_write_offset;\n\n            if (NULL != response->crc)\n            {\n                // Lock mutex omitted\n            }\n\n            if (MHD_NO == try_ready_normal_body(connection))\n            {\n                // mutex unlocked inside try_ready_normal_body\n                return;\n            }\n\n            if (NULL != response->data_iov)\n            {\n                // send iovec omitted\n                return;\n            }\n            else\n            {\n                data_write_offset = connection->rp.rsp_write_position - response->data_start;\n\n                // Intentionally log the potentially out-of-bounds access\n                log_to_file(\"Attempting to send data from data offset %lu of size %lu\\n\",\n                            (unsigned long)data_write_offset,\n                            (unsigned long)(response->data_size - (size_t)data_write_offset));\n\n                // Possible out-of-bounds if data_write_offset > response->data_size\n                ret = MHD_send_data_(connection,\n                                      &response->data[(size_t)data_write_offset],\n                                      response->data_size - (size_t)data_write_offset,\n                                      true);\n\n#if _MHD_DEBUG_SEND_DATA\n                if (ret > 0)\n                    fprintf(stderr,\n                            \"Sent %zd-byte DATA response starting at offset %lu\\n\",\n                            ret, (unsigned long)connection->rp.rsp_write_position);\n#endif\n            }\n\n            if (NULL != response->crc)\n            {\n                // Unlock mutex omitted\n            }\n\n            if (ret < 0)\n            {\n                if (MHD_ERR_AGAIN_ == ret)\n                    return;\n                log_to_file(\"Error sending response body for URL %s, error code: %zd\\n\",\n                            connection->rq.url != NULL ? connection->rq.url : \"(null)\", ret);\n                CONNECTION_CLOSE_ERROR(connection, NULL);\n                return;\n            }\n\n            connection->rp.rsp_write_position += (size_t)ret;\n            MHD_update_last_activity_(connection);\n        }\n        if (connection->rp.rsp_write_position == response->total_size)\n            connection->state = MHD_CONNECTION_FULL_REPLY_SENT;\n        return;\n\n    default:\n        break;\n    }\n}\n\n```\nThe test code failed to compile, so we could not obtain any output.\n\n</test_code>\n<response format>\nProvide your answer with these fields.\n- explanation: your evaluation of the scenario provided by the agent A.\n- is_report_correct: whether the report is correct or not (true/false)\n</response format>\n<instruction>   \nJudge whether the report is correct or not.\n</instruction>\n",
  "is_report_correct": true,
  "explanation": "The reported violation concerns potential out-of-bounds access in calls to string handling functions (specifically via MHD_send_data_ or related functions) due to insufficient runtime validation of pointer and size parameters derived from response->data and associated offsets. MISRA C 2023 Rule 21.17 requires that calls to string handling functions must not result in accessing beyond object bounds.\n\nIn the provided code snippet, particularly in the case MHD_CONNECTION_NORMAL_BODY_READY, the calculation of data_write_offset as (connection->rp.rsp_write_position - response->data_start) must be within the bounds of response->data_size to prevent out-of-bounds access. The code uses assertions (mhd_assert) to verify some conditions earlier in the flow, but these are disabled in production, and there is no explicit runtime check that data_write_offset <= response->data_size before performing the pointer arithmetic and calling MHD_send_data_.\n\nThis lack of definitive runtime checks means that an invalid state, memory corruption, or incorrect calculations elsewhere could lead to data_write_offset exceeding response->data_size, causing the MHD_send_data_ call to access memory beyond the buffer bounds, thereby violating Rule 21.17.\n\nTherefore, the scenario proposed by agent A is plausible and the report that the code violates MISRA C 2023 Rule 21.17 is correct."
}