{
  "user_message": "<target code>Here is the code that failed to compile:\n```c\nenum MHD_DigestAuthAlgo3 { ALG_INVALID = 0 };\nstatic bool digest_init_one_time(struct DigestAlgorithm *da, MHD_DigestBaseAlgo algo) {\n    da->algo = algo;\n    da->algo_selected = true;\n    da->ready_for_hashing = true;\n    da->uninitialised = false;\n    return true;\n}\nstatic void digest_deinit(struct DigestAlgorithm *da) { (void)da; }\n\nstatic void digest_update(struct DigestAlgorithm *da, const void *data, size_t length) { /* dummy */ (void)da; (void)data; (void)length; }\nstatic size_t digest_get_size(struct DigestAlgorithm *da) {\n    (void)da;\n    return 16;\n}\nstatic void calc_userdigest(struct DigestAlgorithm *da, const char *username, const size_t username_len, const char *realm, const size_t realm_len, const char *password, uint8_t *userdigest_bin) {\n    FILE *log = fopen(\"/tmp/logs/567.txt\", \"a\");\n    if (log) {\n        fprintf(log, \"calc_userdigest called with username_len=%zu, realm_len=%zu\\n\", username_len, realm_len);\n        fprintf(log, \"username buffer contents (up to 20 chars): %.*s\\n\", (int)(username_len < 20 ? username_len : 20), username);\n        fprintf(log, \"realm buffer contents (up to 20 chars): %.*s\\n\", (int)(realm_len < 20 ? realm_len : 20), realm);\n        fclose(log);\n    }\n    digest_update(da, username, username_len);\n    digest_update(da, \":\", 1);\n    digest_update(da, realm, realm_len);\n    digest_update(da, \":\", 1);\n    digest_update(da, password, strlen(password));\n    /* Simulate writing a dummy digest */\n    if (userdigest_bin) {\n        for (size_t i = 0; i < 16; i++) {\n            userdigest_bin[i] = (uint8_t)i;\n        }\n    }\n}\nMHD_Result MHD_digest_auth_calc_userdigest(enum MHD_DigestAuthAlgo3 algo3,\n                                          const char *username,\n                                          const char *realm,\n                                          const char *password,\n                                          void *userdigest_bin,\n                                          size_t bin_buf_size) {\n    FILE *log = fopen(\"/tmp/logs/567.txt\", \"a\");\n    struct DigestAlgorithm da;\n    MHD_Result ret;\n\n    if (log) fprintf(log, \"Entered MHD_digest_auth_calc_userdigest\\n\");\n\n    if (!digest_init_one_time(&da, MHD_DIGEST_BASE_ALGO_MD5)) {\n        if (log) fprintf(log, \"digest_init_one_time failed\\n\");\n        if (log) fclose(log);\n        return MHD_NO;\n    }\n\n    if (digest_get_size(&da) > bin_buf_size) {\n        if (log) fprintf(log, \"Buffer too small: digest size > bin_buf_size\\n\");\n        ret = MHD_NO;\n    } else {\n        size_t username_len = strlen(username);\n        size_t realm_len = strlen(realm);\n        if (log) fprintf(log, \"username_len=%zu, realm_len=%zu\\n\", username_len, realm_len);\n\n        /* PROBE: Here is risk of reading beyond bounds if username or realm buffers are not properly null-terminated */\n        calc_userdigest(&da, username, username_len, realm, realm_len, password, (uint8_t *)userdigest_bin);\n        ret = MHD_YES;\n    }\n\n    digest_deinit(&da);\n\n    if (log) {\n        fprintf(log, \"Exiting MHD_digest_auth_calc_userdigest with result %d\\n\", ret);\n        fclose(log);\n    }\n\n    return ret;\n}\n\n```\n</target code>\n<build error>\nThe build failed with the following error:\n```\ndigestauth.c:359:6: error: redeclaration of 'enum MHD_DigestAuthAlgo3'\n  359 | enum MHD_DigestAuthAlgo3 { ALG_INVALID = 0 };\n      |      ^~~~~~~~~~~~~~~~~~~\nIn file included from internal.h:34,\n                 from digestauth.c:43:\n../../src/include/microhttpd.h:4755:6: note: originally defined here\n 4755 | enum MHD_DigestAuthAlgo3\n      |      ^~~~~~~~~~~~~~~~~~~\ndigestauth.c:360:62: error: unknown type name 'MHD_DigestBaseAlgo'\n  360 | static bool digest_init_one_time(struct DigestAlgorithm *da, MHD_DigestBaseAlgo algo) {\n      |                                                              ^~~~~~~~~~~~~~~~~~\ndigestauth.c:1863:1: error: duplicate 'static'\n 1863 | _MHD_static_inline static void calc_userdigest(struct DigestAlgorithm *da, const char *username, const size_t username_len, const char *realm, const size_t realm_len, const char *password, uint8_t *userdigest_bin) {\n      | ^~~~~~~~~~~~~~~~~~\ndigestauth.c:1919:1: error: unknown type name 'MHD_Result'; use 'enum' keyword to refer to the type\n 1919 | MHD_Result MHD_digest_auth_calc_userdigest(enum MHD_DigestAuthAlgo3 algo3,\n      | ^~~~~~~~~~\n      | enum \ndigestauth.c:1919:12: error: conflicting types for 'MHD_digest_auth_calc_userdigest'; have 'int(enum MHD_DigestAuthAlgo3,  const char *, const char *, const char *, void *, size_t)' {aka 'int(enum MHD_DigestAuthAlgo3,  const char *, const char *, const char *, void *, long unsigned int)'}\n 1919 | MHD_Result MHD_digest_auth_calc_userdigest(enum MHD_DigestAuthAlgo3 algo3,\n      |            ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\nIn file included from internal.h:34,\n                 from digestauth.c:43:\n../../src/include/microhttpd.h:5607:1: note: previous declaration of 'MHD_digest_auth_calc_userdigest' with type 'enum MHD_Result(enum MHD_DigestAuthAlgo3,  const char *, const char *, const char *, void *, size_t)' {aka 'enum MHD_Result(enum MHD_DigestAuthAlgo3,  const char *, const char *, const char *, void *, long unsigned int)'}\n 5607 | MHD_digest_auth_calc_userdigest (enum MHD_DigestAuthAlgo3 algo3,\n      | ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\ndigestauth.c: In function 'MHD_digest_auth_calc_userdigest':\ndigestauth.c:1927:5: error: unknown type name 'MHD_Result'; use 'enum' keyword to refer to the type\n 1927 |     MHD_Result ret;\n      |     ^~~~~~~~~~\n      |     enum \nmake[3]: *** [Makefile:2224: libmicrohttpd_la-digestauth.lo] Error 1\nmake[2]: *** [Makefile:449: all-recursive] Error 1\nmake[1]: *** [Makefile:788: all-recursive] Error 1\nmake: *** [Makefile:693: all] Error 2\n```\n</build error>\n<response format>\nProvide your answer with these answers.\n- fixed_test_code: the fixed test code that compiles successfully.\n- explanation: a brief explanation of the changes you made to fix the code.\nHere are the constraints for the test code:\n- The test code MUST be compilable and executable.\n- The test code MUST include line breaks.\n- The test code MUST preserve the original logic of MHD_digest_auth_calc_userdigest as much as possible.\n- You MUST not define the main function.\n- You MUST not define macros.\n- The test code MUST not contain any mock functions.\n</response format>\n<instruction>\nPlease fix the code so that it compiles successfully.\n</instruction>\n",
  "fixed_test_code": "static bool digest_init_one_time(struct DigestAlgorithm *da, enum MHD_DigestBaseAlgo algo) {\n    da->algo = algo;\n    da->algo_selected = true;\n    da->ready_for_hashing = true;\n    da->uninitialised = false;\n    return true;\n}\n\nstatic void digest_deinit(struct DigestAlgorithm *da) { (void)da; }\n\nstatic void digest_update(struct DigestAlgorithm *da, const void *data, size_t length) { /* dummy */ (void)da; (void)data; (void)length; }\n\nstatic size_t digest_get_size(struct DigestAlgorithm *da) {\n    (void)da;\n    return 16;\n}\n\nstatic void calc_userdigest(struct DigestAlgorithm *da, const char *username, const size_t username_len, const char *realm, const size_t realm_len, const char *password, uint8_t *userdigest_bin) {\n    FILE *log = fopen(\"/tmp/logs/567.txt\", \"a\");\n    if (log) {\n        fprintf(log, \"calc_userdigest called with username_len=%zu, realm_len=%zu\\n\", username_len, realm_len);\n        fprintf(log, \"username buffer contents (up to 20 chars): %.*s\\n\", (int)(username_len < 20 ? username_len : 20), username);\n        fprintf(log, \"realm buffer contents (up to 20 chars): %.*s\\n\", (int)(realm_len < 20 ? realm_len : 20), realm);\n        fclose(log);\n    }\n    digest_update(da, username, username_len);\n    digest_update(da, \":\", 1);\n    digest_update(da, realm, realm_len);\n    digest_update(da, \":\", 1);\n    digest_update(da, password, strlen(password));\n    /* Simulate writing a dummy digest */\n    if (userdigest_bin) {\n        for (size_t i = 0; i < 16; i++) {\n            userdigest_bin[i] = (uint8_t)i;\n        }\n    }\n}\n\nenum MHD_Result MHD_digest_auth_calc_userdigest(enum MHD_DigestAuthAlgo3 algo3,\n                                              const char *username,\n                                              const char *realm,\n                                              const char *password,\n                                              void *userdigest_bin,\n                                              size_t bin_buf_size) {\n    FILE *log = fopen(\"/tmp/logs/567.txt\", \"a\");\n    struct DigestAlgorithm da;\n    enum MHD_Result ret;\n\n    if (log) fprintf(log, \"Entered MHD_digest_auth_calc_userdigest\\n\");\n\n    if (!digest_init_one_time(&da, MHD_DIGEST_BASE_ALGO_MD5)) {\n        if (log) fprintf(log, \"digest_init_one_time failed\\n\");\n        if (log) fclose(log);\n        return MHD_NO;\n    }\n\n    if (digest_get_size(&da) > bin_buf_size) {\n        if (log) fprintf(log, \"Buffer too small: digest size > bin_buf_size\\n\");\n        ret = MHD_NO;\n    } else {\n        size_t username_len = strlen(username);\n        size_t realm_len = strlen(realm);\n        if (log) fprintf(log, \"username_len=%zu, realm_len=%zu\\n\", username_len, realm_len);\n\n        /* PROBE: Here is risk of reading beyond bounds if username or realm buffers are not properly null-terminated */\n        calc_userdigest(&da, username, username_len, realm, realm_len, password, (uint8_t *)userdigest_bin);\n        ret = MHD_YES;\n    }\n\n    digest_deinit(&da);\n\n    if (log) {\n        fprintf(log, \"Exiting MHD_digest_auth_calc_userdigest with result %d\\n\", ret);\n        fclose(log);\n    }\n\n    return ret;\n}\n",
  "explanation": "1. Removed redeclaration of enum MHD_DigestAuthAlgo3 since it conflicts with the existing declaration in included headers.\n2. Changed the parameter type of digest_init_one_time to use 'enum MHD_DigestBaseAlgo' instead of unknown 'MHD_DigestBaseAlgo'.\n3. Removed duplicate 'static' keyword before calc_userdigest function.\n4. Changed return type and variable declaration of MHD_digest_auth_calc_userdigest function and local variable 'ret' to use 'enum MHD_Result' explicitly, matching the previous declaration in the header.\n\nThese changes remove conflicts with existing declarations and unknown types, ensuring consistency with the headers already included. The original logic and function implementations remain unchanged."
}