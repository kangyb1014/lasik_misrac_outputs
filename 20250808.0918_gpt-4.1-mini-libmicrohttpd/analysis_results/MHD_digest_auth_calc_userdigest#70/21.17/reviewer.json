{
  "user_message": "An agent A claimed that the following MHD_digest_auth_calc_userdigest code violates the MISRA C 2023 rule 21.17.\n<misra_rule>\nMISRA C 2023 Rule 21.17 is Use of the string handling functions from <string.h> shall not result in accesses beyond the bounds of the objects referenced by their pointer parameters.\nThis rule strictly applies to the Standard Library functions in <string.h> such as memcpy, memmove, memset, memcmp, strcpy, strncpy, strcat, strncat, strlen, and strspn..\n</misra_rule>\n<target_code>\nHere is the original code of MHD_digest_auth_calc_userdigest.\n```c\n_MHD_EXTERN enum MHD_Result\nMHD_digest_auth_calc_userdigest (enum MHD_DigestAuthAlgo3 algo3,\n                                 const char *username,\n                                 const char *realm,\n                                 const char *password,\n                                 void *userdigest_bin,\n                                 size_t bin_buf_size)\n{\n  struct DigestAlgorithm da;\n  enum MHD_Result ret;\n  if (! digest_init_one_time (&da, get_base_digest_algo (algo3)))\n    return MHD_NO;\n\n  if (digest_get_size (&da) > bin_buf_size)\n    ret = MHD_NO;\n  else\n  {\n    calc_userdigest (&da,\n                     username,\n                     strlen (username),\n                     realm,\n                     strlen (realm),\n                     password,\n                     userdigest_bin);\n    ret = MHD_YES;\n\n#ifdef MHD_DIGEST_HAS_EXT_ERROR\n    if (digest_ext_error (&da))\n      ret = MHD_NO;\n#endif /* MHD_DIGEST_HAS_EXT_ERROR */\n  }\n  digest_deinit (&da);\n\n  return ret;\n}\n```\n</target_code>\n<scenario>\nThe agent A provided the following violation scenario:If the username or realm strings are not properly null-terminated or if their length reports are incorrect, calls to strlen(username) or strlen(realm) in MHD_digest_auth_calc_userdigest could cause accesses beyond the bounds of the respective objects, violating Rule 21.17. This could happen if the input strings are malformed or incorrectly handled upstream before calling this function.\n</scenario>\n<test_code>\nAlso, the agent A provided the following modified code that prints out the log to support their scenario:\n```c\nstatic bool digest_init_one_time(struct DigestAlgorithm *da, enum MHD_DigestBaseAlgo algo) {\n    da->algo = algo;\n    da->algo_selected = true;\n    da->ready_for_hashing = true;\n    da->uninitialised = false;\n    return true;\n}\nstatic void digest_deinit(struct DigestAlgorithm *da) { (void)da; }\n\nstatic void digest_update(struct DigestAlgorithm *da, const void *data, size_t length) { /* dummy */ (void)da; (void)data; (void)length; }\nstatic size_t digest_get_size(struct DigestAlgorithm *da) {\n    (void)da;\n    return 16;\n}\nstatic void calc_userdigest(struct DigestAlgorithm *da, const char *username, const size_t username_len, const char *realm, const size_t realm_len, const char *password, uint8_t *userdigest_bin) {\n    FILE *log = fopen(\"/tmp/logs/567.txt\", \"a\");\n    if (log) {\n        fprintf(log, \"calc_userdigest called with username_len=%zu, realm_len=%zu\\n\", username_len, realm_len);\n        fprintf(log, \"username buffer contents (up to 20 chars): %.*s\\n\", (int)(username_len < 20 ? username_len : 20), username);\n        fprintf(log, \"realm buffer contents (up to 20 chars): %.*s\\n\", (int)(realm_len < 20 ? realm_len : 20), realm);\n        fclose(log);\n    }\n    digest_update(da, username, username_len);\n    digest_update(da, \":\", 1);\n    digest_update(da, realm, realm_len);\n    digest_update(da, \":\", 1);\n    digest_update(da, password, strlen(password));\n    /* Simulate writing a dummy digest */\n    if (userdigest_bin) {\n        for (size_t i = 0; i < 16; i++) {\n            userdigest_bin[i] = (uint8_t)i;\n        }\n    }\n}\nenum MHD_Result MHD_digest_auth_calc_userdigest(enum MHD_DigestAuthAlgo3 algo3,\n                                              const char *username,\n                                              const char *realm,\n                                              const char *password,\n                                              void *userdigest_bin,\n                                              size_t bin_buf_size) {\n    FILE *log = fopen(\"/tmp/logs/567.txt\", \"a\");\n    struct DigestAlgorithm da;\n    enum MHD_Result ret;\n\n    if (log) fprintf(log, \"Entered MHD_digest_auth_calc_userdigest\\n\");\n\n    if (!digest_init_one_time(&da, MHD_DIGEST_BASE_ALGO_MD5)) {\n        if (log) fprintf(log, \"digest_init_one_time failed\\n\");\n        if (log) fclose(log);\n        return MHD_NO;\n    }\n\n    if (digest_get_size(&da) > bin_buf_size) {\n        if (log) fprintf(log, \"Buffer too small: digest size > bin_buf_size\\n\");\n        ret = MHD_NO;\n    } else {\n        size_t username_len = strlen(username);\n        size_t realm_len = strlen(realm);\n        if (log) fprintf(log, \"username_len=%zu, realm_len=%zu\\n\", username_len, realm_len);\n\n        /* PROBE: Here is risk of reading beyond bounds if username or realm buffers are not properly null-terminated */\n        calc_userdigest(&da, username, username_len, realm, realm_len, password, (uint8_t *)userdigest_bin);\n        ret = MHD_YES;\n    }\n\n    digest_deinit(&da);\n\n    if (log) {\n        fprintf(log, \"Exiting MHD_digest_auth_calc_userdigest with result %d\\n\", ret);\n        fclose(log);\n    }\n\n    return ret;\n}\n\n```\nThe test code failed to compile, so we could not obtain any output.\n\n</test_code>\n<response format>\nProvide your answer with these fields.\n- explanation: your evaluation of the scenario provided by the agent A.\n- is_report_correct: whether the report is correct or not (true/false)\n</response format>\n<instruction>   \nJudge whether the report is correct or not.\n</instruction>\n",
  "is_report_correct": false,
  "explanation": "MISRA C 2023 Rule 21.17 requires that use of string handling functions from <string.h> must not result in accesses beyond the bounds of the referenced objects. In the code, strlen is used on 'username' and 'realm'. These functions inherently require that the input strings be null-terminated to avoid reading beyond their allocated bounds. The rule applies to the code under analysis; however, it does not mandate that the function must protect against malformed, non-null-terminated inputs but rather that its own use of standard library functions must not lead to out-of-bounds access given valid inputs. The scenario described by agent A states that if 'username' or 'realm' are not properly null-terminated or have incorrect lengths upstream, then the strlen calls could cause buffer overruns. While this is true in a practical context, it reflects undefined or erroneous input rather than a violation within this function's proper use of the string functions. The function relies on correct inputs as is standard practice and does not itself perform checks to confirm null-termination before strlen calls. The violation would only occur if the function is expected to defend against invalid inputs, which MISRA Rule 21.17 does not explicitly require. Thus, the function itself does not violate Rule 21.17 by calling strlen on the input parameters as given. The inputs must be valid strings as a precondition. Therefore, the report is not correct according to the MISRA 21.17 interpretation."
}