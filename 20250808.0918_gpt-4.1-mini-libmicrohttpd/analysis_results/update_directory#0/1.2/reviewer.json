{
  "user_message": "An agent A claimed that the following update_directory code violates the MISRA C 2023 rule 1.2.\n<misra_rule>\nMISRA C 2023 Rule 1.2 is Language extensions should not be used.\nYou should report only when the code uses any language compiler extensions that are explicitly stated as an extension in compiler documentations..\n</misra_rule>\n<target_code>\nHere is the original code of update_directory.\n```c\nstatic void\nupdate_directory (void)\n{\n  static size_t initial_allocation = 32 * 1024; /* initial size for response buffer */\n  struct MHD_Response *response;\n  struct ResponseDataContext rdc;\n  unsigned int language_idx;\n  unsigned int category_idx;\n  const struct Language *language;\n  const char *category;\n  char dir_name[128];\n  struct stat sbuf;\n  int res;\n  size_t len;\n\n  rdc.buf_len = initial_allocation;\n  if (NULL == (rdc.buf = malloc (rdc.buf_len)))\n  {\n    update_cached_response (NULL);\n    return;\n  }\n  len = strlen (INDEX_PAGE_HEADER);\n  if (rdc.buf_len <= len)\n  { /* buffer too small */\n    free (rdc.buf);\n    update_cached_response (NULL);\n    return;\n  }\n  memcpy (rdc.buf, INDEX_PAGE_HEADER, len);\n  rdc.off = len;\n  for (language_idx = 0; NULL != languages[language_idx].dirname;\n       language_idx++)\n  {\n    language = &languages[language_idx];\n\n    if (0 != stat (language->dirname, &sbuf))\n      continue; /* empty */\n    /* we ensured always +1k room, filenames are ~256 bytes,\n       so there is always still enough space for the header\n       without need for an additional reallocation check. */\n    res = snprintf (&rdc.buf[rdc.off], rdc.buf_len - rdc.off,\n                    \"<h2>%s</h2>\\n\",\n                    language->longname);\n    if (0 >= res)\n      continue;  /* snprintf() error */\n    if (rdc.buf_len - rdc.off <= (size_t) res)\n      continue;  /* buffer too small?? */\n    rdc.off += (size_t) res;\n    for (category_idx = 0; NULL != categories[category_idx]; category_idx++)\n    {\n      category = categories[category_idx];\n      res = snprintf (dir_name, sizeof (dir_name),\n                      \"%s/%s\",\n                      language->dirname,\n                      category);\n      if ((0 >= res) || (sizeof (dir_name) <= (size_t) res))\n        continue;  /* cannot print dir name */\n      if (0 != stat (dir_name, &sbuf))\n        continue;  /* empty */\n\n      /* we ensured always +1k room, filenames are ~256 bytes,\n         so there is always still enough space for the header\n         without need for an additional reallocation check. */\n      res = snprintf (&rdc.buf[rdc.off], rdc.buf_len - rdc.off,\n                      \"<h3>%s</h3>\\n\",\n                      category);\n      if (0 >= res)\n        continue;  /* snprintf() error */\n      if (rdc.buf_len - rdc.off <= (size_t) res)\n        continue;  /* buffer too small?? */\n      rdc.off += (size_t) res;\n\n      if (MHD_NO == list_directory (&rdc, dir_name))\n      {\n        free (rdc.buf);\n        update_cached_response (NULL);\n        return;\n      }\n    }\n  }\n  /* we ensured always +1k room, filenames are ~256 bytes,\n     so there is always still enough space for the footer\n     without need for a final reallocation check. */\n  len = strlen (INDEX_PAGE_FOOTER);\n  if (rdc.buf_len - rdc.off <= len)\n  { /* buffer too small */\n    free (rdc.buf);\n    update_cached_response (NULL);\n    return;\n  }\n  memcpy (rdc.buf, INDEX_PAGE_FOOTER, len);\n  rdc.off += len;\n  initial_allocation = rdc.buf_len; /* remember for next time */\n  response =\n    MHD_create_response_from_buffer_with_free_callback (rdc.off,\n                                                        rdc.buf,\n                                                        &free);\n  mark_as_html (response);\n#ifdef FORCE_CLOSE\n  (void) MHD_add_response_header (response,\n                                  MHD_HTTP_HEADER_CONNECTION,\n                                  \"close\");\n#endif\n  update_cached_response (response);\n}\n```\n</target_code>\n<scenario>\nThe agent A provided the following violation scenario:Use of conditional compilation with FORCE_CLOSE macro is a language extension that may rely on compiler-specific preprocessor behavior; if FORCE_CLOSE is not defined by standard C, its use represents a language extension violating MISRA C 2023 Rule 1.2.\n</scenario>\n<test_code>\nAlso, the agent A provided the following modified code that prints out the log to support their scenario:\n```c\n\nstatic void\nupdate_directory(void)\n{\n  FILE *log = fopen(\"/tmp/logs/0.txt\", \"a\");\n  static size_t initial_allocation = 32 * 1024; /* initial size for response buffer */\n  struct MHD_Response *response;\n  struct ResponseDataContext rdc;\n  unsigned int language_idx;\n  unsigned int category_idx;\n  const struct Language *language;\n  const char *category;\n  char dir_name[128];\n  struct stat sbuf;\n  int res;\n  size_t len;\n\n  if (log != NULL)\n  {\n    fprintf(log, \"update_directory start\\n\");\n  }\n\n  rdc.buf_len = initial_allocation;\n  if (NULL == (rdc.buf = malloc(rdc.buf_len)))\n  {\n    if (log != NULL)\n      fprintf(log, \"malloc failed, returning early\\n\");\n    update_cached_response(NULL);\n    if (log != NULL)\n      fclose(log);\n    return;\n  }\n\n  len = strlen(INDEX_PAGE_HEADER);\n  if (rdc.buf_len <= len)\n  { /* buffer too small */\n    free(rdc.buf);\n    update_cached_response(NULL);\n    if (log != NULL)\n    {\n      fprintf(log, \"buffer too small for header, returning early\\n\");\n      fclose(log);\n    }\n    return;\n  }\n\n  memcpy(rdc.buf, INDEX_PAGE_HEADER, len);\n  rdc.off = len;\n\n  for (language_idx = 0; NULL != languages[language_idx].dirname; language_idx++)\n  {\n    language = &languages[language_idx];\n    if (log != NULL)\n      fprintf(log, \"Processing language: %s\\n\", language->dirname);\n\n    if (0 != stat(language->dirname, &sbuf))\n    {\n      if (log != NULL)\n        fprintf(log, \"stat failed on %s, skipping\\n\", language->dirname);\n      continue; /* empty */\n    }\n\n    res = snprintf(&rdc.buf[rdc.off], rdc.buf_len - rdc.off, \"<h2>%s</h2>\\n\", language->longname);\n    if (0 > res || rdc.buf_len - rdc.off <= (size_t)res)\n    {\n      if (log != NULL)\n        fprintf(log, \"snprintf error or buffer too small for language header\\n\");\n      continue;\n    }\n\n    rdc.off += (size_t)res;\n\n    for (category_idx = 0; NULL != categories[category_idx]; category_idx++)\n    {\n      category = categories[category_idx];\n      res = snprintf(dir_name, sizeof(dir_name), \"%s/%s\", language->dirname, category);\n      if ((0 > res) || (sizeof(dir_name) <= (size_t)res))\n      {\n        if (log != NULL)\n          fprintf(log, \"dir_name snprintf error for category %s\\n\", category);\n        continue;  /* cannot print dir name */\n      }\n\n      if (0 != stat(dir_name, &sbuf))\n      {\n        if (log != NULL)\n          fprintf(log, \"stat failed on dir %s, skipping\\n\", dir_name);\n        continue;  /* empty */\n      }\n\n      res = snprintf(&rdc.buf[rdc.off], rdc.buf_len - rdc.off, \"<h3>%s</h3>\\n\", category);\n      if (0 > res || rdc.buf_len - rdc.off <= (size_t)res)\n      {\n        if (log != NULL)\n          fprintf(log, \"snprintf error or buffer too small for category header\\n\");\n        continue;  /* snprintf() error or buffer too small?? */\n      }\n      rdc.off += (size_t)res;\n\n      if (MHD_NO == list_directory(&rdc, dir_name))\n      {\n        free(rdc.buf);\n        update_cached_response(NULL);\n        if (log != NULL)\n        {\n          fprintf(log, \"list_directory failed on %s, returning early\\n\", dir_name);\n          fclose(log);\n        }\n        return;\n      }\n    }\n  }\n\n  len = strlen(INDEX_PAGE_FOOTER);\n  if (rdc.buf_len - rdc.off <= len)\n  { /* buffer too small */\n    free(rdc.buf);\n    update_cached_response(NULL);\n    if (log != NULL)\n    {\n      fprintf(log, \"buffer too small for footer, returning early\\n\");\n      fclose(log);\n    }\n    return;\n  }\n\n  memcpy(&rdc.buf[rdc.off], INDEX_PAGE_FOOTER, len);\n  rdc.off += len;\n  initial_allocation = rdc.buf_len; /* remember for next time */\n  response = MHD_create_response_from_buffer_with_free_callback(rdc.off, rdc.buf, free);\n  mark_as_html(response);\n\n#ifdef FORCE_CLOSE\n  if (log != NULL)\n    fprintf(log, \"FORCE_CLOSE is defined, adding close header\\n\");\n  (void) MHD_add_response_header(response, MHD_HTTP_HEADER_CONNECTION, \"close\");\n#endif\n\n  update_cached_response(response);\n\n  if (log != NULL)\n  {\n    fprintf(log, \"update_directory completed successfully\\n\");\n    fclose(log);\n  }\n}\n\n```\nThe test code failed to compile, so we could not obtain any output.\n\n</test_code>\n<response format>\nProvide your answer with these fields.\n- explanation: your evaluation of the scenario provided by the agent A.\n- is_report_correct: whether the report is correct or not (true/false)\n</response format>\n<instruction>   \nJudge whether the report is correct or not.\n</instruction>\n",
  "is_report_correct": false,
  "explanation": "MISRA C 2023 Rule 1.2 states that language extensions should not be used, specifically prohibiting compiler-specific language extensions beyond standard C. The usage of conditional compilation (#ifdef FORCE_CLOSE) is a standard feature of the C preprocessor, which is part of standard C language and not considered a compiler language extension. The macro FORCE_CLOSE is likely defined via compilation options or earlier in the code, but conditional compilation itself is standard C. The agent A's claim that the use of the FORCE_CLOSE macro and its conditional compilation is a language extension violating Rule 1.2 is incorrect. Therefore, this code does not violate MISRA C 2023 Rule 1.2 by virtue of conditional compilation or the FORCE_CLOSE macro. The test code provided failing to compile does not affect the determination that the original code does not use language extensions as per MISRA C 2023 Rule 1.2."
}