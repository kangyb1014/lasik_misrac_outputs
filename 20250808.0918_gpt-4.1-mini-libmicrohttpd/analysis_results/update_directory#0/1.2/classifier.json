{
  "user_message": "<misra_rule>\nMISRA C 2023 Rule 1.2 is: Language extensions should not be used.\nYou should report only when the code uses any language compiler extensions that are explicitly stated as an extension in compiler documentations.\n</misra_rule>\n<response format>\nProvide your answer with these fields.\n- is_rule_violated: whether the rule is violated or not (true/false),\n- scenario: a specific violation scenario.\n- test_code: a modified update_directory code that contains useful probe functions that print useful logs to a file \"/tmp/logs/0.txt\". The logs should contain the control path and state information of the violation scenario. If the MISRA C rule is not violated, you can just return an empty string for the test code.\nHere are the constraints for the test code:\n- DO NOT introduce new violations to demonstrate your scenario.\n- The test code MUST be compilable and executable.\n- The test code MUST include line breaks.\n- The test code MUST preserve the original logic of update_directory as much as possible.\n- You MUST NOT define the main function.\n- You MUST NOT define macros.\n- The test code MUST not contain any mock functions.\n</response format>\n<target_code>\nHere is the code of update_directory:\n```c\nstatic void\nupdate_directory (void)\n{\n  static size_t initial_allocation = 32 * 1024; /* initial size for response buffer */\n  struct MHD_Response *response;\n  struct ResponseDataContext rdc;\n  unsigned int language_idx;\n  unsigned int category_idx;\n  const struct Language *language;\n  const char *category;\n  char dir_name[128];\n  struct stat sbuf;\n  int res;\n  size_t len;\n\n  rdc.buf_len = initial_allocation;\n  if (NULL == (rdc.buf = malloc (rdc.buf_len)))\n  {\n    update_cached_response (NULL);\n    return;\n  }\n  len = strlen (INDEX_PAGE_HEADER);\n  if (rdc.buf_len <= len)\n  { /* buffer too small */\n    free (rdc.buf);\n    update_cached_response (NULL);\n    return;\n  }\n  memcpy (rdc.buf, INDEX_PAGE_HEADER, len);\n  rdc.off = len;\n  for (language_idx = 0; NULL != languages[language_idx].dirname;\n       language_idx++)\n  {\n    language = &languages[language_idx];\n\n    if (0 != stat (language->dirname, &sbuf))\n      continue; /* empty */\n    /* we ensured always +1k room, filenames are ~256 bytes,\n       so there is always still enough space for the header\n       without need for an additional reallocation check. */\n    res = snprintf (&rdc.buf[rdc.off], rdc.buf_len - rdc.off,\n                    \"<h2>%s</h2>\\n\",\n                    language->longname);\n    if (0 >= res)\n      continue;  /* snprintf() error */\n    if (rdc.buf_len - rdc.off <= (size_t) res)\n      continue;  /* buffer too small?? */\n    rdc.off += (size_t) res;\n    for (category_idx = 0; NULL != categories[category_idx]; category_idx++)\n    {\n      category = categories[category_idx];\n      res = snprintf (dir_name, sizeof (dir_name),\n                      \"%s/%s\",\n                      language->dirname,\n                      category);\n      if ((0 >= res) || (sizeof (dir_name) <= (size_t) res))\n        continue;  /* cannot print dir name */\n      if (0 != stat (dir_name, &sbuf))\n        continue;  /* empty */\n\n      /* we ensured always +1k room, filenames are ~256 bytes,\n         so there is always still enough space for the header\n         without need for an additional reallocation check. */\n      res = snprintf (&rdc.buf[rdc.off], rdc.buf_len - rdc.off,\n                      \"<h3>%s</h3>\\n\",\n                      category);\n      if (0 >= res)\n        continue;  /* snprintf() error */\n      if (rdc.buf_len - rdc.off <= (size_t) res)\n        continue;  /* buffer too small?? */\n      rdc.off += (size_t) res;\n\n      if (MHD_NO == list_directory (&rdc, dir_name))\n      {\n        free (rdc.buf);\n        update_cached_response (NULL);\n        return;\n      }\n    }\n  }\n  /* we ensured always +1k room, filenames are ~256 bytes,\n     so there is always still enough space for the footer\n     without need for a final reallocation check. */\n  len = strlen (INDEX_PAGE_FOOTER);\n  if (rdc.buf_len - rdc.off <= len)\n  { /* buffer too small */\n    free (rdc.buf);\n    update_cached_response (NULL);\n    return;\n  }\n  memcpy (rdc.buf, INDEX_PAGE_FOOTER, len);\n  rdc.off += len;\n  initial_allocation = rdc.buf_len; /* remember for next time */\n  response =\n    MHD_create_response_from_buffer_with_free_callback (rdc.off,\n                                                        rdc.buf,\n                                                        &free);\n  mark_as_html (response);\n#ifdef FORCE_CLOSE\n  (void) MHD_add_response_header (response,\n                                  MHD_HTTP_HEADER_CONNECTION,\n                                  \"close\");\n#endif\n  update_cached_response (response);\n}\n```\n</target_code>\n<additional code>Here are the definitions of symbols that are close to the target function update_directory:\nstatic void\nupdate_cached_response (struct MHD_Response *response)\n{\n  (void) pthread_mutex_lock (&mutex);\n  if (NULL != cached_directory_response)\n    MHD_destroy_response (cached_directory_response);\n  cached_directory_response = response;\n  (void) pthread_mutex_unlock (&mutex);\n}\n...\nstatic enum MHD_Result\nlist_directory (struct ResponseDataContext *rdc,\n                const char *dirname)\n{\n  char fullname[PATH_MAX];\n  struct stat sbuf;\n  DIR *dir;\n  struct dirent *de;\n\n  if (NULL == (dir = opendir (dirname)))\n    return MHD_NO;\n  while (NULL != (de = readdir (dir)))\n  {\n    int res;\n    if ('.' == de->d_name[0])\n      continue;\n    if (sizeof (fullname) <= (unsigned int)\n        snprintf (fullname, sizeof (fullname),\n                  \"%s/%s\",\n                  dirname, de->d_name))\n      continue;  /* ugh, file too long? how can this be!? */\n    if (0 != stat (fullname, &sbuf))\n      continue;  /* ugh, failed to 'stat' */\n    if (! S_ISREG (sbuf.st_mode))\n      continue;  /* not a regular file, skip */\n    if (rdc->off + 1024 > rdc->buf_len)\n    {\n      void *r;\n\n      if ( (2 * rdc->buf_len + 1024) < rdc->buf_len)\n        break; /* more than SIZE_T _index_ size? Too big for us */\n      rdc->buf_len = 2 * rdc->buf_len + 1024;\n      if (NULL == (r = realloc (rdc->buf, rdc->buf_len)))\n        break; /* out of memory */\n      rdc->buf = r;\n    }\n    res = snprintf (&rdc->buf[rdc->off],\n                    rdc->buf_len - rdc->off,\n                    \"<li><a href=\\\"/%s\\\">%s</a></li>\\n\",\n                    fullname,\n                    de->d_name);\n    if (0 >= res)\n      continue;  /* snprintf() error */\n    if (rdc->buf_len - rdc->off <= (size_t) res)\n      continue;  /* buffer too small?? */\n    rdc->off += (size_t) res;\n  }\n  (void) closedir (dir);\n  return MHD_YES;\n}\n...\n_MHD_EXTERN struct MHD_Response *\nMHD_create_response_from_buffer_with_free_callback (size_t size,\n                                                    void *buffer,\n                                                    MHD_ContentReaderFreeCallback\n                                                    crfc)\n{\n  return MHD_create_response_from_buffer_with_free_callback_cls (size,\n                                                                 buffer,\n                                                                 crfc,\n                                                                 buffer);\n}\n...\nstatic void\nmark_as_html (struct MHD_Response *response)\n{\n  (void) MHD_add_response_header (response,\n                                  MHD_HTTP_HEADER_CONTENT_TYPE,\n                                  \"text/html\");\n}\n</additional code>\nJudge whether the above update_directory code violates the rule 1.2 or not.",
  "is_rule_violated": true,
  "scenario": "Use of conditional compilation with FORCE_CLOSE macro is a language extension that may rely on compiler-specific preprocessor behavior; if FORCE_CLOSE is not defined by standard C, its use represents a language extension violating MISRA C 2023 Rule 1.2.",
  "test_code": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <sys/stat.h>\n#include <pthread.h>\n#include <microhttpd.h>\n\nstatic void update_cached_response(struct MHD_Response *response);\nenum MHD_Result list_directory(struct ResponseDataContext *rdc, const char *dirname);\nvoid mark_as_html(struct MHD_Response *response);\n\nstatic void\nupdate_directory(void)\n{\n  FILE *log = fopen(\"/tmp/logs/0.txt\", \"a\");\n  static size_t initial_allocation = 32 * 1024; /* initial size for response buffer */\n  struct MHD_Response *response;\n  struct ResponseDataContext rdc;\n  unsigned int language_idx;\n  unsigned int category_idx;\n  const struct Language *language;\n  const char *category;\n  char dir_name[128];\n  struct stat sbuf;\n  int res;\n  size_t len;\n\n  if (log != NULL)\n  {\n    fprintf(log, \"update_directory start\\n\");\n  }\n\n  rdc.buf_len = initial_allocation;\n  if (NULL == (rdc.buf = malloc(rdc.buf_len)))\n  {\n    if (log != NULL)\n      fprintf(log, \"malloc failed, returning early\\n\");\n    update_cached_response(NULL);\n    if (log != NULL)\n      fclose(log);\n    return;\n  }\n\n  len = strlen(INDEX_PAGE_HEADER);\n  if (rdc.buf_len <= len)\n  { /* buffer too small */\n    free(rdc.buf);\n    update_cached_response(NULL);\n    if (log != NULL)\n    {\n      fprintf(log, \"buffer too small for header, returning early\\n\");\n      fclose(log);\n    }\n    return;\n  }\n\n  memcpy(rdc.buf, INDEX_PAGE_HEADER, len);\n  rdc.off = len;\n\n  for (language_idx = 0; NULL != languages[language_idx].dirname; language_idx++)\n  {\n    language = &languages[language_idx];\n    if (log != NULL)\n      fprintf(log, \"Processing language: %s\\n\", language->dirname);\n\n    if (0 != stat(language->dirname, &sbuf))\n    {\n      if (log != NULL)\n        fprintf(log, \"stat failed on %s, skipping\\n\", language->dirname);\n      continue; /* empty */\n    }\n\n    res = snprintf(&rdc.buf[rdc.off], rdc.buf_len - rdc.off, \"<h2>%s</h2>\\n\", language->longname);\n    if (0 >= res || rdc.buf_len - rdc.off <= (size_t)res)\n    {\n      if (log != NULL)\n        fprintf(log, \"snprintf error or buffer too small for language header\\n\");\n      continue;\n    }\n\n    rdc.off += (size_t)res;\n\n    for (category_idx = 0; NULL != categories[category_idx]; category_idx++)\n    {\n      category = categories[category_idx];\n      res = snprintf(dir_name, sizeof(dir_name), \"%s/%s\", language->dirname, category);\n      if ((0 >= res) || (sizeof(dir_name) <= (size_t)res))\n      {\n        if (log != NULL)\n          fprintf(log, \"dir_name snprintf error for category %s\\n\", category);\n        continue;  /* cannot print dir name */\n      }\n\n      if (0 != stat(dir_name, &sbuf))\n      {\n        if (log != NULL)\n          fprintf(log, \"stat failed on dir %s, skipping\\n\", dir_name);\n        continue;  /* empty */\n      }\n\n      res = snprintf(&rdc.buf[rdc.off], rdc.buf_len - rdc.off, \"<h3>%s</h3>\\n\", category);\n      if (0 >= res || rdc.buf_len - rdc.off <= (size_t)res)\n      {\n        if (log != NULL)\n          fprintf(log, \"snprintf error or buffer too small for category header\\n\");\n        continue;  /* snprintf() error or buffer too small?? */\n      }\n      rdc.off += (size_t)res;\n\n      if (MHD_NO == list_directory(&rdc, dir_name))\n      {\n        free(rdc.buf);\n        update_cached_response(NULL);\n        if (log != NULL)\n        {\n          fprintf(log, \"list_directory failed on %s, returning early\\n\", dir_name);\n          fclose(log);\n        }\n        return;\n      }\n    }\n  }\n\n  len = strlen(INDEX_PAGE_FOOTER);\n  if (rdc.buf_len - rdc.off <= len)\n  { /* buffer too small */\n    free(rdc.buf);\n    update_cached_response(NULL);\n    if (log != NULL)\n    {\n      fprintf(log, \"buffer too small for footer, returning early\\n\");\n      fclose(log);\n    }\n    return;\n  }\n\n  memcpy(&rdc.buf[rdc.off], INDEX_PAGE_FOOTER, len);\n  rdc.off += len;\n  initial_allocation = rdc.buf_len; /* remember for next time */\n  response = MHD_create_response_from_buffer_with_free_callback(rdc.off, rdc.buf, &free);\n  mark_as_html(response);\n\n#ifdef FORCE_CLOSE\n  if (log != NULL)\n    fprintf(log, \"FORCE_CLOSE is defined, adding close header\\n\");\n  (void) MHD_add_response_header(response, MHD_HTTP_HEADER_CONNECTION, \"close\");\n#endif\n\n  update_cached_response(response);\n\n  if (log != NULL)\n  {\n    fprintf(log, \"update_directory completed successfully\\n\");\n    fclose(log);\n  }\n}\n"
}