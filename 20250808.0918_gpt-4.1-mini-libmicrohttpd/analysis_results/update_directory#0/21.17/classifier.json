{
  "user_message": "<misra_rule>\nMISRA C 2023 Rule 21.17 is: Use of the string handling functions from <string.h> shall not result in accesses beyond the bounds of the objects referenced by their pointer parameters.\nThis rule strictly applies to the Standard Library functions in <string.h> such as memcpy, memmove, memset, memcmp, strcpy, strncpy, strcat, strncat, strlen, and strspn.\n</misra_rule>\n<response format>\nProvide your answer with these fields.\n- is_rule_violated: whether the rule is violated or not (true/false),\n- scenario: a specific violation scenario.\n- test_code: a modified update_directory code that contains useful probe functions that print useful logs to a file \"/tmp/logs/7.txt\". The logs should contain the control path and state information of the violation scenario. If the MISRA C rule is not violated, you can just return an empty string for the test code.\nHere are the constraints for the test code:\n- DO NOT introduce new violations to demonstrate your scenario.\n- The test code MUST be compilable and executable.\n- The test code MUST include line breaks.\n- The test code MUST preserve the original logic of update_directory as much as possible.\n- You MUST NOT define the main function.\n- You MUST NOT define macros.\n- The test code MUST not contain any mock functions.\n</response format>\n<target_code>\nHere is the code of update_directory:\n```c\nstatic void\nupdate_directory (void)\n{\n  static size_t initial_allocation = 32 * 1024; /* initial size for response buffer */\n  struct MHD_Response *response;\n  struct ResponseDataContext rdc;\n  unsigned int language_idx;\n  unsigned int category_idx;\n  const struct Language *language;\n  const char *category;\n  char dir_name[128];\n  struct stat sbuf;\n  int res;\n  size_t len;\n\n  rdc.buf_len = initial_allocation;\n  if (NULL == (rdc.buf = malloc (rdc.buf_len)))\n  {\n    update_cached_response (NULL);\n    return;\n  }\n  len = strlen (INDEX_PAGE_HEADER);\n  if (rdc.buf_len <= len)\n  { /* buffer too small */\n    free (rdc.buf);\n    update_cached_response (NULL);\n    return;\n  }\n  memcpy (rdc.buf, INDEX_PAGE_HEADER, len);\n  rdc.off = len;\n  for (language_idx = 0; NULL != languages[language_idx].dirname;\n       language_idx++)\n  {\n    language = &languages[language_idx];\n\n    if (0 != stat (language->dirname, &sbuf))\n      continue; /* empty */\n    /* we ensured always +1k room, filenames are ~256 bytes,\n       so there is always still enough space for the header\n       without need for an additional reallocation check. */\n    res = snprintf (&rdc.buf[rdc.off], rdc.buf_len - rdc.off,\n                    \"<h2>%s</h2>\\n\",\n                    language->longname);\n    if (0 >= res)\n      continue;  /* snprintf() error */\n    if (rdc.buf_len - rdc.off <= (size_t) res)\n      continue;  /* buffer too small?? */\n    rdc.off += (size_t) res;\n    for (category_idx = 0; NULL != categories[category_idx]; category_idx++)\n    {\n      category = categories[category_idx];\n      res = snprintf (dir_name, sizeof (dir_name),\n                      \"%s/%s\",\n                      language->dirname,\n                      category);\n      if ((0 >= res) || (sizeof (dir_name) <= (size_t) res))\n        continue;  /* cannot print dir name */\n      if (0 != stat (dir_name, &sbuf))\n        continue;  /* empty */\n\n      /* we ensured always +1k room, filenames are ~256 bytes,\n         so there is always still enough space for the header\n         without need for an additional reallocation check. */\n      res = snprintf (&rdc.buf[rdc.off], rdc.buf_len - rdc.off,\n                      \"<h3>%s</h3>\\n\",\n                      category);\n      if (0 >= res)\n        continue;  /* snprintf() error */\n      if (rdc.buf_len - rdc.off <= (size_t) res)\n        continue;  /* buffer too small?? */\n      rdc.off += (size_t) res;\n\n      if (MHD_NO == list_directory (&rdc, dir_name))\n      {\n        free (rdc.buf);\n        update_cached_response (NULL);\n        return;\n      }\n    }\n  }\n  /* we ensured always +1k room, filenames are ~256 bytes,\n     so there is always still enough space for the footer\n     without need for a final reallocation check. */\n  len = strlen (INDEX_PAGE_FOOTER);\n  if (rdc.buf_len - rdc.off <= len)\n  { /* buffer too small */\n    free (rdc.buf);\n    update_cached_response (NULL);\n    return;\n  }\n  memcpy (rdc.buf, INDEX_PAGE_FOOTER, len);\n  rdc.off += len;\n  initial_allocation = rdc.buf_len; /* remember for next time */\n  response =\n    MHD_create_response_from_buffer_with_free_callback (rdc.off,\n                                                        rdc.buf,\n                                                        &free);\n  mark_as_html (response);\n#ifdef FORCE_CLOSE\n  (void) MHD_add_response_header (response,\n                                  MHD_HTTP_HEADER_CONNECTION,\n                                  \"close\");\n#endif\n  update_cached_response (response);\n}\n```\n</target_code>\n<additional code>Here are the definitions of symbols that are close to the target function update_directory:\nstatic const struct Language languages[] = {\n  { \"no-lang\", \"No language specified\" },\n  { \"en\", \"English\" },\n  { \"de\", \"German\" },\n  { \"fr\", \"French\" },\n  { \"es\", \"Spanish\" },\n  { NULL, NULL },\n}\n...\nstatic const char *const categories[] = {\n  \"books\",\n  \"images\",\n  \"music\",\n  \"software\",\n  \"videos\",\n  \"other\",\n  NULL,\n}\n...\n#define INDEX_PAGE_HEADER \"<html>\\n<head><title>Welcome</title></head>\\n<body>\\n\"\"<h1>Upload</h1>\\n\"\"<form method=\\\"POST\\\" enctype=\\\"multipart/form-data\\\" action=\\\"/\\\">\\n\"\"<dl><dt>Content type:</dt><dd>\"\"<input type=\\\"radio\\\" name=\\\"category\\\" value=\\\"books\\\">Book</input>\"\"<input type=\\\"radio\\\" name=\\\"category\\\" value=\\\"images\\\">Image</input>\"\"<input type=\\\"radio\\\" name=\\\"category\\\" value=\\\"music\\\">Music</input>\"\"<input type=\\\"radio\\\" name=\\\"category\\\" value=\\\"software\\\">Software</input>\"\"<input type=\\\"radio\\\" name=\\\"category\\\" value=\\\"videos\\\">Videos</input>\\n\"\"<input type=\\\"radio\\\" name=\\\"category\\\" value=\\\"other\\\" checked>Other</input></dd>\"\"<dt>Language:</dt><dd>\"\"<input type=\\\"radio\\\" name=\\\"language\\\" value=\\\"no-lang\\\" checked>none</input>\"\"<input type=\\\"radio\\\" name=\\\"language\\\" value=\\\"en\\\">English</input>\"\"<input type=\\\"radio\\\" name=\\\"language\\\" value=\\\"de\\\">German</input>\"\"<input type=\\\"radio\\\" name=\\\"language\\\" value=\\\"fr\\\">French</input>\"\"<input type=\\\"radio\\\" name=\\\"language\\\" value=\\\"es\\\">Spanish</input></dd>\\n\"\"<dt>File:</dt><dd>\"\"<input type=\\\"file\\\" name=\\\"upload\\\"/></dd></dl>\"\"<input type=\\\"submit\\\" value=\\\"Send!\\\"/>\\n\"\"</form>\\n\"\"<h1>Download</h1>\\n\"\"<ol>\\n\"\n...\n#define INDEX_PAGE_FOOTER \"</ol>\\n</body>\\n</html>\"\n...\nstruct ResponseDataContext\n{\n  /**\n   * Response data string.\n   */\n  char *buf;\n\n  /**\n   * Number of bytes allocated for 'buf'.\n   */\n  size_t buf_len;\n\n  /**\n   * Current position where we append to 'buf'. Must be smaller or equal to 'buf_len'.\n   */\n  size_t off;\n\n}\n...\nstatic void\nupdate_cached_response (struct MHD_Response *response)\n{\n  (void) pthread_mutex_lock (&mutex);\n  if (NULL != cached_directory_response)\n    MHD_destroy_response (cached_directory_response);\n  cached_directory_response = response;\n  (void) pthread_mutex_unlock (&mutex);\n}\n...\nstatic enum MHD_Result\nlist_directory (struct ResponseDataContext *rdc,\n                const char *dirname)\n{\n  char fullname[PATH_MAX];\n  struct stat sbuf;\n  DIR *dir;\n  struct dirent *de;\n\n  if (NULL == (dir = opendir (dirname)))\n    return MHD_NO;\n  while (NULL != (de = readdir (dir)))\n  {\n    int res;\n    if ('.' == de->d_name[0])\n      continue;\n    if (sizeof (fullname) <= (unsigned int)\n        snprintf (fullname, sizeof (fullname),\n                  \"%s/%s\",\n                  dirname, de->d_name))\n      continue;  /* ugh, file too long? how can this be!? */\n    if (0 != stat (fullname, &sbuf))\n      continue;  /* ugh, failed to 'stat' */\n    if (! S_ISREG (sbuf.st_mode))\n      continue;  /* not a regular file, skip */\n    if (rdc->off + 1024 > rdc->buf_len)\n    {\n      void *r;\n\n      if ( (2 * rdc->buf_len + 1024) < rdc->buf_len)\n        break; /* more than SIZE_T _index_ size? Too big for us */\n      rdc->buf_len = 2 * rdc->buf_len + 1024;\n      if (NULL == (r = realloc (rdc->buf, rdc->buf_len)))\n        break; /* out of memory */\n      rdc->buf = r;\n    }\n    res = snprintf (&rdc->buf[rdc->off],\n                    rdc->buf_len - rdc->off,\n                    \"<li><a href=\\\"/%s\\\">%s</a></li>\\n\",\n                    fullname,\n                    de->d_name);\n    if (0 >= res)\n      continue;  /* snprintf() error */\n    if (rdc->buf_len - rdc->off <= (size_t) res)\n      continue;  /* buffer too small?? */\n    rdc->off += (size_t) res;\n  }\n  (void) closedir (dir);\n  return MHD_YES;\n}\n...\n_MHD_EXTERN struct MHD_Response *\nMHD_create_response_from_buffer_with_free_callback (size_t size,\n                                                    void *buffer,\n                                                    MHD_ContentReaderFreeCallback\n                                                    crfc)\n{\n  return MHD_create_response_from_buffer_with_free_callback_cls (size,\n                                                                 buffer,\n                                                                 crfc,\n                                                                 buffer);\n}\n...\nstatic void\nmark_as_html (struct MHD_Response *response)\n{\n  (void) MHD_add_response_header (response,\n                                  MHD_HTTP_HEADER_CONTENT_TYPE,\n                                  \"text/html\");\n}\n</additional code>\nJudge whether the above update_directory code violates the rule 21.17 or not.",
  "is_rule_violated": true,
  "scenario": "In the final part of the function, the code uses memcpy to copy INDEX_PAGE_FOOTER into rdc.buf without ensuring that the destination buffer has enough space to accommodate the footer. The condition checks if (rdc.buf_len - rdc.off <= len), and if true, it frees the buffer and returns. But then memcpy(rdc.buf, INDEX_PAGE_FOOTER, len) is called unconditionally, copying into rdc.buf starting at offset zero, overwriting the beginning of the buffer, which is likely unintended and may cause out-of-bounds write if len is larger than buffer length or not consistent with the actual buffer contents. Moreover, the memcpy overwrites the buffer from the beginning rather than from the offset, probably causing invalid memory accesses beyond the intended buffer area. This constitutes a violation of Rule 21.17 because accesses beyond the bounds of the object referenced by memcpy parameters may occur.",
  "test_code": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <sys/stat.h>\n\nstatic const struct Language {\n  const char *dirname;\n  const char *longname;\n} languages[] = {\n  { \"no-lang\", \"No language specified\" },\n  { \"en\", \"English\" },\n  { NULL, NULL },\n};\n\nstatic const char *const categories[] = {\n  \"books\",\n  \"images\",\n  NULL,\n};\n\n#define INDEX_PAGE_HEADER \"<html>HEADER\"\n#define INDEX_PAGE_FOOTER \"<footer>FOOTER\"\n\nstruct ResponseDataContext\n{\n  char *buf;\n  size_t buf_len;\n  size_t off;\n};\n\nstatic void update_cached_response (void *response) { (void)response; }\nstatic int list_directory (struct ResponseDataContext *rdc, const char *dirname) { (void)rdc; (void)dirname; return 1; }\nstatic void mark_as_html (void *response) { (void)response; }\n\nstatic void update_directory (void)\n{\n  static size_t initial_allocation = 32 * 1024;\n  struct ResponseDataContext rdc;\n  unsigned int language_idx;\n  unsigned int category_idx;\n  const struct Language *language;\n  const char *category;\n  char dir_name[128];\n  struct stat sbuf;\n  int res;\n  size_t len;\n  FILE *log = fopen(\"/tmp/logs/7.txt\", \"w\");\n\n  rdc.buf_len = initial_allocation;\n  rdc.buf = malloc (rdc.buf_len);\n  if (NULL == rdc.buf)\n  {\n    fprintf(log, \"malloc failed\\n\");\n    update_cached_response (NULL);\n    fclose(log);\n    return;\n  }\n\n  len = strlen (INDEX_PAGE_HEADER);\n  if (rdc.buf_len <= len)\n  {\n    fprintf(log, \"buffer too small for header: buf_len=%zu len=%zu\\n\", rdc.buf_len, len);\n    free (rdc.buf);\n    update_cached_response (NULL);\n    fclose(log);\n    return;\n  }\n  memcpy (rdc.buf, INDEX_PAGE_HEADER, len);\n  rdc.off = len;\n  fprintf(log, \"Copied header, off=%zu len=%zu\\n\", rdc.off, len);\n\n  for (language_idx = 0; NULL != languages[language_idx].dirname; language_idx++)\n  {\n    language = &languages[language_idx];\n    fprintf(log, \"Processing language: %s\\n\", language->dirname);\n\n    if (0 != stat (language->dirname, &sbuf))\n    {\n      fprintf(log, \"stat failed for %s\\n\", language->dirname);\n      continue;\n    }\n\n    res = snprintf (&rdc.buf[rdc.off], rdc.buf_len - rdc.off,\n                    \"<h2>%s</h2>\\n\",\n                    language->longname);\n    if (0 >= res)\n    {\n      fprintf(log, \"snprintf error for language header\\n\");\n      continue;\n    }\n    if (rdc.buf_len - rdc.off <= (size_t) res)\n    {\n      fprintf(log, \"buffer too small for language header\\n\");\n      continue;\n    }\n    rdc.off += (size_t) res;\n\n    for (category_idx = 0; NULL != categories[category_idx]; category_idx++)\n    {\n      category = categories[category_idx];\n      res = snprintf (dir_name, sizeof (dir_name), \"%s/%s\", language->dirname, category);\n      if ((0 >= res) || (sizeof (dir_name) <= (size_t) res))\n      {\n        fprintf(log, \"Cannot print dir name: %s/%s\\n\", language->dirname, category);\n        continue;\n      }\n      if (0 != stat (dir_name, &sbuf))\n      {\n        fprintf(log, \"stat failed for %s\\n\", dir_name);\n        continue;\n      }\n\n      res = snprintf (&rdc.buf[rdc.off], rdc.buf_len - rdc.off, \"<h3>%s</h3>\\n\", category);\n      if (0 >= res)\n      {\n        fprintf(log, \"snprintf error for category header\\n\");\n        continue;\n      }\n      if (rdc.buf_len - rdc.off <= (size_t) res)\n      {\n        fprintf(log, \"buffer too small for category header\\n\");\n        continue;\n      }\n      rdc.off += (size_t) res;\n\n      if (list_directory (&rdc, dir_name) == 0)\n      {\n        fprintf(log, \"list_directory failed for %s\\n\", dir_name);\n        free (rdc.buf);\n        update_cached_response (NULL);\n        fclose(log);\n        return;\n      }\n    }\n  }\n\n  len = strlen (INDEX_PAGE_FOOTER);\n  fprintf(log, \"CHECK footer space: buf_len=%zu off=%zu len=%zu\\n\", rdc.buf_len, rdc.off, len);\n  if (rdc.buf_len - rdc.off <= len)\n  {\n    fprintf(log, \"buffer too small for footer, freeing buffer\\n\");\n    free (rdc.buf);\n    update_cached_response (NULL);\n    fclose(log);\n    return;\n  }\n\n  fprintf(log, \"Copying footer at offset 0 instead of off %zu, len=%zu\\n\", rdc.off, len);\n  memcpy (rdc.buf, INDEX_PAGE_FOOTER, len);  /* Violation: overwrites from start */\n  rdc.off += len;\n\n  initial_allocation = rdc.buf_len;\n\n  /* Assume response creation and marking as HTML */\n  update_cached_response (NULL);\n  fclose(log);\n}\n"
}