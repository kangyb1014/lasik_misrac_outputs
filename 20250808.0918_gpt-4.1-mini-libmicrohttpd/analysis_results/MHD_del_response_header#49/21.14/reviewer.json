{
  "user_message": "An agent A claimed that the following MHD_del_response_header code violates the MISRA C 2023 rule 21.14.\n<misra_rule>\nMISRA C 2023 Rule 21.14 is The Standard Library function memcmp shall not be used to compare null terminated strings.\n.\n</misra_rule>\n<target_code>\nHere is the original code of MHD_del_response_header.\n```c\n_MHD_EXTERN enum MHD_Result\nMHD_del_response_header (struct MHD_Response *response,\n                         const char *header,\n                         const char *content)\n{\n  struct MHD_HTTP_Res_Header *pos;\n  size_t header_len;\n  size_t content_len;\n\n  if ( (NULL == header) ||\n       (NULL == content) )\n    return MHD_NO;\n  header_len = strlen (header);\n\n  if ((0 != (response->flags_auto & MHD_RAF_HAS_CONNECTION_HDR)) &&\n      (MHD_STATICSTR_LEN_ (MHD_HTTP_HEADER_CONNECTION) == header_len) &&\n      MHD_str_equal_caseless_bin_n_ (header, MHD_HTTP_HEADER_CONNECTION,\n                                     header_len))\n    return del_response_header_connection (response, content);\n\n  content_len = strlen (content);\n  pos = response->first_header;\n  while (NULL != pos)\n  {\n    if ((header_len == pos->header_size) &&\n        (content_len == pos->value_size) &&\n        (0 == memcmp (header,\n                      pos->header,\n                      header_len)) &&\n        (0 == memcmp (content,\n                      pos->value,\n                      content_len)))\n    {\n      _MHD_remove_header (response, pos);\n      free (pos->header);\n      free (pos->value);\n      free (pos);\n      if ( (MHD_STATICSTR_LEN_ (MHD_HTTP_HEADER_TRANSFER_ENCODING) ==\n            header_len) &&\n           MHD_str_equal_caseless_bin_n_ (header,\n                                          MHD_HTTP_HEADER_TRANSFER_ENCODING,\n                                          header_len) )\n        response->flags_auto &=\n          ~((enum MHD_ResponseAutoFlags) MHD_RAF_HAS_TRANS_ENC_CHUNKED);\n      else if ( (MHD_STATICSTR_LEN_ (MHD_HTTP_HEADER_DATE) ==\n                 header_len) &&\n                MHD_str_equal_caseless_bin_n_ (header,\n                                               MHD_HTTP_HEADER_DATE,\n                                               header_len) )\n        response->flags_auto &=\n          ~((enum MHD_ResponseAutoFlags) MHD_RAF_HAS_DATE_HDR);\n      else if ( (MHD_STATICSTR_LEN_ (MHD_HTTP_HEADER_CONTENT_LENGTH) ==\n                 header_len) &&\n                MHD_str_equal_caseless_bin_n_ (header,\n                                               MHD_HTTP_HEADER_CONTENT_LENGTH,\n                                               header_len) )\n      {\n        if (NULL == MHD_get_response_element_n_ (response,\n                                                 MHD_HEADER_KIND,\n                                                 MHD_HTTP_HEADER_CONTENT_LENGTH,\n                                                 header_len))\n          response->flags_auto &=\n            ~((enum MHD_ResponseAutoFlags) MHD_RAF_HAS_CONTENT_LENGTH);\n      }\n      return MHD_YES;\n    }\n    pos = pos->next;\n  }\n  return MHD_NO;\n}\n```\n</target_code>\n<scenario>\nThe agent A provided the following violation scenario:In the MHD_del_response_header function, the memcmp function is used to compare null terminated strings 'header' and 'content' against pos->header and pos->value respectively. Since these are null terminated strings, using memcmp violates MISRA C 2023 Rule 21.14 which prohibits using memcmp to compare null terminated strings.\n</scenario>\n<test_code>\nAlso, the agent A provided the following modified code that prints out the log to support their scenario:\n```c\n\n_MHD_EXTERN enum MHD_Result\nMHD_del_response_header (struct MHD_Response *response,\n                         const char *header,\n                         const char *content)\n{\n  FILE *log = fopen(\"/tmp/logs/398.txt\", \"a\");\n  struct MHD_HTTP_Res_Header *pos;\n  size_t header_len;\n  size_t content_len;\n\n  if (log) fprintf(log, \"Entered MHD_del_response_header\\n\");\n\n  if ((NULL == header) ||\n      (NULL == content))\n  {\n    if (log) fprintf(log, \"Null parameter detected\\n\");\n    if (log) fclose(log);\n    return MHD_NO;\n  }\n\n  header_len = strlen(header);\n  if (log) fprintf(log, \"header_len: %zu\\n\", header_len);\n\n  if ((0 != (response->flags_auto & MHD_RAF_HAS_CONNECTION_HDR)) &&\n      (MHD_STATICSTR_LEN_(MHD_HTTP_HEADER_CONNECTION) == header_len) &&\n      MHD_str_equal_caseless_bin_n_(header, MHD_HTTP_HEADER_CONNECTION, header_len))\n  {\n    if (log) fprintf(log, \"Calling del_response_header_connection\\n\");\n    if (log) fclose(log);\n    return del_response_header_connection(response, content);\n  }\n\n  content_len = strlen(content);\n  if (log) fprintf(log, \"content_len: %zu\\n\", content_len);\n\n  pos = response->first_header;\n  while (NULL != pos)\n  {\n    if ((header_len == pos->header_size) &&\n        (content_len == pos->value_size) &&\n        (0 == memcmp(header, pos->header, header_len)) &&\n        (0 == memcmp(content, pos->value, content_len)))\n    {\n      if (log) fprintf(log, \"Match found, removing header\\n\");\n      _MHD_remove_header(response, pos);\n\n      struct MHD_HTTP_Res_Header *to_free = pos;\n      pos = pos->next;\n\n      free(to_free->header);\n      free(to_free->value);\n      free(to_free);\n\n      if ((MHD_STATICSTR_LEN_(MHD_HTTP_HEADER_TRANSFER_ENCODING) == header_len) &&\n          MHD_str_equal_caseless_bin_n_(header, MHD_HTTP_HEADER_TRANSFER_ENCODING, header_len))\n      {\n        response->flags_auto &= ~((enum MHD_ResponseAutoFlags) MHD_RAF_HAS_TRANS_ENC_CHUNKED);\n        if (log) fprintf(log, \"Removed transfer encoding chunked flag\\n\");\n      }\n      else if ((MHD_STATICSTR_LEN_(MHD_HTTP_HEADER_DATE) == header_len) &&\n               MHD_str_equal_caseless_bin_n_(header, MHD_HTTP_HEADER_DATE, header_len))\n      {\n        response->flags_auto &= ~((enum MHD_ResponseAutoFlags) MHD_RAF_HAS_DATE_HDR);\n        if (log) fprintf(log, \"Removed date header flag\\n\");\n      }\n      else if ((MHD_STATICSTR_LEN_(MHD_HTTP_HEADER_CONTENT_LENGTH) == header_len) &&\n               MHD_str_equal_caseless_bin_n_(header, MHD_HTTP_HEADER_CONTENT_LENGTH, header_len))\n      {\n        if (NULL == MHD_get_response_element_n_(response, MHD_HEADER_KIND, MHD_HTTP_HEADER_CONTENT_LENGTH, header_len))\n        {\n          response->flags_auto &= ~((enum MHD_ResponseAutoFlags) MHD_RAF_HAS_CONTENT_LENGTH);\n          if (log) fprintf(log, \"Removed content length flag\\n\");\n        }\n      }\n      if (log) fclose(log);\n      return MHD_YES;\n    }\n    else\n    {\n      pos = pos->next;\n    }\n  }\n  if (log) fprintf(log, \"No matching header found\\n\");\n  if (log) fclose(log);\n  return MHD_NO;\n}\n\n```\nThe test code failed to compile, so we could not obtain any output.\n\n</test_code>\n<response format>\nProvide your answer with these fields.\n- explanation: your evaluation of the scenario provided by the agent A.\n- is_report_correct: whether the report is correct or not (true/false)\n</response format>\n<instruction>   \nJudge whether the report is correct or not.\n</instruction>\n",
  "is_report_correct": true,
  "explanation": "MISRA C 2023 Rule 21.14 states that the standard library function memcmp shall not be used to compare null terminated strings. In the provided code, memcmp is used as follows:\n\n    (0 == memcmp(header, pos->header, header_len)) &&\n    (0 == memcmp(content, pos->value, content_len))\n\nHere, header_len and content_len are obtained via strlen(header) and strlen(content), respectively. This indicates that header and content are null-terminated strings, and memcmp is used to compare the first header_len or content_len bytes.\n\nHowever, memcmp compares raw memory regions, not null-terminated strings per se. But since the length used for memcmp matches the length of the null-terminated strings, and the strings are null-terminated, memcmp is effectively used to compare null-terminated strings, not arbitrary buffers.\n\nAccording to MISRA C 2023 Rule 21.14, memcmp must not be used for comparing null terminated strings because functions like strcmp or strncmp are more appropriate and safer for this use case.\n\nTherefore, the agent A's report that the code violates MISRA C 2023 Rule 21.14 is correct.\n\nRegarding the test code, the failure to compile does not impact the validity of the rule violation found in the source code itself."
}