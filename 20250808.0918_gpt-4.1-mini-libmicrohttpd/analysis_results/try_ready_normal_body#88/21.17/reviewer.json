{
  "user_message": "An agent A claimed that the following try_ready_normal_body code violates the MISRA C 2023 rule 21.17.\n<misra_rule>\nMISRA C 2023 Rule 21.17 is Use of the string handling functions from <string.h> shall not result in accesses beyond the bounds of the objects referenced by their pointer parameters.\nThis rule strictly applies to the Standard Library functions in <string.h> such as memcpy, memmove, memset, memcmp, strcpy, strncpy, strcat, strncat, strlen, and strspn..\n</misra_rule>\n<target_code>\nHere is the original code of try_ready_normal_body.\n```c\nstatic enum MHD_Result\ntry_ready_normal_body (struct MHD_Connection *connection)\n{\n  ssize_t ret;\n  struct MHD_Response *response;\n\n  response = connection->rp.response;\n  mhd_assert (connection->rp.props.send_reply_body);\n\n  if ( (0 == response->total_size) ||\n                     /* TODO: replace the next check with assert */\n       (connection->rp.rsp_write_position == response->total_size) )\n    return MHD_YES;  /* 0-byte response is always ready */\n  if (NULL != response->data_iov)\n  {\n    size_t copy_size;\n\n    if (NULL != connection->rp.resp_iov.iov)\n      return MHD_YES;\n    copy_size = response->data_iovcnt * sizeof(MHD_iovec_);\n    connection->rp.resp_iov.iov = MHD_connection_alloc_memory_ (connection,\n                                                                copy_size);\n    if (NULL == connection->rp.resp_iov.iov)\n    {\n      MHD_mutex_unlock_chk_ (&response->mutex);\n      /* not enough memory */\n      CONNECTION_CLOSE_ERROR (connection,\n                              _ (\"Closing connection (out of memory).\"));\n      return MHD_NO;\n    }\n    memcpy (connection->rp.resp_iov.iov,\n            response->data_iov,\n            copy_size);\n    connection->rp.resp_iov.cnt = response->data_iovcnt;\n    connection->rp.resp_iov.sent = 0;\n    return MHD_YES;\n  }\n  if (NULL == response->crc)\n    return MHD_YES;\n  if ( (response->data_start <=\n        connection->rp.rsp_write_position) &&\n       (response->data_size + response->data_start >\n        connection->rp.rsp_write_position) )\n    return MHD_YES; /* response already ready */\n#if defined(_MHD_HAVE_SENDFILE)\n  if (MHD_resp_sender_sendfile == connection->rp.resp_sender)\n  {\n    /* will use sendfile, no need to bother response crc */\n    return MHD_YES;\n  }\n#endif /* _MHD_HAVE_SENDFILE */\n\n  ret = response->crc (response->crc_cls,\n                       connection->rp.rsp_write_position,\n                       (char *) response->data,\n                       (size_t) MHD_MIN ((uint64_t) response->data_buffer_size,\n                                         response->total_size\n                                         - connection->rp.rsp_write_position));\n  if (0 > ret)\n  {\n    /* either error or http 1.0 transfer, close socket! */\n    /* TODO: do not update total size, check whether response\n     * was really with unknown size */\n    response->total_size = connection->rp.rsp_write_position;\n#if defined(MHD_USE_POSIX_THREADS) || defined(MHD_USE_W32_THREADS)\n    MHD_mutex_unlock_chk_ (&response->mutex);\n#endif\n    if (MHD_CONTENT_READER_END_OF_STREAM == ret)\n      MHD_connection_close_ (connection,\n                             MHD_REQUEST_TERMINATED_COMPLETED_OK);\n    else\n      CONNECTION_CLOSE_ERROR (connection,\n                              _ (\"Closing connection (application reported \" \\\n                                 \"error generating data).\"));\n    return MHD_NO;\n  }\n  response->data_start = connection->rp.rsp_write_position;\n  response->data_size = (size_t) ret;\n  if (0 == ret)\n  {\n    connection->state = MHD_CONNECTION_NORMAL_BODY_UNREADY;\n#if defined(MHD_USE_POSIX_THREADS) || defined(MHD_USE_W32_THREADS)\n    MHD_mutex_unlock_chk_ (&response->mutex);\n#endif\n    return MHD_NO;\n  }\n  return MHD_YES;\n}\n```\n</target_code>\n<scenario>\nThe agent A provided the following violation scenario:The memcpy function is called with the source pointer connection->rp.response->data_iov and the size copy_size calculated as response->data_iovcnt * sizeof(MHD_iovec_). If response->data_iovcnt is incorrect (e.g., larger than the actual number of elements allocated in data_iov), this could cause memcpy to access beyond the bounds of data_iov, violating Rule 21.17.\n</scenario>\n<test_code>\nAlso, the agent A provided the following modified code that prints out the log to support their scenario:\n```c\nstruct {\n    struct MHD_iovec_ *iov;\n    size_t cnt;\n    size_t sent;\n} typedef MHD_RespIov;\nstruct RP {\n  struct MHD_Response *response;\n  bool send_reply_body;\n  MHD_RespIov resp_iov;\n  size_t rsp_write_position;\n  enum MHD_Result resp_sender;\n};\n\nstatic void *MHD_connection_alloc_memory_(struct MHD_Connection *connection, size_t size) {\n    (void)connection; // unused\n    return malloc(size);\n}\nstatic enum MHD_Result\ntry_ready_normal_body (struct MHD_Connection *connection)\n{\n  ssize_t ret UNUSED;\n  struct MHD_Response *response;\n\n  response = connection->rp.response;\n  if (!connection->rp.send_reply_body) return MHD_NO;\n\n  FILE *log = fopen(\"/tmp/logs/711.txt\", \"a\");\n  if (log)\n    fprintf(log, \"try_ready_normal_body start\\n\");\n\n  if ( (0 == response->total_size) ||\n       (connection->rp.rsp_write_position == response->total_size) )\n  {\n    if (log) {\n      fprintf(log, \"Zero byte or fully sent response; returning MHD_YES\\n\");\n      fclose(log);\n    }\n    return MHD_YES;  /* 0-byte response is always ready */\n  }\n\n  if (NULL != response->data_iov)\n  {\n    size_t copy_size;\n\n    if (NULL != connection->rp.resp_iov.iov)\n    {\n      if (log) {\n        fprintf(log, \"resp_iov.iov not NULL; returning MHD_YES\\n\");\n        fclose(log);\n      }\n      return MHD_YES;\n    }\n\n    copy_size = response->data_iovcnt * sizeof(struct MHD_iovec_);\n    if (log)\n      fprintf(log, \"Allocating memory for resp_iov.iov, size: %zu\\n\", copy_size);\n\n    connection->rp.resp_iov.iov = MHD_connection_alloc_memory_(connection, copy_size);\n    if (NULL == connection->rp.resp_iov.iov)\n    {\n      if (log) {\n        fprintf(log, \"Memory allocation failed, setting error flags and returning MHD_NO\\n\");\n        fclose(log);\n      }\n      /* not enough memory */\n      connection->stop_with_error = true;\n      connection->discard_request = true;\n      return MHD_NO;\n    }\n\n    if (log)\n      fprintf(log, \"Performing memcpy with copy_size: %zu\\n\", copy_size);\n\n    memcpy (connection->rp.resp_iov.iov, response->data_iov, copy_size);\n    connection->rp.resp_iov.cnt = response->data_iovcnt;\n    connection->rp.resp_iov.sent = 0;\n    if (log) {\n      fprintf(log, \"memcpy done, returning MHD_YES\\n\");\n      fclose(log);\n    }\n    return MHD_YES;\n  }\n\n  if (log) fclose(log);\n  return MHD_YES; // For simplicity in this test code\n}\n\n```\nThe test code failed to compile, so we could not obtain any output.\n\n</test_code>\n<response format>\nProvide your answer with these fields.\n- explanation: your evaluation of the scenario provided by the agent A.\n- is_report_correct: whether the report is correct or not (true/false)\n</response format>\n<instruction>   \nJudge whether the report is correct or not.\n</instruction>\n",
  "is_report_correct": true,
  "explanation": "The reported potential violation concerns the memcpy call copying data from response->data_iov to connection->rp.resp_iov.iov where the size is computed as response->data_iovcnt * sizeof(MHD_iovec_). According to MISRA C 2023 Rule 21.17, the string handling functions (including memcpy) shall not access beyond the bounds of the referenced objects. If response->data_iovcnt incorrectly specifies a size larger than the allocated memory region of data_iov, this could indeed lead to out-of-bound access, violating Rule 21.17. The responsibility to maintain consistency between data_iov and data_iovcnt lies with the surrounding code, but within this function, the memcpy is used directly with these values without validation. Therefore, the scenario highlighted by agent A, showing that an incorrect response->data_iovcnt would cause out-of-bound memcpy, is a valid concern and represents a potential MISRA 21.17 violation. The test code failing to compile does not invalidate the scenario; the conceptual issue remains. Hence, the agent's report about a Rule 21.17 violation is correct."
}