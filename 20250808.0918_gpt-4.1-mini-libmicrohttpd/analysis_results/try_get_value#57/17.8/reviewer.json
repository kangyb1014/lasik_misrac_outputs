{
  "user_message": "An agent A claimed that the following try_get_value code violates the MISRA C 2023 rule 17.8.\n<misra_rule>\nMISRA C 2023 Rule 17.8 is A function parameter should not be modified.\nNote that the object referred to by a pointer parameter may be modified, but the pointer itself shall not be modified..\n</misra_rule>\n<target_code>\nHere is the original code of try_get_value.\n```c\nstatic void\ntry_get_value (const char *buf,\n               const char *key,\n               char **destination)\n{\n  const char *spos;\n  const char *bpos;\n  const char *endv;\n  size_t klen;\n  size_t vlen;\n\n  if (NULL != *destination)\n    return;\n  bpos = buf;\n  klen = strlen (key);\n  while (NULL != (spos = strstr (bpos, key)))\n  {\n    if ( (spos[klen] != '=') ||\n         ( (spos != buf) &&\n           (spos[-1] != ' ') ) )\n    {\n      /* no match */\n      bpos = spos + 1;\n      continue;\n    }\n    if (spos[klen + 1] != '\"')\n      return;                   /* not quoted */\n    if (NULL == (endv = strchr (&spos[klen + 2],\n                                '\\\"')))\n      return;                   /* no end-quote */\n    vlen = (size_t) (endv - spos) - klen - 1;\n    *destination = malloc (vlen);\n    if (NULL == *destination)\n      return;                   /* out of memory */\n    (*destination)[vlen - 1] = '\\0';\n    memcpy (*destination,\n            &spos[klen + 2],\n            vlen - 1);\n    return;                     /* success */\n  }\n}\n```\n</target_code>\n<scenario>\nThe agent A provided the following violation scenario:The function try_get_value modifies the pointer parameter 'destination' itself (i.e., the pointer variable), by assigning newly allocated memory to '*destination'. This modifies the content of the pointer parameter. According to MISRA C 2023 Rule 17.8, the pointer parameter itself should not be modified. Although the object pointed to by the pointer may be modified, the pointer should remain unmodified. In this case, the pointer '*destination' is assigned a new address, which is a modification of the pointer parameter, violating Rule 17.8.\n</scenario>\n<test_code>\nAlso, the agent A provided the following modified code that prints out the log to support their scenario:\n```c\n\nstatic void\ntry_get_value (const char *buf,\n               const char *key,\n               char **destination)\n{\n  const char *spos;\n  const char *bpos;\n  const char *endv;\n  size_t klen;\n  size_t vlen;\n  FILE *logfile = fopen(\"/tmp/logs/461.txt\", \"a\");\n\n  if (logfile != NULL) {\n    fprintf(logfile, \"Entered try_get_value\\n\");\n    fprintf(logfile, \"*destination before check: %p\\n\", (void*)(*destination));\n  }\n\n  if (NULL != *destination) {\n    if (logfile != NULL) {\n      fprintf(logfile, \"*destination not NULL, returning early\\n\");\n      fclose(logfile);\n    }\n    return;\n  }\n\n  bpos = buf;\n  klen = strlen(key);\n  while (NULL != (spos = strstr(bpos, key)))\n  {\n    if ((spos[klen] != '=') ||\n        ((spos != buf) && (spos[-1] != ' ')))\n    {\n      /* no match */\n      if (logfile != NULL) {\n        fprintf(logfile, \"No match at position %ld, continuing\\n\", (long)(spos - buf));\n      }\n      bpos = spos + 1;\n      continue;\n    }\n    if (spos[klen + 1] != '\"') {\n      if (logfile != NULL) {\n        fprintf(logfile, \"Not quoted value, returning\\n\");\n        fclose(logfile);\n      }\n      return;                   /* not quoted */\n    }\n    if (NULL == (endv = strchr(&spos[klen + 2], '\"'))) {\n      if (logfile != NULL) {\n        fprintf(logfile, \"No end-quote found, returning\\n\");\n        fclose(logfile);\n      }\n      return;                   /* no end-quote */\n    }\n    vlen = (size_t)(endv - &spos[klen + 2]) + 1; // length of value plus null terminator\n    *destination = malloc(vlen);\n    if (NULL == *destination) {\n      if (logfile != NULL) {\n        fprintf(logfile, \"Out of memory, returning\\n\");\n        fclose(logfile);\n      }\n      return;                   /* out of memory */\n    }\n    memcpy(*destination,\n           &spos[klen + 2],\n           vlen - 1);\n    (*destination)[vlen - 1] = '\\0';\n\n    if (logfile != NULL) {\n      fprintf(logfile, \"*destination assigned new memory at %p\\n\", (void*)(*destination));\n      fprintf(logfile, \"Extracted value: %s\\n\", *destination);\n      fclose(logfile);\n    }\n    return;                     /* success */\n  }\n  if (logfile != NULL) {\n    fprintf(logfile, \"Key not found, no assignment made\\n\");\n    fclose(logfile);\n  }\n}\n\n```\nThe test code failed to compile, so we could not obtain any output.\n\n</test_code>\n<response format>\nProvide your answer with these fields.\n- explanation: your evaluation of the scenario provided by the agent A.\n- is_report_correct: whether the report is correct or not (true/false)\n</response format>\n<instruction>   \nJudge whether the report is correct or not.\n</instruction>\n",
  "is_report_correct": false,
  "explanation": "MISRA C 2023 Rule 17.8 states that a function parameter should not be modified. Specifically, if the parameter is a pointer, the pointer itself (the parameter variable) must not be modified (i.e., reassigned), but the object pointed to by the pointer can be modified. In the function try_get_value, the parameter is 'char **destination'. The code modifies '*destination', which means it modifies the object pointed to by 'destination' (which is a 'char *'). However, the function does not modify 'destination' itself (i.e., the pointer parameter variable). The pointer parameter variable 'destination' remains unchanged; only the content it points to is updated. According to the rule, modifying the object referenced by the pointer parameter is allowed, and only modifying the pointer parameter variable is disallowed. Therefore, assigning to '*destination' is allowed and does not violate Rule 17.8. The scenario provided by agent A mistakenly interprets modifying '*destination' as modifying the pointer parameter itself, which is incorrect. The pointer parameter 'destination' is not reassigned; the memory address stored at the location pointed to by 'destination' is updated. Hence, the report is incorrect for Rule 17.8 violation."
}