{
  "user_message": "An agent A claimed that the following keepalive_possible code violates the MISRA C 2023 rule 21.17.\n<misra_rule>\nMISRA C 2023 Rule 21.17 is Use of the string handling functions from <string.h> shall not result in accesses beyond the bounds of the objects referenced by their pointer parameters.\nThis rule strictly applies to the Standard Library functions in <string.h> such as memcpy, memmove, memset, memcmp, strcpy, strncpy, strcat, strncat, strlen, and strspn..\n</misra_rule>\n<target_code>\nHere is the original code of keepalive_possible.\n```c\nstatic enum MHD_ConnKeepAlive\nkeepalive_possible (struct MHD_Connection *connection)\n{\n  struct MHD_Connection *const c = connection; /**< a short alias */\n  struct MHD_Response *const r = c->rp.response;  /**< a short alias */\n\n  mhd_assert (NULL != r);\n  if (MHD_CONN_MUST_CLOSE == c->keepalive)\n    return MHD_CONN_MUST_CLOSE;\n\n#ifdef UPGRADE_SUPPORT\n  /* TODO: Move below the next check when MHD stops closing connections\n   * when response is queued in first callback */\n  if (NULL != r->upgrade_handler)\n  {\n    /* No \"close\" token is enforced by 'add_response_header_connection()' */\n    mhd_assert (0 == (r->flags_auto & MHD_RAF_HAS_CONNECTION_CLOSE));\n    /* Valid HTTP version is enforced by 'MHD_queue_response()' */\n    mhd_assert (MHD_IS_HTTP_VER_SUPPORTED (c->rq.http_ver));\n    mhd_assert (! c->stop_with_error);\n    return MHD_CONN_MUST_UPGRADE;\n  }\n#endif /* UPGRADE_SUPPORT */\n\n  mhd_assert ( (! c->stop_with_error) || (c->discard_request));\n  if ((c->read_closed) || (c->discard_request))\n    return MHD_CONN_MUST_CLOSE;\n\n  if (0 != (r->flags & MHD_RF_HTTP_1_0_COMPATIBLE_STRICT))\n    return MHD_CONN_MUST_CLOSE;\n  if (0 != (r->flags_auto & MHD_RAF_HAS_CONNECTION_CLOSE))\n    return MHD_CONN_MUST_CLOSE;\n\n  if (! MHD_IS_HTTP_VER_SUPPORTED (c->rq.http_ver))\n    return MHD_CONN_MUST_CLOSE;\n\n  if (MHD_lookup_header_s_token_ci (c,\n                                    MHD_HTTP_HEADER_CONNECTION,\n                                    \"close\"))\n    return MHD_CONN_MUST_CLOSE;\n\n  if ((MHD_HTTP_VER_1_0 == connection->rq.http_ver) ||\n      (0 != (connection->rp.response->flags & MHD_RF_HTTP_1_0_SERVER)))\n  {\n    if (MHD_lookup_header_s_token_ci (connection,\n                                      MHD_HTTP_HEADER_CONNECTION,\n                                      \"Keep-Alive\"))\n      return MHD_CONN_USE_KEEPALIVE;\n\n    return MHD_CONN_MUST_CLOSE;\n  }\n\n  if (MHD_IS_HTTP_VER_1_1_COMPAT (c->rq.http_ver))\n    return MHD_CONN_USE_KEEPALIVE;\n\n  return MHD_CONN_MUST_CLOSE;\n}\n```\n</target_code>\n<scenario>\nThe agent A provided the following violation scenario:A violation occurs if any string handling function from <string.h>, such as those used inside MHD_lookup_header_s_token_ci (likely using strstr, strncmp, or similar), accesses beyond the bounds of its pointer parameters. In the keepalive_possible function, there is a call to MHD_lookup_header_s_token_ci with the string literal \"close\" or \"Keep-Alive\" as the token, and a header string from the connection structure. If the header string pointer or its length used in MHD_lookup_header_s_token_ci is invalid or not properly bounded, these string functions may read beyond the intended memory bounds.\n</scenario>\n<test_code>\nAlso, the agent A provided the following modified code that prints out the log to support their scenario:\n```c\nstruct rq {\n    int http_ver;\n};\nstruct rp {\n    struct MHD_Response *response;\n};\nint MHD_IS_HTTP_VER_SUPPORTED(int ver) {\n    return (ver >= 10 && ver <= 12);\n}\nint MHD_IS_HTTP_VER_1_1_COMPAT(int ver) {\n    return (ver == 11 || ver == 12);\n}\nint MHD_lookup_header_s_token_ci(const struct MHD_Connection *c, const char *header, const char *token) {\n    FILE *f = fopen(\"/tmp/logs/151.txt\", \"a\");\n    if (f) {\n        fprintf(f, \"MHD_lookup_header_s_token_ci called with header ptr=%p, token='%s'\\n\", (void *)header, token);\n        fclose(f);\n    }\n    if (!header || !token) return 0;\n\n    if (strstr(header, token) != NULL) {\n        f = fopen(\"/tmp/logs/151.txt\", \"a\");\n        if (f) {\n            fprintf(f, \"Token '%s' found in header '%s'\\n\", token, header);\n            fclose(f);\n        }\n        return 1;\n    }\n    return 0;\n}\n\nstatic enum MHD_ConnKeepAlive\nkeepalive_possible(struct MHD_Connection *connection)\n{\n    FILE *f = fopen(\"/tmp/logs/151.txt\", \"a\");\n    if (f) {\n        fprintf(f, \"keepalive_possible called with connection ptr=%p, keepalive=%d, http_ver=%d\\n\",\n                (void *)connection, connection->keepalive, connection->rq.http_ver);\n        fclose(f);\n    }\n\n    struct MHD_Connection *const c = connection;\n    struct MHD_Response *const r = c->rp.response;\n\n    if (r == NULL) {\n        f = fopen(\"/tmp/logs/151.txt\", \"a\");\n        if (f) {\n            fprintf(f, \"Response pointer is NULL, exiting with MUST_CLOSE\\n\");\n            fclose(f);\n        }\n        return MHD_CONN_MUST_CLOSE;\n    }\n\n    if (MHD_CONN_MUST_CLOSE == c->keepalive) {\n        f = fopen(\"/tmp/logs/151.txt\", \"a\");\n        if (f) {\n            fprintf(f, \"Keepalive marked MUST_CLOSE, returning MUST_CLOSE\\n\");\n            fclose(f);\n        }\n        return MHD_CONN_MUST_CLOSE;\n    }\n\n    if ((c->read_closed) || (c->discard_request)) {\n        f = fopen(\"/tmp/logs/151.txt\", \"a\");\n        if (f) {\n            fprintf(f, \"Read closed or discard request set, returning MUST_CLOSE\\n\");\n            fclose(f);\n        }\n        return MHD_CONN_MUST_CLOSE;\n    }\n\n    if (0 != (r->flags & MHD_RF_HTTP_1_0_COMPATIBLE_STRICT)) {\n        f = fopen(\"/tmp/logs/151.txt\", \"a\");\n        if (f) {\n            fprintf(f, \"HTTP 1.0 compatible strict flag set, MUST_CLOSE\\n\");\n            fclose(f);\n        }\n        return MHD_CONN_MUST_CLOSE;\n    }\n\n    // Simulating flags_auto as flags since original struct does not define it\n    int flags_auto = 0; // Assume 0 here when unknown\n    if (0 != (flags_auto & MHD_RAF_HAS_CONNECTION_CLOSE)) {\n        f = fopen(\"/tmp/logs/151.txt\", \"a\");\n        if (f) {\n            fprintf(f, \"Auto flags has connection close, MUST_CLOSE\\n\");\n            fclose(f);\n        }\n        return MHD_CONN_MUST_CLOSE;\n    }\n\n    if (!MHD_IS_HTTP_VER_SUPPORTED(c->rq.http_ver)) {\n        f = fopen(\"/tmp/logs/151.txt\", \"a\");\n        if (f) {\n            fprintf(f, \"HTTP version not supported, MUST_CLOSE\\n\");\n            fclose(f);\n        }\n        return MHD_CONN_MUST_CLOSE;\n    }\n\n    if (MHD_lookup_header_s_token_ci(c, MHD_HTTP_HEADER_CONNECTION, \"close\")) {\n        f = fopen(\"/tmp/logs/151.txt\", \"a\");\n        if (f) {\n            fprintf(f, \"Header contains 'close' token, MUST_CLOSE\\n\");\n            fclose(f);\n        }\n        return MHD_CONN_MUST_CLOSE;\n    }\n\n    if ((MHD_HTTP_VER_1_0 == connection->rq.http_ver) ||\n        (0 != (connection->rp.response->flags & MHD_RF_HTTP_1_0_COMPATIBLE_STRICT)))\n    {\n        if (MHD_lookup_header_s_token_ci(connection, MHD_HTTP_HEADER_CONNECTION, \"Keep-Alive\")) {\n            f = fopen(\"/tmp/logs/151.txt\", \"a\");\n            if (f) {\n                fprintf(f, \"Header contains 'Keep-Alive' token, USE_KEEPALIVE\\n\");\n                fclose(f);\n            }\n            return MHD_CONN_USE_KEEPALIVE;\n        }\n\n        f = fopen(\"/tmp/logs/151.txt\", \"a\");\n        if (f) {\n            fprintf(f, \"Defaulting to MUST_CLOSE for HTTP/1.0 without 'Keep-Alive'\\n\");\n            fclose(f);\n        }\n        return MHD_CONN_MUST_CLOSE;\n    }\n\n    if (MHD_IS_HTTP_VER_1_1_COMPAT(c->rq.http_ver)) {\n        f = fopen(\"/tmp/logs/151.txt\", \"a\");\n        if (f) {\n            fprintf(f, \"HTTP 1.1 compatible, USE_KEEPALIVE\\n\");\n            fclose(f);\n        }\n        return MHD_CONN_USE_KEEPALIVE;\n    }\n\n    f = fopen(\"/tmp/logs/151.txt\", \"a\");\n    if (f) {\n        fprintf(f, \"Defaulting to MUST_CLOSE at end of function\\n\");\n        fclose(f);\n    }\n    return MHD_CONN_MUST_CLOSE;\n}\n\n```\nThe test code failed to compile, so we could not obtain any output.\n\n</test_code>\n<response format>\nProvide your answer with these fields.\n- explanation: your evaluation of the scenario provided by the agent A.\n- is_report_correct: whether the report is correct or not (true/false)\n</response format>\n<instruction>   \nJudge whether the report is correct or not.\n</instruction>\n",
  "is_report_correct": false,
  "explanation": "MISRA C 2023 Rule 21.17 mandates that string handling functions from <string.h> (e.g., strstr, strncmp) must not access memory beyond the bounds of their pointer parameters. The function keepalive_possible calls MHD_lookup_header_s_token_ci, which likely uses string functions such as strstr internally, passing it header strings and literal tokens like \"close\" or \"Keep-Alive\". However, the risk of violating Rule 21.17 depends on the validity and bounds of the header strings passed into MHD_lookup_header_s_token_ci. In the provided code, these header pointers come from the connection structure and are used without explicit length parameters or bounds checks visible in keepalive_possible. If MHD_lookup_header_s_token_ci or the code populating these headers ensures that the pointers refer to valid null-terminated strings within bounds, then there is no violation. The agent\u2019s concern about potential out-of-bounds accesses is based on an assumption that the header strings might not be properly bounded. Without evidence from the code that these pointers can be invalid or improperly bounded, or that MHD_lookup_header_s_token_ci mismanages their length, there is no clear violation. The test code intended to confirm the violation failed to compile and gave no runtime evidence. Therefore, based solely on the analyzed code, the report that keepalive_possible violates Rule 21.17 is not substantiated."
}