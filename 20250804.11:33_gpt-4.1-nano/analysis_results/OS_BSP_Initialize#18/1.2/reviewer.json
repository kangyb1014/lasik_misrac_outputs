{
  "user_message": "An agent A claimed that the following OS_BSP_Initialize code violates the MISRA C 2023 rule 1.2.\n<misra_rule>\nMISRA C 2023 Rule 1.2 is Language extensions should not be used.\nYou should report only when the code uses any language compiler extensions that are explicitly stated as an extension in compiler documentations..\n</misra_rule>\n<target_code>\nHere is the original code of OS_BSP_Initialize.\n```c\nvoid OS_BSP_Initialize(void)\n{\n    FILE *              fp;\n    char                buffer[32];\n    pthread_mutexattr_t mutex_attr;\n    int                 status;\n\n    /*\n     * If not running as root, check /proc/sys/fs/mqueue/msg_max\n     *\n     * This special file represents the max depth of a POSIX message queue for an unprivileged user.\n     *\n     * In order to facilitate running in simulation mode without any need for root access --\n     * this will allow the OSAL to successfully create message queues by truncating anything larger than this size.\n     *\n     * No need to check _LINUX_OS_ here; if the file fails to open, i.e. if not on Linux and the file does not exist,\n     * then leave well enough alone and don't do anything.\n     */\n    if (geteuid() != 0)\n    {\n        fp = fopen(\"/proc/sys/fs/mqueue/msg_max\", \"r\");\n        if (fp)\n        {\n            if (fgets(buffer, sizeof(buffer), fp) != NULL)\n            {\n                OS_BSP_Global.MaxQueueDepth = OSAL_BLOCKCOUNT_C(strtoul(buffer, NULL, 10));\n                BSP_DEBUG(\"Maximum user msg queue depth = %u\\n\", (unsigned int)OS_BSP_Global.MaxQueueDepth);\n            }\n            fclose(fp);\n        }\n    }\n\n    /* Initialize the low level access mutex (w/priority inheritance) */\n    status = pthread_mutexattr_init(&mutex_attr);\n    if (status < 0)\n    {\n        BSP_DEBUG(\"pthread_mutexattr_init: %s\\n\", strerror(status));\n    }\n    status = pthread_mutexattr_setprotocol(&mutex_attr, PTHREAD_PRIO_INHERIT);\n    if (status < 0)\n    {\n        BSP_DEBUG(\"pthread_mutexattr_setprotocol: %s\\n\", strerror(status));\n    }\n    status = pthread_mutex_init(&OS_BSP_GenericLinuxGlobal.AccessMutex, &mutex_attr);\n    if (status < 0)\n    {\n        BSP_DEBUG(\"pthread_mutex_init: %s\\n\", strerror(status));\n    }\n}\n```\n</target_code>\n<scenario>\nThe agent A provided the following violation scenario:The code uses 'pthread_mutexattr_setprotocol' and 'pthread_mutex_init' functions, which are part of POSIX extensions beyond the standard C language.\n</scenario>\n<test_code>\nAlso, the agent A provided the following modified code that prints out the log to support their scenario:\n```c\n\nvoid OS_BSP_Initialize(void)\n{\n    FILE *              fp;\n    char                buffer[32];\n    pthread_mutexattr_t mutex_attr;\n    int                 status;\n\n    if (geteuid() != 0)\n    {\n        fp = fopen(\"/proc/sys/fs/mqueue/msg_max\", \"r\");\n        if (fp)\n        {\n            if (fgets(buffer, sizeof(buffer), fp) != NULL)\n            {\n                OS_BSP_Global.MaxQueueDepth = OSAL_BLOCKCOUNT_C(strtoul(buffer, NULL, 10));\n                BSP_DEBUG(\"Maximum user msg queue depth = %u\\n\", (unsigned int)OS_BSP_Global.MaxQueueDepth);\n            }\n            fclose(fp);\n        }\n    }\n\n    status = pthread_mutexattr_init(&mutex_attr);\n    if (status != 0)\n    {\n        FILE *log_fp = fopen(\"/tmp/logs/144.txt\", \"a\");\n        if (log_fp) {\n            fprintf(log_fp, \"pthread_mutexattr_init: %s\\n\", strerror(status));\n            fclose(log_fp);\n        }\n    }\n    status = pthread_mutexattr_setprotocol(&mutex_attr, PTHREAD_PRIO_INHERIT);\n    if (status != 0)\n    {\n        FILE *log_fp = fopen(\"/tmp/logs/144.txt\", \"a\");\n        if (log_fp) {\n            fprintf(log_fp, \"pthread_mutexattr_setprotocol: %s\\n\", strerror(status));\n            fclose(log_fp);\n        }\n    }\n    status = pthread_mutex_init(&OS_BSP_Global.mutex, &mutex_attr);\n    if (status != 0)\n    {\n        FILE *log_fp = fopen(\"/tmp/logs/144.txt\", \"a\");\n        if (log_fp) {\n            fprintf(log_fp, \"pthread_mutex_init: %s\\n\", strerror(status));\n            fclose(log_fp);\n        }\n    }\n}\n\n```\nThe test code failed to compile, so we could not obtain any output.\n\n</test_code>\n<response format>\nProvide your answer with these fields.\n- explanation: your evaluation of the scenario provided by the agent A.\n- is_report_correct: whether the report is correct or not (true/false)\n</response format>\n<instruction>   \nJudge whether the report is correct or not.\n</instruction>\n",
  "is_report_correct": true,
  "explanation": "The functions 'pthread_mutexattr_setprotocol' and 'pthread_mutex_init' are part of the POSIX threads (pthreads) library, which introduces extensions beyond the ISO C standard. These are non-standard, implementation-specific extensions used to interact with POSIX threading features. Therefore, their usage constitutes reliance on language extensions beyond the base C language standard, which violates MISRA C 2023 rule 1.2."
}