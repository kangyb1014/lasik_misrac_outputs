{
  "user_message": "<misra_rule>\nMISRA C 2023 Rule 21.17 is: Use of the string handling functions from <string.h> shall not result in accesses beyond the bounds of the objects referenced by their pointer parameters.\nThis rule strictly applies to the Standard Library functions in <string.h> such as memcpy, memmove, memset, memcmp, strcpy, strncpy, strcat, strncat, strlen, and strspn.\n</misra_rule>\n<response format>\nProvide your answer with these fields.\n- is_rule_violated: whether the rule is violated or not (true/false),\n- scenario: a specific violation scenario.\n- test_code: a modified OS_rename code that contains useful probe functions that print useful logs to a file \"/tmp/logs/175.txt\". The logs should contain the control path and state information of the violation scenario. If the MISRA C rule is not violated, you can just return an empty string for the test code.\nHere are the constraints for the test code:\n- DO NOT introduce new violations to demonstrate your scenario.\n- The test code MUST be compilable and executable.\n- The test code MUST include line breaks.\n- The test code MUST preserve the original logic of OS_rename as much as possible.\n- You MUST NOT define the main function.\n- You MUST NOT define macros.\n- The test code MUST not contain any mock functions.\n</response format>\n<target_code>\nHere is the code of OS_rename:\n```c\nint32 OS_rename(const char *old, const char *new)\n{\n    OS_object_iter_t             iter;\n    OS_stream_internal_record_t *stream;\n    int32                        return_code;\n    char                         old_path[OS_MAX_LOCAL_PATH_LEN];\n    char                         new_path[OS_MAX_LOCAL_PATH_LEN];\n\n    return_code = OS_TranslatePath(old, old_path);\n    if (return_code == OS_SUCCESS)\n    {\n        return_code = OS_TranslatePath(new, new_path);\n    }\n\n    if (return_code == OS_SUCCESS)\n    {\n        return_code = OS_FileRename_Impl(old_path, new_path);\n    }\n\n    if (return_code == OS_SUCCESS)\n    {\n        OS_ObjectIdIterateActive(LOCAL_OBJID_TYPE, &iter);\n\n        while (OS_ObjectIdIteratorGetNext(&iter))\n        {\n            stream = OS_OBJECT_TABLE_GET(OS_stream_table, iter.token);\n\n            if (stream->socket_domain == OS_SocketDomain_INVALID && strcmp(stream->stream_name, old) == 0)\n            {\n                strncpy(stream->stream_name, new, sizeof(stream->stream_name) - 1);\n                stream->stream_name[sizeof(stream->stream_name) - 1] = 0;\n            }\n        }\n\n        OS_ObjectIdIteratorDestroy(&iter);\n    }\n\n    return return_code;\n}\n```\n</target_code>\nJudge whether the above OS_rename code violates the rule 21.17 or not.",
  "is_rule_violated": true,
  "scenario": "The use of strncpy with stream->stream_name might potentially result in a buffer overflow if stream->stream_name's size is not properly defined or if the 'new' string length exceeds the buffer size minus one. Proper bounds checking on the 'new' string length before copying is necessary to avoid accessing beyond buffer bounds.",
  "test_code": "```c\n#include <stdio.h>\n#include <string.h>\n\n// Logs to file\nvoid log_violation(const char *msg) {\n    FILE *fp = fopen(\"/tmp/logs/175.txt\", \"a\");\n    if (fp) {\n        fprintf(fp, \"%s\\n\", msg);\n        fclose(fp);\n    }\n}\n\n// Suffix for strncpy check\nsize_t safe_size = sizeof(((OS_stream_internal_record_t *)0)->stream_name);\n\n// Modified OS_rename with logging\nint32 OS_rename(const char *old, const char *new) {\n    OS_object_iter_t iter;\n    OS_stream_internal_record_t *stream;\n    int32 return_code;\n    char old_path[OS_MAX_LOCAL_PATH_LEN];\n    char new_path[OS_MAX_LOCAL_PATH_LEN];\n\n    return_code = OS_TranslatePath(old, old_path);\n    if (return_code == OS_SUCCESS) {\n        return_code = OS_TranslatePath(new, new_path);\n    }\n\n    if (return_code == OS_SUCCESS) {\n        return_code = OS_FileRename_Impl(old_path, new_path);\n    }\n\n    if (return_code == OS_SUCCESS) {\n        OS_ObjectIdIterateActive(LOCAL_OBJID_TYPE, &iter);\n\n        while (OS_ObjectIdIteratorGetNext(&iter)) {\n            stream = OS_OBJECT_TABLE_GET(OS_stream_table, iter.token);\n\n            if (stream->socket_domain == OS_SocketDomain_INVALID && strcmp(stream->stream_name, old) == 0) {\n                if (strlen(new) < safe_size) {\n                    strncpy(stream->stream_name, new, safe_size - 1);\n                    stream->stream_name[safe_size - 1] = '\\0';\n                } else {\n                    log_violation(\"Potential buffer overflow detected in OS_rename: 'new' string exceeds buffer size.\");\n                }\n            }\n        }\n\n        OS_ObjectIdIteratorDestroy(&iter);\n    }\n\n    return return_code;\n}\n```"
}