{
  "user_message": "<misra_rule>\nMISRA C 2023 Rule 2.1 is: A project shall not contain unreachable code.\n\n</misra_rule>\n<response format>\nProvide your answer with these fields.\n- is_rule_violated: whether the rule is violated or not (true/false),\n- scenario: a specific violation scenario.\n- test_code: a modified OS_CountSemTake_Impl code that contains useful probe functions that print useful logs to a file \"/tmp/logs/153.txt\". The logs should contain the control path and state information of the violation scenario. If the MISRA C rule is not violated, you can just return an empty string for the test code.\nHere are the constraints for the test code:\n- DO NOT introduce new violations to demonstrate your scenario.\n- The test code MUST be compilable and executable.\n- The test code MUST include line breaks.\n- The test code MUST preserve the original logic of OS_CountSemTake_Impl as much as possible.\n- You MUST NOT define the main function.\n- You MUST NOT define macros.\n- The test code MUST not contain any mock functions.\n</response format>\n<target_code>\nHere is the code of OS_CountSemTake_Impl:\n```c\nint32 OS_CountSemTake_Impl(const OS_object_token_t *token)\n{\n    OS_impl_countsem_internal_record_t *impl;\n\n    impl = OS_OBJECT_TABLE_GET(OS_impl_count_sem_table, *token);\n\n    if (sem_wait(&impl->id) < 0)\n    {\n        return OS_SEM_FAILURE;\n    }\n\n    return OS_SUCCESS;\n}\n```\n</target_code>\n<additional code>Here are the definitions of symbols that are close to the target function OS_CountSemTake_Impl:\n#define OS_OBJECT_TABLE_GET(tbl, tok) (&tbl[OS_ObjectIndexFromToken(&(tok))])\n</additional code>\nJudge whether the above OS_CountSemTake_Impl code violates the rule 2.1 or not.",
  "is_rule_violated": true,
  "scenario": "If the function contains code after a return statement that is never executed, it violates MISRA C 2023 Rule 2.1.",
  "test_code": "\n#include <stdio.h>\n#include <errno.h>\n#include <sys/types.h>\n#include <semaphore.h>\n\ntypedef int32_t OS_SEM_FAILURE;\ntypedef int32_t OS_SUCCESS;\n\ntypedef struct {\n    int id;\n} OS_impl_countsem_internal_record_t;\n\ntypedef struct {\n    int dummy;\n} OS_object_token_t;\n\n#define OS_OBJECT_TABLE_GET(tbl, tok) (&tbl[OS_ObjectIndexFromToken(&(tok))])\n\nunsigned int OS_ObjectIndexFromToken(const OS_object_token_t *tok) {\n    return 0;\n}\n\nOS_impl_countsem_internal_record_t OS_impl_count_sem_table[10];\n\nint32 OS_CountSemTake_Impl(const OS_object_token_t *token)\n{\n    OS_impl_countsem_internal_record_t *impl;\n\n    impl = OS_OBJECT_TABLE_GET(OS_impl_count_sem_table, *token);\n\n    if (sem_wait(&impl->id) < 0)\n    {\n        return OS_SEM_FAILURE;\n    }\n    return OS_SUCCESS;\n}\n\n// Probe function to add logs for control path and state\nint32 OS_CountSemTake_Impl_with_logs(const OS_object_token_t *token)\n{\n    FILE *log_file = fopen(\"/tmp/logs/153.txt\", \"a\");\n    if (log_file == NULL) {\n        return OS_SEM_FAILURE;\n    }\n    \n    fprintf(log_file, \"Entering OS_CountSemTake_Impl_with_logs\\n\");\n\n    OS_impl_countsem_internal_record_t *impl;\n\n    impl = OS_OBJECT_TABLE_GET(OS_impl_count_sem_table, *token);\n    fprintf(log_file, \"Token fetched, impl id: %d\\n\", impl->id);\n\n    if (sem_wait(&impl->id) < 0)\n    {\n        fprintf(log_file, \"sem_wait failed with errno: %d\\n\", errno);\n        fclose(log_file);\n        return OS_SEM_FAILURE;\n    }\n    \n    fprintf(log_file, \"sem_wait succeeded\\n\");\n    fclose(log_file);\n    return OS_SUCCESS;\n}\n"
}