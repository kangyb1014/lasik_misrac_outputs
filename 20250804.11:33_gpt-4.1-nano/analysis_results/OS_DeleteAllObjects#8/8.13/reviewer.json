{
  "user_message": "An agent A claimed that the following OS_DeleteAllObjects code violates the MISRA C 2023 rule 8.13.\n<misra_rule>\nMISRA C 2023 Rule 8.13 is A pointer should point to a const-qualified type whenever possible.\nA pointer should not point to a const-qualified type if the pointer is used by a function that modifies the object pointed to by the pointer..\n</misra_rule>\n<target_code>\nHere is the original code of OS_DeleteAllObjects.\n```c\nvoid OS_DeleteAllObjects(void)\n{\n    uint32 ObjectCount;\n    uint32 TryCount;\n\n    /*\n     * Note - this is done in a loop because some objects depend on other objects\n     * and you will not be able to delete the object until the ref count becomes zero.\n     */\n    TryCount = 0;\n    while (true)\n    {\n        ObjectCount = 0;\n        ++TryCount;\n\n        /* Delete timers and tasks first, as they could be actively using other object types  */\n        OS_ForEachObjectOfType(OS_OBJECT_TYPE_OS_TIMECB, OS_OBJECT_CREATOR_ANY, OS_CleanUpObject, &ObjectCount);\n        OS_ForEachObjectOfType(OS_OBJECT_TYPE_OS_TIMEBASE, OS_OBJECT_CREATOR_ANY, OS_CleanUpObject, &ObjectCount);\n        OS_ForEachObjectOfType(OS_OBJECT_TYPE_OS_TASK, OS_OBJECT_CREATOR_ANY, OS_CleanUpObject, &ObjectCount);\n\n        /* Then try to delete all other remaining objects of any type */\n        OS_ForEachObject(OS_OBJECT_CREATOR_ANY, OS_CleanUpObject, &ObjectCount);\n\n        if (ObjectCount == 0 || TryCount > 4)\n        {\n            break;\n        }\n        OS_TaskDelay(5);\n    }\n}\n```\n</target_code>\n<scenario>\nThe agent A provided the following violation scenario:The code uses a function pointer 'OS_CleanUpObject' that is used as a callback and might modify the object pointed to by the callback's argument, which is a void pointer &ObjectCount. If 'OS_CleanUpObject' modifies the object in a way that violates const-correctness, and it is not a pointer to const, then a violation occurs.\n</scenario>\n<test_code>\nAlso, the agent A provided the following modified code that prints out the log to support their scenario:\n```c\n\nvoid OS_DeleteAllObjects(void)\n{\n    uint32 ObjectCount;\n    uint32 TryCount;\n\n    /*\n     * Note - this is done in a loop because some objects depend on other objects\n     * and you will not be able to delete the object until the ref count becomes zero.\n     */\n    TryCount = 0;\n    while (true)\n    {\n        ObjectCount = 0;\n        ++TryCount;\n\n        /* Delete timers and tasks first, as they could be actively using other object types  */\n        /* Log access to OS_CleanUpObject that might modify objects */\n        OS_ForEachObjectOfType(OS_OBJECT_TYPE_OS_TIMECB, OS_OBJECT_CREATOR_ANY, NULL, &ObjectCount);\n        OS_ForEachObjectOfType(OS_OBJECT_TYPE_OS_TIMEBASE, OS_OBJECT_CREATOR_ANY, NULL, &ObjectCount);\n        OS_ForEachObjectOfType(OS_OBJECT_TYPE_OS_TASK, OS_OBJECT_CREATOR_ANY, NULL, &ObjectCount);\n\n        /* Then try to delete all other remaining objects of any type */\n        OS_ForEachObject(OS_OBJECT_CREATOR_ANY, NULL, &ObjectCount);\n\n        if (ObjectCount == 0 || TryCount > 4)\n        {\n            break;\n        }\n        OS_TaskDelay(5);\n    }\n}\n\n```\nThe test code failed to compile, so we could not obtain any output.\n\n</test_code>\n<response format>\nProvide your answer with these fields.\n- explanation: your evaluation of the scenario provided by the agent A.\n- is_report_correct: whether the report is correct or not (true/false)\n</response format>\n<instruction>   \nJudge whether the report is correct or not.\n</instruction>\n",
  "is_report_correct": true,
  "explanation": "The agent A's scenario suggests that the function pointer 'OS_CleanUpObject', used as a callback, may modify the object pointed to, which could violate MISRA C 2023 Rule 8.13 if the pointer does not have const qualifier. However, in the provided code, 'OS_CleanUpObject' is used as a callback without being declared with a 'const' pointer parameter, indicating it might modify the object pointed to. The modified code replaced the callback function with 'NULL', which is invalid and causes a compile error. Since the original code indeed uses a function pointer that might modify objects, and the argument is a 'void *' (non-const), this pattern is susceptible to violating Rule 8.13 if 'OS_CleanUpObject' modifies objects without a 'const' qualifier. Therefore, the scenario is valid, and the report is correct."
}