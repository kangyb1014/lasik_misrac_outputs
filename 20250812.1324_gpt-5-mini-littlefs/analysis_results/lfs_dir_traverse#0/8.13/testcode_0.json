{
  "user_message": "<misra_rule>\nMISRA C 2023 Rule 8.13 is: A pointer should point to a const-qualified type whenever possible.\n\n</misra_rule>\n\nAnother agent reported that the target code violated the Rule 8.13.\nHere is the comment from the agent.\n<violation scenario>\nThe struct lfs_attr declares a non-const pointer member 'void *buffer' although the attribute data is only read (e.g. in lfs_dir_traverse it is accessed via 'const struct lfs_attr *a' and passed to callbacks expecting const void *). The pointer should be declared 'const void *buffer' to reflect that the pointed-to data is not modified and to avoid qualifier inconsistencies with other APIs (such as lfs_mattr::buffer which is const).\n</violation scenario>\n\nYour job is to insert logging code to capture the control flow and state information of the program.\nInsert logging code so that other agents can reproduce and get evidence for the violation scenario.\n<response format>\n- test_code: a modified lfs_dir_traverse code that contains useful probe functions that print useful logs to a file \"/tmp/logs/3.txt\". The logs should contain the control path and state information of the violation scenario. If test code is not required to validate the scenario, you can leave this blank.\nHere are the constraints for the test code:\n- The test code MUST preserve the original logic of lfs_dir_traverse as much as possible.\nYou CAN just insert probe functions to the original code.\n- DO NOT introduce new violations to demonstrate your scenario.\n- The test code MUST be compilable and executable.\n- The test code MUST include line breaks.\n- You MUST NOT define the main function.\n- You MUST NOT define macros.\n</response format>\n<target_code>\nHere is the code of lfs_dir_traverse:\n```c\nstatic int lfs_dir_traverse(lfs_t *lfs,\n        const lfs_mdir_t *dir, lfs_off_t off, lfs_tag_t ptag,\n        const struct lfs_mattr *attrs, int attrcount,\n        lfs_tag_t tmask, lfs_tag_t ttag,\n        uint16_t begin, uint16_t end, int16_t diff,\n        int (*cb)(void *data, lfs_tag_t tag, const void *buffer), void *data) {\n    // This function in inherently recursive, but bounded. To allow tool-based\n    // analysis without unnecessary code-cost we use an explicit stack\n    struct lfs_dir_traverse stack[LFS_DIR_TRAVERSE_DEPTH-1];\n    unsigned sp = 0;\n    int res;\n\n    // iterate over directory and attrs\n    lfs_tag_t tag;\n    const void *buffer;\n    struct lfs_diskoff disk = {0};\n    while (true) {\n        {\n            if (off+lfs_tag_dsize(ptag) < dir->off) {\n                off += lfs_tag_dsize(ptag);\n                int err = lfs_bd_read(lfs,\n                        NULL, &lfs->rcache, sizeof(tag),\n                        dir->pair[0], off, &tag, sizeof(tag));\n                if (err) {\n                    return err;\n                }\n\n                tag = (lfs_frombe32(tag) ^ ptag) | 0x80000000;\n                disk.block = dir->pair[0];\n                disk.off = off+sizeof(lfs_tag_t);\n                buffer = &disk;\n                ptag = tag;\n            } else if (attrcount > 0) {\n                tag = attrs[0].tag;\n                buffer = attrs[0].buffer;\n                attrs += 1;\n                attrcount -= 1;\n            } else {\n                // finished traversal, pop from stack?\n                res = 0;\n                break;\n            }\n\n            // do we need to filter?\n            lfs_tag_t mask = LFS_MKTAG(0x7ff, 0, 0);\n            if ((mask & tmask & tag) != (mask & tmask & ttag)) {\n                continue;\n            }\n\n            if (lfs_tag_id(tmask) != 0) {\n                LFS_ASSERT(sp < LFS_DIR_TRAVERSE_DEPTH);\n                // recurse, scan for duplicates, and update tag based on\n                // creates/deletes\n                stack[sp] = (struct lfs_dir_traverse){\n                    .dir        = dir,\n                    .off        = off,\n                    .ptag       = ptag,\n                    .attrs      = attrs,\n                    .attrcount  = attrcount,\n                    .tmask      = tmask,\n                    .ttag       = ttag,\n                    .begin      = begin,\n                    .end        = end,\n                    .diff       = diff,\n                    .cb         = cb,\n                    .data       = data,\n                    .tag        = tag,\n                    .buffer     = buffer,\n                    .disk       = disk,\n                };\n                sp += 1;\n\n                tmask = 0;\n                ttag = 0;\n                begin = 0;\n                end = 0;\n                diff = 0;\n                cb = lfs_dir_traverse_filter;\n                data = &stack[sp-1].tag;\n                continue;\n            }\n        }\n\npopped:\n        // in filter range?\n        if (lfs_tag_id(tmask) != 0 &&\n                !(lfs_tag_id(tag) >= begin && lfs_tag_id(tag) < end)) {\n            continue;\n        }\n\n        // handle special cases for mcu-side operations\n        if (lfs_tag_type3(tag) == LFS_FROM_NOOP) {\n            // do nothing\n        } else if (lfs_tag_type3(tag) == LFS_FROM_MOVE) {\n            // Without this condition, lfs_dir_traverse can exhibit an\n            // extremely expensive O(n^3) of nested loops when renaming.\n            // This happens because lfs_dir_traverse tries to filter tags by\n            // the tags in the source directory, triggering a second\n            // lfs_dir_traverse with its own filter operation.\n            //\n            // traverse with commit\n            // '-> traverse with filter\n            //     '-> traverse with move\n            //         '-> traverse with filter\n            //\n            // However we don't actually care about filtering the second set of\n            // tags, since duplicate tags have no effect when filtering.\n            //\n            // This check skips this unnecessary recursive filtering explicitly,\n            // reducing this runtime from O(n^3) to O(n^2).\n            if (cb == lfs_dir_traverse_filter) {\n                continue;\n            }\n\n            // recurse into move\n            stack[sp] = (struct lfs_dir_traverse){\n                .dir        = dir,\n                .off        = off,\n                .ptag       = ptag,\n                .attrs      = attrs,\n                .attrcount  = attrcount,\n                .tmask      = tmask,\n                .ttag       = ttag,\n                .begin      = begin,\n                .end        = end,\n                .diff       = diff,\n                .cb         = cb,\n                .data       = data,\n                .tag        = LFS_MKTAG(LFS_FROM_NOOP, 0, 0),\n            };\n            sp += 1;\n\n            uint16_t fromid = lfs_tag_size(tag);\n            uint16_t toid = lfs_tag_id(tag);\n            dir = buffer;\n            off = 0;\n            ptag = 0xffffffff;\n            attrs = NULL;\n            attrcount = 0;\n            tmask = LFS_MKTAG(0x600, 0x3ff, 0);\n            ttag = LFS_MKTAG(LFS_TYPE_STRUCT, 0, 0);\n            begin = fromid;\n            end = fromid+1;\n            diff = toid-fromid+diff;\n        } else if (lfs_tag_type3(tag) == LFS_FROM_USERATTRS) {\n            for (unsigned i = 0; i < lfs_tag_size(tag); i++) {\n                const struct lfs_attr *a = buffer;\n                res = cb(data, LFS_MKTAG(LFS_TYPE_USERATTR + a[i].type,\n                        lfs_tag_id(tag) + diff, a[i].size), a[i].buffer);\n                if (res < 0) {\n                    return res;\n                }\n\n                if (res) {\n                    break;\n                }\n            }\n        } else {\n            res = cb(data, tag + LFS_MKTAG(0, diff, 0), buffer);\n            if (res < 0) {\n                return res;\n            }\n\n            if (res) {\n                break;\n            }\n        }\n    }\n\n    if (sp > 0) {\n        // pop from the stack and return, fortunately all pops share\n        // a destination\n        dir         = stack[sp-1].dir;\n        off         = stack[sp-1].off;\n        ptag        = stack[sp-1].ptag;\n        attrs       = stack[sp-1].attrs;\n        attrcount   = stack[sp-1].attrcount;\n        tmask       = stack[sp-1].tmask;\n        ttag        = stack[sp-1].ttag;\n        begin       = stack[sp-1].begin;\n        end         = stack[sp-1].end;\n        diff        = stack[sp-1].diff;\n        cb          = stack[sp-1].cb;\n        data        = stack[sp-1].data;\n        tag         = stack[sp-1].tag;\n        buffer      = stack[sp-1].buffer;\n        disk        = stack[sp-1].disk;\n        sp -= 1;\n        goto popped;\n    } else {\n        return res;\n    }\n}\n```\n</target_code>\nPlease provide the modified lfs_dir_traverse code.\n",
  "test_code": "static int lfs_dir_traverse(lfs_t *lfs,\n        const lfs_mdir_t *dir, lfs_off_t off, lfs_tag_t ptag,\n        const struct lfs_mattr *attrs, int attrcount,\n        lfs_tag_t tmask, lfs_tag_t ttag,\n        uint16_t begin, uint16_t end, int16_t diff,\n        int (*cb)(void *data, lfs_tag_t tag, const void *buffer), void *data) {\n    // This function in inherently recursive, but bounded. To allow tool-based\n    // analysis without unnecessary code-cost we use an explicit stack\n    struct lfs_dir_traverse stack[LFS_DIR_TRAVERSE_DEPTH-1];\n    unsigned sp = 0;\n    int res;\n\n    // iterate over directory and attrs\n    lfs_tag_t tag;\n    const void *buffer;\n    struct lfs_diskoff disk = {0};\n\n    // probe: entry\n    {\n        FILE *log = fopen(\"/tmp/logs/3.txt\", \"a\");\n        if (log) {\n            fprintf(log, \"lfs_dir_traverse ENTRY: dir=%p off=%llu ptag=0x%08llx attrs=%p attrcount=%d tmask=0x%08llx ttag=0x%08llx begin=%u end=%u diff=%d cb=%p data=%p\\n\",\n                    (void*)dir, (unsigned long long)off, (unsigned long long)ptag,\n                    (void*)attrs, attrcount, (unsigned long long)tmask, (unsigned long long)ttag,\n                    (unsigned)begin, (unsigned)end, (int)diff, (void*)cb, data);\n            fclose(log);\n        }\n    }\n\n    while (true) {\n        {\n            if (off+lfs_tag_dsize(ptag) < dir->off) {\n                off += lfs_tag_dsize(ptag);\n                int err = lfs_bd_read(lfs,\n                        NULL, &lfs->rcache, sizeof(tag),\n                        dir->pair[0], off, &tag, sizeof(tag));\n                if (err) {\n                    // probe: read error\n                    FILE *log = fopen(\"/tmp/logs/3.txt\", \"a\");\n                    if (log) {\n                        fprintf(log, \"lfs_dir_traverse BD_READ_ERR: err=%d dir_pair0=%llu off=%llu\\n\",\n                                err, (unsigned long long)dir->pair[0], (unsigned long long)off);\n                        fclose(log);\n                    }\n                    return err;\n                }\n\n                tag = (lfs_frombe32(tag) ^ ptag) | 0x80000000;\n                disk.block = dir->pair[0];\n                disk.off = off+sizeof(lfs_tag_t);\n                buffer = &disk;\n                ptag = tag;\n\n                // probe: disk path taken\n                {\n                    FILE *log = fopen(\"/tmp/logs/3.txt\", \"a\");\n                    if (log) {\n                        fprintf(log, \"DISK_ENTRY: sp=%u tag=0x%08llx ptag=0x%08llx disk.block=%llu disk.off=%llu buffer=%p off=%llu\\n\",\n                                sp, (unsigned long long)tag, (unsigned long long)ptag,\n                                (unsigned long long)disk.block, (unsigned long long)disk.off,\n                                (void*)buffer, (unsigned long long)off);\n                        fclose(log);\n                    }\n                }\n\n            } else if (attrcount > 0) {\n                tag = attrs[0].tag;\n                buffer = attrs[0].buffer;\n\n                // probe: attr path taken (this is where violation evidence can be observed)\n                {\n                    FILE *log = fopen(\"/tmp/logs/3.txt\", \"a\");\n                    if (log) {\n                        fprintf(log, \"ATTR_ENTRY: sp=%u tag=0x%08llx attrs_ptr=%p attrs0_tag=0x%08llx attrs0_buffer=%p attrcount_before=%d\\n\",\n                                sp, (unsigned long long)tag, (void*)attrs, (unsigned long long)attrs[0].tag,\n                                (void*)attrs[0].buffer, attrcount);\n                        /* Also log hypothesis about constness: we note that attrs[0].buffer\n                           is used as a const void* by callers of lfs_dir_traverse. */\n                        fprintf(log, \"ATTR_ENTRY_NOTE: attrs[0].buffer address=%p (original type: void *)\\n\",\n                                (void*)attrs[0].buffer);\n                        fclose(log);\n                    }\n                }\n\n                attrs += 1;\n                attrcount -= 1;\n            } else {\n                // finished traversal, pop from stack?\n                res = 0;\n                break;\n            }\n\n            // do we need to filter?\n            lfs_tag_t mask = LFS_MKTAG(0x7ff, 0, 0);\n            if ((mask & tmask & tag) != (mask & tmask & ttag)) {\n                continue;\n            }\n\n            if (lfs_tag_id(tmask) != 0) {\n                LFS_ASSERT(sp < LFS_DIR_TRAVERSE_DEPTH);\n                // recurse, scan for duplicates, and update tag based on\n                // creates/deletes\n                stack[sp] = (struct lfs_dir_traverse){\n                    .dir        = dir,\n                    .off        = off,\n                    .ptag       = ptag,\n                    .attrs      = attrs,\n                    .attrcount  = attrcount,\n                    .tmask      = tmask,\n                    .ttag       = ttag,\n                    .begin      = begin,\n                    .end        = end,\n                    .diff       = diff,\n                    .cb         = cb,\n                    .data       = data,\n                    .tag        = tag,\n                    .buffer     = buffer,\n                    .disk       = disk,\n                };\n\n                // probe: push stack\n                {\n                    FILE *log = fopen(\"/tmp/logs/3.txt\", \"a\");\n                    if (log) {\n                        fprintf(log, \"STACK_PUSH: sp=%u new_sp=%u tag=0x%08llx buffer=%p ptag=0x%08llx off=%llu attrs=%p attrcount=%d\\n\",\n                                sp, sp+1, (unsigned long long)tag, (void*)buffer, (unsigned long long)ptag,\n                                (unsigned long long)off, (void*)attrs, attrcount);\n                        fclose(log);\n                    }\n                }\n\n                sp += 1;\n\n                tmask = 0;\n                ttag = 0;\n                begin = 0;\n                end = 0;\n                diff = 0;\n                cb = lfs_dir_traverse_filter;\n                data = &stack[sp-1].tag;\n                continue;\n            }\n        }\n\npopped:\n        // in filter range?\n        if (lfs_tag_id(tmask) != 0 &&\n                !(lfs_tag_id(tag) >= begin && lfs_tag_id(tag) < end)) {\n            continue;\n        }\n\n        // handle special cases for mcu-side operations\n        if (lfs_tag_type3(tag) == LFS_FROM_NOOP) {\n            // do nothing\n        } else if (lfs_tag_type3(tag) == LFS_FROM_MOVE) {\n            // Without this condition, lfs_dir_traverse can exhibit an\n            // extremely expensive O(n^3) of nested loops when renaming.\n            // This happens because lfs_dir_traverse tries to filter tags by\n            // the tags in the source directory, triggering a second\n            // lfs_dir_traverse with its own filter operation.\n            //\n            // traverse with commit\n            // '-> traverse with filter\n            //     '-> traverse with move\n            //         '-> traverse with filter\n            //\n            // However we don't actually care about filtering the second set of\n            // tags, since duplicate tags have no effect when filtering.\n            //\n            // This check skips this unnecessary recursive filtering explicitly,\n            // reducing this runtime from O(n^3) to O(n^2).\n            if (cb == lfs_dir_traverse_filter) {\n                continue;\n            }\n\n            // probe: entering MOVE\n            {\n                FILE *log = fopen(\"/tmp/logs/3.txt\", \"a\");\n                if (log) {\n                    fprintf(log, \"MOVE_ENTRY: sp=%u tag=0x%08llx cb=%p data=%p\\n\",\n                            sp, (unsigned long long)tag, (void*)cb, data);\n                    fclose(log);\n                }\n            }\n\n            // recurse into move\n            stack[sp] = (struct lfs_dir_traverse){\n                .dir        = dir,\n                .off        = off,\n                .ptag       = ptag,\n                .attrs      = attrs,\n                .attrcount  = attrcount,\n                .tmask      = tmask,\n                .ttag       = ttag,\n                .begin      = begin,\n                .end        = end,\n                .diff       = diff,\n                .cb         = cb,\n                .data       = data,\n                .tag        = LFS_MKTAG(LFS_FROM_NOOP, 0, 0),\n            };\n            sp += 1;\n\n            uint16_t fromid = lfs_tag_size(tag);\n            uint16_t toid = lfs_tag_id(tag);\n\n            // probe: move details\n            {\n                FILE *log = fopen(\"/tmp/logs/3.txt\", \"a\");\n                if (log) {\n                    fprintf(log, \"MOVE_DETAILS: fromid=%u toid=%u dir=%p\\n\",\n                            (unsigned)fromid, (unsigned)toid, (void*)buffer);\n                    fclose(log);\n                }\n            }\n\n            dir = buffer;\n            off = 0;\n            ptag = 0xffffffff;\n            attrs = NULL;\n            attrcount = 0;\n            tmask = LFS_MKTAG(0x600, 0x3ff, 0);\n            ttag = LFS_MKTAG(LFS_TYPE_STRUCT, 0, 0);\n            begin = fromid;\n            end = fromid+1;\n            diff = toid-fromid+diff;\n        } else if (lfs_tag_type3(tag) == LFS_FROM_USERATTRS) {\n            for (unsigned i = 0; i < lfs_tag_size(tag); i++) {\n                const struct lfs_attr *a = buffer;\n                /* probe: per-userattr before callback */\n                {\n                    FILE *log = fopen(\"/tmp/logs/3.txt\", \"a\");\n                    if (log) {\n                        fprintf(log, \"USERATTR_BEFORE_CB: sp=%u i=%u a=%p a[i].type=%u a[i].size=%u a[i].buffer=%p\\n\",\n                                sp, (unsigned)i, (void*)a, (unsigned)a[i].type, (unsigned)a[i].size, (void*)a[i].buffer);\n                        fclose(log);\n                    }\n                }\n\n                lfs_tag_t usertag = LFS_MKTAG(LFS_TYPE_USERATTR + a[i].type,\n                        lfs_tag_id(tag) + diff, a[i].size);\n                res = cb(data, usertag, a[i].buffer);\n\n                /* probe: after callback */\n                {\n                    FILE *log = fopen(\"/tmp/logs/3.txt\", \"a\");\n                    if (log) {\n                        fprintf(log, \"USERATTR_AFTER_CB: i=%u usertag=0x%08llx a[i].buffer=%p res=%d\\n\",\n                                (unsigned)i, (unsigned long long)usertag, (void*)a[i].buffer, res);\n                        fclose(log);\n                    }\n                }\n\n                if (res < 0) {\n                    // probe: callback error\n                    FILE *log = fopen(\"/tmp/logs/3.txt\", \"a\");\n                    if (log) {\n                        fprintf(log, \"USERATTR_CB_ERR: res=%d i=%u\\n\", res, (unsigned)i);\n                        fclose(log);\n                    }\n                    return res;\n                }\n\n                if (res) {\n                    break;\n                }\n            }\n        } else {\n            lfs_tag_t calltag = tag + LFS_MKTAG(0, diff, 0);\n\n            // probe: non-userattr callback\n            {\n                FILE *log = fopen(\"/tmp/logs/3.txt\", \"a\");\n                if (log) {\n                    fprintf(log, \"GEN_CB_BEFORE: sp=%u tag=0x%08llx calltag=0x%08llx buffer=%p data=%p cb=%p\\n\",\n                            sp, (unsigned long long)tag, (unsigned long long)calltag, (void*)buffer, data, (void*)cb);\n                    fclose(log);\n                }\n            }\n\n            res = cb(data, calltag, buffer);\n\n            // probe: after callback\n            {\n                FILE *log = fopen(\"/tmp/logs/3.txt\", \"a\");\n                if (log) {\n                    fprintf(log, \"GEN_CB_AFTER: calltag=0x%08llx buffer=%p res=%d\\n\",\n                            (unsigned long long)calltag, (void*)buffer, res);\n                    fclose(log);\n                }\n            }\n\n            if (res < 0) {\n                // probe: callback error\n                FILE *log = fopen(\"/tmp/logs/3.txt\", \"a\");\n                if (log) {\n                    fprintf(log, \"GEN_CB_ERR: res=%d calltag=0x%08llx\\n\", res, (unsigned long long)calltag);\n                    fclose(log);\n                }\n                return res;\n            }\n\n            if (res) {\n                break;\n            }\n        }\n    }\n\n    if (sp > 0) {\n        // pop from the stack and return, fortunately all pops share\n        // a destination\n        // probe: pop\n        {\n            FILE *log = fopen(\"/tmp/logs/3.txt\", \"a\");\n            if (log) {\n                fprintf(log, \"STACK_POP: sp=%u -> popping index=%u tag=0x%08llx\\n\",\n                        sp, sp-1, (unsigned long long)stack[sp-1].tag);\n                fclose(log);\n            }\n        }\n\n        dir         = stack[sp-1].dir;\n        off         = stack[sp-1].off;\n        ptag        = stack[sp-1].ptag;\n        attrs       = stack[sp-1].attrs;\n        attrcount   = stack[sp-1].attrcount;\n        tmask       = stack[sp-1].tmask;\n        ttag        = stack[sp-1].ttag;\n        begin       = stack[sp-1].begin;\n        end         = stack[sp-1].end;\n        diff        = stack[sp-1].diff;\n        cb          = stack[sp-1].cb;\n        data        = stack[sp-1].data;\n        tag         = stack[sp-1].tag;\n        buffer      = stack[sp-1].buffer;\n        disk        = stack[sp-1].disk;\n        sp -= 1;\n        goto popped;\n    } else {\n        // probe: exit\n        {\n            FILE *log = fopen(\"/tmp/logs/3.txt\", \"a\");\n            if (log) {\n                fprintf(log, \"lfs_dir_traverse EXIT: res=%d\\n\", res);\n                fclose(log);\n            }\n        }\n        return res;\n    }\n}\n"
}