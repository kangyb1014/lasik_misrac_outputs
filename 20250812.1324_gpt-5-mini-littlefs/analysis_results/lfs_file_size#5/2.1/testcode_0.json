{
  "user_message": "<misra_rule>\nMISRA C 2023 Rule 2.1 is: A project shall not contain unreachable code.\n\n</misra_rule>\n\nAnother agent reported that the target code violated the Rule 2.1.\nHere is the comment from the agent.\n<violation scenario>\nThe macro LFS_LOCK(cfg) expands to the constant expression ((void)cfg, 0). In lfs_file_size this yields int err = 0, so the subsequent if (err) { return err; } can never be true \u2014 the body of that if (the return) is unreachable. This constitutes a violation of MISRA C 2023 Rule 2.1 (unreachable code).\n</violation scenario>\n\nYour job is to insert logging code to capture the control flow and state information of the program.\nInsert logging code so that other agents can reproduce and get evidence for the violation scenario.\n<response format>\n- test_code: a modified lfs_file_size code that contains useful probe functions that print useful logs to a file \"/tmp/logs/41.txt\". The logs should contain the control path and state information of the violation scenario. If test code is not required to validate the scenario, you can leave this blank.\nHere are the constraints for the test code:\n- The test code MUST preserve the original logic of lfs_file_size as much as possible.\nYou CAN just insert probe functions to the original code.\n- DO NOT introduce new violations to demonstrate your scenario.\n- The test code MUST be compilable and executable.\n- The test code MUST include line breaks.\n- You MUST NOT define the main function.\n- You MUST NOT define macros.\n</response format>\n<target_code>\nHere is the code of lfs_file_size:\n```c\nlfs_soff_t lfs_file_size(lfs_t *lfs, lfs_file_t *file) {\n    int err = LFS_LOCK(lfs->cfg);\n    if (err) {\n        return err;\n    }\n    LFS_TRACE(\"lfs_file_size(%p, %p)\", (void*)lfs, (void*)file);\n    LFS_ASSERT(lfs_mlist_isopen(lfs->mlist, (struct lfs_mlist*)file));\n\n    lfs_soff_t res = lfs_file_size_(lfs, file);\n\n    LFS_TRACE(\"lfs_file_size -> %\"PRIu32, res);\n    LFS_UNLOCK(lfs->cfg);\n    return res;\n}\n```\n</target_code>\nPlease provide the modified lfs_file_size code.\n",
  "test_code": "#include <stdio.h>\n#include <stdint.h>\n#include <inttypes.h>\n#include <stdarg.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n\n/* Minimal type stubs to make this testable and compilable. */\ntypedef struct lfs_tag { void *cfg; void *mlist; } lfs_t;\ntypedef struct lfs_file_tag { int dummy; } lfs_file_t;\ntypedef uint32_t lfs_soff_t;\n\n/* Helper: ensure log directory exists and append logs. */\nstatic void probe_ensure_dir(void) {\n    /* ignore errors if already exists */\n    (void)mkdir(\"/tmp/logs\", 0777);\n}\n\nstatic void probe_log(const char *fmt, ...) {\n    probe_ensure_dir();\n    FILE *f = fopen(\"/tmp/logs/41.txt\", \"a\");\n    if (!f) { return; }\n    va_list ap;\n    va_start(ap, fmt);\n    vfprintf(f, fmt, ap);\n    fprintf(f, \"\\n\");\n    va_end(ap);\n    fclose(f);\n}\n\n/* Substitute implementations for external helpers used by lfs_file_size.\n   These are implemented as functions (not macros) so this file compiles\n   standalone for testing the control flow. LFS_LOCK intentionally returns 0\n   to mirror the reported expansion ((void)cfg, 0). */\nstatic int LFS_LOCK(void *cfg) {\n    (void)cfg; /* mimic ((void)cfg, 0) */\n    probe_log(\"LFS_LOCK called with cfg=%p -> returning 0\", cfg);\n    return 0;\n}\n\nstatic void LFS_UNLOCK(void *cfg) {\n    probe_log(\"LFS_UNLOCK called with cfg=%p\", cfg);\n    (void)cfg;\n}\n\nstatic void LFS_TRACE(const char *fmt, ...) {\n    va_list ap;\n    va_start(ap, fmt);\n    /* forward to probe_log with a prefix so traces and probes are in same file */\n    char buf[512];\n    vsnprintf(buf, sizeof(buf), fmt, ap);\n    va_end(ap);\n    probe_log(\"TRACE: %s\", buf);\n}\n\nstatic void LFS_ASSERT(int cond) {\n    probe_log(\"ASSERT: %s\", cond ? \"true\" : \"false\");\n    /* Do not abort to preserve original control flow for testing. */\n}\n\n/* Minimal mlist check - always true for this test harness. */\nstatic int lfs_mlist_isopen(void *mlist, struct lfs_mlist *file) {\n    (void)mlist; (void)file;\n    probe_log(\"lfs_mlist_isopen called -> true\");\n    return 1;\n}\n\n/* Minimal implementation of the internal file size function. */\nstatic lfs_soff_t lfs_file_size_(lfs_t *lfs, lfs_file_t *file) {\n    (void)lfs; (void)file;\n    probe_log(\"lfs_file_size_ called\");\n    return (lfs_soff_t)12345u;\n}\n\n/* The target function with inserted probes to capture control flow and state. */\nlfs_soff_t lfs_file_size(lfs_t *lfs, lfs_file_t *file) {\n    probe_log(\"ENTER lfs_file_size: lfs=%p, file=%p\", (void*)lfs, (void*)file);\n\n    int err = LFS_LOCK(lfs->cfg);\n    probe_log(\"after LFS_LOCK: err=%d\", err);\n\n    if (err) {\n        probe_log(\"if (err) branch taken: returning err=%d\", err);\n        return err;\n    }\n    probe_log(\"if (err) branch not taken (err==0)\");\n\n    LFS_TRACE(\"lfs_file_size(%p, %p)\", (void*)lfs, (void*)file);\n    LFS_ASSERT(lfs_mlist_isopen(lfs->mlist, (struct lfs_mlist*)file));\n\n    lfs_soff_t res = lfs_file_size_(lfs, file);\n\n    LFS_TRACE(\"lfs_file_size -> %\" PRIu32, res);\n    LFS_UNLOCK(lfs->cfg);\n\n    probe_log(\"EXIT lfs_file_size: returning res=%\" PRIu32, res);\n    return res;\n}\n"
}