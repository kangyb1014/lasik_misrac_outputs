{
  "user_message": "<misra_rule>\nMISRA C 2023 Rule 2.1 is: A project shall not contain unreachable code.\n\n</misra_rule>\n\nAnother agent reported that the target code violated the Rule 2.1.\nHere is the comment from the agent.\n<violation scenario>\nThe macro LFS_LOCK(cfg) is defined as ((void)cfg,0), which always evaluates to 0. In lfs_file_write the code int err = LFS_LOCK(lfs->cfg); if (err) { return err; } therefore the condition if (err) can never be true and its body (return err;) is unreachable. This unreachable branch violates MISRA C 2023 Rule 2.1.\n</violation scenario>\n\nYour job is to insert logging code to capture the control flow and state information of the program.\nInsert logging code so that other agents can reproduce and get evidence for the violation scenario.\n<response format>\n- test_code: a modified lfs_file_write code that contains useful probe functions that print useful logs to a file \"/tmp/logs/145.txt\". The logs should contain the control path and state information of the violation scenario. If test code is not required to validate the scenario, you can leave this blank.\nHere are the constraints for the test code:\n- The test code MUST preserve the original logic of lfs_file_write as much as possible.\nYou CAN just insert probe functions to the original code.\n- DO NOT introduce new violations to demonstrate your scenario.\n- The test code MUST be compilable and executable.\n- The test code MUST include line breaks.\n- You MUST NOT define the main function.\n- You MUST NOT define macros.\n</response format>\n<target_code>\nHere is the code of lfs_file_write:\n```c\nlfs_ssize_t lfs_file_write(lfs_t *lfs, lfs_file_t *file,\n        const void *buffer, lfs_size_t size) {\n    int err = LFS_LOCK(lfs->cfg);\n    if (err) {\n        return err;\n    }\n    LFS_TRACE(\"lfs_file_write(%p, %p, %p, %\"PRIu32\")\",\n            (void*)lfs, (void*)file, buffer, size);\n    LFS_ASSERT(lfs_mlist_isopen(lfs->mlist, (struct lfs_mlist*)file));\n\n    lfs_ssize_t res = lfs_file_write_(lfs, file, buffer, size);\n\n    LFS_TRACE(\"lfs_file_write -> %\"PRId32, res);\n    LFS_UNLOCK(lfs->cfg);\n    return res;\n}\n```\n</target_code>\nPlease provide the modified lfs_file_write code.\n",
  "test_code": "/* Probe logging functions for lfs_file_write control flow/state capture.\n * These functions append logs to /tmp/logs/145.txt. They are defined static\n * so they don't change external linkage. They do not modify program logic.\n */\n\nstatic void lfs_log_lock_result(lfs_t *lfs, lfs_file_t *file,\n        const void *buffer, lfs_size_t size, int err) {\n    FILE *fp = fopen(\"/tmp/logs/145.txt\", \"a\");\n    if (fp) {\n        /* Log lock result and basic state. Cast size for safe printing. */\n        fprintf(fp, \"lfs_file_write: LFS_LOCK returned=%d lfs=%p file=%p buffer=%p size=%llu\\n\",\n                err, (void*)lfs, (void*)file, buffer, (unsigned long long)size);\n        fclose(fp);\n    }\n}\n\nstatic void lfs_log_unreachable_branch(lfs_t *lfs, lfs_file_t *file,\n        const void *buffer, lfs_size_t size, int err) {\n    FILE *fp = fopen(\"/tmp/logs/145.txt\", \"a\");\n    if (fp) {\n        /* Signal that the (presumed) unreachable branch was entered. */\n        fprintf(fp, \"lfs_file_write: Entered if(err) branch - returning err=%d lfs=%p file=%p buffer=%p size=%llu\\n\",\n                err, (void*)lfs, (void*)file, buffer, (unsigned long long)size);\n        fclose(fp);\n    }\n}\n\nlfs_ssize_t lfs_file_write(lfs_t *lfs, lfs_file_t *file,\n        const void *buffer, lfs_size_t size) {\n    int err = LFS_LOCK(lfs->cfg);\n\n    /* Probe: log the result of LFS_LOCK and the call inputs. */\n    lfs_log_lock_result(lfs, file, buffer, size, err);\n\n    if (err) {\n        /* If this ever executes, record detailed evidence before returning. */\n        lfs_log_unreachable_branch(lfs, file, buffer, size, err);\n        return err;\n    }\n    LFS_TRACE(\"lfs_file_write(%p, %p, %p, %\"PRIu32\")\",\n            (void*)lfs, (void*)file, buffer, size);\n    LFS_ASSERT(lfs_mlist_isopen(lfs->mlist, (struct lfs_mlist*)file));\n\n    lfs_ssize_t res = lfs_file_write_(lfs, file, buffer, size);\n\n    LFS_TRACE(\"lfs_file_write -> %\"PRId32, res);\n\n    /* Probe: log the result of the write before unlocking. */\n    {\n        FILE *fp = fopen(\"/tmp/logs/145.txt\", \"a\");\n        if (fp) {\n            fprintf(fp, \"lfs_file_write: write result=%lld lfs=%p file=%p buffer=%p size=%llu\\n\",\n                    (long long)res, (void*)lfs, (void*)file, buffer, (unsigned long long)size);\n            fclose(fp);\n        }\n    }\n\n    LFS_UNLOCK(lfs->cfg);\n    return res;\n}\n"
}