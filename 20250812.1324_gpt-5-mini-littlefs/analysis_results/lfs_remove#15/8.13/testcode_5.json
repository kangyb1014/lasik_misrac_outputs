{
  "user_message": "<misra_rule>\nMISRA C 2023 Rule 8.13 is: A pointer should point to a const-qualified type whenever possible.\n\n</misra_rule>\n\nAnother agent reported that the target code violated the Rule 8.13.\nHere is the comment from the agent.\n<violation scenario>\nThe call passes &dir.m (type lfs_mdir_t *) to lfs_dir_drop. If lfs_dir_drop does not modify the lfs_mdir_t object (it only reads it to drop the directory), its parameter should be declared as const lfs_mdir_t *. In that case the current non-const pointer usage violates MISRA C 2023 Rule 8.13. Recommended fix: change the lfs_dir_drop prototype to accept const lfs_mdir_t * and update its implementation accordingly.\n</violation scenario>\n\nYour job is to insert logging code to capture the control flow and state information of the program.\nInsert logging code so that other agents can reproduce and get evidence for the violation scenario.\n<response format>\n- test_code: a modified lfs_remove code that contains useful probe functions that print useful logs to a file \"/tmp/logs/123.txt\". The logs should contain the control path and state information of the violation scenario. If test code is not required to validate the scenario, you can leave this blank.\nHere are the constraints for the test code:\n- The test code MUST preserve the original logic of lfs_remove as much as possible.\nYou CAN just insert probe functions to the original code.\n- DO NOT introduce new violations to demonstrate your scenario.\n- The test code MUST be compilable and executable.\n- The test code MUST include line breaks.\n- You MUST NOT define the main function.\n- You MUST NOT define macros.\n</response format>\n<target_code>\nHere is the code of lfs_remove:\n```c\nint lfs_remove(lfs_t *lfs, const char *path) {\n    int err = LFS_LOCK(lfs->cfg);\n    if (err) {\n        return err;\n    }\n    LFS_TRACE(\"lfs_remove(%p, \\\"%s\\\")\", (void*)lfs, path);\n\n    err = lfs_remove_(lfs, path);\n\n    LFS_TRACE(\"lfs_remove -> %d\", err);\n    LFS_UNLOCK(lfs->cfg);\n    return err;\n}\n```\n</target_code>\nPlease provide the modified lfs_remove code.\n",
  "test_code": "#include <stdio.h>\n#include <stdarg.h>\n#include <time.h>\n\n/*\n * Probe logger for lfs_remove: appends human-readable control-flow and state\n * information to /tmp/logs/123.txt. This preserves the original logic of\n * lfs_remove while emitting extra evidence useful to reproduce the reported\n * MISRA Rule 8.13 violation scenario.\n *\n * Note: This file must be compiled as part of the lfs project where lfs_t,\n * LFS_LOCK, LFS_UNLOCK, LFS_TRACE and lfs_remove_ are defined.\n */\n\nstatic void lfs_remove_log(const char *fmt, ...)\n{\n    FILE *f = fopen(\"/tmp/logs/123.txt\", \"a\");\n    if (!f) {\n        return;\n    }\n\n    /* timestamp */\n    time_t t = time(NULL);\n    struct tm tm_buf;\n#if defined(__STDC_LIB_EXT1__)\n    localtime_s(&tm_buf, &t);\n#else\n    {\n        struct tm *tmp = localtime(&t);\n        if (tmp) {\n            tm_buf = *tmp;\n        }\n    }\n#endif\n    fprintf(f, \"%04d-%02d-%02d %02d:%02d:%02d - \",\n            tm_buf.tm_year + 1900, tm_buf.tm_mon + 1, tm_buf.tm_mday,\n            tm_buf.tm_hour, tm_buf.tm_min, tm_buf.tm_sec);\n\n    va_list ap;\n    va_start(ap, fmt);\n    vfprintf(f, fmt, ap);\n    va_end(ap);\n\n    fprintf(f, \"\\n\");\n    fclose(f);\n}\n\n/* Forward declaration: actual definition exists elsewhere in the codebase. */\nextern int lfs_remove_(lfs_t *lfs, const char *path);\n\nint lfs_remove(lfs_t *lfs, const char *path) {\n    int err = LFS_LOCK(lfs->cfg);\n    lfs_remove_log(\"ENTER lfs_remove: lfs=%p path=%s lock_err=%d\",\n                   (void *)lfs, path ? path : \"(null)\", err);\n\n    if (err) {\n        lfs_remove_log(\"lfs_remove: early return due to lock error: %d\", err);\n        return err;\n    }\n\n    LFS_TRACE(\"lfs_remove(%p, \\\"%s\\\")\", (void*)lfs, path);\n\n    /*\n     * Before calling the internal implementation, log intent. This gives\n     * a reproducible point in the logs to correlate the higher-level call\n     * and the lower-level actions that may pass &dir.m (lfs_mdir_t *) to\n     * lfs_dir_drop.\n     */\n    lfs_remove_log(\"Calling lfs_remove_ (internal implementation) with lfs=%p path=%s\",\n                   (void *)lfs, path ? path : \"(null)\");\n\n    err = lfs_remove_(lfs, path);\n\n    /* Log return value from the internal implementation */\n    lfs_remove_log(\"Returned from lfs_remove_: lfs=%p path=%s result=%d\",\n                   (void *)lfs, path ? path : \"(null)\", err);\n\n    /*\n     * Helpful hint for investigators: if lfs_remove_ calls lfs_dir_drop with\n     * a non-const pointer (for example '&dir.m' of type lfs_mdir_t *), that\n     * usage may violate MISRA C 2023 Rule 8.13. Consumers of these logs can\n     * search for the \"Calling lfs_remove_\" and \"Returned from lfs_remove_\"\n     * entries to locate the exact execution window during which the\n     * violation would occur.\n     */\n    lfs_remove_log(\"NOTE: Inspect calls within lfs_remove_ for non-const lfs_mdir_t* (e.g. &dir.m) passed to lfs_dir_drop\");\n\n    LFS_TRACE(\"lfs_remove -> %d\", err);\n    LFS_UNLOCK(lfs->cfg);\n\n    lfs_remove_log(\"EXIT lfs_remove: lfs=%p path=%s result=%d\",\n                   (void *)lfs, path ? path : \"(null)\", err);\n\n    return err;\n}\n"
}