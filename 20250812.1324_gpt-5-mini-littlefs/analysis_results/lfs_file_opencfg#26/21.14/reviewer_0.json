{
  "user_message": "An agent A claimed that the following lfs_file_opencfg code violates the MISRA C 2023 rule 21.14.\n<misra_rule>\nMISRA C 2023 Rule 21.14 is The Standard Library function memcmp shall not be used to compare null terminated strings.\n.\n</misra_rule>\n<target_code>\nHere is the original code of lfs_file_opencfg.\n```c\nint lfs_file_opencfg(lfs_t *lfs, lfs_file_t *file,\n        const char *path, int flags,\n        const struct lfs_file_config *cfg) {\n    int err = LFS_LOCK(lfs->cfg);\n    if (err) {\n        return err;\n    }\n    LFS_TRACE(\"lfs_file_opencfg(%p, %p, \\\"%s\\\", %x, %p {\"\n                 \".buffer=%p, .attrs=%p, .attr_count=%\"PRIu32\"})\",\n            (void*)lfs, (void*)file, path, (unsigned)flags,\n            (void*)cfg, cfg->buffer, (void*)cfg->attrs, cfg->attr_count);\n    LFS_ASSERT(!lfs_mlist_isopen(lfs->mlist, (struct lfs_mlist*)file));\n\n    err = lfs_file_opencfg_(lfs, file, path, flags, cfg);\n\n    LFS_TRACE(\"lfs_file_opencfg -> %d\", err);\n    LFS_UNLOCK(lfs->cfg);\n    return err;\n}\n```\n</target_code>\n<scenario>\nThe agent A provided the following violation scenario:The code calls memcmp(name, \".\", 1) to test whether a path component equals the string \".\". Here 'name' points into a null-terminated path buffer and the second argument is a string literal (\".\") \u2014 i.e. this is using memcmp to compare string data. (The same pattern also appears elsewhere in the file for \"..\" and suffix checks.) According to MISRA C 2023 Rule 21.14, memcmp shall not be used to compare null-terminated strings, so this use violates the rule.\n</scenario>\n<test_code>\nAlso, the agent A provided the following modified code that prints out the log to support their scenario:\n```c\nstatic void lfs_probe_log(const char *msg) {\n    FILE *f = fopen(\"/tmp/logs/214.txt\", \"a\");\n    if (!f) {\n        return;\n    }\n    fprintf(f, \"%s\\n\", msg);\n    fclose(f);\n}\nstatic void lfs_probe_log_state(const char *prefix, const void *lfs, const void *file,\n        const char *path, int flags, const void *cfg, const void *buffer,\n        const void *attrs, unsigned long attr_count) {\n    FILE *f = fopen(\"/tmp/logs/214.txt\", \"a\");\n    if (!f) {\n        return;\n    }\n    fprintf(f, \"%s: lfs=%p file=%p path=%p(\\\"%s\\\") flags=0x%X cfg=%p buffer=%p attrs=%p attr_count=%lu\\n\",\n            prefix, lfs, file, (const void*)path, path ? path : \"(null)\", (unsigned)flags,\n            cfg, buffer, attrs, attr_count);\n    fclose(f);\n}\nstatic void lfs_probe_scan_path_for_dot_components(const char *path) {\n    FILE *f = fopen(\"/tmp/logs/214.txt\", \"a\");\n    if (!f) {\n        return;\n    }\n    if (!path) {\n        fprintf(f, \"scan_path: path is NULL\\n\");\n        fclose(f);\n        return;\n    }\n\n    const char *p = path;\n    unsigned comp_index = 0;\n    while (*p) {\n        /* skip leading slashes */\n        while (*p == '/') {\n            p++;\n        }\n        if (!*p) break;\n        /* find end of component */\n        const char *q = p;\n        while (*q && *q != '/') q++;\n        size_t len = (size_t)(q - p);\n\n        /* check for \".\" and \"..\" without using memcmp */\n        if (len == 1 && p[0] == '.') {\n            fprintf(f, \"scan_path: component[%u] == \\\".\\\" at offset %td\\n\", comp_index, (ptrdiff_t)(p - path));\n        }\n        else if (len == 2 && p[0] == '.' && p[1] == '.') {\n            fprintf(f, \"scan_path: component[%u] == \\\"..\\\" at offset %td\\n\", comp_index, (ptrdiff_t)(p - path));\n        }\n        else {\n            /* log suffixes that might be checked elsewhere (e.g., trailing \".\" patterns) */\n            if (len > 0) {\n                /* log a small preview (up to 16 chars) to avoid large output */\n                size_t preview = len > 16 ? 16 : len;\n                char buf[17];\n                for (size_t i = 0; i < preview; i++) buf[i] = p[i];\n                buf[preview] = '\\0';\n                fprintf(f, \"scan_path: component[%u] (len=%zu) preview=\\\"%s\\\" offset=%td\\n\",\n                        comp_index, len, buf, (ptrdiff_t)(p - path));\n            }\n        }\n\n        comp_index++;\n        p = q;\n    }\n\n    fclose(f);\n}\n\nint lfs_file_opencfg(lfs_t *lfs, lfs_file_t *file,\n        const char *path, int flags,\n        const struct lfs_file_config *cfg) {\n    int err = LFS_LOCK(lfs->cfg);\n    if (err) {\n        /* log the lock failure */\n        char buf[128];\n        snprintf(buf, sizeof(buf), \"lfs_file_opencfg: LFS_LOCK failed -> %d\", err);\n        lfs_probe_log(buf);\n        return err;\n    }\n\n    /* Original trace retained */\n    LFS_TRACE(\"lfs_file_opencfg(%p, %p, \\\"%s\\\", %x, %p {\"\n                 \".buffer=%p, .attrs=%p, .attr_count=%\"PRIu32\"})\",\n            (void*)lfs, (void*)file, path, (unsigned)flags,\n            (void*)cfg, cfg->buffer, (void*)cfg->attrs, cfg->attr_count);\n\n    /* Assertion retained */\n    LFS_ASSERT(!lfs_mlist_isopen(lfs->mlist, (struct lfs_mlist*)file));\n\n    /* Probe: log state before calling the internal open function */\n    lfs_probe_log_state(\"lfs_file_opencfg:entry\", lfs, file, path, flags,\n            cfg, cfg ? cfg->buffer : NULL, cfg ? cfg->attrs : NULL,\n            cfg ? (unsigned long)cfg->attr_count : 0UL);\n\n    /* Probe: scan the path and record any '.' or '..' components\n       to provide evidence for string comparison cases. */\n    lfs_probe_scan_path_for_dot_components(path);\n\n    err = lfs_file_opencfg_(lfs, file, path, flags, cfg);\n\n    /* Probe: log the return value and state after the internal call */\n    char buf[128];\n    snprintf(buf, sizeof(buf), \"lfs_file_opencfg: exit -> %d\", err);\n    lfs_probe_log(buf);\n\n    LFS_TRACE(\"lfs_file_opencfg -> %d\", err);\n    LFS_UNLOCK(lfs->cfg);\n    return err;\n}\n\n```\nThe test code was compiled successfully, but the test log is empty for lfs_file_opencfg. The test suite might not cover this function or the test code might be not suitable to print important information.\n</test_code>\n<response format>\nProvide your answer with these fields.\n- explanation: your evaluation of the scenario provided by the agent A.\n- is_report_correct: whether the report is correct or not (true/false)\n</response format>\n<instruction>   \nJudge whether the report is correct or not.\n</instruction>\n",
  "is_report_correct": false,
  "explanation": "MISRA C:2023 Rule 21.14 forbids use of memcmp to compare null-terminated strings. However, the supplied lfs_file_opencfg implementation contains no calls to memcmp, so the function as presented does not violate Rule 21.14. The scenario describes memcmp(name, \".\", 1) occurring elsewhere in the same source file; that usage (memcmp against a string literal) would indeed be contrary to the intent of Rule 21.14 and should be replaced (e.g. by a direct character comparison or a bounded string function). But based on the provided lfs_file_opencfg code and the empty probe logs, there is no evidence that this specific function violates the rule. Therefore the report about lfs_file_opencfg is not correct."
}