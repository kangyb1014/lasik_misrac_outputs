{
  "user_message": "<misra_rule>\nMISRA C 2023 Rule 21.17 is: Use of the string handling functions from <string.h> shall not result in accesses beyond the bounds of the objects referenced by their pointer parameters.\nThis rule strictly applies to the Standard Library functions in <string.h> such as memcpy, memmove, memset, memcmp, strcpy, strncpy, strcat, strncat, strlen, and strspn.\n</misra_rule>\n\nAnother agent reported that the target code violated the Rule 21.17.\nHere is the comment from the agent.\n<violation scenario>\nIf file->cfg->buffer is a caller-supplied pointer that is smaller than lfs->cfg->cache_size, the code assigns that pointer to file->cache.buffer without checking its capacity. Later the code calls lfs_cache_zero(lfs, &file->cache) (and other operations that read/write cache_size bytes, e.g. lfs_dir_get) which likely use memset/memcpy to operate on file->cache.buffer using lfs->cfg->cache_size. In that case those string/memory functions would access beyond the bounds of the provided buffer, violating Rule 21.17.\n</violation scenario>\n\nYour job is to insert logging code to capture the control flow and state information of the program.\nInsert logging code so that other agents can reproduce and get evidence for the violation scenario.\n<response format>\n- test_code: a modified lfs_file_open code that contains useful probe functions that print useful logs to a file \"/tmp/logs/39.txt\". The logs should contain the control path and state information of the violation scenario. If test code is not required to validate the scenario, you can leave this blank.\nHere are the constraints for the test code:\n- The test code MUST preserve the original logic of lfs_file_open as much as possible.\nYou CAN just insert probe functions to the original code.\n- DO NOT introduce new violations to demonstrate your scenario.\n- The test code MUST be compilable and executable.\n- The test code MUST include line breaks.\n- You MUST NOT define the main function.\n- You MUST NOT define macros.\n</response format>\n<target_code>\nHere is the code of lfs_file_open:\n```c\nint lfs_file_open(lfs_t *lfs, lfs_file_t *file, const char *path, int flags) {\n    int err = LFS_LOCK(lfs->cfg);\n    if (err) {\n        return err;\n    }\n    LFS_TRACE(\"lfs_file_open(%p, %p, \\\"%s\\\", %x)\",\n            (void*)lfs, (void*)file, path, (unsigned)flags);\n    LFS_ASSERT(!lfs_mlist_isopen(lfs->mlist, (struct lfs_mlist*)file));\n\n    err = lfs_file_open_(lfs, file, path, flags);\n\n    LFS_TRACE(\"lfs_file_open -> %d\", err);\n    LFS_UNLOCK(lfs->cfg);\n    return err;\n}\n```\n</target_code>\nPlease provide the modified lfs_file_open code.\n",
  "test_code": "#include <stdio.h>\n#include <stddef.h>\n\n/* Probe helper: append diagnostic logs to /tmp/logs/39.txt. */\nstatic void lfs_file_open_probe(const char *stage, struct lfs *lfs, struct lfs_file *file,\n        const char *path, int flags, int err) {\n    FILE *fp = fopen(\"/tmp/logs/39.txt\", \"a\");\n    if (!fp) {\n        return;\n    }\n\n    /* Safely collect state we expect to be present for the violation scenario. */\n    void *file_cache_buffer = NULL;\n    size_t lfs_cache_size = 0;\n\n    if (lfs && lfs->cfg) {\n        /* cache_size is expected to exist on lfs->cfg in the target code. */\n        lfs_cache_size = (size_t)lfs->cfg->cache_size;\n    }\n\n    if (file) {\n        /* file->cache.buffer is expected to exist in the target code. */\n        file_cache_buffer = (void*)file->cache.buffer;\n    }\n\n    fprintf(fp, \"[lfs_file_open_probe] stage=%s\\n\", stage);\n    fprintf(fp, \"  lfs=%p, file=%p, path=%s, flags=0x%x, err=%d\\n\",\n            (void*)lfs, (void*)file, (path ? path : \"(null)\"), (unsigned)flags, err);\n    fprintf(fp, \"  lfs->cfg->cache_size=%zu\\n\", lfs_cache_size);\n    fprintf(fp, \"  file->cache.buffer=%p\\n\", file_cache_buffer);\n    fflush(fp);\n    fclose(fp);\n}\n\nint lfs_file_open(lfs_t *lfs, lfs_file_t *file, const char *path, int flags) {\n    int err = LFS_LOCK(lfs->cfg);\n    if (err) {\n        /* Log the early lock failure state */\n        lfs_file_open_probe(\"after_lock_failure\", lfs, file, path, flags, err);\n        return err;\n    }\n    LFS_TRACE(\"lfs_file_open(%p, %p, \\\"%s\\\", %x)\",\n            (void*)lfs, (void*)file, path, (unsigned)flags);\n    LFS_ASSERT(!lfs_mlist_isopen(lfs->mlist, (struct lfs_mlist*)file));\n\n    /* Log state before delegating to lfs_file_open_ so we can capture the\n       caller-supplied buffer pointer and the configured cache size. */\n    lfs_file_open_probe(\"before_lfs_file_open_\", lfs, file, path, flags, 0);\n\n    err = lfs_file_open_(lfs, file, path, flags);\n\n    /* Log result and state after lfs_file_open_ returns. This helps reveal\n       whether file->cache.buffer was assigned from a caller-supplied pointer\n       that is smaller than lfs->cfg->cache_size. */\n    lfs_file_open_probe(\"after_lfs_file_open_\", lfs, file, path, flags, err);\n\n    LFS_TRACE(\"lfs_file_open -> %d\", err);\n    LFS_UNLOCK(lfs->cfg);\n    return err;\n}\n"
}