{
  "user_message": "<misra_rule>\nMISRA C 2023 Rule 21.17 is: Use of the string handling functions from <string.h> shall not result in accesses beyond the bounds of the objects referenced by their pointer parameters.\nThis rule strictly applies to the Standard Library functions in <string.h> such as memcpy, memmove, memset, memcmp, strcpy, strncpy, strcat, strncat, strlen, and strspn.\n</misra_rule>\n\nAnother agent reported that the target code violated the Rule 21.17.\nHere is the comment from the agent.\n<violation scenario>\nThe code passes file->cfg->attrs[i].buffer and file->cfg->attrs[i].size to lfs_dir_get without validating that the buffer is non-NULL and that the buffer is at least attrs[i].size bytes long. If lfs_dir_get uses memcpy/memmove/memset (or other <string.h> functions) to transfer attrs[i].size bytes into attrs[i].buffer, and the buffer is smaller than attrs[i].size (or NULL), this will produce out\u2011of\u2011bounds accesses. Note that the code only checks attribute size against lfs->attr_max in the write path, not in the read path shown, so a malformed/incorrect cfg can trigger the overflow.\n</violation scenario>\n\nYour job is to insert logging code to capture the control flow and state information of the program.\nInsert logging code so that other agents can reproduce and get evidence for the violation scenario.\n<response format>\n- test_code: a modified lfs_file_open code that contains useful probe functions that print useful logs to a file \"/tmp/logs/39.txt\". The logs should contain the control path and state information of the violation scenario. If test code is not required to validate the scenario, you can leave this blank.\nHere are the constraints for the test code:\n- The test code MUST preserve the original logic of lfs_file_open as much as possible.\nYou CAN just insert probe functions to the original code.\n- DO NOT introduce new violations to demonstrate your scenario.\n- The test code MUST be compilable and executable.\n- The test code MUST include line breaks.\n- You MUST NOT define the main function.\n- You MUST NOT define macros.\n</response format>\n<target_code>\nHere is the code of lfs_file_open:\n```c\nint lfs_file_open(lfs_t *lfs, lfs_file_t *file, const char *path, int flags) {\n    int err = LFS_LOCK(lfs->cfg);\n    if (err) {\n        return err;\n    }\n    LFS_TRACE(\"lfs_file_open(%p, %p, \\\"%s\\\", %x)\",\n            (void*)lfs, (void*)file, path, (unsigned)flags);\n    LFS_ASSERT(!lfs_mlist_isopen(lfs->mlist, (struct lfs_mlist*)file));\n\n    err = lfs_file_open_(lfs, file, path, flags);\n\n    LFS_TRACE(\"lfs_file_open -> %d\", err);\n    LFS_UNLOCK(lfs->cfg);\n    return err;\n}\n```\n</target_code>\nPlease provide the modified lfs_file_open code.\n",
  "test_code": "#include <stdio.h>\n#include <stdarg.h>\n#include <stdint.h>\n\n/* Probe helpers: append human-readable logs and hex dumps to /tmp/logs/39.txt */\nstatic void lfs_probe_log(const char *fmt, ...) {\n    FILE *f = fopen(\"/tmp/logs/39.txt\", \"a\");\n    if (!f) {\n        return;\n    }\n    va_list ap;\n    va_start(ap, fmt);\n    vfprintf(f, fmt, ap);\n    va_end(ap);\n    fprintf(f, \"\\n\");\n    fclose(f);\n}\n\nstatic void lfs_probe_dump_hex(const void *ptr, size_t len) {\n    if (ptr == NULL || len == 0) {\n        lfs_probe_log(\"<hex dump: nil or zero length>\");\n        return;\n    }\n    const unsigned char *b = (const unsigned char *)ptr;\n    FILE *f = fopen(\"/tmp/logs/39.txt\", \"a\");\n    if (!f) {\n        return;\n    }\n    size_t i;\n    for (i = 0; i < len; i++) {\n        fprintf(f, \"%02x\", b[i]);\n        if ((i + 1) % 16 == 0) {\n            fprintf(f, \"\\n\");\n        } else if ((i + 1) % 2 == 0) {\n            fprintf(f, \" \");\n        }\n    }\n    if (len % 16 != 0) fprintf(f, \"\\n\");\n    fclose(f);\n}\n\nint lfs_file_open(lfs_t *lfs, lfs_file_t *file, const char *path, int flags) {\n    int err = LFS_LOCK(lfs->cfg);\n    if (err) {\n        return err;\n    }\n    LFS_TRACE(\"lfs_file_open(%p, %p, \\\"%s\\\", %x)\",\n            (void*)lfs, (void*)file, path, (unsigned)flags);\n    LFS_ASSERT(!lfs_mlist_isopen(lfs->mlist, (struct lfs_mlist*)file));\n\n    /* --- Probes: capture control flow and surrounding state to help reproduce\n       potential out-of-bounds attribute uses. These probes do not change\n       program logic or state. They append information to /tmp/logs/39.txt. */\n    lfs_probe_log(\"--- lfs_file_open probe start ---\");\n    lfs_probe_log(\"entry: lfs=%p file=%p path=%s flags=0x%x\",\n            (void*)lfs, (void*)file, (path?path:\"(null)\"), (unsigned)flags);\n\n    if (lfs) {\n        /* Log lfs->cfg pointer value only (do not assume layout beyond pointer)\n           but also safely attempt a small hex dump of the cfg block if non-NULL. */\n        lfs_probe_log(\"lfs->cfg=%p\", (void*)lfs->cfg);\n        if (lfs->cfg) {\n            /* Limit dump to a small size to avoid large IO; adjust as needed. */\n            size_t dump_sz = 128;\n            lfs_probe_log(\"hex dump of lfs->cfg (first %zu bytes):\", dump_sz);\n            lfs_probe_dump_hex(lfs->cfg, dump_sz);\n        } else {\n            lfs_probe_log(\"lfs->cfg is NULL\");\n        }\n    }\n\n    if (file) {\n        /* Dump the beginning of the user-provided file struct. This may include\n           internal pointers (such as file->cfg or attribute descriptors) which\n           helps reproduce incorrect cfg/attrs contents without dereferencing\n           unknown fields directly. */\n        lfs_probe_log(\"file struct address: %p\", (void*)file);\n        size_t sz = sizeof *file;\n        if (sz > 256) sz = 256; /* cap size to avoid huge dumps */\n        lfs_probe_log(\"hex dump of file struct (first %zu bytes):\", sz);\n        lfs_probe_dump_hex((const void*)file, sz);\n    } else {\n        lfs_probe_log(\"file pointer is NULL\");\n    }\n\n    lfs_probe_log(\"calling lfs_file_open_\");\n    /* --- End probes --- */\n\n    err = lfs_file_open_(lfs, file, path, flags);\n\n    lfs_probe_log(\"lfs_file_open_ returned %d\", err);\n    /* Post-call: dump again to capture any changes that lfs_file_open_ made\n       to the file structure (e.g. pointers/sizes written into the file). */\n    if (file) {\n        size_t sz = sizeof *file;\n        if (sz > 256) sz = 256;\n        lfs_probe_log(\"post-call hex dump of file struct (first %zu bytes):\", sz);\n        lfs_probe_dump_hex((const void*)file, sz);\n    }\n    lfs_probe_log(\"--- lfs_file_open probe end ---\");\n\n    LFS_TRACE(\"lfs_file_open -> %d\", err);\n    LFS_UNLOCK(lfs->cfg);\n    return err;\n}\n"
}